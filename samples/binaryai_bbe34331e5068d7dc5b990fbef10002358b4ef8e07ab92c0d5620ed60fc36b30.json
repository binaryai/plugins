{"file_sha256":"bbe34331e5068d7dc5b990fbef10002358b4ef8e07ab92c0d5620ed60fc36b30","base_addr":65536,"functions":{"100584":{"score":0.9184815,"function_name":"_do_recovery","code":"static iot_error_t _do_recovery(struct iot_context *ctx,\n\t\t\tiot_state_t fail_state)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\n\tIOT_WARN(\"state changing fail for %d, curr_state :%d\",\n\t\tfail_state, ctx-\u003ecurr_state);\n\n\tif ((fail_state != IOT_STATE_PROV_ENTER) \u0026\u0026 (fail_state != IOT_STATE_PROV_CONFIRM)) {\n\t\tif (fail_state != ctx-\u003ercv_fail_state) {\n\t\t\tctx-\u003ercv_try_cnt = 0;\n\t\t\tctx-\u003ercv_fail_state = fail_state;\n\t\t} else {\n\t\t\tctx-\u003ercv_try_cnt++;\n\t\t}\n\t}\n\n\t/* Repeated same exceptional cases\n\t * So try do something more first\n\t */\n\tif (ctx-\u003ercv_try_cnt \u003e RECOVER_TRY_MAX) {\n\t\tIOT_WARN(\"Recovery state:[%d] repeated MAX times(%d)\",\n\t\t\tfail_state, ctx-\u003ercv_try_cnt);\n\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\t/* fall through */\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* wifi on againg by station */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI station command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for repeating state:[%d] failure (%d)\",\n\t\t\t\tfail_state, ctx-\u003ercv_try_cnt);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ercv_try_cnt);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* reset rcv_try_cnt */\n\t\tctx-\u003ercv_try_cnt = 0;\n\t}\n\n\tif (ctx-\u003ecurr_state == fail_state) {\n\t\t/* We assume that these are intentional timeout cases\n\t\t * when target didn't receive PROV_CONFIRM, CLOUD_REGISTERED\n\t\t */\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_PROV_ENTER:\n\t\tcase IOT_STATE_PROV_CONFIRM:\n\t\t\tIOT_ERROR(\"Failed process [%d] on time, STOP\", fail_state);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADFEED);\n\n\t\t\tif (ctx-\u003escan_result) {\n\t\t\t\tfree(ctx-\u003escan_result);\n\t\t\t\tctx-\u003escan_result = NULL;\n\t\t\t}\n\t\t\tctx-\u003escan_num = 0;\n\n\t\t\t/* change its state by UNKNOWN to prevent self-reentrant */\n\t\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\tIOT_ERROR(\"Failed to go to CLOUD_REGISTERED on time\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xC1EAC1EA);\n\n\t\t\tiot_device_cleanup(ctx);\n\t\t\tIOT_REBOOT();\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\tIOT_ERROR(\"Failed to go to CLOUD_CONNECTED on time\");\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* wifi on againg for station */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI station command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* retry CLOUD_CONNECTING */\n\t\t\tiot_err = iot_command_send(ctx,\n\t\t\t\t\t\tIOT_COMMAND_CLOUD_CONNECTING,\n\t\t\t\t\t\tNULL, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for state:[%d] failure\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\t\tbreak;\n\n\t\t}\n\t} else {\n\t\t/* These are exceptional timeout cases\n\t\t * when the target can't do somthing\n\t\t */\n\t\tswitch (fail_state) {\n\t\tcase IOT_STATE_PROV_ENTER:\n\t\tcase IOT_STATE_PROV_CONFIRM:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, STOP\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADFEED);\n\n\t\t\tif (ctx-\u003escan_result) {\n\t\t\t\tfree(ctx-\u003escan_result);\n\t\t\t\tctx-\u003escan_result = NULL;\n\t\t\t}\n\t\t\tctx-\u003escan_num = 0;\n\n\t\t\t/* change its state by UNKNOWN to prevent self-reentrant */\n\t\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_PROV_DONE:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, retry\",\n\t\t\t\tfail_state);\n\t\t\t/* wifi off */\n\t\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tiot_err = iot_state_update(ctx, fail_state, 0);\n\t\t\tbreak;\n\n\t\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\t\t/* fall through */\n\t\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\t\tIOT_ERROR(\"Failed to do process [%d] on time, retry\",\n\t\t\t\tfail_state);\n\t\t\tiot_err = iot_state_update(ctx,\n\t\t\t\t\t\tIOT_STATE_CLOUD_DISCONNECTED, 0);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Can't update Disconnected state(%d)\",\n\t\t\t\t\tiot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t}\n\n\t\t\tIOT_WARN(\"Self retry/recovery it again\\n\");\n\t\t\tiot_err = iot_state_update(ctx, fail_state, 0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_WARN(\"No action for process:[%d] failure\",\n\t\t\t\tfail_state);\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, fail_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1413,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"102056":{"score":0.9268072,"function_name":"_do_state_updating","code":"static iot_error_t _do_state_updating(struct iot_context *ctx,\n\t\tiot_state_t new_state, int opt, unsigned int *timeout_ms)\n{\n\tiot_error_t iot_err = IOT_ERROR_INVALID_ARGS;\n\tenum iot_command_type iot_cmd;\n\n\t/* Set default timeout value for next state */\n\t*timeout_ms = NEXT_STATE_TIMEOUT_MS;\n\n\tswitch (new_state) {\n\tcase IOT_STATE_INITIALIZED:\n\t\tiot_cmd = IOT_COMMAND_CHECK_PROV_STATUS;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_DUMP_MAIN_ARG2(INFO, STATE, new_state, iot_err);\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_ENTER:\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SCAN);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't control WIFI mode scan.(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n \t\t\tbreak;\n \t\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_DISCOVERY_SSID)\n\t\t/*wifi soft-ap mode w/ ssid E4 format*/\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SOFTAP);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI mode softap.(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n \t\t\tbreak;\n \t\t}\n#endif\n\t\t/* Update next state waiting time for Easy-setup process */\n\t\t*timeout_ms = EASYSETUP_TIMEOUT_MS;\n\t\tIOT_MEM_CHECK(\"ES_PROV_ENTER DONE \u003e\u003ePT\u003c\u003c\");\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONN_MOBILE:\n\t\tIOT_INFO(\"Notification only with IOT_STATE_PROV_CONN_MOBILE\");\n\t\t*timeout_ms = 0;\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONFIRM:\n\t\tIOT_REMARK(\"the state changes to IOT_STATE_PROV_CONFIRM\");\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_DONE:\n\t\t/* Wakeup user interaction by provisioning done */\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_PROV_DONE);\n\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_STATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI mode command(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t} else {\n\t\t\tiot_cmd = IOT_COMMAND_CHECK_CLOUD_STATE;\n\t\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\t}\n\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t*timeout_ms = REGISTRATION_TIMEOUT_MS;\n\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERING;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_REMARK(\"the state changes to IOT_STATE_CLOUD_REGISTERING\");\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\tiot_cmd = IOT_COMMAND_CLOUD_CONNECTING;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTED:\n\t\tiot_cmd = IOT_COMMAND_READY_TO_CTL;\n\t\tiot_err = iot_command_send(ctx, iot_cmd, NULL, 0);\n\t\tIOT_DUMP_MAIN_ARG2(INFO, STATE, new_state, iot_err);\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_DISCONNECTED:\n\t\tiot_err = IOT_ERROR_NONE;\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tbreak;\n\n\tcase IOT_STATE_CHANGE_FAILED:\n\t\tiot_err = _do_recovery(ctx, (iot_state_t)opt);\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tbreak;\n\n\tcase IOT_STATE_UNKNOWN:\n\t\t/* At this state, iot-core can't make next decision by itself\n\t\t * So just wait(stop) process until external triggering happened\n\t\t * such as reboot, re-start command from user-apps\n\t\t */\n\t\tIOT_WARN(\"Iot-core task will be stopped, needed ext-triggering\\n\");\n\t\tIOT_DUMP_MAIN_ARG2(WARN, STATE, new_state, iot_err);\n\n\t\t/* if there is previous connection, disconnect it first. */\n\t\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t}\n\n\t\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t}\n\n\t\t/* wifi off */\n\t\tiot_err = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_OFF);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't send WIFI off command(%d)\",\n\t\t\t\tiot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t}\n\n\t\tif (ctx-\u003ees_http_ready) {\n\t\t\tctx-\u003ees_http_ready = false;\n\t\t\tiot_easysetup_deinit(ctx);\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created)\n\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t/* This is final state of iot-core, so update it now */\n\t\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_UNKNOWN;\n\n\t\t/* clear reported_stat for the next connection */\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\t_do_status_report(ctx, IOT_STATE_CLOUD_DISCONNECTED, false);\n\t\t}\n\n\t\t/* Reset recovery flags */\n\t\tctx-\u003ercv_fail_state = IOT_STATE_UNKNOWN;\n\t\tctx-\u003ercv_try_cnt = 0;\n\n\t\tif (opt == IOT_STATE_OPT_CLEANUP) {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN | IOT_USR_INTERACT_BIT_CLEANUP_DONE);\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN);\n\t\t}\n\n\t\t*timeout_ms = IOT_OS_MAX_DELAY;\n\t\tiot_err = IOT_ERROR_NONE;\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported new IOT_STATE!!(%d)\\n\", new_state);\n\t\tIOT_DUMP_MAIN(ERROR, STATE, new_state);\n\t\tbreak;\n\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1596,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"103296":{"score":0.84805185,"function_name":"st_conn_start","code":"int st_conn_start(IOT_CTX *iot_ctx, st_status_cb status_cb,\n\t\tiot_status_t maps, void *usr_data, iot_pin_t *pin_num)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t iot_err;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tunsigned char curr_events;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx))\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%s)\", __func__, pin_num ? \"pin\" : \"no-pin\");\n\tIOT_DUMP_MAIN(INFO, BASE, (pin_num ? 1 : 0));\n\n\tif ((ctx-\u003ecurr_state != IOT_STATE_UNKNOWN) || (ctx-\u003ereq_state != IOT_STATE_UNKNOWN)) {\n\t\tIOT_WARN(\"Can't start it, iot_main_task is already working(%d)\", ctx-\u003ecurr_state);\n\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ecurr_state);\n\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tgoto end_st_conn_start;\n\t}\n\n\tif (ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_BUTTON) {\n\t\tif (!status_cb) {\n\t\t\tIOT_ERROR(\"There is no status_cb for otm\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto end_st_conn_start;\n\t\t}\n\t}\n\n\tif (ctx-\u003ees_res_created) {\n\t\tIOT_WARN(\"Already easysetup resources are created!!\");\n\t} else {\n\t\tiot_err = _create_easysetup_resources(ctx, pin_num);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to create easysetup resources(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start;\n\t\t}\n\t}\n\n\tstate_data.iot_state = IOT_STATE_INITIALIZED;\n\tstate_data.opt = IOT_STATE_OPT_NONE;\n\n\tctx-\u003eadd_justworks = false;\n\n\tif (status_cb) {\n\t\tSET_STATUS_CB(status_cb, maps, usr_data);\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BITS_ST_CONN);\n\n\tiot_err = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n\t\t\t\t\u0026state_data, sizeof(struct iot_state_data));\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send command(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\tUNSET_STATUS_CB();\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\t_delete_easysetup_resources_all(ctx);\n\t\t}\n\t\tgoto end_st_conn_start;\n\t}\n\n\tWAIT_USR_INTERACT();\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nend_st_conn_start:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1813,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"104562":{"score":0.9082805,"function_name":"st_conn_cleanup","code":"int st_conn_cleanup(IOT_CTX *iot_ctx, bool reboot)\n{\n\tiot_error_t iot_err;\n\tunsigned char curr_events;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx))\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d)\", __func__, reboot);\n\tIOT_DUMP_MAIN(INFO, BASE, reboot);\n\n\t/* remove all queued commands */\n\tif (iot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\t_throw_away_all_cmd_queue(ctx);\n\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\n\t/* Try to delete device_card first, but it depends on connection-status */\n\tiot_err = _delete_dev_card_by_usr(ctx);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to delete device_card(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CLEANUP_DONE);\n\n\tiot_err = iot_command_send(ctx,\n\t\t\tIOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send cleanup(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto err_cleanup;\n\t}\n\n\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\tIOT_USR_INTERACT_BIT_CLEANUP_DONE, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CLEANUP_DONE)) {\n\t\tIOT_ERROR(\"Timeout happened for st_conn_cleanup\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0x8BADF00D);\n\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nerr_cleanup:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1907,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"105303":{"score":0.87614536,"function_name":"st_conn_start_ex","code":"int st_conn_start_ex(IOT_CTX *iot_ctx, iot_ext_args_t *ext_args)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t iot_err;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tunsigned char curr_events;\n\tiot_os_thread curr_thread;\n\n\tif (!IS_CTX_VALID(ctx) || !ext_args) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (iot_os_thread_get_current_handle(\u0026curr_thread) == IOT_OS_TRUE) {\n\t\tif (curr_thread == ctx-\u003emain_thread) {\n\t\t\tIOT_WARN(\"Can't support it on same thread!!\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBABE);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t} else {\n\t\tIOT_WARN(\"Can't get thread info. Please check it called same thread or not!!\");\n\t\tIOT_DUMP_MAIN(WARN, BASE, 0xDEADBABE);\n\t}\n\n\tif ((ext_args-\u003estart_pt != IOT_STATUS_CONNECTING) \u0026\u0026\n\t\t\t(ext_args-\u003estart_pt != IOT_STATUS_PROVISIONING)) {\n\t\tIOT_ERROR(\"Unsupported request (%d)\\n\", ext_args-\u003estart_pt);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (!(ext_args-\u003eskip_usr_confirm) \u0026\u0026\n\t\t\t(ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_BUTTON)) {\n\t\tif (!ext_args-\u003estatus_cb \u0026\u0026 (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING)) {\n\t\t\tIOT_ERROR(\"There is no status_cb for otm\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d/%d)\", __func__,\n\t\text_args-\u003estart_pt, ext_args-\u003eskip_usr_confirm);\n\tIOT_DUMP_MAIN(INFO, BASE, ((ext_args-\u003estart_pt \u003c\u003c 8u) | ext_args-\u003eskip_usr_confirm));\n\n\tif ((ctx-\u003ecurr_state != IOT_STATE_UNKNOWN) || (ctx-\u003ereq_state != IOT_STATE_UNKNOWN)) {\n\t\tIOT_WARN(\"iot-core is already working(%d), stop \u0026 remove all cmd first\",\n\t\t\tctx-\u003ecurr_state);\n\t\tIOT_DUMP_MAIN(WARN, BASE, ctx-\u003ecurr_state);\n\n\t\t/* remove all queued commands */\n\t\tiot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock);\n\t\t_throw_away_all_cmd_queue(ctx);\n\t\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_STATE_UNKNOWN);\n\n\t\t/* change its state by UNKNOWN to reset all */\n\t\tiot_err = iot_state_update(ctx, IOT_STATE_UNKNOWN, 0);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to change IOT_STATE_UNKNOWN(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\t/* Wait until IOT_STATE_UNKNOWN changing done */\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_STATE_UNKNOWN, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_STATE_UNKNOWN)) {\n\t\t\tIOT_ERROR(\"Timeout happened to change IOT_STATE_UNKNOWN\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0x8BADF00D);\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\t}\n\n\t/* Forcely set iot_state by initialized */\n\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_INITIALIZED;\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_CONNECTING) {\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CMD_DONE);\n\n\t\t/* Check if STDK can try to connect to sever */\n\t\tiot_err = _iot_command_peek(ctx, IOT_COMMAND_CHECK_PROV_STATUS);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to send check_prov(%d)\", iot_err);\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE, true, (NEXT_STATE_TIMEOUT_MS * 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CMD_DONE)) {\n\t\t\tIOT_ERROR(\"Timeout happened for check_prov\");\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tif (ctx-\u003eiot_reg_data.new_reged) {\n\t\t\tIOT_ERROR(\"Can't support request to go to connecting\");\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto end_st_conn_start_ex;\n\t\t}\n\n\t\tctx-\u003eiot_reg_data.updated = false;\n\t\tstate_data.iot_state = IOT_STATE_PROV_DONE;\n\t\tstate_data.opt = IOT_STATE_OPT_NONE;\n\t} else {\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\tIOT_WARN(\"Already easysetup resources are created!!\");\n\t\t} else {\n\t\t\tiot_err = _create_easysetup_resources(ctx, ext_args-\u003epin_num);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to create easysetup resources(%d)\", iot_err);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\t\t\tgoto end_st_conn_start_ex;\n\t\t\t}\n\t\t}\n\n\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\tstate_data.iot_state = IOT_STATE_PROV_ENTER;\n\t\tstate_data.opt = IOT_STATE_OPT_NONE;\n\n\t\tif (ext_args-\u003eskip_usr_confirm) {\n\t\t\tctx-\u003eadd_justworks = true;\n\t\t\tIOT_DEBUG(\"Skip user confirm adding by JUSTWORK\");\n\t\t} else {\n\t\t\tctx-\u003eadd_justworks = false;\n\t\t}\n\t}\n\n\tif (ext_args-\u003estatus_cb) {\n\t\tSET_STATUS_CB(ext_args-\u003estatus_cb, ext_args-\u003emaps, ext_args-\u003eusr_data);\n\t}\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING) {\n\t\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BITS_ST_CONN);\n\t}\n\n\tiot_err = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n\t\t\t\t\u0026state_data, sizeof(struct iot_state_data));\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to send command(%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tif (ctx-\u003estatus_cb) {\n\t\t\tUNSET_STATUS_CB();\n\t\t}\n\n\t\tif (ctx-\u003ees_res_created) {\n\t\t\t_delete_easysetup_resources_all(ctx);\n\t\t}\n\t\tgoto end_st_conn_start_ex;\n\t}\n\n\tif (ext_args-\u003estart_pt == IOT_STATUS_PROVISIONING) {\n\t\tWAIT_USR_INTERACT();\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\nend_st_conn_start_ex:\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":1976,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"107315":{"score":0.909256,"function_name":"st_info_get","code":"int st_info_get(IOT_CTX *iot_ctx, iot_info_type_t info_type, iot_info_data_t *info_data)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!IS_CTX_VALID(ctx) || !info_data) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (iot_os_mutex_lock(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE)\n\t\treturn IOT_ERROR_BAD_REQ;\n\n\tIOT_INFO(\"%s start (%d)\", __func__, info_type);\n\tIOT_DUMP_MAIN(INFO, BASE, info_type);\n\n\tswitch (info_type) {\n\tcase IOT_INFO_TYPE_IOT_STATUS_AND_STAT:\n\t\tif (ctx-\u003ereported_stat) {\n\t\t\tinfo_data-\u003est_status.iot_status = (ctx-\u003ereported_stat \u0026 IOT_STATUS_ALL);\n\t\t\tinfo_data-\u003est_status.stat_lv = (ctx-\u003ereported_stat \u003e\u003e 8u);\n\t\t} else {\n\t\t\tIOT_WARN(\"There is no reported_stat!!\");\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_INFO_TYPE_IOT_PROVISIONED:\n\t\tinfo_data-\u003eprovisioned = iot_nv_prov_data_exist();\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported iot_info_type!!(%d)\\n\", info_type);\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tbreak;\n\t}\n\n\tIOT_INFO(\"%s done (%d)\", __func__, iot_err);\n\tIOT_DUMP_MAIN(INFO, BASE, iot_err);\n\n\tiot_os_mutex_unlock(\u0026ctx-\u003est_conn_lock);\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":2145,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"107786":{"score":0.8938002,"function_name":"st_change_device_name","code":"int st_change_device_name(IOT_CTX *iot_ctx, const char *new_name)\n{\n\tint ret = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tst_mqtt_msg msg = {0};\n\tJSON_H *json_root = NULL;\n\n\tif (!ctx || !new_name) {\n\t\tIOT_ERROR(\"invalid input params\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (strlen(new_name) \u003e IOT_DEVICE_NAME_MAX_LENGTH) {\n\t\tIOT_ERROR(\"new device name is over length(%d)\", IOT_DEVICE_NAME_MAX_LENGTH);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tjson_root = JSON_CREATE_OBJECT();\n\tJSON_ADD_STRING_TO_OBJECT(json_root, \"label\", new_name);\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(json_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(json_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to make json string\");\n\t\tret = IOT_ERROR_BAD_REQ;\n\t\tgoto exit;\n\t}\n\tmsg.payloadlen = strlen(msg.payload);\n#endif\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = IOT_PUB_TOPIC_DEVICES_UPDATE;\n\n\tIOT_INFO(\"change device name, topic : %s, payload :\\n%s\",\n\t\t(char *)msg.topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tret = IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t\tIOT_ERROR(\"Failt to publish change period packet\");\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (msg.payload)\n\t\tfree(msg.payload);\n\tif (json_root)\n\t\tJSON_DELETE(json_root);\n\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":2189,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"108418":{"score":0.8872464,"function_name":"st_change_health_period","code":"int st_change_health_period(IOT_CTX *iot_ctx, unsigned int new_period)\n{\n\tint ret = IOT_ERROR_NONE;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\tst_mqtt_msg msg = {0};\n\tJSON_H *json_root = NULL;\n\t/* MQTT connection expired after twice ping period */\n\tunsigned int new_mqtt_period = new_period/2;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"ctx is null\");\n\t    return IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tjson_root = JSON_CREATE_OBJECT();\n\tJSON_ADD_STRING_TO_OBJECT(json_root, \"status\", \"changePeriod\");\n\tJSON_ADD_NUMBER_TO_OBJECT(json_root, \"newPeriod\", new_mqtt_period);\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(json_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(json_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to make json string\");\n\t\tret = IOT_ERROR_BAD_REQ;\n\t\tgoto exit;\n\t}\n\tmsg.payloadlen = strlen(msg.payload);\n#endif\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_health_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_health_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tret = IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t\tIOT_ERROR(\"Failt to publish change period packet\");\n\t\tgoto exit;\n\t}\n\tst_mqtt_change_ping_period(ctx-\u003eevt_mqttcli, new_mqtt_period);\n\nexit:\n\tif (msg.payload)\n\t\tfree(msg.payload);\n\tif (json_root)\n\t\tJSON_DELETE(json_root);\n\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":2247,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109051":{"score":0.9029224,"function_name":"_iot_mqtt_chunk_destroy","code":"static void _iot_mqtt_chunk_destroy(iot_mqtt_packet_chunk_t *chunk)\n{\n\tif (chunk \u0026\u0026 chunk-\u003echunk_data) {\n\t\tiot_os_free(chunk-\u003echunk_data);\n\t}\n\n\tif (chunk \u0026\u0026 chunk-\u003eexpiry_time) {\n\t\tiot_os_timer_destroy(\u0026chunk-\u003eexpiry_time);\n\t}\n\n\tif (chunk) {\n\t\tiot_os_free(chunk);\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":27,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109163":{"score":0.9294749,"function_name":"_iot_mqtt_chunk_create","code":"static iot_mqtt_packet_chunk_t * _iot_mqtt_chunk_create(size_t chunk_size)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL;\n\tiot_error_t iot_err;\n\n\tchunk = iot_os_malloc(sizeof(iot_mqtt_packet_chunk_t));\n\tif (chunk == NULL) {\n\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\treturn NULL;\n\t}\n\tmemset(chunk, '\\0', sizeof(iot_mqtt_packet_chunk_t));\n\n\tchunk-\u003echunk_data = iot_os_malloc(chunk_size);\n\tif (chunk-\u003echunk_data == NULL) {\n\t\tIOT_ERROR(\"chunk data malloc fail\");\n\t\tiot_os_free(chunk);\n\t\treturn NULL;\n\t}\n\tchunk-\u003echunk_size = chunk_size;\n\n\tiot_err = iot_os_timer_init(\u0026chunk-\u003eexpiry_time);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init chunk expiry\");\n\t\tiot_os_free(chunk-\u003echunk_data);\n\t\tiot_os_free(chunk);\n\t\treturn NULL;\n\t}\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109482":{"score":0.82743883,"function_name":"_iot_mqtt_queue_push","code":"static int _iot_mqtt_queue_push(iot_mqtt_packet_chunk_queue_t *queue, iot_mqtt_packet_chunk_t *chunk)\n{\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn -1;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tqueue-\u003ehead = queue-\u003etail = chunk;\n\t} else {\n\t\tqueue-\u003etail-\u003enext = chunk;\n\t\tqueue-\u003etail = chunk;\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn 0;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109625":{"score":0.8538904,"function_name":"_iot_mqtt_queue_pop_by_type_and_id","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop_by_type_and_id(iot_mqtt_packet_chunk_queue_t *queue,\n\t\t\t\t\t\t\t\tint packet_type, unsigned int packet_id)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL, *iterator = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tif (queue-\u003ehead-\u003epacket_type == packet_type \u0026\u0026 queue-\u003ehead-\u003epacket_id == packet_id) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t\t}\n\t} else {\n\t\tif (queue-\u003ehead-\u003epacket_type == packet_type \u0026\u0026 queue-\u003ehead-\u003epacket_id == packet_id) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\t\tchunk-\u003enext = NULL;\n\t\t} else {\n\t\t\titerator = queue-\u003ehead;\n\t\t\twhile (iterator-\u003enext) {\n\t\t\t\tif (iterator-\u003enext-\u003epacket_type == packet_type \u0026\u0026 iterator-\u003enext-\u003epacket_id == packet_id) {\n\t\t\t\t\tchunk = iterator-\u003enext;\n\t\t\t\t\titerator-\u003enext = iterator-\u003enext-\u003enext;\n\t\t\t\t\tchunk-\u003enext = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titerator = iterator-\u003enext;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"109994":{"score":0.8388576,"function_name":"_iot_mqtt_queue_pop_by_expiry","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop_by_expiry(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL, *iterator = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tif (iot_os_timer_isexpired(queue-\u003ehead-\u003eexpiry_time)) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t\t}\n\t} else {\n\t\tif (iot_os_timer_isexpired(queue-\u003ehead-\u003eexpiry_time)) {\n\t\t\tchunk = queue-\u003ehead;\n\t\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\t\tchunk-\u003enext = NULL;\n\t\t} else {\n\t\t\titerator = queue-\u003ehead;\n\t\t\twhile (iterator-\u003enext) {\n\t\t\t\tif (iot_os_timer_isexpired(iterator-\u003enext-\u003eexpiry_time)) {\n\t\t\t\t\tchunk = iterator-\u003enext;\n\t\t\t\t\titerator-\u003enext = iterator-\u003enext-\u003enext;\n\t\t\t\t\tchunk-\u003enext = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\titerator = iterator-\u003enext;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":129,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110353":{"score":0.83537734,"function_name":"_iot_mqtt_queue_pop","code":"static iot_mqtt_packet_chunk_t* _iot_mqtt_queue_pop(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_mqtt_packet_chunk_t *chunk = NULL;\n\n\tif((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE)\n\t\treturn NULL;\n\n\tif (queue-\u003ehead == NULL || queue-\u003etail == NULL) {\n\t\tchunk = NULL;\n\t} else if (queue-\u003ehead == queue-\u003etail) {\n\t\tchunk = queue-\u003ehead;\n\t\tqueue-\u003ehead = queue-\u003etail = NULL;\n\t} else {\n\t\tchunk = queue-\u003ehead;\n\t\tqueue-\u003ehead = queue-\u003ehead-\u003enext;\n\t\tchunk-\u003enext = NULL;\n\t}\n\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\treturn chunk;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":167,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110552":{"score":0.94627815,"function_name":"_iot_mqtt_queue_init","code":"static int _iot_mqtt_queue_init(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tiot_os_mutex_init(\u0026queue-\u003elock);\n\tif (queue-\u003elock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init queue lock\");\n\t\treturn -1;\n\t}\n\tqueue-\u003ehead = NULL;\n\tqueue-\u003etail = NULL;\n\n\treturn 0;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":190,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110670":{"score":0.81431365,"function_name":"_iot_mqtt_queue_destroy","code":"static void _iot_mqtt_queue_destroy(iot_mqtt_packet_chunk_queue_t *queue)\n{\n\tdo {\n\t\tif (queue-\u003elock.sem == NULL)\n\t\t\treturn;\n\t} while ((iot_os_mutex_lock(\u0026queue-\u003elock)) != IOT_OS_TRUE);\n\tiot_mqtt_packet_chunk_t *iterator = queue-\u003ehead, *tmp;\n\twhile (iterator) {\n\t\ttmp = iterator;\n\t\titerator = iterator-\u003enext;\n\t\tif (tmp-\u003ehave_owner) {\n\t\t\ttmp-\u003enext = NULL;\n\t\t\ttmp-\u003echunk_state = PACKET_CHUNK_QUEUE_DESTROYED;\n\t\t} else {\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t}\n\t}\n\tqueue-\u003ehead = queue-\u003etail = NULL;\n\tiot_os_mutex_unlock(\u0026queue-\u003elock);\n\n\tif (queue-\u003elock.sem != NULL) {\n\t\tiot_os_mutex_destroy(\u0026queue-\u003elock);\n\t\tqueue-\u003elock.sem = NULL;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":203,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"110887":{"score":0.8774873,"function_name":"_iot_mqtt_process_post_write","code":"static void _iot_mqtt_process_post_write(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tswitch(chunk-\u003epacket_type) {\n\t\tcase CONNECT:\n\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_CONNECT_TIMEOUT);\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\tbreak;\n\t\tcase SUBSCRIBE:\n\t\tcase UNSUBSCRIBE:\n\t\tcase PUBREL:\n\t\tcase PUBREC:\n\t\tcase PINGREQ:\n\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_RETRY_TIMEOUT);\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\tbreak;\n\t\tcase PUBLISH:\n\t\t\tif (chunk-\u003eqos == 0) {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_WRITE_COMPLETED;\n\t\t\t\tif (!chunk-\u003ehave_owner) {\n\t\t\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_ACK_PENDING;\n\t\t\t\tiot_os_timer_count_ms(chunk-\u003eexpiry_time, MQTT_RETRY_TIMEOUT);\n\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003eack_pending_queue, chunk);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DISCONNECT:\n\t\t\tif (chunk-\u003ehave_owner) {\n\t\t\t\tchunk-\u003echunk_state = PACKET_CHUNK_WRITE_COMPLETED;\n\t\t\t} else {\n\t\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\tbreak;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":229,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"111225":{"score":0.90280986,"function_name":"_iot_mqtt_run_write_stream","code":"static int _iot_mqtt_run_write_stream(MQTTClient *client)\n{\n\tint rc = 0, written = 0;\n\tiot_error_t iot_err;\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\tiot_os_timer expiry_timer = NULL;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE) {\n\t\treturn 0;\n\t}\n\n\tw_chunk = _iot_mqtt_queue_pop(\u0026client-\u003ewrite_pending_queue);\n\tif (w_chunk == NULL) {\n\t\tgoto exit;\n\t} else {\n\t\tiot_err = iot_os_timer_init(\u0026expiry_timer);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"fail to init timer\");\n\t\t\twritten = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\t\tgoto exit;\n\t\t}\n\t\tiot_os_timer_count_ms(expiry_timer, MQTT_WRITE_TIMEOUT);\n\t}\n\n\tif(!client-\u003eisconnected) {\n\t\twritten = E_ST_MQTT_DISCONNECTED;\n\t\tgoto exit;\n\t}\n\n\twhile (written != w_chunk-\u003echunk_size \u0026\u0026 !iot_os_timer_isexpired(expiry_timer)) {\n\t\trc = client-\u003enet-\u003ewrite(client-\u003enet, \u0026w_chunk-\u003echunk_data[written],\n\t\t\t\tw_chunk-\u003echunk_size - written, expiry_timer);\n\n\t\tif (rc \u003e 0) {\n\t\t\twritten += rc;\n\t\t\tiot_os_timer_count_ms(expiry_timer, MQTT_WRITE_TIMEOUT);\n\t\t} else if (rc \u003c 0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (written == w_chunk-\u003echunk_size) {\n\t\t_iot_mqtt_process_post_write(client, w_chunk);\n\t\tw_chunk = NULL;\n\t} else {\n\t\twritten = E_ST_MQTT_NETWORK_ERROR;\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\n\tif (expiry_timer) {\n\t\tiot_os_timer_destroy(\u0026expiry_timer);\n\t}\n\n\tif (written \u003c 0 \u0026\u0026 w_chunk != NULL) {\n\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_WRITE_FAIL;\n\t\tw_chunk-\u003ereturn_code = written;\n\t\tif (!w_chunk-\u003ehave_owner) {\n\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t}\n\t}\n\n\tif (written \u003e 0) {\n\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\t\tiot_os_timer_count_ms(client-\u003elast_sent, client-\u003ekeepAliveInterval * 1000);\n\t\t\t\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn written;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":271,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"111931":{"score":0.6803144,"function_name":"_convert_return_code","code":"static int _convert_return_code(int mqtt_rc)\n{\n\tint rc;\n\tswitch (mqtt_rc) {\n\tcase MQTT_CONNECTION_ACCEPTED:\n\t\trc = 0;\n\t\tbreak;\n\tcase MQTT_UNNACCEPTABLE_PROTOCOL:\n\t\trc = E_ST_MQTT_UNNACCEPTABLE_PROTOCOL;\n\t\tbreak;\n\tcase MQTT_SERVER_UNAVAILABLE:\n\t\trc = E_ST_MQTT_SERVER_UNAVAILABLE;\n\t\tbreak;\n\tcase MQTT_CLIENTID_REJECTED:\n\t\trc = E_ST_MQTT_CLIENTID_REJECTED;\n\t\tbreak;\n\tcase MQTT_BAD_USERNAME_OR_PASSWORD:\n\t\trc = E_ST_MQTT_BAD_USERNAME_OR_PASSWORD;\n\t\tbreak;\n\tcase MQTT_NOT_AUTHORIZED:\n\t\trc = E_ST_MQTT_NOT_AUTHORIZED;\n\t\tbreak;\n\tdefault:\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tbreak;\n\t}\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":350,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112037":{"score":0.8847776,"function_name":"_iot_mqtt_process_received_ack","code":"static void _iot_mqtt_process_received_ack(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\n\tif (chunk-\u003epacket_type == CONNACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, CONNECT, 0);\n\t} else if (chunk-\u003epacket_type == PUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBLISH, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == SUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, SUBSCRIBE, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == UNSUBACK) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, UNSUBSCRIBE, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PUBCOMP) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBREL, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PINGRESP) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PINGREQ, 0);\n\t} else {\n\t\treturn;\n\t}\n\n\tif (tmp != NULL) {\n\t\tif (chunk-\u003epacket_type == CONNACK) {\n\t\t\tunsigned char ack_rc = 0;\n\t\t\tunsigned char sessionPresent = 0;\n\n\t\t\tMQTTDeserialize_connack(\u0026sessionPresent, \u0026ack_rc, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\t\t\ttmp-\u003ereturn_code = _convert_return_code(ack_rc);\n\t\t} else if (chunk-\u003epacket_type == SUBACK) {\n\t\t\tint count = 0, ack_qos;\n\t\t\tunsigned short mypacketid;\n\t\t\tMQTTDeserialize_suback(\u0026mypacketid, 1, \u0026count, (int *)\u0026ack_qos, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\t\t\tif (ack_qos == 0x80) {\n\t\t\t\ttmp-\u003ereturn_code = E_ST_MQTT_FAILURE;\n\t\t\t} else {\n\t\t\t\ttmp-\u003ereturn_code = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp-\u003ehave_owner) {\n\t\t\ttmp-\u003echunk_state = PACKET_CHUNK_ACKNOWLEDGED;\n\t\t} else {\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"There is no ack packet matched\");\n\t}\n\t_iot_mqtt_chunk_destroy(chunk);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":379,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112631":{"score":0.92999774,"function_name":"_iot_mqtt_process_received_publish","code":"static void _iot_mqtt_process_received_publish(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\t// Send Ack back\n\tif (chunk-\u003eqos != st_mqtt_qos0) {\n\t\tiot_mqtt_packet_chunk_t *puback;\n\t\tpuback = _iot_mqtt_chunk_create(MQTT_ACK_PACKET_SIZE);\n\t\tif (puback == NULL) {\n\t\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\tpuback-\u003epacket_id = chunk-\u003epacket_id;\n\t\tif (chunk-\u003eqos == st_mqtt_qos1) {\n\t\t\tpuback-\u003epacket_type = PUBACK;\n\t\t\tMQTTSerialize_ack(puback-\u003echunk_data, puback-\u003echunk_size, PUBACK, 0, puback-\u003epacket_id);\n\t\t} else if (chunk-\u003eqos == st_mqtt_qos2) {\n\t\t\tpuback-\u003epacket_type = PUBREC;\n\t\t\tMQTTSerialize_ack(puback-\u003echunk_data, puback-\u003echunk_size, PUBREC, 0, puback-\u003epacket_id);\n\t\t}\n\t\tpuback-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, puback);\n\t}\n\n\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, chunk);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":428,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"112936":{"score":0.9000322,"function_name":"_iot_mqtt_process_received_pubrec_pubrel","code":"static void _iot_mqtt_process_received_pubrec_pubrel(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\n\tif (chunk-\u003epacket_type == PUBREC) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBLISH, chunk-\u003epacket_id);\n\t} else if (chunk-\u003epacket_type == PUBREL) {\n\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, PUBREC, chunk-\u003epacket_id);\n\t} else {\n\t\treturn;\n\t}\n\t_iot_mqtt_chunk_destroy(chunk);\n\n\t// Recycling packet\n\tif (tmp != NULL) {\n\t\tiot_os_free(tmp-\u003echunk_data);\n\t\ttmp-\u003echunk_data = NULL;\n\n\t\ttmp-\u003echunk_size = MQTT_ACK_PACKET_SIZE;\n\t\ttmp-\u003echunk_data = iot_os_malloc(tmp-\u003echunk_size);\n\t\tif (tmp-\u003echunk_data == NULL) {\n\t\t\tIOT_ERROR(\"chunk data malloc fail\");\n\t\t\t_iot_mqtt_chunk_destroy(tmp);\n\t\t\treturn;\n\t\t}\n\t\tif (tmp-\u003epacket_type == PUBLISH) {\n\t\t\ttmp-\u003epacket_type = PUBREL;\n\t\t\tMQTTSerialize_ack(tmp-\u003echunk_data, tmp-\u003echunk_size, PUBREL, 0, tmp-\u003epacket_id);\n\t\t} else if (tmp-\u003epacket_type == PUBREC) {\n\t\t\ttmp-\u003epacket_type = PUBCOMP;\n\t\t\tMQTTSerialize_ack(tmp-\u003echunk_data, tmp-\u003echunk_size, PUBCOMP, 0, tmp-\u003epacket_id);\n\t\t}\n\t\ttmp-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, tmp);\n\t} else {\n\t\tIOT_ERROR(\"There is no ack packet matched\");\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":455,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"113405":{"score":0.88675547,"function_name":"_iot_mqtt_process_post_read","code":"static void _iot_mqtt_process_post_read(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tswitch (chunk-\u003epacket_type) {\n\t\tcase CONNACK:\n\t\tcase PUBACK:\n\t\tcase SUBACK:\n\t\tcase UNSUBACK:\n\t\tcase PUBCOMP:\n\t\tcase PINGRESP:\n\t\t\t_iot_mqtt_process_received_ack(client, chunk);\n\t\t\tbreak;\n\t\tcase PUBLISH:\n\t\t\t_iot_mqtt_process_received_publish(client, chunk);\n\t\t\tbreak;\n\t\tcase PUBREC:\n\t\tcase PUBREL:\n\t\t\t_iot_mqtt_process_received_pubrec_pubrel(client, chunk);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIOT_WARN(\"There is no read packet type handle %d\", chunk-\u003epacket_type);\n\t\t\t_iot_mqtt_chunk_destroy(chunk);\n\t\t\tbreak;\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":494,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"113571":{"score":0.91580915,"function_name":"_iot_mqtt_run_read_stream","code":"static int _iot_mqtt_run_read_stream(MQTTClient *client)\n{\n\tint rc = 0 , read = 0;\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\tiot_error_t iot_err;\n\tiot_os_timer expiry_timer = NULL;\n\tunsigned char packet_fixed_header[MAX_NUM_OF_REMAINING_LENGTH_BYTES + 1];\n\tint rem_size = 0, multiplier = 1;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE) {\n\t\treturn 0;\n\t}\n\tif(!client-\u003eisconnected) {\n\t\tread = E_ST_MQTT_DISCONNECTED;\n\t\tgoto exit;\n\t}\n\n\trc = client-\u003enet-\u003eselect(client-\u003enet, 0);\n\tif (rc \u003c 0) {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\tgoto exit;\n\t} else if (rc == 0) {\n\t\tgoto exit;\n\t} else {\n\t\tiot_err = iot_os_timer_init(\u0026expiry_timer);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"fail to init timer\");\n\t\t\tread = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\t\tgoto exit;\n\t\t}\n\t\tiot_os_timer_count_ms(expiry_timer, MQTT_READ_TIMEOUT);\n\t}\n\n\trc = client-\u003enet-\u003eread(client-\u003enet, \u0026packet_fixed_header[0], 1, expiry_timer);\n\tif (rc \u003c= 0) {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\tgoto exit;\n\t}\n\tread++;\n\tdo {\n\t\tif (read - 1 \u003e= MAX_NUM_OF_REMAINING_LENGTH_BYTES) {\n\t\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\trc = client-\u003enet-\u003eread(client-\u003enet, \u0026packet_fixed_header[read], 1, expiry_timer);\n\t\tif (rc \u003c= 0) {\n\t\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t\trem_size += (packet_fixed_header[read] \u0026 127) * multiplier;\n\t\tmultiplier *= 128;\n\t\tread++;\n\t} while ((packet_fixed_header[read - 1] \u0026 128) != 0);\n\n\tw_chunk = _iot_mqtt_chunk_create(read + rem_size);\n\tif (w_chunk == NULL) {\n\t\tIOT_ERROR(\"chunk malloc fail\");\n\t\tread = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tmemcpy(w_chunk-\u003echunk_data, packet_fixed_header, read);\n\n\twhile (read != w_chunk-\u003echunk_size \u0026\u0026 !iot_os_timer_isexpired(expiry_timer)) {\n\t\trc = client-\u003enet-\u003eread(client-\u003enet, w_chunk-\u003echunk_data + read,\n\t\t\t\tw_chunk-\u003echunk_size - read, expiry_timer);\n\t\tif (rc \u003c 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tread += rc;\n\t\t\tiot_os_timer_count_ms(expiry_timer, MQTT_READ_TIMEOUT);\n\t\t}\n\t}\n\n\tif (read == w_chunk-\u003echunk_size) {\n\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_READ_COMPLETED;\n\t\tw_chunk-\u003epacket_type = (w_chunk-\u003echunk_data[0] \u0026 MQTT_FIXED_HEADER_PACKET_TYPE_MASK) \u003e\u003e MQTT_FIXED_HEADER_PACKET_TYPE_OFFSET;\n\t\tw_chunk-\u003eqos = (w_chunk-\u003echunk_data[0] \u0026 MQTT_FIXED_HEADER_QOS_MASK) \u003e\u003e MQTT_FIXED_HEADER_QOS_OFFSET;\n\t\tw_chunk-\u003epacket_id = MQTTPacket_getPacketId(w_chunk-\u003echunk_data);\n\t\t_iot_mqtt_process_post_read(client, w_chunk);\n\t\tw_chunk = NULL;\n\t} else {\n\t\tread = E_ST_MQTT_NETWORK_ERROR;\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\n\tif (expiry_timer) {\n\t\tiot_os_timer_destroy(\u0026expiry_timer);\n\t}\n\n\tif (w_chunk != NULL) {\n\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t}\n\n\tif (read \u003e 0) {\n\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\t\tiot_os_timer_count_ms(client-\u003elast_received, client-\u003ekeepAliveInterval * 1000);\n\t\t\t\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn read;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":519,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"114645":{"score":0.8483529,"function_name":"st_mqtt_create","code":"int st_mqtt_create(st_mqtt_client *client, st_mqtt_event_callback callback_fp, void *user_data)\n{\n\tMQTTClient *c = NULL;\n\tint rc = E_ST_MQTT_FAILURE;\n\tiot_error_t iot_err;\n\n\tif (callback_fp == NULL) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\t*client = iot_os_malloc(sizeof(MQTTClient));\n\tif (*client == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto error_handle;\n\t}\n\tmemset(*client, '\\0', sizeof(MQTTClient));\n\n\tc = *client;\n\tc-\u003emagic = MQTT_CLIENT_STRUCT_MAGIC_NUMBER;\n\tc-\u003euser_callback_fp = callback_fp;\n\tc-\u003euser_callback_user_data = user_data;\n\n\tc-\u003enet = iot_os_malloc(sizeof(iot_net_interface_t));\n\tif (c-\u003enet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto error_handle;\n\t}\n\tmemset(c-\u003enet, '\\0', sizeof(iot_net_interface_t));\n\tc-\u003enext_packetid = 1;\n\tiot_err = iot_os_timer_init(\u0026c-\u003elast_sent);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init last_send timer\");\n\t\tgoto error_handle;\n\t}\n\tiot_err = iot_os_timer_init(\u0026c-\u003elast_received);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init last_received timer\");\n\t\tgoto error_handle;\n\t}\n\tiot_os_mutex_init(\u0026c-\u003eclient_manage_lock);\n\tif (c-\u003eclient_manage_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init mutex\");\n\t\tgoto error_handle;\n\t}\n\tc-\u003ethread = NULL;\n\tiot_os_mutex_init(\u0026c-\u003ewrite_lock);\n\tif (c-\u003ewrite_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init write_lock\");\n\t\tgoto error_handle;\n\t}\n\tiot_os_mutex_init(\u0026c-\u003eread_lock);\n\tif (c-\u003eread_lock.sem == NULL) {\n\t\tIOT_ERROR(\"fail to init read_lock\");\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003ewrite_pending_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003eack_pending_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((_iot_mqtt_queue_init(\u0026c-\u003euser_event_callback_queue))) {\n\t\tgoto error_handle;\n\t}\n\tif ((c-\u003eping_packet = _iot_mqtt_chunk_create(MQTT_PINGREQ_PACKET_SIZE)) == NULL) {\n\t\tgoto error_handle;\n\t}\n\tMQTTSerialize_pingreq(c-\u003eping_packet-\u003echunk_data, MQTT_PINGREQ_PACKET_SIZE);\n\tc-\u003eping_packet-\u003epacket_type = PINGREQ;\n\tc-\u003eping_packet-\u003ehave_owner = 1;\n\n\treturn 0;\nerror_handle:\n\tif (c) {\n\t\tif (c-\u003enet)\n\t\t\tiot_os_free(c-\u003enet);\n\t\tif (c-\u003elast_sent)\n\t\t\tiot_os_timer_destroy(\u0026c-\u003elast_sent);\n\t\tif (c-\u003elast_received)\n\t\t\tiot_os_timer_destroy(\u0026c-\u003elast_received);\n\t\tif (c-\u003eclient_manage_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003eclient_manage_lock);\n\t\tif (c-\u003ewrite_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003ewrite_lock);\n\t\tif (c-\u003eread_lock.sem)\n\t\t\tiot_os_mutex_destroy(\u0026c-\u003eread_lock);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003ewrite_pending_queue);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003eack_pending_queue);\n\t\t_iot_mqtt_queue_destroy(\u0026c-\u003euser_event_callback_queue);\n\t\tif (c-\u003eping_packet) {\n\t\t\t_iot_mqtt_chunk_destroy(c-\u003eping_packet);\n\t\t}\n\t\tiot_os_free(c);\n\t\t*client = NULL;\n\t}\n\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_MQTT_CREATE_FAIL, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":630,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"115760":{"score":0.8652681,"function_name":"_iot_mqtt_close_net","code":"static void _iot_mqtt_close_net(MQTTClient *client)\n{\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn;\n\t}\n\n\tdo {\n\t\tif (client-\u003eread_lock.sem == NULL)\n\t\t\treturn;\n\t} while ((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE);\n\n\tdo {\n\t\tif (client-\u003ewrite_lock.sem == NULL) {\n\t\t\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\t\t\treturn;\n\t\t}\n\t} while ((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE);\n\tif (client-\u003eisconnected) {\n\t\tclient-\u003eisconnected = 0;\n\t\tclient-\u003enet-\u003eshow_status(client-\u003enet);\n\t\tclient-\u003enet-\u003edisconnect(client-\u003enet);\n\t}\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":729,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"116036":{"score":0.84752345,"function_name":"_iot_mqtt_connect_net","code":"static int _iot_mqtt_connect_net(MQTTClient *client, st_mqtt_broker_info_t *broker)\n{\n\tint rc = 0, connect_retry = 3;\n\tiot_error_t iot_err;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eread_lock)) != IOT_OS_TRUE) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003ewrite_lock)) != IOT_OS_TRUE) {\n\t\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tiot_err = iot_net_init(client-\u003enet);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"failed to init network\");\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tgoto exit;\n\t}\n\n\tclient-\u003enet-\u003econnection.url = broker-\u003eurl;\n\tclient-\u003enet-\u003econnection.port = broker-\u003eport;\n\tclient-\u003enet-\u003econnection.ca_cert = broker-\u003eca_cert;\n\tclient-\u003enet-\u003econnection.ca_cert_len = broker-\u003eca_cert_len;\n\n\tdo {\n\t\tiot_err = client-\u003enet-\u003econnect(client-\u003enet);\n\t\tif (iot_err) {\n\t\t\tIOT_ERROR(\"net-\u003econnect = %d, retry (%d)\", iot_err, connect_retry);\n\t\t\tconnect_retry--;\n\t\t\tiot_os_delay(2000);\n\t\t}\n\t} while ((iot_err != IOT_ERROR_NONE) \u0026\u0026 connect_retry);\n\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"MQTT net connection failed\");\n\t\trc = E_ST_MQTT_FAILURE;\n\t\tgoto exit;\n\t}\n\n\tif (client-\u003enet-\u003etcp_keepalive) {\n\t\tiot_err = client-\u003enet-\u003etcp_keepalive(client-\u003enet, ST_MQTT_TCP_KEEPALIVE_IDLE,\n\t\t\t\tST_MQTT_TCP_KEEPALIVE_COUNT,\n\t\t\t\tST_MQTT_TCP_KEEPALIVE_INTERVAL);\n\t\tif (iot_err) {\n\t\t\tIOT_WARN(\"fail to set keepalive %d\", iot_err);\n\t\t}\n\t}\n\n\tclient-\u003eisconnected = 1;\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003ewrite_lock);\n\tiot_os_mutex_unlock(\u0026client-\u003eread_lock);\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":755,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"116655":{"score":0.9034426,"function_name":"st_mqtt_destroy","code":"void st_mqtt_destroy(st_mqtt_client client)\n{\n\tMQTTClient *c = client;\n\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn;\n\t}\n\t// invalidate MQTTClient struct\n\tc-\u003emagic = 0;\n\n\t_iot_mqtt_close_net(c);\n\tiot_os_free(c-\u003enet);\n\tiot_os_mutex_destroy(\u0026c-\u003ewrite_lock);\n\tiot_os_mutex_destroy(\u0026c-\u003eread_lock);\n\n\t_iot_mqtt_queue_destroy(\u0026c-\u003ewrite_pending_queue);\n\t_iot_mqtt_queue_destroy(\u0026c-\u003eack_pending_queue);\n\t_iot_mqtt_queue_destroy(\u0026c-\u003euser_event_callback_queue);\n\tdo {\n\t\tif (c-\u003eclient_manage_lock.sem == NULL)\n\t\t\tgoto skip_manage_lock;\n\t} while ((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) != IOT_OS_TRUE);\n\tiot_os_timer_destroy(\u0026c-\u003elast_sent);\n\tiot_os_timer_destroy(\u0026c-\u003elast_received);\n\tif (c-\u003eping_packet) {\n\t\t_iot_mqtt_chunk_destroy(c-\u003eping_packet);\n\t}\n\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\tiot_os_mutex_destroy(\u0026c-\u003eclient_manage_lock);\n\nskip_manage_lock:\n\tc-\u003ethread = NULL;\n\tiot_os_free(c);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":818,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117017":{"score":0.84721726,"function_name":"_iot_mqtt_check_alive","code":"static int _iot_mqtt_check_alive(MQTTClient *client)\n{\n\tint rc = 0;\n\n\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\n\tif((iot_os_mutex_lock(\u0026client-\u003eclient_manage_lock)) != IOT_OS_TRUE) {\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\tif (iot_os_timer_isexpired(client-\u003elast_sent) || iot_os_timer_isexpired(client-\u003elast_received)) {\n\t\tswitch (client-\u003eping_packet-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_ACKNOWLEDGED :\n\t\t\tcase PACKET_CHUNK_INIT :\n\t\t\t\tclient-\u003eping_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t\t\tclient-\u003eping_packet-\u003eretry_count = 0;\n\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, client-\u003eping_packet);\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\t\tclient-\u003eping_packet-\u003echunk_state = PACKET_CHUNK_INIT;\n\t\t\t\tIOT_WARN(\"mqtt didn't get PINGRESP\");\n\t\t\t\trc = E_ST_MQTT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tiot_os_mutex_unlock(\u0026client-\u003eclient_manage_lock);\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":853,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117326":{"score":0.6116907,"function_name":"_iot_mqtt_process_pending_packets","code":"static void _iot_mqtt_process_pending_packets(MQTTClient *client)\n{\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\n\twhile (1) {\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn;\n\t\t}\n\t\tw_chunk = _iot_mqtt_queue_pop_by_expiry(\u0026client-\u003eack_pending_queue);\n\t\tif (w_chunk == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (w_chunk-\u003epacket_type) {\n\t\t\tcase CONNECT:\n\t\t\t\tif (w_chunk-\u003ehave_owner) {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t} else {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tw_chunk-\u003eretry_count++;\n\t\t\t\tif (w_chunk-\u003eretry_count \u003c MQTT_PUBLISH_RETRY) {\n\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003ewrite_pending_queue, w_chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (w_chunk-\u003ehave_owner) {\n\t\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tw_chunk-\u003echunk_state = PACKET_CHUNK_TIMEOUT;\n\t\t\t\t\t\tif (client != NULL \u0026\u0026 client-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\t\t\t\t\t_iot_mqtt_queue_push(\u0026client-\u003euser_event_callback_queue, w_chunk);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":888,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117710":{"score":0.89329433,"function_name":"_iot_mqtt_deliver_publish","code":"static void _iot_mqtt_deliver_publish(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tst_mqtt_msg msg;\n\tMQTTString topic_name;\n\tint qos;\n\tunsigned char dup;\n\tunsigned short id;\n\n\tMQTTDeserialize_publish(\u0026dup, \u0026qos, \u0026msg.retained, \u0026id, \u0026topic_name,\n\t\t\t\t\t\t\t(unsigned char **)\u0026msg.payload, (int *)\u0026msg.payloadlen, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\n\tmsg.qos = qos;\n\tmsg.topic = topic_name.lenstring.data;\n\tmsg.topiclen = topic_name.lenstring.len;\n\tclient-\u003euser_callback_fp(ST_MQTT_EVENT_MSG_DELIVERED, \u0026msg, client-\u003euser_callback_user_data);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":939,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"117885":{"score":0.90304106,"function_name":"_iot_mqtt_notify_publish_failed","code":"static void _iot_mqtt_notify_publish_failed(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tst_mqtt_msg msg;\n\tMQTTString topic_name;\n\tint qos;\n\tunsigned char dup;\n\tunsigned short id;\n\n\tMQTTDeserialize_publish(\u0026dup, \u0026qos, \u0026msg.retained, \u0026id, \u0026topic_name,\n\t\t\t\t\t\t\t(unsigned char **)\u0026msg.payload, (int *)\u0026msg.payloadlen, chunk-\u003echunk_data, chunk-\u003echunk_size);\n\n\tmsg.qos = qos;\n\tmsg.topic = topic_name.lenstring.data;\n\tmsg.topiclen = topic_name.lenstring.len;\n\tclient-\u003euser_callback_fp(ST_MQTT_EVENT_PUBLISH_FAILED, \u0026msg, client-\u003euser_callback_user_data);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":956,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118060":{"score":0.5862708,"function_name":"_iot_mqtt_process_user_callback","code":"static void _iot_mqtt_process_user_callback(MQTTClient *client)\n{\n\tiot_mqtt_packet_chunk_t *w_chunk = NULL;\n\n\twhile (1) {\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn;\n\t\t}\n\t\tw_chunk = _iot_mqtt_queue_pop(\u0026client-\u003euser_event_callback_queue);\n\t\tif (w_chunk == NULL) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (w_chunk-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\tcase PACKET_CHUNK_WRITE_FAIL:\n\t\t\t\tif (w_chunk-\u003epacket_type == PUBLISH) {\n\t\t\t\t\t_iot_mqtt_notify_publish_failed(client, w_chunk);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_READ_COMPLETED:\n\t\t\t\tif (w_chunk-\u003epacket_type == PUBLISH) {\n\t\t\t\t\t_iot_mqtt_deliver_publish(client, w_chunk);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\t\t_iot_mqtt_chunk_destroy(w_chunk);\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":973,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118246":{"score":0.5717248,"function_name":"_iot_mqtt_run_cycle","code":"static int _iot_mqtt_run_cycle(MQTTClient *client)\n{\n\tint rc = 0;\n\n\trc = _iot_mqtt_run_write_stream(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_WRITE_STREAM_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\trc = _iot_mqtt_run_read_stream(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_READ_STREAM_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\t_iot_mqtt_process_pending_packets(client);\n\n\trc = _iot_mqtt_check_alive(client);\n\tif (rc \u003c 0) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_MQTT_PING_FAIL, rc, 0);\n\t\treturn rc;\n\t}\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1004,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118372":{"score":0.87235296,"function_name":"st_mqtt_yield","code":"int st_mqtt_yield(st_mqtt_client client, int time)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tiot_error_t iot_err;\n\tiot_os_timer timer;\n\n\tiot_err = iot_os_timer_init(\u0026timer);\n\tif (iot_err) {\n\t\tIOT_ERROR(\"fail to init timer\");\n\t\treturn E_ST_MQTT_FAILURE;\n\t}\n\tiot_os_timer_count_ms(timer, time);\n\n\tdo {\n\t\trc = _iot_mqtt_run_cycle(c);\n\t\t_iot_mqtt_process_user_callback(c);\n\t} while (!iot_os_timer_isexpired(timer) \u0026\u0026 !rc);\n\tiot_os_timer_destroy(\u0026timer);\n\n\t// Check if there is left work to do.\n\tif (rc == 0) {\n\t\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\treturn E_ST_MQTT_FAILURE;\n\t\t}\n\n\t\tif((iot_os_mutex_lock(\u0026c-\u003eread_lock)) == IOT_OS_TRUE) {\n\t\t\tif (c-\u003ewrite_pending_queue.head != NULL) {\n\t\t\t\trc = 1;\n\t\t\t} else if (c-\u003euser_event_callback_queue.head != NULL) {\n\t\t\t\trc = 1;\n\t\t\t} else if(c-\u003eisconnected \u0026\u0026 (c-\u003enet-\u003eselect(c-\u003enet, 0) \u003e 0)) {\n\t\t\t\trc = 1;\n\t\t\t}\n\n\t\t\tiot_os_mutex_unlock(\u0026c-\u003eread_lock);\n\t\t}\n\t}\n\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1031,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118784":{"score":0.78754723,"function_name":"_iot_mqtt_thread_run","code":"static void _iot_mqtt_thread_run(void *parm)\n{\n\tMQTTClient *client = (MQTTClient *)parm;\n\tint rc = 0;\n\n\tdo {\n\t\trc = _iot_mqtt_run_cycle(client);\n\t\t_iot_mqtt_process_user_callback(client);\n\t\tif (client == NULL || client-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\t\tbreak;\n\t\t}\n\t} while (!rc \u0026\u0026 client-\u003ethread);\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1073,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"118998":{"score":0.83233255,"function_name":"_iot_mqtt_wait_for","code":"static int _iot_mqtt_wait_for(MQTTClient *client, iot_mqtt_packet_chunk_t *chunk)\n{\n\tiot_mqtt_packet_chunk_t *tmp = NULL;\n\tint rc = 0;\n\n\twhile (1) {\n\t\trc = _iot_mqtt_run_cycle(client);\n\t\tswitch (chunk-\u003echunk_state) {\n\t\t\tcase PACKET_CHUNK_WRITE_PENDING:\n\t\t\t\tif (rc \u003c 0) {\n\t\t\t\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003ewrite_pending_queue, chunk-\u003epacket_type, chunk-\u003epacket_id);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_ACK_PENDING:\n\t\t\t\tif (rc \u003c 0) {\n\t\t\t\t\ttmp = _iot_mqtt_queue_pop_by_type_and_id(\u0026client-\u003eack_pending_queue, chunk-\u003epacket_type, chunk-\u003epacket_id);\n\t\t\t\t\tif (tmp) {\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tiot_os_delay(MQTT_ACKPENDING_WAITCYCLE_IN_SYNC_FUNCTION);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PACKET_CHUNK_WRITE_COMPLETED:\n\t\t\tcase PACKET_CHUNK_ACKNOWLEDGED:\n\t\t\t\trc = chunk-\u003ereturn_code;\n\t\t\t\tgoto exit;\n\t\t\tcase PACKET_CHUNK_QUEUE_DESTROYED:\n\t\t\tcase PACKET_CHUNK_WRITE_FAIL:\n\t\t\tcase PACKET_CHUNK_TIMEOUT:\n\t\t\t\trc = E_ST_MQTT_FAILURE;\n\t\t\t\tgoto exit;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\nexit:\n\t_iot_mqtt_chunk_destroy(chunk);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1103,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"119251":{"score":0.8724883,"function_name":"st_mqtt_connect","code":"int st_mqtt_connect(st_mqtt_client client, st_mqtt_broker_info_t *broker, st_mqtt_connect_data *connect_data)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tMQTTPacket_connectData options = MQTTPacket_connectData_initializer;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *connect_packet = NULL;\n\n\trc = _iot_mqtt_connect_net(c, broker);\n\tif (rc \u003c 0) {\n\t\treturn rc;\n\t}\n\n\tif (connect_data-\u003ewill_flag) {\n\t\toptions.willFlag = 1;\n\t\toptions.will.topicName.cstring = connect_data-\u003ewill_topic;\n\t\toptions.will.message.cstring = connect_data-\u003ewill_message;\n\t\toptions.will.retained = connect_data-\u003ewill_retained;\n\t\toptions.will.qos = connect_data-\u003ewill_qos;\n\t} else\n\t\toptions.willFlag = 0;\n\n\toptions.MQTTVersion  = connect_data-\u003emqtt_ver;\n\toptions.clientID.cstring  = connect_data-\u003eclientid;\n\toptions.username.cstring  = connect_data-\u003eusername;\n\toptions.password.cstring  = connect_data-\u003epassword;\n\toptions.keepAliveInterval = connect_data-\u003ealive_interval;\n\toptions.cleansession = connect_data-\u003ecleansession;\n\n\tchunk_size = MQTTSerialize_connect_size(\u0026options);\n\tconnect_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (connect_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tMQTTSerialize_connect(connect_packet-\u003echunk_data, chunk_size, \u0026options);\n\tconnect_packet-\u003epacket_type = CONNECT;\n\tconnect_packet-\u003ehave_owner = 1;\n\tif (c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(connect_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003ekeepAliveInterval = options.keepAliveInterval;\n\tiot_os_timer_count_ms(c-\u003elast_sent, c-\u003ekeepAliveInterval * 1000);\n\tiot_os_timer_count_ms(c-\u003elast_received, c-\u003ekeepAliveInterval * 1000);\n\tconnect_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, connect_packet);\n\n\trc = _iot_mqtt_wait_for(c, connect_packet);\n\nexit:\n\tif (rc \u003c 0) {\n\t\t_iot_mqtt_close_net(c);\n\t}\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_CONNECT_RESULT, rc, connect_data-\u003ealive_interval);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1148,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"119914":{"score":0.80634403,"function_name":"st_mqtt_subscribe","code":"int st_mqtt_subscribe(st_mqtt_client client, const char *topic, int qos)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *sub_packet = NULL;\n\tMQTTString Topic = MQTTString_initializer;\n\tTopic.cstring = (char *)topic;\n\n\tchunk_size = MQTTSerialize_subscribe_size(1, \u0026Topic);\n\tsub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (sub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(sub_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\tsub_packet-\u003epacket_id = c-\u003enext_packetid;\n\tMQTTSerialize_subscribe(sub_packet-\u003echunk_data, chunk_size, 0, sub_packet-\u003epacket_id, 1, \u0026Topic, (int *)\u0026qos);\n\tsub_packet-\u003epacket_type = SUBSCRIBE;\n\tsub_packet-\u003ehave_owner = 1;\n\tsub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, sub_packet);\n\n\trc = _iot_mqtt_wait_for(c, sub_packet);\n\nexit:\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_SUBSCRIBE, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1209,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"120323":{"score":0.83819354,"function_name":"st_mqtt_unsubscribe","code":"int st_mqtt_unsubscribe(st_mqtt_client client, const char *topic)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tMQTTString Topic = MQTTString_initializer;\n\tTopic.cstring = (char *)topic;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *unsub_packet = NULL;\n\n\tchunk_size = MQTTSerialize_unsubscribe_size(1, \u0026Topic);\n\tunsub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (unsub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(unsub_packet);\n\t\tgoto exit;\n\t}\n\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\tunsub_packet-\u003epacket_id = c-\u003enext_packetid;\n\tMQTTSerialize_unsubscribe(unsub_packet-\u003echunk_data, chunk_size, 0, unsub_packet-\u003epacket_id, 1, \u0026Topic);\n\tunsub_packet-\u003epacket_type = UNSUBSCRIBE;\n\tunsub_packet-\u003ehave_owner = 1;\n\tunsub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, unsub_packet);\n\n\trc = _iot_mqtt_wait_for(c, unsub_packet);\n\nexit:\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_UNSUBSCRIBE, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1245,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"120728":{"score":0.8789093,"function_name":"_iot_mqtt_push_publish_packet","code":"static iot_mqtt_packet_chunk_t * _iot_mqtt_push_publish_packet(MQTTClient *c, st_mqtt_msg *msg, unsigned char is_sync)\n{\n\tMQTTString topic = MQTTString_initializer;\n\ttopic.cstring = (char *)msg-\u003etopic;\n\tint chunk_size;\n\tiot_mqtt_packet_chunk_t *pub_packet = NULL;\n\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\treturn NULL;\n\t}\n\tif((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) != IOT_OS_TRUE) {\n\t\treturn NULL;\n\t}\n\n\tchunk_size = MQTTSerialize_publish_size(msg-\u003eqos, topic, msg-\u003epayloadlen);\n\tpub_packet = _iot_mqtt_chunk_create(chunk_size);\n\tif (pub_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\tgoto exit;\n\t}\n\n\tif (msg-\u003eqos == st_mqtt_qos1 || msg-\u003eqos == st_mqtt_qos2) {\n\t\tc-\u003enext_packetid = (c-\u003enext_packetid \u003e= MAX_PACKET_ID) ? 1 : c-\u003enext_packetid + 1;\n\t\tpub_packet-\u003epacket_id = c-\u003enext_packetid;\n\t}\n\n\tMQTTSerialize_publish(pub_packet-\u003echunk_data, chunk_size, 0, msg-\u003eqos, msg-\u003eretained, pub_packet-\u003epacket_id,\n\t\t\t\t\t\t\t\t\ttopic, (unsigned char *)msg-\u003epayload, msg-\u003epayloadlen);\n\tpub_packet-\u003epacket_type = PUBLISH;\n\tpub_packet-\u003ehave_owner = is_sync;\n\tpub_packet-\u003eqos = msg-\u003eqos;\n\tpub_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, pub_packet);\n\nexit:\n\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\n\treturn pub_packet;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1281,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121204":{"score":0.9217156,"function_name":"st_mqtt_change_ping_period","code":"void st_mqtt_change_ping_period(st_mqtt_client client, unsigned int new_period)\n{\n\tMQTTClient *c = client;\n\n\tif (c != NULL \u0026\u0026 c-\u003emagic == MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\tif((iot_os_mutex_lock(\u0026c-\u003eclient_manage_lock)) == IOT_OS_TRUE) {\n\t\t\tc-\u003ekeepAliveInterval = new_period;\n\t\t\tiot_os_timer_count_ms(c-\u003elast_sent, c-\u003ekeepAliveInterval * 1000);\n\t\t\tiot_os_timer_count_ms(c-\u003elast_received, c-\u003ekeepAliveInterval * 1000);\n\t\t\tiot_os_mutex_unlock(\u0026c-\u003eclient_manage_lock);\n\t\t}\n\t}\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121539":{"score":0.9175328,"function_name":"st_mqtt_disconnect","code":"int st_mqtt_disconnect(st_mqtt_client client)\n{\n\tMQTTClient *c = client;\n\tint rc = 0;\n\tiot_mqtt_packet_chunk_t *disconnect_packet = NULL;\n\n\tdisconnect_packet = _iot_mqtt_chunk_create(MQTT_DISCONNECT_PACKET_SIZE);\n\tif (disconnect_packet == NULL) {\n\t\tIOT_ERROR(\"buf malloc fail\");\n\t\trc = E_ST_MQTT_BUFFER_OVERFLOW;\n\t\tgoto exit;\n\t}\n\tMQTTSerialize_disconnect(disconnect_packet-\u003echunk_data, MQTT_DISCONNECT_PACKET_SIZE);\n\tdisconnect_packet-\u003epacket_type = DISCONNECT;\n\tdisconnect_packet-\u003ehave_owner = 1;\n\tdisconnect_packet-\u003echunk_state = PACKET_CHUNK_WRITE_PENDING;\n\tif (c == NULL || c-\u003emagic != MQTT_CLIENT_STRUCT_MAGIC_NUMBER) {\n\t\trc = E_ST_MQTT_FAILURE;\n\t\t_iot_mqtt_chunk_destroy(disconnect_packet);\n\t\tgoto exit;\n\t}\n\t_iot_mqtt_queue_push(\u0026c-\u003ewrite_pending_queue, disconnect_packet);\n\n\trc = _iot_mqtt_wait_for(c, disconnect_packet);\n\nexit:\n\tIOT_INFO(\"mqtt disconnect %d\", rc);\n\t_iot_mqtt_close_net(c);\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_MQTT_DISCONNECT, rc, 0);\n\treturn rc;\n}","filepath":"src/mqtt/client/iot_mqtt_client.c","line_number":1365,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"121842":{"score":0.778298,"function_name":"MQTTSerialize_connectLength","code":"int MQTTSerialize_connectLength(MQTTPacket_connectData* options)\n{\n\tint len = 0;\n\n\tFUNC_ENTRY;\n\n\tif (options-\u003eMQTTVersion == 3)\n\t\tlen = 12; /* variable depending on MQTT or MQIsdp */\n\telse if (options-\u003eMQTTVersion == 4)\n\t\tlen = 10;\n\n\tlen += MQTTstrlen(options-\u003eclientID)+2;\n\tif (options-\u003ewillFlag)\n\t\tlen += MQTTstrlen(options-\u003ewill.topicName)+2 + MQTTstrlen(options-\u003ewill.message)+2;\n\tif (options-\u003eusername.cstring || options-\u003eusername.lenstring.data)\n\t\tlen += MQTTstrlen(options-\u003eusername)+2;\n\tif (options-\u003epassword.cstring || options-\u003epassword.lenstring.data)\n\t\tlen += MQTTstrlen(options-\u003epassword)+2;\n\n\tFUNC_EXIT_RC(len);\n\treturn len;\n}","filepath":"platform/mcu/rtl8710bn/sdk/component/common/application/mqtt/MQTTPacket/MQTTConnectClient.c","line_number":27,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v1.2.2"},"122111":{"score":0.81122446,"function_name":"MQTTSerialize_connect","code":"int MQTTSerialize_connect(unsigned char* buf, int buflen, MQTTPacket_connectData* options)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tMQTTConnectFlags flags = {0};\n\tint len = 0;\n\tint rc = -1;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(len = MQTTSerialize_connectLength(options)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = CONNECT;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, len); /* write remaining length */\n\n\tif (options-\u003eMQTTVersion == 4)\n\t{\n\t\twriteCString(\u0026ptr, \"MQTT\");\n\t\twriteChar(\u0026ptr, (char) 4);\n\t}\n\telse\n\t{\n\t\twriteCString(\u0026ptr, \"MQIsdp\");\n\t\twriteChar(\u0026ptr, (char) 3);\n\t}\n\n\tflags.all = 0;\n\tflags.bits.cleansession = options-\u003ecleansession;\n\tflags.bits.will = (options-\u003ewillFlag) ? 1 : 0;\n\tif (flags.bits.will)\n\t{\n\t\tflags.bits.willQoS = options-\u003ewill.qos;\n\t\tflags.bits.willRetain = options-\u003ewill.retained;\n\t}\n\n\tif (options-\u003eusername.cstring || options-\u003eusername.lenstring.data)\n\t\tflags.bits.username = 1;\n\tif (options-\u003epassword.cstring || options-\u003epassword.lenstring.data)\n\t\tflags.bits.password = 1;\n\n\twriteChar(\u0026ptr, flags.all);\n\twriteInt(\u0026ptr, options-\u003ekeepAliveInterval);\n\twriteMQTTString(\u0026ptr, options-\u003eclientID);\n\tif (options-\u003ewillFlag)\n\t{\n\t\twriteMQTTString(\u0026ptr, options-\u003ewill.topicName);\n\t\twriteMQTTString(\u0026ptr, options-\u003ewill.message);\n\t}\n\tif (flags.bits.username)\n\t\twriteMQTTString(\u0026ptr, options-\u003eusername);\n\tif (flags.bits.password)\n\t\twriteMQTTString(\u0026ptr, options-\u003epassword);\n\n\trc = ptr - buf;\n\n\texit: FUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"platform/mcu/rtl8710bn/sdk/component/common/application/mqtt/MQTTPacket/MQTTConnectClient.c","line_number":58,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v1.2.2"},"123142":{"score":0.7988243,"function_name":"MQTTSerialize_zero","code":"int MQTTSerialize_zero(unsigned char* buf, int buflen, unsigned char packettype)\n{\n\tMQTTHeader header = {0};\n\tint rc = -1;\n\tunsigned char *ptr = buf;\n\n\tFUNC_ENTRY;\n\tif (buflen \u003c 2)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\theader.byte = 0;\n\theader.bits.type = packettype;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, 0); /* write remaining length */\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"platform/mcu/rtl8710bn/sdk/component/common/application/mqtt/MQTTPacket/MQTTConnectClient.c","line_number":169,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v1.2.2"},"123778":{"score":0.6462923,"function_name":"MQTTDeserialize_connack","code":"int MQTTDeserialize_connack(unsigned char* sessionPresent, unsigned char* connack_rc, unsigned char* buf, int buflen)\n{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen;\n\tMQTTConnackFlags flags = {0};\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(\u0026curdata);\n\tif (header.bits.type != CONNACK)\n\t\tgoto exit;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, \u0026mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\tif (enddata - curdata \u003c 2)\n\t\tgoto exit;\n\n\tflags.all = readChar(\u0026curdata);\n\t*sessionPresent = flags.bits.sessionpresent;\n\t*connack_rc = readChar(\u0026curdata);\n\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"platform/mcu/rtl8710bn/sdk/component/common/application/mqtt/MQTTPacket/MQTTConnectClient.c","line_number":132,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"v1.2.2"},"124022":{"score":0.6994847,"function_name":"MQTTPacket_encode","code":"int MQTTPacket_encode(unsigned char* buf, int length)\n{\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tdo\n\t{\n\t\tchar d = length % 128;\n\t\tlength /= 128;\n\t\t/* if there are more digits to encode, set the top bit of this digit */\n\t\tif (length \u003e 0)\n\t\t\td |= 0x80;\n\t\tbuf[rc++] = d;\n\t} while (length \u003e 0);\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":29,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"124122":{"score":0.9010924,"function_name":"MQTTPacket_decode","code":"int MQTTPacket_decode(int (*getcharfn)(unsigned char*, int), int* value)\n{\n\tunsigned char c;\n\tint multiplier = 1;\n\tint len = 0;\n\n\tFUNC_ENTRY;\n\t*value = 0;\n\tdo\n\t{\n\t\tint rc = MQTTPACKET_READ_ERROR;\n\n\t\tif (++len \u003e MAX_NUM_OF_REMAINING_LENGTH_BYTES)\n\t\t{\n\t\t\trc = MQTTPACKET_READ_ERROR;\t/* bad data */\n\t\t\tgoto exit;\n\t\t}\n\t\trc = (*getcharfn)(\u0026c, 1);\n\t\tif (rc != 1)\n\t\t\tgoto exit;\n\t\t*value += (c \u0026 127) * multiplier;\n\t\tmultiplier *= 128;\n\t} while ((c \u0026 128) != 0);\nexit:\n\tFUNC_EXIT_RC(len);\n\treturn len;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":54,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"124299":{"score":0.87672263,"function_name":"MQTTPacket_len","code":"int MQTTPacket_len(int rem_len)\n{\n\trem_len += 1; /* header byte */\n\n\t/* now remaining_length field */\n\tif (rem_len \u003c 128)\n\t\trem_len += 1;\n\telse if (rem_len \u003c 16384)\n\t\trem_len += 2;\n\telse if (rem_len \u003c 2097151)\n\t\trem_len += 3;\n\telse\n\t\trem_len += 4;\n\treturn rem_len;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":83,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"124888":{"score":0.6249056,"function_name":"writeMQTTString","code":"void writeMQTTString(unsigned char** pptr, MQTTString mqttstring)\n{\n\tif (mqttstring.lenstring.len \u003e 0)\n\t{\n\t\twriteInt(pptr, mqttstring.lenstring.len);\n\t\tmemcpy(*pptr, mqttstring.lenstring.data, mqttstring.lenstring.len);\n\t\t*pptr += mqttstring.lenstring.len;\n\t}\n\telse if (mqttstring.cstring)\n\t\twriteCString(pptr, mqttstring.cstring);\n\telse\n\t\twriteInt(pptr, 0);\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":193,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125021":{"score":0.7973988,"function_name":"readMQTTLenString","code":"int readMQTTLenString(MQTTString* mqttstring, unsigned char** pptr, unsigned char* enddata)\n{\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\t/* the first two bytes are the length of the string */\n\tif (enddata - (*pptr) \u003e 1) /* enough length to read the integer? */\n\t{\n\t\tmqttstring-\u003elenstring.len = readInt(pptr); /* increments pptr to point past length */\n\t\tif (\u0026(*pptr)[mqttstring-\u003elenstring.len] \u003c= enddata)\n\t\t{\n\t\t\tmqttstring-\u003elenstring.data = (char*)*pptr;\n\t\t\t*pptr += mqttstring-\u003elenstring.len;\n\t\t\trc = 1;\n\t\t}\n\t}\n\tmqttstring-\u003ecstring = NULL;\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":214,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125148":{"score":0.6198275,"function_name":"MQTTstrlen","code":"int MQTTstrlen(MQTTString mqttstring)\n{\n\tint rc = 0;\n\n\tif (mqttstring.cstring)\n\t\trc = strlen(mqttstring.cstring);\n\telse\n\t\trc = mqttstring.lenstring.len;\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":241,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125215":{"score":0.9491348,"function_name":"MQTTPacket_equals","code":"int MQTTPacket_equals(MQTTString* a, char* bptr)\n{\n\tint alen = 0,\n\t\tblen = 0;\n\tchar *aptr;\n\t\n\tif (a-\u003ecstring)\n\t{\n\t\taptr = a-\u003ecstring;\n\t\talen = strlen(a-\u003ecstring);\n\t}\n\telse\n\t{\n\t\taptr = a-\u003elenstring.data;\n\t\talen = a-\u003elenstring.len;\n\t}\n\tblen = strlen(bptr);\n\t\n\treturn (alen == blen) \u0026\u0026 (strncmp(aptr, bptr, alen) == 0);\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":259,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125371":{"score":0.9269615,"function_name":"MQTTPacket_read","code":"int MQTTPacket_read(unsigned char* buf, int buflen, int (*getfn)(unsigned char*, int))\n{\n\tint rc = -1;\n\tMQTTHeader header = {0};\n\tint len = 0;\n\tint rem_len = 0;\n\n\t/* 1. read the header byte.  This has the packet type in it */\n\tif ((*getfn)(buf, 1) != 1)\n\t\tgoto exit;\n\n\tlen = 1;\n\t/* 2. read the remaining length.  This is variable in itself */\n\tMQTTPacket_decode(getfn, \u0026rem_len);\n\tlen += MQTTPacket_encode(buf + 1, rem_len); /* put the original remaining length back into the buffer */\n\n\t/* 3. read the rest of the buffer using a callback to supply the rest of the data */\n\tif((rem_len + len) \u003e buflen)\n\t\tgoto exit;\n\tif (rem_len \u0026\u0026 ((*getfn)(buf + len, rem_len) != rem_len))\n\t\tgoto exit;\n\n\theader.byte = buf[0];\n\trc = header.bits.type;\nexit:\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":289,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125615":{"score":0.81131566,"function_name":"MQTTPacket_decodenb","code":"static int MQTTPacket_decodenb(MQTTTransport *trp)\n{\n\tunsigned char c;\n\tint rc = MQTTPACKET_READ_ERROR;\n\n\tFUNC_ENTRY;\n\tif(trp-\u003elen == 0){\t\t/* initialize on first call */\n\t\ttrp-\u003emultiplier = 1;\n\t\ttrp-\u003erem_len = 0;\n\t}\n\tdo {\n\t\tint frc;\n\t\tif (trp-\u003elen \u003e= MAX_NUM_OF_REMAINING_LENGTH_BYTES)\n\t\t\tgoto exit;\n\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, \u0026c, 1)) == -1)\n\t\t\tgoto exit;\n\t\tif (frc == 0){\n\t\t\trc = 0;\n\t\t\tgoto exit;\n\t\t}\n\t\t++(trp-\u003elen);\n\t\ttrp-\u003erem_len += (c \u0026 127) * trp-\u003emultiplier;\n\t\ttrp-\u003emultiplier *= 128;\n\t} while ((c \u0026 128) != 0);\n\trc = trp-\u003elen;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":323,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"125866":{"score":0.91812015,"function_name":"MQTTPacket_readnb","code":"int MQTTPacket_readnb(unsigned char* buf, int buflen, MQTTTransport *trp)\n{\n\tint rc = -1, frc;\n\tMQTTHeader header = {0};\n\n\tswitch(trp-\u003estate){\n\tdefault:\n\t\ttrp-\u003estate = 0;\n\t\t/*FALLTHROUGH*/\n\tcase 0:\n\t\t/* read the header byte.  This has the packet type in it */\n\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, buf, 1)) == -1)\n\t\t\tgoto exit;\n\t\tif (frc == 0)\n\t\t\treturn 0;\n\t\ttrp-\u003elen = 0;\n\t\t++trp-\u003estate;\n\t\t/*FALLTHROUGH*/\n\t\t/* read the remaining length.  This is variable in itself */\n\tcase 1:\n\t\tif((frc=MQTTPacket_decodenb(trp)) == MQTTPACKET_READ_ERROR)\n\t\t\tgoto exit;\n\t\tif(frc == 0)\n\t\t\treturn 0;\n\t\ttrp-\u003elen = 1 + MQTTPacket_encode(buf + 1, trp-\u003erem_len); /* put the original remaining length back into the buffer */\n\t\tif((trp-\u003erem_len + trp-\u003elen) \u003e buflen)\n\t\t\tgoto exit;\n\t\t++trp-\u003estate;\n\t\t/*FALLTHROUGH*/\n\tcase 2:\n\t\tif(trp-\u003erem_len){\n\t\t\t/* read the rest of the buffer using a callback to supply the rest of the data */\n\t\t\tif ((frc=(*trp-\u003egetfn)(trp-\u003esck, buf + trp-\u003elen, trp-\u003erem_len)) == -1)\n\t\t\t\tgoto exit;\n\t\t\tif (frc == 0)\n\t\t\t\treturn 0;\n\t\t\ttrp-\u003erem_len -= frc;\n\t\t\ttrp-\u003elen += frc;\n\t\t\tif(trp-\u003erem_len)\n\t\t\t\treturn 0;\n\t\t}\n\t\theader.byte = buf[0];\n\t\trc = header.bits.type;\n\t\tbreak;\n\t}\n\nexit:\n\ttrp-\u003estate = 0;\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":361,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126305":{"score":0.9419157,"function_name":"MQTTPacket_msgTypesToString","code":"const char* MQTTPacket_msgTypesToString(enum msgTypes msgType)\n{\n\tswitch (msgType)\n\t{\n\t\tcase CONNECT: return \"CONNECT\";\n\t\tcase CONNACK: return \"CONNACK\";\n\t\tcase PUBLISH: return \"PUBLISH\";\n\t\tcase PUBACK: return \"PUBACK\";\n\t\tcase PUBREC: return \"PUBREC\";\n\t\tcase PUBREL: return \"PUBREL\";\n\t\tcase PUBCOMP: return \"PUBCOMP\";\n\t\tcase SUBSCRIBE: return \"SUBSCRIBE\";\n\t\tcase SUBACK: return \"SUBACK\";\n\t\tcase UNSUBSCRIBE: return \"UNSUBSCRIBE\";\n\t\tcase UNSUBACK: return \"UNSUBACK\";\n\t\tcase PINGREQ: return \"PINGREQ\";\n\t\tcase PINGRESP: return \"PINGRESP\";\n\t\tcase DISCONNECT: return \"DISCONNECT\";\n\t\tdefault: return NULL;\n\t}\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":412,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126464":{"score":0.8879858,"function_name":"MQTTPacket_getPacketId","code":"unsigned int MQTTPacket_getPacketId(unsigned char *buf)\n{\n\tint packet_type = (buf[0] \u0026 0xf0) \u003e\u003e 4;\n\tint qos = (buf[0] \u0026 0x06) \u003e\u003e 1;\n\tint rem_size = 0;\n\tunsigned int packet_id = 0;\n\n\tswitch (packet_type) {\n\t\tcase PUBLISH:\n\t\t\tif (qos == 0)\n\t\t\t\tbreak;\n\t\t\tbuf++;\n\t\t\tbuf += MQTTPacket_decodeBuf(buf, \u0026rem_size);\n\t\t\tbuf += readInt(\u0026buf);\n\t\t\tpacket_id = readInt(\u0026buf);\n\t\t\tbreak;\n\t\tcase PUBACK:\n\t\tcase PUBREC:\n\t\tcase PUBREL:\n\t\tcase PUBCOMP:\n\t\tcase SUBSCRIBE:\n\t\tcase SUBACK:\n\t\tcase UNSUBSCRIBE:\n\t\tcase UNSUBACK:\n\t\t\tbuf++;\n\t\t\tbuf += MQTTPacket_decodeBuf(buf, \u0026rem_size);\n\t\t\tpacket_id += readInt(\u0026buf);\n\t\t\tbreak;\n\t}\n\n\treturn packet_id;\n}","filepath":"src/mqtt/packet/iot_mqtt_packet.c","line_number":434,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126745":{"score":0.69191605,"function_name":"MQTTSerialize_publishLength","code":"int MQTTSerialize_publishLength(int qos, MQTTString topicName, int payloadlen)\n{\n\tint len = 0;\n\n\tlen += 2 + MQTTstrlen(topicName) + payloadlen;\n\tif (qos \u003e 0)\n\t\tlen += 2; /* packetid */\n\treturn len;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":31,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"126820":{"score":0.87686634,"function_name":"MQTTSerialize_publish","code":"int MQTTSerialize_publish(unsigned char* buf, int buflen, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,\n\t\tMQTTString topicName, unsigned char* payload, int payloadlen)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.bits.type = PUBLISH;\n\theader.bits.dup = dup;\n\theader.bits.qos = qos;\n\theader.bits.retain = retained;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteMQTTString(\u0026ptr, topicName);\n\n\tif (qos \u003e 0)\n\t\twriteInt(\u0026ptr, packetid);\n\n\tmemcpy(ptr, payload, payloadlen);\n\tptr += payloadlen;\n\n\trc = ptr - buf;\n\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":55,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"127298":{"score":0.87494874,"function_name":"MQTTSerialize_publish_header","code":"int MQTTSerialize_publish_header(unsigned char* buf, unsigned char dup, int qos, unsigned char retained, unsigned short packetid,\n\t\tMQTTString topicName, int payloadlen)\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\n\trem_len = MQTTSerialize_publishLength(qos, topicName, payloadlen);\n\n\theader.bits.type = PUBLISH;\n\theader.bits.dup = dup;\n\theader.bits.qos = qos;\n\theader.bits.retain = retained;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteMQTTString(\u0026ptr, topicName);\n\n\tif (qos \u003e 0)\n\t\twriteInt(\u0026ptr, packetid);\n\n\trc = ptr - buf;\n\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":98,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"127645":{"score":0.8710425,"function_name":"MQTTSerialize_ack","code":"int MQTTSerialize_ack(unsigned char* buf, int buflen, unsigned char packettype, unsigned char dup, unsigned short packetid)\n{\n\tMQTTHeader header = {0};\n\tint rc = 0;\n\tunsigned char *ptr = buf;\n\n\tFUNC_ENTRY;\n\tif (buflen \u003c 4)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\theader.bits.type = packettype;\n\theader.bits.dup = dup;\n\theader.bits.qos = (packettype == PUBREL) ? 1 : 0;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, 2); /* write remaining length */\n\twriteInt(\u0026ptr, packetid);\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_serialize_publish.c","line_number":135,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"128197":{"score":0.8589493,"function_name":"MQTTSerialize_subscribe","code":"int MQTTSerialize_subscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid, int count,\n\t\tMQTTString topicFilters[], int requestedQoSs[])\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = 0;\n\tint i = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_subscribeLength(count, topicFilters)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = SUBSCRIBE;\n\theader.bits.dup = dup;\n\theader.bits.qos = 1;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteInt(\u0026ptr, packetid);\n\n\tfor (i = 0; i \u003c count; ++i)\n\t{\n\t\twriteMQTTString(\u0026ptr, topicFilters[i]);\n\t\twriteChar(\u0026ptr, requestedQoSs[i]);\n\t}\n\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":50,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"128664":{"score":0.82307124,"function_name":"MQTTDeserialize_suback","code":"int MQTTDeserialize_suback(unsigned short* packetid, int maxcount, int* count, int grantedQoSs[], unsigned char* buf, int buflen)\n{\n\tMQTTHeader header = {0};\n\tunsigned char* curdata = buf;\n\tunsigned char* enddata = NULL;\n\tint rc = 0;\n\tint mylen;\n\n\tFUNC_ENTRY;\n\theader.byte = readChar(\u0026curdata);\n\tif (header.bits.type != SUBACK)\n\t\tgoto exit;\n\n\tcurdata += (rc = MQTTPacket_decodeBuf(curdata, \u0026mylen)); /* read remaining length */\n\tenddata = curdata + mylen;\n\tif (enddata - curdata \u003c 2)\n\t\tgoto exit;\n\n\t*packetid = readInt(\u0026curdata);\n\n\t*count = 0;\n\twhile (curdata \u003c enddata)\n\t{\n\t\tif (*count \u003e maxcount)\n\t\t{\n\t\t\trc = -1;\n\t\t\tgoto exit;\n\t\t}\n\t\tgrantedQoSs[(*count)++] = readChar(\u0026curdata);\n\t}\n\n\trc = 1;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":100,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"128985":{"score":0.79458046,"function_name":"MQTTSerialize_subscribeLength","code":"int MQTTSerialize_subscribeLength(int count, MQTTString topicFilters[])\n{\n\tint i;\n\tint len = 2; /* packetid */\n\n\tfor (i = 0; i \u003c count; ++i)\n\t\tlen += 2 + MQTTstrlen(topicFilters[i]) + 1; /* length + topic + req_qos */\n\treturn len;\n}","filepath":"src/lib/MQTTSubscribeClient.c","line_number":28,"entry_url":"https://github.com/256dpi/arduino-mqtt.git","slot_name":"v1.0"},"129083":{"score":0.8448688,"function_name":"MQTTSerialize_unsubscribe","code":"int MQTTSerialize_unsubscribe(unsigned char* buf, int buflen, unsigned char dup, unsigned short packetid,\n\t\tint count, MQTTString topicFilters[])\n{\n\tunsigned char *ptr = buf;\n\tMQTTHeader header = {0};\n\tint rem_len = 0;\n\tint rc = -1;\n\tint i = 0;\n\n\tFUNC_ENTRY;\n\tif (MQTTPacket_len(rem_len = MQTTSerialize_unsubscribeLength(count, topicFilters)) \u003e buflen)\n\t{\n\t\trc = MQTTPACKET_BUFFER_TOO_SHORT;\n\t\tgoto exit;\n\t}\n\n\theader.byte = 0;\n\theader.bits.type = UNSUBSCRIBE;\n\theader.bits.dup = dup;\n\theader.bits.qos = 1;\n\twriteChar(\u0026ptr, header.byte); /* write header */\n\n\tptr += MQTTPacket_encode(ptr, rem_len); /* write remaining length */;\n\n\twriteInt(\u0026ptr, packetid);\n\n\tfor (i = 0; i \u003c count; ++i)\n\t\twriteMQTTString(\u0026ptr, topicFilters[i]);\n\n\trc = ptr - buf;\nexit:\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_unsubscribe_client.c","line_number":49,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"129508":{"score":0.67760897,"function_name":"MQTTDeserialize_unsuback","code":"int MQTTDeserialize_unsuback(unsigned short* packetid, unsigned char* buf, int buflen)\n{\n\tunsigned char type = 0;\n\tunsigned char dup = 0;\n\tint rc = 0;\n\n\tFUNC_ENTRY;\n\trc = MQTTDeserialize_ack(\u0026type, \u0026dup, packetid, buf, buflen);\n\tif (type == UNSUBACK)\n\t\trc = 1;\n\tFUNC_EXIT_RC(rc);\n\treturn rc;\n}","filepath":"src/mqtt/packet/iot_mqtt_unsubscribe_client.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.0.0"},"129637":{"score":0.9340159,"function_name":"_iot_net_check_interface","code":"static iot_error_t _iot_net_check_interface(iot_net_interface_t *net)\n{\n\tif (net == NULL) {\n\t\tIOT_ERROR(\"interface is null\");\n\t\treturn IOT_ERROR_NET_INVALID_INTERFACE;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":48,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"129715":{"score":0.9277657,"function_name":"_iot_net_show_status","code":"static void _iot_net_show_status(iot_net_interface_t *net)\n{\n\tstruct timeval tv;\n\tstruct timeval timeout = {0};\n\tint socket;\n\tint sock_err = 0;\n\tsocklen_t err_len = sizeof(sock_err);\n\tfd_set rfdset;\n\tfd_set wfdset;\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\n\tFD_ZERO(\u0026rfdset);\n\tFD_ZERO(\u0026wfdset);\n\tFD_SET(socket, \u0026rfdset);\n\tFD_SET(socket, \u0026wfdset);\n\n\tif (select(socket + 1, \u0026rfdset, \u0026wfdset, NULL, \u0026timeout) \u003c 0) {\n\t\tIOT_ERROR(\"failed to select :%d/%d\", (socket + 1), errno);\n\t}\n\tif (getsockopt(socket, SOL_SOCKET, SO_ERROR, \u0026sock_err, \u0026err_len) \u003c 0) {\n\t\tIOT_ERROR(\"failed to getsockopt :%d/%d\", socket, errno);\n\t}\n\tif (gettimeofday(\u0026tv, NULL) \u003c 0) {\n\t\tIOT_ERROR(\"failed to gettimeofday :%d\", errno);\n\t}\n\n\tIOT_INFO(\"[%ld] network socket status: sockfd %d readable %d writable %d sock_err %d errno %d\",\n\t\t\t\ttv.tv_sec, socket,\n\t\t\t\tFD_ISSET(socket, \u0026rfdset),\n\t\t\t\tFD_ISSET(socket, \u0026wfdset), sock_err, errno);\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":58,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"130559":{"score":0.92512226,"function_name":"_iot_net_select","code":"static int _iot_net_select(iot_net_interface_t *net, unsigned int timeout_ms)\n{\n\tstruct timeval timeout;\n\tfd_set fdset;\n\tint socket;\n\tint ret;\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\n\tFD_ZERO(\u0026fdset);\n\tFD_SET(socket, \u0026fdset);\n\n\ttimeout.tv_sec = timeout_ms / 1000;\n\ttimeout.tv_usec = (timeout_ms % 1000) * 1000;\n\n\tret = select(socket + 1, \u0026fdset, NULL, NULL, \u0026timeout);\n\n\treturn ret;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":95,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"130892":{"score":0.81891704,"function_name":"_iot_net_cleanup_platform_context","code":"static void _iot_net_cleanup_platform_context(iot_net_interface_t *net)\n{\n\tif (_iot_net_check_interface(net)) {\n\t\treturn;\n\t}\n\n\tmbedtls_net_free(\u0026net-\u003econtext.server_fd);\n\n\tmbedtls_x509_crt_free(\u0026net-\u003econtext.cacert);\n\tmbedtls_ssl_free(\u0026net-\u003econtext.ssl);\n\tmbedtls_ssl_config_free(\u0026net-\u003econtext.conf);\n\tmbedtls_ctr_drbg_free(\u0026net-\u003econtext.ctr_drbg);\n\tmbedtls_entropy_free(\u0026net-\u003econtext.entropy);\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":119,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"131068":{"score":0.90650755,"function_name":"_iot_net_tls_connect","code":"static iot_error_t _iot_net_tls_connect(iot_net_interface_t *net)\n{\n\tiot_error_t err;\n\tconst char *pers = \"iot_net_mbedtls\";\n\tchar port[5] = {0};\n\tunsigned int flags;\n\tint ret;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmbedtls_net_init(\u0026net-\u003econtext.server_fd);\n\tmbedtls_ssl_init(\u0026net-\u003econtext.ssl);\n\tmbedtls_ssl_config_init(\u0026net-\u003econtext.conf);\n\tmbedtls_x509_crt_init(\u0026net-\u003econtext.cacert);\n\tmbedtls_ctr_drbg_init(\u0026net-\u003econtext.ctr_drbg);\n\n\tmbedtls_entropy_init(\u0026net-\u003econtext.entropy);\n\tret = mbedtls_ctr_drbg_seed(\u0026net-\u003econtext.ctr_drbg,\n\t\t\t\tmbedtls_entropy_func, \u0026net-\u003econtext.entropy,\n\t\t\t\t(const unsigned char *)pers, strlen((char *)pers));\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ctr_drbg_seed = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tif ((net-\u003econnection.ca_cert == NULL) ||\n\t    (net-\u003econnection.ca_cert_len == 0)) {\n\t\tIOT_ERROR(\"ca cert is invalid\");\n\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto exit;\n\t}\n\n\tIOT_INFO(\"Loading the CA root certificate %d@%p\",\n\t\t\t\tnet-\u003econnection.ca_cert_len + 1,\n\t\t\t\tnet-\u003econnection.ca_cert);\n\n\t/* iot-core passed the certificate without NULL character */\n\tret = mbedtls_x509_crt_parse(\u0026net-\u003econtext.cacert,\n\t\t\t\t(const unsigned char *)net-\u003econnection.ca_cert,\n\t\t\t\tnet-\u003econnection.ca_cert_len + 1);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_x509_crt_parse = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tif ((net-\u003econnection.url == NULL) ||\n\t    (net-\u003econnection.port == 0)) {\n\t\tIOT_ERROR(\"server infomation is invalid\");\n\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto exit;\n\t}\n\n\tIOT_DEBUG(\"Connecting to %s:%d\", net-\u003econnection.url, net-\u003econnection.port);\n\n\tsnprintf(port, sizeof(port), \"%d\", net-\u003econnection.port);\n\tret = mbedtls_net_connect(\u0026net-\u003econtext.server_fd,\n\t\t\t\tnet-\u003econnection.url, port,\n\t\t\t\tMBEDTLS_NET_PROTO_TCP);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_net_connect = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ssl_config_defaults(\u0026net-\u003econtext.conf,\n\t\t\t\tMBEDTLS_SSL_IS_CLIENT,\n\t\t\t\tMBEDTLS_SSL_TRANSPORT_STREAM,\n\t\t\t\tMBEDTLS_SSL_PRESET_DEFAULT);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_config_defaults = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tmbedtls_ssl_conf_authmode(\u0026net-\u003econtext.conf, MBEDTLS_SSL_VERIFY_REQUIRED);\n\tmbedtls_ssl_conf_ca_chain(\u0026net-\u003econtext.conf, \u0026net-\u003econtext.cacert, NULL);\n\tmbedtls_ssl_conf_rng(\u0026net-\u003econtext.conf, mbedtls_ctr_drbg_random,\n\t\t\t\t\u0026net-\u003econtext.ctr_drbg);\n\tmbedtls_ssl_conf_read_timeout(\u0026net-\u003econtext.conf, IOT_MBEDTLS_READ_TIMEOUT_MS);\n\n#ifdef CONFIG_MBEDTLS_DEBUG\n\tmbedtls_ssl_conf_dbg(\u0026net-\u003econtext.conf, _iot_net_mbedtls_debug, NULL);\n\tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL);\n#endif\n\n\tret = mbedtls_ssl_setup(\u0026net-\u003econtext.ssl, \u0026net-\u003econtext.conf);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_setup = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ssl_set_hostname(\u0026net-\u003econtext.ssl, net-\u003econnection.url);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ssl_set_hostname = -0x%04X\", -ret);\n\t\tgoto exit;\n\t}\n\n\tmbedtls_ssl_set_bio(\u0026net-\u003econtext.ssl,\n\t\t\t\t\u0026net-\u003econtext.server_fd,\n\t\t\t\tmbedtls_net_send, NULL, mbedtls_net_recv_timeout);\n\n\tIOT_DEBUG(\"Performing the SSL/TLS handshake\");\n\n\twhile ((ret = mbedtls_ssl_handshake(\u0026net-\u003econtext.ssl)) != 0) {\n\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t    (ret != MBEDTLS_ERR_SSL_WANT_WRITE)) {\n\t\t\tIOT_ERROR(\"mbedtls_ssl_handshake = -0x%x\", -ret);\n\t\t\tif (ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED) {\n\t\t\t\tIOT_ERROR(\"failed to verify the server's certificate\");\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tIOT_DEBUG(\"Protocol is %s\", mbedtls_ssl_get_version(\u0026net-\u003econtext.ssl));\n\tIOT_DEBUG(\"Ciphersuite is %s\", mbedtls_ssl_get_ciphersuite(\u0026net-\u003econtext.ssl));\n\n\tIOT_DEBUG(\"Verifying peer X.509 certificate\");\n\n\tflags = mbedtls_ssl_get_verify_result(\u0026net-\u003econtext.ssl);\n\tif (flags) {\n\t\tIOT_ERROR(\"mbedtls_ssl_get_verify_result = 0x%x\", flags);\n\t\tgoto exit;\n\t}\n#if defined(STDK_IOT_CORE_TLS_DEBUG)\n\tif (mbedtls_ssl_get_peer_cert(\u0026net-\u003econtext.ssl) != NULL) {\n\t\tunsigned char buf[2048];\n\t\tIOT_INFO(\"Peer certificate information\");\n\t\tmbedtls_x509_crt_info((char *)buf, sizeof(buf) - 1,\n\t\t\t\t\"!\", mbedtls_ssl_get_peer_cert(\u0026net-\u003econtext.ssl));\n\t\tIOT_INFO(\"%s\\n\", buf);\n\t}\n#endif\n\n\treturn IOT_ERROR_NONE;\n\nexit:\n\t_iot_net_cleanup_platform_context(net);\n\n\treturn IOT_ERROR_NET_CONNECT;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":257,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"132473":{"score":0.8818004,"function_name":"_iot_net_tcp_keepalive","code":"static iot_error_t _iot_net_tcp_keepalive(iot_net_interface_t *net, unsigned int idle, unsigned int count, unsigned int intval)\n{\n\tiot_error_t err;\n\tint socket;\n\tint keepAlive = 1;\n\tint ret;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tsocket = net-\u003econtext.server_fd.fd;\n\tret = setsockopt(socket, SOL_SOCKET, SO_KEEPALIVE, \u0026keepAlive, sizeof(keepAlive));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVE error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPIDLE, \u0026idle, sizeof(idle));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVEIDLE error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPCNT, \u0026count, sizeof(count));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVECOUNT error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tret = setsockopt(socket, IPPROTO_TCP, TCP_KEEPINTVL, \u0026intval, sizeof(intval));\n\tif (ret)\n\t{\n\t\tIOT_WARN(\"fail to set KEEPALIVEINTERVAL error %d\", ret);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":400,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"132949":{"score":0.9012851,"function_name":"_iot_net_tls_read","code":"static int _iot_net_tls_read(iot_net_interface_t *net,\n\t\tunsigned char *buf, size_t len, iot_os_timer timer)\n{\n\tint recvLen = 0, ret = 0;\n\n\tIOT_DEBUG(\"%d@%p\", len, buf);\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tif (buf == NULL || timer == NULL) {\n\t\treturn -1;\n\t}\n\n\tif (len == 0) {\n\t\treturn 0;\n\t}\n\n\tmbedtls_ssl_conf_read_timeout(\u0026net-\u003econtext.conf, (uint32_t)iot_os_timer_left_ms(timer));\n\n\tdo {\n\t\tret = mbedtls_ssl_read(\u0026net-\u003econtext.ssl, buf, len);\n\n\t\tif(ret \u003e 0) {\n\t\t\trecvLen += ret;\n\t\t} else {\n\t\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_WANT_WRITE) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_TIMEOUT)) {\n\t\t\t\tIOT_ERROR(\"mbedtls_ssl_read = -0x%04X\", -ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} while(recvLen \u003c len \u0026\u0026 !iot_os_timer_isexpired(timer));\n\n\treturn recvLen;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":446,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133240":{"score":0.87670076,"function_name":"_iot_net_tls_write","code":"static int _iot_net_tls_write(iot_net_interface_t *net,\n\t\tunsigned char *buf, int len, iot_os_timer timer)\n{\n\tint sentLen = 0, ret = 0;\n\n\tIOT_DEBUG(\"%d@%p\", len, buf);\n\n\tif (_iot_net_check_interface(net)) {\n\t\treturn 0;\n\t}\n\n\tdo {\n\t\tret = mbedtls_ssl_write(\u0026net-\u003econtext.ssl, buf + sentLen, (size_t)len - sentLen);\n\n\t\tif(ret \u003e 0) {\n\t\t\tsentLen += ret;\n\t\t} else {\n\t\t\tif ((ret != MBEDTLS_ERR_SSL_WANT_READ) \u0026\u0026\n\t\t\t\t(ret != MBEDTLS_ERR_SSL_WANT_WRITE)) {\n\t\t\t\tIOT_ERROR(\"mbedtls_ssl_write = -0x%04X\\n\", -ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} while (sentLen \u003c len \u0026\u0026 !iot_os_timer_isexpired(timer));\n\n\treturn sentLen;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":485,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133461":{"score":0.91618794,"function_name":"iot_net_init","code":"iot_error_t iot_net_init(iot_net_interface_t *net)\n{\n\tiot_error_t err;\n\n\terr = _iot_net_check_interface(net);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tnet-\u003econnect = _iot_net_tls_connect;\n\tnet-\u003etcp_keepalive = _iot_net_tcp_keepalive;\n\tnet-\u003edisconnect = _iot_net_tls_disconnect;\n\tnet-\u003eselect = _iot_net_select;\n\tnet-\u003eread = _iot_net_tls_read;\n\tnet-\u003ewrite = _iot_net_tls_write;\n\tnet-\u003eshow_status = _iot_net_show_status;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/net/mbedtls/iot_net_mbedtls.c","line_number":513,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"133622":{"score":0.8971354,"function_name":"_iot_nv_io_storage_init","code":"STATIC_FUNCTION\niot_security_context_t *_iot_nv_io_storage_init(void)\n{\n\tiot_error_t err;\n\tiot_security_context_t *security_context;\n\n\tsecurity_context = iot_security_init();\n\tif (!security_context) {\n\t\tIOT_ERROR(\"failed to init security\");\n\t\treturn NULL;\n\t}\n\n\terr = iot_security_storage_init(security_context);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_storage_init = %d\", err);\n\t\tiot_security_deinit(security_context);\n\t\treturn NULL;\n\t}\n\n\treturn security_context;\n}","filepath":"src/iot_nv_data.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"133788":{"score":0.83440673,"function_name":"_iot_nv_io_storage_deinit","code":"STATIC_FUNCTION\niot_error_t _iot_nv_io_storage_deinit(iot_security_context_t *security_context)\n{\n\tiot_error_t err;\n\n\terr = iot_security_storage_deinit(security_context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_security_deinit(security_context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":78,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"133872":{"score":0.94207174,"function_name":"_iot_nv_io_storage","code":"STATIC_FUNCTION\niot_error_t _iot_nv_io_storage(const iot_nvd_t nv_id, iot_nv_io_mode_t mode, char *data, size_t data_len, size_t *read_len)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_context_t *security_context;\n\tiot_security_buffer_t data_buf = {0};\n\n\tIOT_DEBUG(\"id = %d, mode = %d\", nv_id, mode);\n\n\tif ((nv_id \u003c 0 || nv_id \u003e= IOT_NVD_MAX)) {\n\t\tIOT_ERROR(\"nv type is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((mode != IOT_NV_MODE_REMOVE) \u0026\u0026 (!data || (data_len == 0))) {\n\t\tIOT_ERROR(\"data input is invalid\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tsecurity_context = _iot_nv_io_storage_init();\n\tIOT_ERROR_CHECK(security_context == NULL, IOT_ERROR_NV_DATA_ERROR, \"failed to init storage\");\n\n\tswitch (mode) {\n\tcase IOT_NV_MODE_READ:\n\t\terr = iot_security_storage_read(security_context, nv_id, \u0026data_buf);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\t\tIOT_DEBUG(\"nv '%d' does not exist\", nv_id);\n\t\t\t\terr = IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_security_storage_read = %d\", err);\n\t\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (data_len \u003c data_buf.len) {\n\t\t\tIOT_ERROR(\"output buffer is not enough (%d \u003c %d)\", data_len, data_buf.len);\n\t\t\terr = IOT_ERROR_SECURITY_FS_BUFFER;\n\t\t\tiot_os_free(data_buf.p);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(data, data_buf.p, data_buf.len);\n\t\t/* make null terminated string */\n\t\tif (data_buf.len \u003c data_len) {\n\t\t\tdata[data_buf.len] = '\\0';\n\t\t}\n\n\t\tif (read_len != NULL) {\n\t\t\t*read_len = data_buf.len;\n\t\t}\n\n\t\tiot_os_free(data_buf.p);\n\t\tbreak;\n\tcase IOT_NV_MODE_WRITE:\n\t\tdata_buf.p = (unsigned char *)data;\n\t\tdata_buf.len = data_len;\n\n\t\terr = iot_security_storage_write(security_context, nv_id, \u0026data_buf);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"iot_security_storage_write = %d\", err);\n\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t}\n\t\tbreak;\n\tcase IOT_NV_MODE_REMOVE:\n                err = iot_security_storage_remove(security_context, nv_id);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\t\tIOT_DEBUG(\"nv '%d' does not exist\", nv_id);\n\t\t\t\terr = IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_security_storage_remove = %d\", err);\n\t\t\t\terr = IOT_ERROR_NV_DATA_ERROR;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\t(void)_iot_nv_io_storage_deinit(security_context);\n\n\treturn err;\n}","filepath":"src/iot_nv_data.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"134896":{"score":0.73882455,"function_name":"iot_nv_prov_data_exist","code":"bool iot_nv_prov_data_exist(void)\n{\n\tiot_error_t ret;\n\tchar nv_status[5];\n\n\tmemset(nv_status, 0, sizeof(nv_status));\n\n\t/* CHECK IOT_NVD_WIFI_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_WIFI_PROV_STATUS, nv_status, sizeof(nv_status) - 1, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\treturn false;\n\t}\n\n\tif (strncmp(nv_status, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No wifi provisioning data\");\n\t\treturn false;\n\t}\n\n\tmemset(nv_status, 0, sizeof(nv_status));\n\n\t/* CHECK IOT_NVD_CLOUD_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_CLOUD_PROV_STATUS, nv_status, sizeof(nv_status) - 1, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\treturn false;\n\t}\n\n\tif (strncmp(nv_status, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No cloud provisioning data\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}","filepath":"src/iot_nv_data.c","line_number":221,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"135131":{"score":0.717041,"function_name":"iot_nv_get_prov_data","code":"iot_error_t iot_nv_get_prov_data(struct iot_device_prov_data* prov_data)\n{\n\tHIT();\n\tIOT_WARN_CHECK(prov_data == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\n\tret = iot_nv_get_wifi_prov_data(\u0026prov_data-\u003ewifi);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"get wifi prov fail\");\n\n\tret = iot_nv_get_cloud_prov_data(\u0026prov_data-\u003ecloud);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"get cloud prov fail\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":259,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"135277":{"score":0.72375095,"function_name":"iot_nv_set_prov_data","code":"iot_error_t iot_nv_set_prov_data(struct iot_device_prov_data* prov_data)\n{\n\tHIT();\n\tIOT_WARN_CHECK(prov_data == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\n\tret = iot_nv_set_wifi_prov_data(\u0026prov_data-\u003ewifi);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"set wifi prov fail\");\n\n\tret = iot_nv_set_cloud_prov_data(\u0026prov_data-\u003ecloud);\n\tIOT_DEBUG_CHECK(ret != IOT_ERROR_NONE, IOT_ERROR_NV_DATA_ERROR, \"set cloud prov fail\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":275,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"135423":{"score":0.6867216,"function_name":"iot_nv_erase_prov_data","code":"iot_error_t iot_nv_erase_prov_data()\n{\n\tHIT();\n\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t */\n\tiot_error_t ret;\n\tconst char* status = \"NONE\";\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, status, strlen(status));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, status, strlen(status));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":291,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"135554":{"score":0.7690314,"function_name":"iot_nv_get_wifi_prov_data","code":"iot_error_t iot_nv_get_wifi_prov_data(struct iot_wifi_prov_data* wifi_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(wifi_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_AP_SSID\n\t * IOT_NVD_AP_PASS\n\t * IOT_NVD_AP_BSSID\n\t * IOT_NVD_AP_AUTH_TYPE\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_PW_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* CHECK IOT_NVD_WIFI_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_WIFI_PROV_STATUS, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tif (strncmp(data, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No wifi provisioning data\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_SSID */\n\tret = _iot_nv_read_data(IOT_NVD_AP_SSID, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tif (size \u003c IOT_WIFI_PROV_SSID_LEN) {\n\t\t\tsnprintf(wifi_prov-\u003essid, IOT_WIFI_PROV_SSID_LEN, \"%s\", data);\n\t\t} else {\n\t\t\tmemcpy(wifi_prov-\u003essid, data, IOT_WIFI_PROV_SSID_LEN);\n\t\t\twifi_prov-\u003essid[IOT_WIFI_PROV_SSID_LEN - 1] = '\\0';\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003essid[0] = '\\0';\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP SSID : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_SSID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_PASS */\n\tret = _iot_nv_read_data(IOT_NVD_AP_PASS, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tif (size \u003c IOT_WIFI_PROV_PASSWORD_LEN) {\n\t\t\tsnprintf(wifi_prov-\u003epassword, IOT_WIFI_PROV_PASSWORD_LEN, \"%s\", data);\n\t\t} else {\n\t\t\tmemcpy(wifi_prov-\u003epassword, data, IOT_WIFI_PROV_PASSWORD_LEN);\n\t\t\twifi_prov-\u003epassword[IOT_WIFI_PROV_PASSWORD_LEN - 1] = '\\0';\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003epassword[0] = '\\0';\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP PW : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_PASS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_BSSID */\n\tsize_t read_len = 0;\n\tret = _iot_nv_read_data(IOT_NVD_AP_BSSID, data, DATA_SIZE, \u0026read_len);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tif (read_len \u003e= IOT_WIFI_PROV_MAC_STR_LEN) {\n\t\t\t/* bssid : new style, 17byte string case */\n\t\t\tmemcpy(wifi_prov-\u003emac_str, data, IOT_WIFI_PROV_MAC_STR_LEN);\n\t\t\twifi_prov-\u003emac_str[IOT_WIFI_PROV_MAC_STR_LEN] = '\\0';\n\t\t\tret = iot_util_convert_str_mac(wifi_prov-\u003emac_str, \u0026wifi_prov-\u003ebssid);\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_INFO(\"Saved AP BSSID is invalid string(%d):%s\",\n\t\t\t\t\tret, wifi_prov-\u003emac_str);\n\t\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t\t\tret = IOT_ERROR_NONE;\n\t\t\t}\n\t\t} else if (read_len \u003e= IOT_NVD_MAX_BSSID_LEN) {\n\t\t\t/* bssid : old style, 6byte chunk data case */\n\t\t\tmemcpy(wifi_prov-\u003ebssid.addr, data, IOT_NVD_MAX_BSSID_LEN);\n\t\t\tret = iot_util_convert_mac_str(\u0026wifi_prov-\u003ebssid, wifi_prov-\u003emac_str,\n\t\t\t\t\tsizeof(wifi_prov-\u003emac_str));\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_INFO(\"Saved AP BSSID is invalid chunk(%d)\", ret);\n\t\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t\t\tret = IOT_ERROR_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\tIOT_INFO(\"Saved AP BSSID is invalid length:%d\", read_len);\n\t\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\t}\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tmemset(wifi_prov-\u003emac_str, '\\0', sizeof(wifi_prov-\u003emac_str));\n\t\tmemset(wifi_prov-\u003ebssid.addr, 0, sizeof(wifi_prov-\u003ebssid.addr));\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"AP BSSID : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_BSSID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_AUTH_TYPE */\n\tret = _iot_nv_read_data(IOT_NVD_AP_AUTH_TYPE, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\twifi_prov-\u003esecurity_type = atoi(data);\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\twifi_prov-\u003esecurity_type = -1;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Auth Type : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_AP_AUTH_TYPE, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":320,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"136775":{"score":0.81649053,"function_name":"iot_nv_set_wifi_prov_data","code":"iot_error_t iot_nv_set_wifi_prov_data(struct iot_wifi_prov_data* wifi_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(wifi_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_WIFI_PROV_STATUS\n\t * IOT_NVD_AP_SSID\n\t * IOT_NVD_AP_PASS\n\t * IOT_NVD_AP_BSSID\n\t * IOT_NVD_AP_AUTH_TYPE\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_PW_LEN + 1;\n\tunsigned int size;\n\tint state;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* IOT_NVD_WIFI_PROV_STATUS - NONE */\n\tsize = 4;\n\tmemcpy(data, \"NONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_AP_SSID */\n\tif (wifi_prov-\u003essid[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_SSID);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_SSID_LEN;\n\t\tmemcpy(data, wifi_prov-\u003essid, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_SSID, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP SSID : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_SSID, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_PASS */\n\tif (wifi_prov-\u003epassword[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_PASS);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_PASSWORD_LEN;\n\t\tmemcpy(data, wifi_prov-\u003epassword, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_PASS, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP PASS : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_PASS, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_BSSID */\n\tif (wifi_prov-\u003emac_str[0] == '\\0') {\n\t\tiot_nv_erase(IOT_NVD_AP_BSSID);\n\t} else {\n\t\tsize = IOT_WIFI_PROV_MAC_STR_LEN;\n\t\tmemcpy(data, wifi_prov-\u003emac_str, size);\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_BSSID, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"AP BSSID : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_BSSID, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_AP_AUTH_TYPE */\n\tif (wifi_prov-\u003esecurity_type \u003c IOT_WIFI_AUTH_OPEN || wifi_prov-\u003esecurity_type \u003e IOT_WIFI_AUTH_MAX) {\n\t\tiot_nv_erase(IOT_NVD_AP_AUTH_TYPE);\n\t} else {\n\t\tstate = snprintf(data, DATA_SIZE, \"%d\", wifi_prov-\u003esecurity_type);\n\t\tif (state \u003c= 0) {\n\t\t\tIOT_DEBUG(\"Auth Type : data load failed from prov structure\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tsize = state;\n\t\tdata[size] = '\\0';\n\n\t\tret = _iot_nv_write_data(IOT_NVD_AP_AUTH_TYPE, data, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Auth Type : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_AP_AUTH_TYPE, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_WIFI_PROV_STATUS - DONE */\n\tsize = 4;\n\tmemcpy(data, \"DONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_WIFI_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Wifi Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_WIFI_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":458,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"137569":{"score":0.78795,"function_name":"iot_nv_get_cloud_prov_data","code":"iot_error_t iot_nv_get_cloud_prov_data(struct iot_cloud_prov_data* cloud_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(cloud_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t * IOT_NVD_SERVER_URL\n\t * IOT_NVD_SERVER_PORT\n\t * IOT_NVD_LOCATION_ID\n\t * IOT_NVD_ROOM_ID\n\t * IOT_NVD_LABEL\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = (IOT_NVD_MAX_DATA_LEN / 2) + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* CHECK IOT_NVD_CLOUD_PROV_STATUS */\n\tret = _iot_nv_read_data(IOT_NVD_CLOUD_PROV_STATUS, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tif (strncmp(data, \"DONE\", 4)) {\n\t\tIOT_DEBUG(\"No cloud provisioning data\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_URL */\n\tret = _iot_nv_read_data(IOT_NVD_SERVER_URL, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tnew_buff = (char *)iot_os_malloc(size + 1);\n\t\tif (new_buff == NULL) {\n\t\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(new_buff, data, size);\n\t\tnew_buff[size] = '\\0';\n\n\t\tcloud_prov-\u003ebroker_url = new_buff;\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003ebroker_url = NULL;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Server Url : read fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERVER_URL, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_PORT */\n\tret = _iot_nv_read_data(IOT_NVD_SERVER_PORT, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tcloud_prov-\u003ebroker_port = atoi(data);\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003ebroker_port = -1;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Server Port : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERVER_PORT, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_LABEL */\n\tmemset(data, 0, DATA_SIZE);\n\n\tret = _iot_nv_read_data(IOT_NVD_LABEL, data, DATA_SIZE, NULL);\n\tif (ret == IOT_ERROR_NONE) {\n\t\tsize = strlen(data);\n\t\tnew_buff = (char *)iot_os_malloc(size + 1);\n\t\tif (new_buff == NULL) {\n\t\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmemcpy(new_buff, data, size);\n\t\tnew_buff[size] = '\\0';\n\n\t\tcloud_prov-\u003elabel = new_buff;\n\t} else if (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\tcloud_prov-\u003elabel = NULL;\n\t\tret = IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"Label : read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_LABEL, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":585,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"138349":{"score":0.7866078,"function_name":"iot_nv_set_cloud_prov_data","code":"iot_error_t iot_nv_set_cloud_prov_data(struct iot_cloud_prov_data* cloud_prov)\n{\n\tHIT();\n\tIOT_WARN_CHECK(cloud_prov == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_CLOUD_PROV_STATUS\n\t * IOT_NVD_SERVER_URL\n\t * IOT_NVD_SERVER_PORT\n\t * IOT_NVD_LOCATION_ID\n\t * IOT_NVD_ROOM_ID\n\t * IOT_NVD_LABEL\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = (IOT_NVD_MAX_DATA_LEN / 2) + 1;\n\tsize_t size;\n\tint state;\n\tchar* data = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\t/* IOT_NVD_CLOUD_PROV_STATUS - NONE */\n\tsize = 4;\n\tmemcpy(data, \"NONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_SERVER_URL */\n\tif (cloud_prov-\u003ebroker_url == NULL) {\n\t\tiot_nv_erase(IOT_NVD_SERVER_URL);\n\t} else {\n\t\tsize = strlen(cloud_prov-\u003ebroker_url);\n\n\t\tret = _iot_nv_write_data(IOT_NVD_SERVER_URL, cloud_prov-\u003ebroker_url, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Server Url : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_SERVER_URL, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_SERVER_PORT */\n\tstate = snprintf(data, DATA_SIZE, \"%d\", cloud_prov-\u003ebroker_port);\n\tif (state \u003c= 0) {\n\t\tIOT_DEBUG(\"Server Port : data load failed from prov structure\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = state;\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_SERVER_PORT, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Server Port : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_SERVER_PORT, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\t/* IOT_NVD_LABEL */\n\tif (cloud_prov-\u003elabel == NULL) {\n\t\tiot_nv_erase(IOT_NVD_LABEL);\n\t} else {\n\t\tsize = strlen(cloud_prov-\u003elabel);\n\t\tret = _iot_nv_write_data(IOT_NVD_LABEL, cloud_prov-\u003elabel, size);\n\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\tIOT_DEBUG(\"Label : write failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_LABEL, __LINE__);\n\t\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* IOT_NVD_CLOUD_PROV_STATUS - DONE */\n\tsize = 4;\n\tmemcpy(data, \"DONE\", size);\n\tdata[size] = '\\0';\n\n\tret = _iot_nv_write_data(IOT_NVD_CLOUD_PROV_STATUS, data, size);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"Cloud Prov Status : write failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_CLOUD_PROV_STATUS, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":694,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"138974":{"score":0.8841096,"function_name":"iot_nv_get_certificate","code":"iot_error_t iot_nv_get_certificate(iot_security_cert_id_t cert_id, char** cert, size_t* len)\n{\n\tiot_error_t ret;\n\tiot_security_context_t *security_context;\n\tiot_security_buffer_t cert_buf;\n\n\tHIT();\n\tIOT_WARN_CHECK((cert == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tsecurity_context = _iot_nv_io_storage_init();\n\tif (security_context == NULL) {\n\t\tIOT_ERROR(\"failed to init storage\");\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = iot_security_manager_init(security_context);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to init manager\");\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tret = iot_security_manager_get_certificate(security_context, cert_id, \u0026cert_buf);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get cert(%d), ret = %d\", cert_id, ret);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\t*cert = (char *)cert_buf.p;\n\t*len = cert_buf.len;\n\n\t(void)iot_security_manager_deinit(security_context);\n\t(void)_iot_nv_io_storage_deinit(security_context);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":796,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"139364":{"score":0.8428625,"function_name":"iot_nv_get_device_id","code":"iot_error_t iot_nv_get_device_id(char** device_id, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((device_id == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_DEVICE_ID\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_UID_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_DEVICE_ID, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_DEVICE_ID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)iot_os_malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*device_id = new_buff;\n\t*len = size;\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":832,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"139738":{"score":0.8015015,"function_name":"iot_nv_set_device_id","code":"iot_error_t iot_nv_set_device_id(const char* device_id)\n{\n\tHIT();\n\tIOT_WARN_CHECK(device_id == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_DEVICE_ID\n\t */\n\tiot_error_t ret;\n\n\tret = _iot_nv_write_data(IOT_NVD_DEVICE_ID, device_id, strlen(device_id));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_DEVICE_ID, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":877,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"139866":{"score":0.86038184,"function_name":"iot_nv_get_serial_number","code":"iot_error_t iot_nv_get_serial_number(char** sn, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((sn == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\n\tiot_error_t ret;\n\tunsigned int size;\n\tconst int DATA_SIZE = IOT_NVD_MAX_SN_LEN + 1;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = iot_os_malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_SERIAL_NUM, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_SERIAL_NUM, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)iot_os_malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*sn = new_buff;\n\t*len = size;\n\nexit:\n\tiot_os_free(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":897,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"140240":{"score":0.84840643,"function_name":"iot_nv_get_misc_info","code":"iot_error_t iot_nv_get_misc_info(char** misc_info, size_t* len)\n{\n\tHIT();\n\tIOT_WARN_CHECK((misc_info == NULL || len == NULL), IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_MISC_INFO\n\t */\n\tiot_error_t ret;\n\tconst int DATA_SIZE = IOT_NVD_MAX_DATA_LEN + 1;\n\tunsigned int size;\n\tchar* data = NULL;\n\tchar* new_buff = NULL;\n\n\tdata = malloc(sizeof(char) * DATA_SIZE);\n\tIOT_WARN_CHECK(data == NULL, IOT_ERROR_NV_DATA_ERROR, \"memory alloc fail\");\n\n\tret = _iot_nv_read_data(IOT_NVD_MISC_INFO, data, DATA_SIZE, NULL);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"read failed\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_READ_FAIL, IOT_NVD_MISC_INFO, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tsize = strlen(data);\n\tnew_buff = (char*)malloc(size + 1);\n\tif (new_buff == NULL) {\n\t\tIOT_WARN(\"failed to malloc for new_buff\");\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t\tgoto exit;\n\t}\n\n\tmemcpy(new_buff, data, size);\n\tnew_buff[size] = '\\0';\n\n\t*misc_info = new_buff;\n\t*len = size;\n\nexit:\n\tfree(data);\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":939,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"140614":{"score":0.8036491,"function_name":"iot_nv_set_misc_info","code":"iot_error_t iot_nv_set_misc_info(const char* misc_info)\n{\n\tHIT();\n\tIOT_WARN_CHECK(misc_info == NULL, IOT_ERROR_INVALID_ARGS, \"Invalid args 'NULL'\");\n\t/*\n\t * Todo :\n\t * IOT_NVD_MISC_INFO\n\t */\n\tiot_error_t ret;\n\n\tret = _iot_nv_write_data(IOT_NVD_MISC_INFO, misc_info, strlen(misc_info));\n\tif (ret != IOT_ERROR_NONE) {\n\t\tIOT_DEBUG(\"write fail\");\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_WRITE_FAIL, IOT_NVD_MISC_INFO, __LINE__);\n\t\tret = IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\treturn ret;\n}","filepath":"src/iot_nv_data.c","line_number":984,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"140742":{"score":0.72263086,"function_name":"iot_nv_erase","code":"iot_error_t iot_nv_erase(iot_nvd_t nv_type)\n{\n\tHIT();\n\tIOT_WARN_CHECK((nv_type \u003c 0 || nv_type \u003e= IOT_NVD_MAX), IOT_ERROR_INVALID_ARGS, \"Invalid args\");\n\n\tiot_error_t ret;\n\n\tret = _iot_nv_remove_data(nv_type);\n\tif (ret != IOT_ERROR_NONE) {\n\t\tif (ret == IOT_ERROR_NV_DATA_NOT_EXIST) {\n\t\t\tIOT_DEBUG(\"file does not exist\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_NOT_EXIST, nv_type, __LINE__);\n\t\t\treturn IOT_ERROR_NV_DATA_NOT_EXIST;\n\t\t} else {\n\t\t\tIOT_DEBUG(\"file remove failed\");\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_DEBUG, IOT_DUMP_NV_DATA_ERASE_FAIL, nv_type, __LINE__);\n\t\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1004,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"140866":{"score":0.89139175,"function_name":"iot_nv_get_static_certificate","code":"iot_error_t iot_nv_get_static_certificate(iot_security_cert_id_t cert_id, iot_security_buffer_t *output_buf)\n{\n\tunsigned char *data = NULL;\n\tunsigned char *cert;\n\tunsigned int cert_len;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tswitch (cert_id) {\n\tcase IOT_SECURITY_CERT_ID_ROOT_CA:\n\t\tcert = st_root_ca;\n\t\tcert_len = st_root_ca_len;\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"%d is not a supported static certificate\", cert_id);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\tdata = (unsigned char *)iot_os_malloc(cert_len + 1);\n\tif (!data) {\n\t\tIOT_ERROR(\"failed to malloc for static nv\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, cert, cert_len);\n\tdata[cert_len] = '\\0';\n\n\toutput_buf-\u003ep = data;\n\toutput_buf-\u003elen = cert_len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1027,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"141157":{"score":0.8936588,"function_name":"iot_nv_get_data_from_device_info","code":"iot_error_t iot_nv_get_data_from_device_info(iot_nvd_t nv_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tconst char *di_name;\n\tchar *data = NULL;\n\n\tIOT_DEBUG(\"nv id = %d\", nv_id);\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tswitch (nv_id) {\n\tcase IOT_NVD_PRIVATE_KEY:\n\t\tdi_name = name_privateKey;\n\t\tbreak;\n\tcase IOT_NVD_PUBLIC_KEY:\n\t\tdi_name = name_publicKey;\n\t\tbreak;\n\tcase IOT_NVD_DEVICE_CERT:\n\t\tdi_name = name_deviceCert;\n\t\tbreak;\n\tcase IOT_NVD_SERIAL_NUM:\n\t\tdi_name = name_serialNumber;\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"%d is not a device info nv\", nv_id);\n\t\treturn IOT_ERROR_NV_DATA_ERROR;\n\t}\n\n\terr = iot_api_read_device_identity(device_nv_info, device_nv_info_len, di_name, \u0026data);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_api_read_device_identity = %d\", err);\n\t\treturn err;\n\t}\n\n\tif (data) {\n\t\toutput_buf-\u003ep = (unsigned char *)data;\n\t\toutput_buf-\u003elen = strlen(data);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_nv_data.c","line_number":1066,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"141592":{"score":0.950806,"function_name":"iot_os_thread_create","code":"int iot_os_thread_create(void * thread_function, const char* name, int stack_size,\n\t\tvoid* data, int priority, iot_os_thread* thread_handle)\n{\n\tpthread_t* thread = malloc(sizeof(pthread_t));\n\tpthread_attr_t attr;\n\n\tif (thread == NULL)\n\t\treturn IOT_OS_FALSE;\n\n\tpthread_attr_init(\u0026attr);\n\tpthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_DETACHED);\n\n\tpthread_create(thread, \u0026attr, thread_function, data);\n\n\tpthread_attr_destroy(\u0026attr);\n\n\tif (thread_handle != NULL) {\n\t\t*thread_handle = (iot_os_thread*)thread;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":55,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141784":{"score":0.92482555,"function_name":"iot_os_thread_delete","code":"void iot_os_thread_delete(iot_os_thread thread_handle)\n{\n\tif (thread_handle != NULL) {\n\t\tpthread_t* thread = (pthread_t*)thread_handle;\n\t\tpthread_cancel(*thread);\n\t\tfree(thread);\n\t} else {\n\t\tpthread_cancel(pthread_self());\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":78,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141901":{"score":0.95132166,"function_name":"iot_os_thread_get_current_handle","code":"int iot_os_thread_get_current_handle(iot_os_thread* thread_handle)\n{\n    if (thread_handle == NULL) {\n        return IOT_OS_FALSE;\n    }\n\n    *thread_handle = (iot_os_thread)pthread_self();\n    return IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":94,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"141956":{"score":0.9146663,"function_name":"iot_os_queue_create","code":"iot_os_queue* iot_os_queue_create(int queue_length, int item_size)\n{\n\tiot_os_queue_posix_t* queue = malloc(sizeof(iot_os_queue_posix_t));\n\tstruct mq_attr attr;\n\n\tif (queue == NULL)\n\t\treturn NULL;\n\n\tattr.mq_flags = 0;\n\tattr.mq_maxmsg = (queue_length \u003c= 10) ? queue_length : 10;\n\tattr.mq_msgsize = item_size;\n\tattr.mq_curmsgs = 0;\n\n\tsnprintf(queue-\u003ename, sizeof(queue-\u003ename), \"/q%u\", iot_bsp_random());\n\tqueue-\u003elength = queue_length;\n\tqueue-\u003emsg_size = item_size;\n\n\tqueue-\u003emqd = mq_open(queue-\u003ename, O_CREAT | O_RDWR, 0644, \u0026attr);\n\tif (queue-\u003emqd == -1) {\n\t\tfree(queue);\n\t\treturn NULL;\n\t}\n\n\treturn (void*)queue;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142188":{"score":0.8730214,"function_name":"iot_os_queue_reset","code":"int iot_os_queue_reset(iot_os_queue* queue_handle)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\n\tmq_close(queue-\u003emqd);\n\tmq_unlink(queue-\u003ename);\n\n\tstruct mq_attr attr;\n\n\tattr.mq_flags = 0;\n\tattr.mq_maxmsg = (queue-\u003elength \u003c= 10) ? queue-\u003elength : 10;\n\tattr.mq_msgsize = queue-\u003emsg_size;\n\tattr.mq_curmsgs = 0;\n\n\tqueue-\u003emqd = mq_open(queue-\u003ename, O_CREAT | O_RDWR, 0644, \u0026attr);\n\tif (queue-\u003emqd == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":138,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142458":{"score":0.9499645,"function_name":"iot_os_queue_send","code":"int iot_os_queue_send(iot_os_queue* queue_handle, void * data, unsigned int wait_time_ms)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\tstruct timespec ts = {0,};\n\n\tif (!queue || !data)\n\t    return IOT_OS_FALSE;\n\n\tts.tv_sec = wait_time_ms / 1000;\n\tts.tv_nsec = (wait_time_ms % 1000) * 1000000;\n\n\tint ret = mq_timedsend(queue-\u003emqd, data, queue-\u003emsg_size, 0, \u0026ts);\n\tif (ret == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":169,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142671":{"score":0.93201894,"function_name":"iot_os_queue_receive","code":"int iot_os_queue_receive(iot_os_queue* queue_handle, void * data, unsigned int wait_time_ms)\n{\n\tiot_os_queue_posix_t* queue = (iot_os_queue_posix_t*)queue_handle;\n\tstruct timespec ts = {0,};\n\n\tts.tv_sec = wait_time_ms / 1000;\n\tts.tv_nsec = (wait_time_ms % 1000) * 1000000;\n\n\tint ret = mq_timedreceive(queue-\u003emqd, data, queue-\u003emsg_size, NULL, \u0026ts);\n\tif (ret == -1) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"142865":{"score":0.9397533,"function_name":"iot_os_eventgroup_create","code":"iot_os_eventgroup* iot_os_eventgroup_create(void)\n{\n\teventgroup_t *eventgroup = malloc(sizeof(eventgroup_t));\n\tif (eventgroup == NULL)\n\t\treturn NULL;\n\n\tif (pthread_mutex_init(\u0026eventgroup-\u003emutex, NULL)) {\n\t\tfree(eventgroup);\n\t\treturn NULL;\n\t}\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\teventgroup-\u003egroup[i].id = (1 \u003c\u003c i);\n\t\tint ret = pipe(eventgroup-\u003egroup[i].fd);\n\t\tif (ret == -1) {\n\t\t\tfree(eventgroup);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\teventgroup-\u003eevent_status = 0;\n\n\treturn eventgroup;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":219,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"143099":{"score":0.9662171,"function_name":"iot_os_eventgroup_delete","code":"void iot_os_eventgroup_delete(iot_os_eventgroup* eventgroup_handle)\n{\n\teventgroup_t* eventgroup = eventgroup_handle;\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\tclose(eventgroup-\u003egroup[i].fd[0]);\n\t\tclose(eventgroup-\u003egroup[i].fd[1]);\n\t}\n\tpthread_mutex_destroy(\u0026eventgroup-\u003emutex);\n\tfree(eventgroup);\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":244,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"143248":{"score":0.9173175,"function_name":"iot_os_eventgroup_wait_bits","code":"unsigned char iot_os_eventgroup_wait_bits(iot_os_eventgroup* eventgroup_handle,\n\t\tconst unsigned char bits_to_wait_for, const int clear_on_exit, const unsigned int wait_time_ms)\n{\n\teventgroup_t *eventgroup = eventgroup_handle;\n\tfd_set readfds;\n\tint fd_max = 0;\n\tunsigned char event_status_backup;\n\n\tFD_ZERO(\u0026readfds);\n\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_wait_for)) {\n\t\t\tFD_SET(eventgroup-\u003egroup[i].fd[0], \u0026readfds);\n\t\t\tif (eventgroup-\u003egroup[i].fd[0] \u003e= fd_max) {\n\t\t\t\tfd_max = eventgroup-\u003egroup[i].fd[0];\n\t\t\t}\n\t\t}\n\t}\n\n\tchar buf[3] = {0,};\n\tstruct timeval tv;\n\tmemset(\u0026tv, 0x00, sizeof(tv));\n\tunsigned char bits = 0x00;\n\tssize_t read_size = 0;\n\n\ttv.tv_sec = wait_time_ms / 1000;\n\ttv.tv_usec = (wait_time_ms % 1000) * 1000;\n\n\tint ret = select(fd_max + 1, \u0026readfds, NULL, NULL, \u0026tv);\n\tpthread_mutex_lock(\u0026eventgroup-\u003emutex);\n\tif (ret == -1) {\n\t\t// Select Error\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\t\treturn 0;\n\t} else if (ret == 0) {\n\t\t// Select Timeout\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\t\treturn (unsigned int)eventgroup-\u003eevent_status;\n\t} else {\n\t\t// read pipe\n\t\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n\t\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_wait_for)) {\n\t\t\t\tif (FD_ISSET(eventgroup-\u003egroup[i].fd[0], \u0026readfds)) {\n\t\t\t\t\tmemset(buf, 0, sizeof(buf));\n\t\t\t\t\tread_size = read(eventgroup-\u003egroup[i].fd[0], buf, sizeof(buf));\n\t\t\t\t\tIOT_DEBUG(\"read_size = %d (%d)\", read_size, i);\n\t\t\t\t\tbits |= eventgroup-\u003egroup[i].id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tevent_status_backup = eventgroup-\u003eevent_status;\n\t\tif (clear_on_exit) {\n\t\t\teventgroup-\u003eevent_status \u0026= ~(bits);\n\t\t}\n\t\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\n\t\treturn (unsigned int)event_status_backup;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":256,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144318":{"score":0.8752027,"function_name":"iot_os_eventgroup_set_bits","code":"int iot_os_eventgroup_set_bits(iot_os_eventgroup* eventgroup_handle,\n\t\tconst unsigned char bits_to_set)\n{\n\teventgroup_t *eventgroup = eventgroup_handle;\n\tunsigned char bits = 0;\n\tssize_t write_size = 0;\n\n\tpthread_mutex_lock(\u0026eventgroup-\u003emutex);\n\tfor (int i = 0; i \u003c EVENT_MAX; i++) {\n        if (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 eventgroup-\u003eevent_status)) {\n            IOT_DEBUG(\"already set 0x%08x (%d)\", eventgroup-\u003egroup[i].id, i);\n            continue;\n        }\n\t\tif (eventgroup-\u003egroup[i].id == (eventgroup-\u003egroup[i].id \u0026 bits_to_set)) {\n\t\t\twrite_size = write(eventgroup-\u003egroup[i].fd[1], \"Set\", strlen(\"Set\"));\n\t\t\tIOT_DEBUG(\"write_size = %d (%d)\", write_size, i);\n\t\t\tbits |= eventgroup-\u003egroup[i].id;\n\t\t}\n\t}\n\n\teventgroup-\u003eevent_status |= bits;\n\tpthread_mutex_unlock(\u0026eventgroup-\u003emutex);\n\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":317,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144725":{"score":0.96382785,"function_name":"iot_os_mutex_init","code":"int iot_os_mutex_init(iot_os_mutex* mutex)\n{\n\tif (!mutex) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\tpthread_mutex_t* mutex_p = malloc(sizeof(pthread_mutex_t));\n\tif (!mutex_p) {\n\t\treturn IOT_OS_FALSE;\n\t} else {\n\t\tpthread_mutex_init(mutex_p, NULL);\n\t\tmutex-\u003esem = mutex_p;\n\t}\n\treturn IOT_OS_TRUE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":358,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144819":{"score":0.93352973,"function_name":"iot_os_mutex_unlock","code":"int iot_os_mutex_unlock(iot_os_mutex* mutex)\n{\n\tint ret;\n\n\tif (!mutex || !mutex-\u003esem) {\n\t\treturn IOT_OS_FALSE;\n\t}\n\n\tpthread_mutex_t* mutex_p = mutex-\u003esem;\n\n\tret = pthread_mutex_unlock(mutex_p);\n\tif (ret) {\n\t\treturn IOT_OS_FALSE;\n\t} else {\n\t\treturn IOT_OS_TRUE;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":392,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"144997":{"score":0.9582554,"function_name":"iot_os_mutex_destroy","code":"void iot_os_mutex_destroy(iot_os_mutex* mutex)\n{\n\tif (!mutex || !mutex-\u003esem) {\n\t\treturn;\n\t}\n\tpthread_mutex_t* mutex_p = mutex-\u003esem;\n\n\tpthread_mutex_destroy(mutex_p);\n\tfree(mutex_p);\n\tmutex-\u003esem = NULL;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":410,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145220":{"score":0.842872,"function_name":"iot_os_timer_count_ms","code":"void iot_os_timer_count_ms(iot_os_timer timer, unsigned int timeout_ms)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it;\n\n\tit.it_interval.tv_sec = 0;\n\tit.it_interval.tv_nsec = 0;\n\tit.it_value.tv_sec = timeout_ms / 1000;\n\tit.it_value.tv_nsec = (timeout_ms % 1000) * 1000000;\n\n\tint ret = timer_settime(*timer_id, 0, \u0026it, NULL);\n\tif (ret == -1) {\n\t\treturn;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":433,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145380":{"score":0.9536531,"function_name":"iot_os_timer_left_ms","code":"unsigned int iot_os_timer_left_ms(iot_os_timer timer)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it = {0,};\n\tunsigned int left = 0;\n\n\tint ret = timer_gettime(*timer_id, \u0026it);\n\tif (ret == -1) {\n\t\treturn 0;\n\t}\n\n\treturn (it.it_value.tv_sec * 1000) + (it.it_value.tv_nsec / 1000000);\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":449,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145552":{"score":0.94618446,"function_name":"iot_os_timer_isexpired","code":"char iot_os_timer_isexpired(iot_os_timer timer)\n{\n\ttimer_t* timer_id = (timer_t*) timer;\n\tstruct itimerspec it = {0,};\n\n\tint ret = timer_gettime(*timer_id, \u0026it);\n\tif (ret == -1) {\n\t\treturn IOT_OS_TRUE;\n\t}\n\n\tif (it.it_value.tv_sec == 0 \u0026\u0026 it.it_value.tv_nsec == 0) {\n\t\treturn IOT_OS_TRUE;\n\t} else {\n\t\treturn IOT_OS_FALSE;\n\t}\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":463,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"145708":{"score":0.89155704,"function_name":"iot_os_timer_init","code":"int iot_os_timer_init(iot_os_timer *timer)\n{\n\ttimer_t* timer_id = malloc(sizeof(timer_t));\n\tstruct sigevent sig;\n\n\tif (timer_id == NULL)\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\n\tmemset(\u0026sig, '\\0', sizeof(struct sigevent));\n\tsig.sigev_notify = SIGEV_NONE;\n\tsig.sigev_value.sival_ptr = timer_id;\n\tint ret = timer_create(CLOCK_REALTIME, \u0026sig, timer_id);\n\tif (ret == -1) {\n\t\tfree(timer_id);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t*timer = timer_id;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/os/posix/iot_os_util_posix.c","line_number":480,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"146621":{"score":0.8735039,"function_name":"iot_security_manager_init","code":"iot_error_t iot_security_manager_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003emanager_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003emanager_init(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_MANAGER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146750":{"score":0.8603262,"function_name":"iot_security_manager_deinit","code":"iot_error_t iot_security_manager_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003emanager_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003emanager_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_MANAGER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":48,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"146879":{"score":0.86246645,"function_name":"iot_security_manager_set_key","code":"iot_error_t iot_security_manager_set_key(iot_security_context_t *context, iot_security_key_params_t *key_params)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_params) {\n\t\tIOT_ERROR(\"key params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_set_key) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_set_key is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\tIOT_DEBUG(\"key id = %d\", key_params-\u003ekey_id);\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_set_key(context, key_params);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_set_key = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":70,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147128":{"score":0.91761756,"function_name":"iot_security_manager_get_key","code":"iot_error_t iot_security_manager_get_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *key_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"key id = %d\", key_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif ((key_id \u003c= IOT_SECURITY_KEY_ID_UNKNOWN) || (key_id \u003e= IOT_SECURITY_KEY_ID_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid\", key_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\tif (!key_buf) {\n\t\tIOT_ERROR(\"key buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(key_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_get_key) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_key is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_get_key(context, key_id, key_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_key = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":100,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147462":{"score":0.87287235,"function_name":"_iot_security_manager_check_certificate_target","code":"STATIC_FUNCTION\niot_security_storage_target_t _iot_security_manager_check_certificate_target(iot_security_cert_id_t cert_id)\n{\n\tswitch (cert_id) {\n\tcase IOT_SECURITY_CERT_ID_ROOT_CA:\n\t\treturn IOT_SECURITY_STORAGE_TARGET_STATIC;\n\tdefault:\n\t\treturn IOT_SECURITY_STORAGE_TARGET_NV;\n\t}\n}","filepath":"src/security/iot_security_manager.c","line_number":137,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147497":{"score":0.908565,"function_name":"iot_security_manager_get_certificate","code":"iot_error_t iot_security_manager_get_certificate(iot_security_context_t *context, iot_security_cert_id_t cert_id, iot_security_buffer_t *cert_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif ((cert_id \u003c= IOT_SECURITY_CERT_ID_UNKNOWN) || (cert_id \u003e= IOT_SECURITY_CERT_ID_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid\", cert_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CERT_INVALID_ID, 0);\n\t}\n\n\tif (!cert_buf) {\n\t\tIOT_ERROR(\"cert buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(cert_buf, 0, sizeof(iot_security_buffer_t));\n\n\tstorage_target = _iot_security_manager_check_certificate_target(cert_id);\n\tif (storage_target == IOT_SECURITY_STORAGE_TARGET_STATIC) {\n\t\treturn iot_nv_get_static_certificate(cert_id, cert_buf);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003emanager_get_certificate) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_certificate is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003emanager_get_certificate(context, cert_id, cert_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003emanager_get_certificate = %d\", err);\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_manager.c","line_number":148,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"147885":{"score":0.78738695,"function_name":"_iot_security_storage_set_storage_id","code":"STATIC_FUNCTION\niot_error_t _iot_security_storage_set_storage_id(iot_security_context_t *context, iot_security_storage_id_t storage_id)\n{\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003estorage_params) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_PARAMS_NULL, 0);\n\t}\n\n\tif ((storage_id \u003c= IOT_NVD_UNKNOWN) || (storage_id \u003e= IOT_NVD_MAX)) {\n\t\tIOT_ERROR(\"'%d' is invalid id\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_INVALID_ID, storage_id);\n\t}\n\n\tcontext-\u003estorage_params-\u003estorage_id = storage_id;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148013":{"score":0.9170282,"function_name":"iot_security_storage_init","code":"iot_error_t iot_security_storage_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tstorage_params = (iot_security_storage_params_t *)iot_os_malloc(sizeof(iot_security_storage_params_t));\n\tif (!storage_params) {\n\t\tIOT_ERROR(\"failed to malloc for storage params\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset(storage_params, 0, sizeof(iot_security_storage_params_t));\n\n\tcontext-\u003estorage_params = storage_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003estorage_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003estorage_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003estorage_params);\n\t\t\tcontext-\u003estorage_params = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_STORAGE;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":47,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148470":{"score":0.8941467,"function_name":"iot_security_storage_read","code":"iot_error_t iot_security_storage_read(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_read) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_read is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_read(context, output_buf);\n\tif (err) {\n\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\tIOT_DEBUG(\"id:%d not found\", context-\u003estorage_params-\u003estorage_id);\n\t\t}\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d read %d@%p\", context-\u003estorage_params-\u003estorage_id, (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148732":{"score":0.86200786,"function_name":"iot_security_storage_write","code":"iot_error_t iot_security_storage_write(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_write) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_write is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_write(context, input_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d written %d@%p\", context-\u003estorage_params-\u003estorage_id, (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":151,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"148998":{"score":0.9028665,"function_name":"iot_security_storage_remove","code":"iot_error_t iot_security_storage_remove(iot_security_context_t *context, iot_security_storage_id_t storage_id)\n{\n\tiot_error_t err;\n\n\tIOT_DEBUG(\"id:%d\", storage_id);\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_storage_set_storage_id(context, storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003estorage_remove) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003estorage_remove is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003estorage_remove(context);\n\tif (err) {\n\t\tif (err == IOT_ERROR_SECURITY_FS_NOT_FOUND) {\n\t\t\tIOT_DEBUG(\"id:%d not found\", context-\u003estorage_params-\u003estorage_id);\n\t\t}\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"id:%d removed\", context-\u003estorage_params-\u003estorage_id);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_storage.c","line_number":187,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"149187":{"score":0.9745435,"function_name":"_isalpha","code":"static int _isalpha(char c)\n{\n\tif (('A' \u003c= c) \u0026\u0026 (c \u003c= 'Z'))\n\t\treturn 1;\n\n\tif (('a' \u003c= c) \u0026\u0026 (c \u003c= 'z'))\n\t\treturn 1;\n\n\treturn 0;\n}","filepath":"src/iot_util.c","line_number":27,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"149302":{"score":0.9644596,"function_name":"_ishex","code":"static int _ishex(char c)\n{\n\tif (c \u003e= '0' \u0026\u0026 c \u003c= '9') {\n\t\treturn 1;\n\t}\n\n\tif (c \u003e= 'a' \u0026\u0026 c \u003c= 'f') {\n\t\treturn 1;\n\t}\n\n\tif (c \u003e= 'A' \u0026\u0026 c \u003c= 'Z') {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}","filepath":"src/iot_util.c","line_number":45,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"149388":{"score":0.88658893,"function_name":"_ishex_len","code":"static int _ishex_len(char *c, size_t len)\n{\n\tint i;\n\tfor (i = 0; i \u003c len; i++, c++)\n\t{\n\t\tif (!_ishex(*c)) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}","filepath":"src/iot_util.c","line_number":62,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"149465":{"score":0.937527,"function_name":"iot_util_dump_mem","code":"void iot_util_dump_mem(char *tag, uint8_t *buf, size_t len)\n{\n\tconst char *newline = \"\";\n\tconst char *space = \" \";\n\tint i, j;\n\tint w = 16;\n\n\tif (!strcmp(tag, \"raw\")) {\n\t\tspace = \"\";\n\t}\n\n\tfor (i = 0; i \u003c len; i += w) {\n\t\tif (!strcmp(tag, \"dump\") \u0026\u0026 !(i % 0x10)) {\n\t\t\tprintf(\"%s[%p] \", newline, buf + i);\n\t\t\tnewline = \"\\n\";\n\t\t}\n\n\t\tfor (j = i; j \u003c (i + w); j++) {\n\t\t\tif (j \u003c len)\n\t\t\t\tprintf(\"%02x%s\", buf[j], space);\n\t\t\telse\n\t\t\t\tprintf(\"   \");\n\t\t}\n\n\t\tif (strcmp(tag, \"dump\"))\n\t\t\tcontinue;\n\n\t\tfor (j = i; j \u003c (i + w); j++) {\n\t\t\tif (_isprint(buf[j])) {\n\t\t\t\tprintf(\"%c\", buf[j]);\n\t\t\t} else {\n\t\t\t\tprintf(\"%c\", '.');\n\t\t\t}\n\t\t\tif (j \u003e= len)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}","filepath":"src/iot_util.c","line_number":74,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"149889":{"score":0.8426111,"function_name":"validate_uuid_format","code":"iot_error_t validate_uuid_format(const char *str, size_t str_len)\n{\n\tchar *ptr = (char*) str;\n\n\tif (!str) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (str_len != UUID_STRING_LENGTH) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_TIME_LOW_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_LOW_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_TIME_MID_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_MID_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (*ptr \u003c '1' || *ptr \u003e '5') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(++ptr, UUID_TIME_HI_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_TIME_HI_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_CLOCK_SEQ_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tptr += UUID_CLOCK_SEQ_LEN;\n\tif (*ptr++ != '-') {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!_ishex_len(ptr, UUID_NODE_LEN)) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":121,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"150224":{"score":0.9054912,"function_name":"iot_util_convert_str_uuid","code":"iot_error_t iot_util_convert_str_uuid(const char* str, struct iot_uuid* uuid)\n{\n\tint i, j = 0, k = 1;\n\tunsigned char c = 0;\n\n\tif (!uuid || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (validate_uuid_format(str, strlen(str)) != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Invalid uuid format\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c UUID_STRING_LENGTH; i++) {\n\t\tif (str[i] == '-') {\n\t\t\tcontinue;\n\t\t} else if (_isalpha(str[i])) {\n\t\t\tswitch (str[i]) {\n\t\t\tcase 65:\n\t\t\tcase 97:\n\t\t\t\tc |= 0x0a;\n\t\t\t\tbreak;\n\t\t\tcase 66:\n\t\t\tcase 98:\n\t\t\t\tc |= 0x0b;\n\t\t\t\tbreak;\n\t\t\tcase 67:\n\t\t\tcase 99:\n\t\t\t\tc |= 0x0c;\n\t\t\t\tbreak;\n\t\t\tcase 68:\n\t\t\tcase 100:\n\t\t\t\tc |= 0x0d;\n\t\t\t\tbreak;\n\t\t\tcase 69:\n\t\t\tcase 101:\n\t\t\t\tc |= 0x0e;\n\t\t\t\tbreak;\n\t\t\tcase 70:\n\t\t\tcase 102:\n\t\t\t\tc |= 0x0f;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tc |= str[i] - 48;\n\t\t}\n\n\t\tif ((j + 1) * 2 == k) {\n\t\t\tuuid-\u003eid[j++] = c;\n\t\t\tc = 0;\n\t\t} else {\n\t\t\tc = c \u003c\u003c 4;\n\t\t}\n\n\t\tk++;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":175,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"150635":{"score":0.9059833,"function_name":"iot_util_convert_uuid_str","code":"iot_error_t iot_util_convert_uuid_str(struct iot_uuid* uuid, char* str, size_t max_sz)\n{\n\tchar* ref_id = \"42365732-c6db-4bc9-8945-2a7ca10d6f23\";\n\tint i, written = 0, wrt;\n\tchar pvt ='-';\n\tchar str_tmp[3];\n\n\tif (!uuid || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (max_sz \u003c (strlen(ref_id) + 1)) {\n\t\tIOT_ERROR(\"Invalid max_sz\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* dump random uuid */\n\tfor (i = 0; i \u003c 16; i++) {\n\t\twrt = snprintf(str_tmp, sizeof(str_tmp),\n\t\t\t\t\"%02x\", (unsigned char)uuid-\u003eid[i]);\n\t\tif (wrt != 2) {\n\t\t\tIOT_ERROR(\"Can't convert id:%02x to str\",\n\t\t\t\t(unsigned char)uuid-\u003eid[i]);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\n\t\tmemcpy(\u0026str[written], str_tmp, wrt);\n\t\twritten += wrt;\n\n\t\tif (ref_id[written] == pvt) {\n\t\t\tstr[written] = pvt;\n\t\t\twritten++;\n\t\t}\n\t}\n\n\tstr[written] = '\\0';\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":237,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"151066":{"score":0.90652484,"function_name":"iot_util_convert_str_mac","code":"iot_error_t iot_util_convert_str_mac(char* str, struct iot_mac* mac)\n{\n\tchar* ref_addr = \"a1:b2:c3:d4:e5:f6\";\n\tint i, j = 0, k = 1;\n\tunsigned char c = 0;\n\n\tif (!mac || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (strlen(str) != strlen(ref_addr)) {\n\t\tIOT_ERROR(\"Input is not a mac string\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c strlen(ref_addr); i++) {\n\t\tif ((i % 3) == 2) {\n\t\t\tif (str[i] == ':') {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t\t}\n\t\t} else if (_isalpha(str[i])) {\n\t\t\tswitch (str[i]) {\n\t\t\tcase 65:\n\t\t\tcase 97:\n\t\t\t\tc |= 0x0a;\n\t\t\t\tbreak;\n\t\t\tcase 66:\n\t\t\tcase 98:\n\t\t\t\tc |= 0x0b;\n\t\t\t\tbreak;\n\t\t\tcase 67:\n\t\t\tcase 99:\n\t\t\t\tc |= 0x0c;\n\t\t\t\tbreak;\n\t\t\tcase 68:\n\t\t\tcase 100:\n\t\t\t\tc |= 0x0d;\n\t\t\t\tbreak;\n\t\t\tcase 69:\n\t\t\tcase 101:\n\t\t\t\tc |= 0x0e;\n\t\t\t\tbreak;\n\t\t\tcase 70:\n\t\t\tcase 102:\n\t\t\t\tc |= 0x0f;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t\t}\n\t\t} else {\n\t\t\tc |= str[i] - 48;\n\t\t}\n\n\t\tif ((j + 1) * 2 == k) {\n\t\t\tmac-\u003eaddr[j++] = c;\n\t\t\tc = 0;\n\t\t} else {\n\t\t\tc = c \u003c\u003c 4;\n\t\t}\n\n\t\tk++;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":278,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"151557":{"score":0.8648306,"function_name":"iot_util_convert_mac_str","code":"iot_error_t iot_util_convert_mac_str(struct iot_mac* mac, char* str, int max_sz)\n{\n\tchar* ref_addr = \"a1:b2:c3:d4:e5:f6\";\n\tint i, written = 0, wrt;\n\tchar pvt =':';\n\tchar str_tmp[3];\n\n\tif (!mac || !str) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (max_sz \u003c (strlen(ref_addr) + 1)) {\n\t\tIOT_ERROR(\"Invalid max_sz\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tfor (i = 0; i \u003c 6; i++) {\n\t\twrt = snprintf(str_tmp, sizeof(str_tmp),\n\t\t\t\t\"%02x\", (unsigned char)mac-\u003eaddr[i]);\n\t\tif (wrt != 2) {\n\t\t\tIOT_ERROR(\"Can't convert mac_addr:%02x to str\",\n\t\t\t\t(unsigned char)mac-\u003eaddr[i]);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\n\t\tmemcpy(\u0026str[written], str_tmp, wrt);\n\t\twritten += wrt;\n\n\t\tif (ref_addr[written] == pvt) {\n\t\t\tstr[written] = pvt;\n\t\t\twritten++;\n\t\t}\n\t}\n\n\tstr[written] = '\\0';\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":347,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"151990":{"score":0.87673753,"function_name":"iot_util_convert_channel_freq","code":"uint16_t iot_util_convert_channel_freq(uint8_t channel)\n{\n\tif(channel \u003c 1) return 0;\n\n\tif(channel \u003c 14) {\n\t\treturn (2412+(5*(channel - 1)));\n\t}\n\telse if(channel == 14) {\n\t\treturn 2484;\n\t}\n\telse if(channel \u003e 31 \u0026\u0026  channel \u003c 174) {\n\t\treturn 5160+(5*(channel - 32));\n\t}\n\telse {\n\t\tIOT_ERROR(\"Not supported channel = %d\", channel);\n\t}\n\n\treturn 0;\n}","filepath":"src/iot_util.c","line_number":387,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"152157":{"score":0.9386947,"function_name":"iot_util_url_parse","code":"iot_error_t iot_util_url_parse(char *url, url_parse_t *output)\n{\n\tchar *p1 = NULL;\n\tchar *p2 = NULL;\n\tchar *p_domain = NULL;\n\tchar *p_port = NULL;\n\n\tif (!url || !output)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp1 = strstr(url, \"://\");\n\tif (!p1)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp_domain = p1 + 3;\n\tp2 = strstr(p_domain, \":\");\n\tif (!p2)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tp_port = p2 + 1;\n\toutput-\u003eprotocol = iot_os_calloc(sizeof(char), p1 - url + 1);\n\tif (!output-\u003eprotocol)\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\tstrncpy(output-\u003eprotocol, url, p1 - url);\n\n\toutput-\u003edomain = iot_os_calloc(sizeof(char), p2 - p_domain + 1);\n\tif (!output-\u003edomain) {\n\t\tfree(output-\u003eprotocol);\n\t\toutput-\u003eprotocol = NULL;\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tstrncpy(output-\u003edomain, p_domain, p2 - p_domain);\n\n\toutput-\u003eport = atoi(p_port);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_util.c","line_number":407,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"152577":{"score":0.69635844,"function_name":"cJSON_GetStringValue","code":"CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) \n{\n    if (!cJSON_IsString(item)) \n    {\n        return NULL;\n    }\n\n    return item-\u003evaluestring;\n}","filepath":"cJSON.c","line_number":95,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"152686":{"score":0.9603225,"function_name":"case_insensitive_strcmp","code":"static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)\n{\n    if ((string1 == NULL) || (string2 == NULL))\n    {\n        return 1;\n    }\n\n    if (string1 == string2)\n    {\n        return 0;\n    }\n\n    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)\n    {\n        if (*string1 == '\\0')\n        {\n            return 0;\n        }\n    }\n\n    return tolower(*string1) - tolower(*string2);\n}","filepath":"cJSON.c","line_number":129,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"152867":{"score":0.8867058,"function_name":"cJSON_strdup","code":"static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)\n{\n    size_t length = 0;\n    unsigned char *copy = NULL;\n\n    if (string == NULL)\n    {\n        return NULL;\n    }\n\n    length = strlen((const char*)string) + sizeof(\"\");\n    copy = (unsigned char*)hooks-\u003eallocate(length);\n    if (copy == NULL)\n    {\n        return NULL;\n    }\n    memcpy(copy, string, length);\n\n    return copy;\n}","filepath":"cJSON.c","line_number":184,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"152992":{"score":0.9351197,"function_name":"cJSON_InitHooks","code":"CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (hooks == NULL)\n    {\n        /* Reset hooks */\n        global_hooks.allocate = malloc;\n        global_hooks.deallocate = free;\n        global_hooks.reallocate = realloc;\n        return;\n    }\n\n    global_hooks.allocate = malloc;\n    if (hooks-\u003emalloc_fn != NULL)\n    {\n        global_hooks.allocate = hooks-\u003emalloc_fn;\n    }\n\n    global_hooks.deallocate = free;\n    if (hooks-\u003efree_fn != NULL)\n    {\n        global_hooks.deallocate = hooks-\u003efree_fn;\n    }\n\n    /* use realloc only if both free and malloc are used */\n    global_hooks.reallocate = NULL;\n    if ((global_hooks.allocate == malloc) \u0026\u0026 (global_hooks.deallocate == free))\n    {\n        global_hooks.reallocate = realloc;\n    }\n}","filepath":"cJSON.c","line_number":205,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"153171":{"score":0.9133191,"function_name":"cJSON_New_Item","code":"static cJSON *cJSON_New_Item(const internal_hooks * const hooks)\n{\n    cJSON* node = (cJSON*)hooks-\u003eallocate(sizeof(cJSON));\n    if (node)\n    {\n        memset(node, '\\0', sizeof(cJSON));\n    }\n\n    return node;\n}","filepath":"cJSON.c","line_number":237,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"153239":{"score":0.8786174,"function_name":"cJSON_Delete","code":"CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item-\u003enext;\n        if (!(item-\u003etype \u0026 cJSON_IsReference) \u0026\u0026 (item-\u003echild != NULL))\n        {\n            cJSON_Delete(item-\u003echild);\n        }\n        if (!(item-\u003etype \u0026 cJSON_IsReference) \u0026\u0026 (item-\u003evaluestring != NULL))\n        {\n            global_hooks.deallocate(item-\u003evaluestring);\n        }\n        if (!(item-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (item-\u003estring != NULL))\n        {\n            global_hooks.deallocate(item-\u003estring);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}","filepath":"cJSON.c","line_number":249,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"153471":{"score":0.930126,"function_name":"parse_number","code":"static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)\n{\n    double number = 0;\n    unsigned char *after_end = NULL;\n    unsigned char number_c_string[64];\n    unsigned char decimal_point = get_decimal_point();\n    size_t i = 0;\n\n    if ((input_buffer == NULL) || (input_buffer-\u003econtent == NULL))\n    {\n        return false;\n    }\n\n    /* copy the number into a temporary buffer and replace '.' with the decimal point\n     * of the current locale (for strtod)\n     * This also takes care of '\\0' not necessarily being available for marking the end of the input */\n    for (i = 0; (i \u003c (sizeof(number_c_string) - 1)) \u0026\u0026 can_access_at_index(input_buffer, i); i++)\n    {\n        switch (buffer_at_offset(input_buffer)[i])\n        {\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n            case '+':\n            case '-':\n            case 'e':\n            case 'E':\n                number_c_string[i] = buffer_at_offset(input_buffer)[i];\n                break;\n\n            case '.':\n                number_c_string[i] = decimal_point;\n                break;\n\n            default:\n                goto loop_end;\n        }\n    }\nloop_end:\n    number_c_string[i] = '\\0';\n\n    number = strtod((const char*)number_c_string, (char**)\u0026after_end);\n    if (number_c_string == after_end)\n    {\n        return false; /* parse_error */\n    }\n\n    item-\u003evaluedouble = number;\n\n    /* use saturation in case of overflow */\n    if (number \u003e= INT_MAX)\n    {\n        item-\u003evalueint = INT_MAX;\n    }\n    else if (number \u003c= (double)INT_MIN)\n    {\n        item-\u003evalueint = INT_MIN;\n    }\n    else\n    {\n        item-\u003evalueint = (int)number;\n    }\n\n    item-\u003etype = cJSON_Number;\n\n    input_buffer-\u003eoffset += (size_t)(after_end - number_c_string);\n    return true;\n}","filepath":"cJSON.c","line_number":301,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"153928":{"score":0.8210329,"function_name":"cJSON_SetNumberHelper","code":"CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)\n{\n    if (number \u003e= INT_MAX)\n    {\n        object-\u003evalueint = INT_MAX;\n    }\n    else if (number \u003c= (double)INT_MIN)\n    {\n        object-\u003evalueint = INT_MIN;\n    }\n    else\n    {\n        object-\u003evalueint = (int)number;\n    }\n\n    return object-\u003evaluedouble = number;\n}","filepath":"cJSON.c","line_number":378,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"154062":{"score":0.90330917,"function_name":"ensure","code":"static unsigned char* ensure(printbuffer * const p, size_t needed)\n{\n    unsigned char *newbuffer = NULL;\n    size_t newsize = 0;\n\n    if ((p == NULL) || (p-\u003ebuffer == NULL))\n    {\n        return NULL;\n    }\n\n    if ((p-\u003elength \u003e 0) \u0026\u0026 (p-\u003eoffset \u003e= p-\u003elength))\n    {\n        /* make sure that offset is valid */\n        return NULL;\n    }\n\n    if (needed \u003e INT_MAX)\n    {\n        /* sizes bigger than INT_MAX are currently not supported */\n        return NULL;\n    }\n\n    needed += p-\u003eoffset + 1;\n    if (needed \u003c= p-\u003elength)\n    {\n        return p-\u003ebuffer + p-\u003eoffset;\n    }\n\n    if (p-\u003enoalloc) {\n        return NULL;\n    }\n\n    /* calculate new buffer size */\n    if (needed \u003e (INT_MAX / 2))\n    {\n        /* overflow of int, use INT_MAX if possible */\n        if (needed \u003c= INT_MAX)\n        {\n            newsize = INT_MAX;\n        }\n        else\n        {\n            return NULL;\n        }\n    }\n    else\n    {\n        newsize = needed * 2;\n    }\n\n    if (p-\u003ehooks.reallocate != NULL)\n    {\n        /* reallocate with realloc if available */\n        newbuffer = (unsigned char*)p-\u003ehooks.reallocate(p-\u003ebuffer, newsize);\n        if (newbuffer == NULL)\n        {\n            p-\u003ehooks.deallocate(p-\u003ebuffer);\n            p-\u003elength = 0;\n            p-\u003ebuffer = NULL;\n\n            return NULL;\n        }\n    }\n    else\n    {\n        /* otherwise reallocate manually */\n        newbuffer = (unsigned char*)p-\u003ehooks.allocate(newsize);\n        if (!newbuffer)\n        {\n            p-\u003ehooks.deallocate(p-\u003ebuffer);\n            p-\u003elength = 0;\n            p-\u003ebuffer = NULL;\n\n            return NULL;\n        }\n        if (newbuffer)\n        {\n            memcpy(newbuffer, p-\u003ebuffer, p-\u003eoffset + 1);\n        }\n        p-\u003ehooks.deallocate(p-\u003ebuffer);\n    }\n    p-\u003elength = newsize;\n    p-\u003ebuffer = newbuffer;\n\n    return newbuffer + p-\u003eoffset;\n}","filepath":"cJSON.c","line_number":435,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"154537":{"score":0.7799852,"function_name":"update_offset","code":"static void update_offset(printbuffer * const buffer)\n{\n    const unsigned char *buffer_pointer = NULL;\n    if ((buffer == NULL) || (buffer-\u003ebuffer == NULL))\n    {\n        return;\n    }\n    buffer_pointer = buffer-\u003ebuffer + buffer-\u003eoffset;\n\n    buffer-\u003eoffset += strlen((const char*)buffer_pointer);\n}","filepath":"cJSON.c","line_number":523,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"154634":{"score":0.8937235,"function_name":"print_number","code":"static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    double d = item-\u003evaluedouble;\n    int length = 0;\n    size_t i = 0;\n    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */\n    unsigned char decimal_point = get_decimal_point();\n    double test = 0.0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* This checks for NaN and Infinity */\n    if (isnan(d) || isinf(d))\n    {\n        length = sprintf((char*)number_buffer, \"null\");\n    }\n    else\n    {\n        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */\n        length = sprintf((char*)number_buffer, \"%1.15g\", d);\n\n        /* Check whether the original double can be recovered */\n        if ((sscanf((char*)number_buffer, \"%lg\", \u0026test) != 1) || !compare_double((double)test, d))\n        {\n            /* If not, print with 17 decimal places of precision */\n            length = sprintf((char*)number_buffer, \"%1.17g\", d);\n        }\n    }\n\n    /* sprintf failed or buffer overrun occurred */\n    if ((length \u003c 0) || (length \u003e (int)(sizeof(number_buffer) - 1)))\n    {\n        return false;\n    }\n\n    /* reserve appropriate space in the output */\n    output_pointer = ensure(output_buffer, (size_t)length + sizeof(\"\"));\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    /* copy the printed number to the output and replace locale\n     * dependent decimal point with '.' */\n    for (i = 0; i \u003c ((size_t)length); i++)\n    {\n        if (number_buffer[i] == decimal_point)\n        {\n            output_pointer[i] = '.';\n            continue;\n        }\n\n        output_pointer[i] = number_buffer[i];\n    }\n    output_pointer[i] = '\\0';\n\n    output_buffer-\u003eoffset += (size_t)length;\n\n    return true;\n}","filepath":"cJSON.c","line_number":543,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"155071":{"score":0.9271994,"function_name":"parse_hex4","code":"static unsigned parse_hex4(const unsigned char * const input)\n{\n    unsigned int h = 0;\n    size_t i = 0;\n\n    for (i = 0; i \u003c 4; i++)\n    {\n        /* parse digit */\n        if ((input[i] \u003e= '0') \u0026\u0026 (input[i] \u003c= '9'))\n        {\n            h += (unsigned int) input[i] - '0';\n        }\n        else if ((input[i] \u003e= 'A') \u0026\u0026 (input[i] \u003c= 'F'))\n        {\n            h += (unsigned int) 10 + input[i] - 'A';\n        }\n        else if ((input[i] \u003e= 'a') \u0026\u0026 (input[i] \u003c= 'f'))\n        {\n            h += (unsigned int) 10 + input[i] - 'a';\n        }\n        else /* invalid */\n        {\n            return 0;\n        }\n\n        if (i \u003c 3)\n        {\n            /* shift left to make place for the next nibble */\n            h = h \u003c\u003c 4;\n        }\n    }\n\n    return h;\n}","filepath":"cJSON.c","line_number":609,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"155320":{"score":0.92038375,"function_name":"utf16_literal_to_utf8","code":"static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)\n{\n    long unsigned int codepoint = 0;\n    unsigned int first_code = 0;\n    const unsigned char *first_sequence = input_pointer;\n    unsigned char utf8_length = 0;\n    unsigned char utf8_position = 0;\n    unsigned char sequence_length = 0;\n    unsigned char first_byte_mark = 0;\n\n    if ((input_end - first_sequence) \u003c 6)\n    {\n        /* input ends unexpectedly */\n        goto fail;\n    }\n\n    /* get the first utf16 sequence */\n    first_code = parse_hex4(first_sequence + 2);\n\n    /* check that the code is valid */\n    if (((first_code \u003e= 0xDC00) \u0026\u0026 (first_code \u003c= 0xDFFF)))\n    {\n        goto fail;\n    }\n\n    /* UTF16 surrogate pair */\n    if ((first_code \u003e= 0xD800) \u0026\u0026 (first_code \u003c= 0xDBFF))\n    {\n        const unsigned char *second_sequence = first_sequence + 6;\n        unsigned int second_code = 0;\n        sequence_length = 12; /* \\uXXXX\\uXXXX */\n\n        if ((input_end - second_sequence) \u003c 6)\n        {\n            /* input ends unexpectedly */\n            goto fail;\n        }\n\n        if ((second_sequence[0] != '\\\\') || (second_sequence[1] != 'u'))\n        {\n            /* missing second half of the surrogate pair */\n            goto fail;\n        }\n\n        /* get the second utf16 sequence */\n        second_code = parse_hex4(second_sequence + 2);\n        /* check that the code is valid */\n        if ((second_code \u003c 0xDC00) || (second_code \u003e 0xDFFF))\n        {\n            /* invalid second half of the surrogate pair */\n            goto fail;\n        }\n\n\n        /* calculate the unicode codepoint from the surrogate pair */\n        codepoint = 0x10000 + (((first_code \u0026 0x3FF) \u003c\u003c 10) | (second_code \u0026 0x3FF));\n    }\n    else\n    {\n        sequence_length = 6; /* \\uXXXX */\n        codepoint = first_code;\n    }\n\n    /* encode as UTF-8\n     * takes at maximum 4 bytes to encode:\n     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n    if (codepoint \u003c 0x80)\n    {\n        /* normal ascii, encoding 0xxxxxxx */\n        utf8_length = 1;\n    }\n    else if (codepoint \u003c 0x800)\n    {\n        /* two bytes, encoding 110xxxxx 10xxxxxx */\n        utf8_length = 2;\n        first_byte_mark = 0xC0; /* 11000000 */\n    }\n    else if (codepoint \u003c 0x10000)\n    {\n        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 3;\n        first_byte_mark = 0xE0; /* 11100000 */\n    }\n    else if (codepoint \u003c= 0x10FFFF)\n    {\n        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n        utf8_length = 4;\n        first_byte_mark = 0xF0; /* 11110000 */\n    }\n    else\n    {\n        /* invalid unicode codepoint */\n        goto fail;\n    }\n\n    /* encode as utf8 */\n    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position \u003e 0; utf8_position--)\n    {\n        /* 10xxxxxx */\n        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) \u0026 0xBF);\n        codepoint \u003e\u003e= 6;\n    }\n    /* encode first byte */\n    if (utf8_length \u003e 1)\n    {\n        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) \u0026 0xFF);\n    }\n    else\n    {\n        (*output_pointer)[0] = (unsigned char)(codepoint \u0026 0x7F);\n    }\n\n    *output_pointer += utf8_length;\n\n    return sequence_length;\n\nfail:\n    return 0;\n}","filepath":"cJSON.c","line_number":646,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"155823":{"score":0.93291336,"function_name":"parse_string","code":"static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)\n{\n    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;\n    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;\n    unsigned char *output_pointer = NULL;\n    unsigned char *output = NULL;\n\n    /* not a string */\n    if (buffer_at_offset(input_buffer)[0] != '\\\"')\n    {\n        goto fail;\n    }\n\n    {\n        /* calculate approximate size of the output (overestimate) */\n        size_t allocation_length = 0;\n        size_t skipped_bytes = 0;\n        while (((size_t)(input_end - input_buffer-\u003econtent) \u003c input_buffer-\u003elength) \u0026\u0026 (*input_end != '\\\"'))\n        {\n            /* is escape sequence */\n            if (input_end[0] == '\\\\')\n            {\n                if ((size_t)(input_end + 1 - input_buffer-\u003econtent) \u003e= input_buffer-\u003elength)\n                {\n                    /* prevent buffer overflow when last input character is a backslash */\n                    goto fail;\n                }\n                skipped_bytes++;\n                input_end++;\n            }\n            input_end++;\n        }\n        if (((size_t)(input_end - input_buffer-\u003econtent) \u003e= input_buffer-\u003elength) || (*input_end != '\\\"'))\n        {\n            goto fail; /* string ended unexpectedly */\n        }\n\n        /* This is at most how much we need for the output */\n        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;\n        output = (unsigned char*)input_buffer-\u003ehooks.allocate(allocation_length + sizeof(\"\"));\n        if (output == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n    }\n\n    output_pointer = output;\n    /* loop through the string literal */\n    while (input_pointer \u003c input_end)\n    {\n        if (*input_pointer != '\\\\')\n        {\n            *output_pointer++ = *input_pointer++;\n        }\n        /* escape sequence */\n        else\n        {\n            unsigned char sequence_length = 2;\n            if ((input_end - input_pointer) \u003c 1)\n            {\n                goto fail;\n            }\n\n            switch (input_pointer[1])\n            {\n                case 'b':\n                    *output_pointer++ = '\\b';\n                    break;\n                case 'f':\n                    *output_pointer++ = '\\f';\n                    break;\n                case 'n':\n                    *output_pointer++ = '\\n';\n                    break;\n                case 'r':\n                    *output_pointer++ = '\\r';\n                    break;\n                case 't':\n                    *output_pointer++ = '\\t';\n                    break;\n                case '\\\"':\n                case '\\\\':\n                case '/':\n                    *output_pointer++ = input_pointer[1];\n                    break;\n\n                /* UTF-16 literal */\n                case 'u':\n                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, \u0026output_pointer);\n                    if (sequence_length == 0)\n                    {\n                        /* failed to convert UTF16-literal to UTF-8 */\n                        goto fail;\n                    }\n                    break;\n\n                default:\n                    goto fail;\n            }\n            input_pointer += sequence_length;\n        }\n    }\n\n    /* zero terminate the output */\n    *output_pointer = '\\0';\n\n    item-\u003etype = cJSON_String;\n    item-\u003evaluestring = (char*)output;\n\n    input_buffer-\u003eoffset = (size_t) (input_end - input_buffer-\u003econtent);\n    input_buffer-\u003eoffset++;\n\n    return true;\n\nfail:\n    if (output != NULL)\n    {\n        input_buffer-\u003ehooks.deallocate(output);\n    }\n\n    if (input_pointer != NULL)\n    {\n        input_buffer-\u003eoffset = (size_t)(input_pointer - input_buffer-\u003econtent);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":767,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"156558":{"score":0.9357152,"function_name":"print_string_ptr","code":"static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)\n{\n    const unsigned char *input_pointer = NULL;\n    unsigned char *output = NULL;\n    unsigned char *output_pointer = NULL;\n    size_t output_length = 0;\n    /* numbers of additional characters needed for escaping */\n    size_t escape_characters = 0;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* empty string */\n    if (input == NULL)\n    {\n        output = ensure(output_buffer, sizeof(\"\\\"\\\"\"));\n        if (output == NULL)\n        {\n            return false;\n        }\n        strcpy((char*)output, \"\\\"\\\"\");\n\n        return true;\n    }\n\n    /* set \"flag\" to 1 if something needs to be escaped */\n    for (input_pointer = input; *input_pointer; input_pointer++)\n    {\n        switch (*input_pointer)\n        {\n            case '\\\"':\n            case '\\\\':\n            case '\\b':\n            case '\\f':\n            case '\\n':\n            case '\\r':\n            case '\\t':\n                /* one character escape sequence */\n                escape_characters++;\n                break;\n            default:\n                if (*input_pointer \u003c 32)\n                {\n                    /* UTF-16 escape sequence uXXXX */\n                    escape_characters += 5;\n                }\n                break;\n        }\n    }\n    output_length = (size_t)(input_pointer - input) + escape_characters;\n\n    output = ensure(output_buffer, output_length + sizeof(\"\\\"\\\"\"));\n    if (output == NULL)\n    {\n        return false;\n    }\n\n    /* no characters have to be escaped */\n    if (escape_characters == 0)\n    {\n        output[0] = '\\\"';\n        memcpy(output + 1, input, output_length);\n        output[output_length + 1] = '\\\"';\n        output[output_length + 2] = '\\0';\n\n        return true;\n    }\n\n    output[0] = '\\\"';\n    output_pointer = output + 1;\n    /* copy the string */\n    for (input_pointer = input; *input_pointer != '\\0'; (void)input_pointer++, output_pointer++)\n    {\n        if ((*input_pointer \u003e 31) \u0026\u0026 (*input_pointer != '\\\"') \u0026\u0026 (*input_pointer != '\\\\'))\n        {\n            /* normal character, copy */\n            *output_pointer = *input_pointer;\n        }\n        else\n        {\n            /* character needs to be escaped */\n            *output_pointer++ = '\\\\';\n            switch (*input_pointer)\n            {\n                case '\\\\':\n                    *output_pointer = '\\\\';\n                    break;\n                case '\\\"':\n                    *output_pointer = '\\\"';\n                    break;\n                case '\\b':\n                    *output_pointer = 'b';\n                    break;\n                case '\\f':\n                    *output_pointer = 'f';\n                    break;\n                case '\\n':\n                    *output_pointer = 'n';\n                    break;\n                case '\\r':\n                    *output_pointer = 'r';\n                    break;\n                case '\\t':\n                    *output_pointer = 't';\n                    break;\n                default:\n                    /* escape and print as unicode codepoint */\n                    sprintf((char*)output_pointer, \"u%04x\", *input_pointer);\n                    output_pointer += 4;\n                    break;\n            }\n        }\n    }\n    output[output_length + 1] = '\\\"';\n    output[output_length + 2] = '\\0';\n\n    return true;\n}","filepath":"cJSON.c","line_number":896,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"157234":{"score":0.8821687,"function_name":"buffer_skip_whitespace","code":"static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer-\u003econtent == NULL))\n    {\n        return NULL;\n    }\n\n    if (cannot_access_at_index(buffer, 0))\n    {\n        return buffer;\n    }\n\n    while (can_access_at_index(buffer, 0) \u0026\u0026 (buffer_at_offset(buffer)[0] \u003c= 32))\n    {\n       buffer-\u003eoffset++;\n    }\n\n    if (buffer-\u003eoffset == buffer-\u003elength)\n    {\n        buffer-\u003eoffset--;\n    }\n\n    return buffer;\n}","filepath":"cJSON.c","line_number":1032,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"157362":{"score":0.91238284,"function_name":"skip_utf8_bom","code":"static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)\n{\n    if ((buffer == NULL) || (buffer-\u003econtent == NULL) || (buffer-\u003eoffset != 0))\n    {\n        return NULL;\n    }\n\n    if (can_access_at_index(buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(buffer), \"\\xEF\\xBB\\xBF\", 3) == 0))\n    {\n        buffer-\u003eoffset += 3;\n    }\n\n    return buffer;\n}","filepath":"cJSON.c","line_number":1058,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"157499":{"score":0.79681695,"function_name":"cJSON_ParseWithLengthOpts","code":"CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)\n{\n    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };\n    cJSON *item = NULL;\n\n    /* reset error position */\n    global_error.json = NULL;\n    global_error.position = 0;\n\n    if (value == NULL || 0 == buffer_length)\n    {\n        goto fail;\n    }\n\n    buffer.content = (const unsigned char*)value;\n    buffer.length = buffer_length; \n    buffer.offset = 0;\n    buffer.hooks = global_hooks;\n\n    item = cJSON_New_Item(\u0026global_hooks);\n    if (item == NULL) /* memory fail */\n    {\n        goto fail;\n    }\n\n    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(\u0026buffer))))\n    {\n        /* parse failure. ep is set. */\n        goto fail;\n    }\n\n    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n    if (require_null_terminated)\n    {\n        buffer_skip_whitespace(\u0026buffer);\n        if ((buffer.offset \u003e= buffer.length) || buffer_at_offset(\u0026buffer)[0] != '\\0')\n        {\n            goto fail;\n        }\n    }\n    if (return_parse_end)\n    {\n        *return_parse_end = (const char*)buffer_at_offset(\u0026buffer);\n    }\n\n    return item;\n\nfail:\n    if (item != NULL)\n    {\n        cJSON_Delete(item);\n    }\n\n    if (value != NULL)\n    {\n        error local_error;\n        local_error.json = (const unsigned char*)value;\n        local_error.position = 0;\n\n        if (buffer.offset \u003c buffer.length)\n        {\n            local_error.position = buffer.offset;\n        }\n        else if (buffer.length \u003e 0)\n        {\n            local_error.position = buffer.length - 1;\n        }\n\n        if (return_parse_end != NULL)\n        {\n            *return_parse_end = (const char*)local_error.json + local_error.position;\n        }\n\n        global_error = local_error;\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":1089,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"157994":{"score":0.88023293,"function_name":"print","code":"static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)\n{\n    static const size_t default_buffer_size = 256;\n    printbuffer buffer[1];\n    unsigned char *printed = NULL;\n\n    memset(buffer, 0, sizeof(buffer));\n\n    /* create buffer */\n    buffer-\u003ebuffer = (unsigned char*) hooks-\u003eallocate(default_buffer_size);\n    buffer-\u003elength = default_buffer_size;\n    buffer-\u003eformat = format;\n    buffer-\u003ehooks = *hooks;\n    if (buffer-\u003ebuffer == NULL)\n    {\n        goto fail;\n    }\n\n    /* print the value */\n    if (!print_value(item, buffer))\n    {\n        goto fail;\n    }\n    update_offset(buffer);\n\n    /* check if reallocate is available */\n    if (hooks-\u003ereallocate != NULL)\n    {\n        printed = (unsigned char*) hooks-\u003ereallocate(buffer-\u003ebuffer, buffer-\u003eoffset + 1);\n        if (printed == NULL) {\n            goto fail;\n        }\n        buffer-\u003ebuffer = NULL;\n    }\n    else /* otherwise copy the JSON over to a new buffer */\n    {\n        printed = (unsigned char*) hooks-\u003eallocate(buffer-\u003eoffset + 1);\n        if (printed == NULL)\n        {\n            goto fail;\n        }\n        memcpy(printed, buffer-\u003ebuffer, cjson_min(buffer-\u003elength, buffer-\u003eoffset + 1));\n        printed[buffer-\u003eoffset] = '\\0'; /* just to be sure */\n\n        /* free the buffer */\n        hooks-\u003edeallocate(buffer-\u003ebuffer);\n    }\n\n    return printed;\n\nfail:\n    if (buffer-\u003ebuffer != NULL)\n    {\n        hooks-\u003edeallocate(buffer-\u003ebuffer);\n    }\n\n    if (printed != NULL)\n    {\n        hooks-\u003edeallocate(printed);\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":1181,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"158487":{"score":0.8087821,"function_name":"cJSON_PrintBuffered","code":"CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if (prebuffer \u003c 0)\n    {\n        return NULL;\n    }\n\n    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);\n    if (!p.buffer)\n    {\n        return NULL;\n    }\n\n    p.length = (size_t)prebuffer;\n    p.offset = 0;\n    p.noalloc = false;\n    p.format = fmt;\n    p.hooks = global_hooks;\n\n    if (!print_value(item, \u0026p))\n    {\n        global_hooks.deallocate(p.buffer);\n        return NULL;\n    }\n\n    return (char*)p.buffer;\n}","filepath":"cJSON.c","line_number":1256,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"158718":{"score":0.7889061,"function_name":"cJSON_PrintPreallocated","code":"CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)\n{\n    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };\n\n    if ((length \u003c 0) || (buffer == NULL))\n    {\n        return false;\n    }\n\n    p.buffer = (unsigned char*)buffer;\n    p.length = (size_t)length;\n    p.offset = 0;\n    p.noalloc = true;\n    p.format = format;\n    p.hooks = global_hooks;\n\n    return print_value(item, \u0026p);\n}","filepath":"cJSON.c","line_number":1286,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"158897":{"score":0.9524582,"function_name":"parse_value","code":"static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer-\u003econtent == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item-\u003etype = cJSON_NULL;\n        input_buffer-\u003eoffset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item-\u003etype = cJSON_False;\n        input_buffer-\u003eoffset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) \u0026\u0026 (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item-\u003etype = cJSON_True;\n        item-\u003evalueint = 1;\n        input_buffer-\u003eoffset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] \u003e= '0') \u0026\u0026 (buffer_at_offset(input_buffer)[0] \u003c= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1306,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"159541":{"score":0.9247857,"function_name":"print_value","code":"static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item-\u003etype) \u0026 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item-\u003evaluestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item-\u003evaluestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item-\u003evaluestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}","filepath":"cJSON.c","line_number":1361,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"160068":{"score":0.9334446,"function_name":"parse_array","code":"static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* head of the linked list */\n    cJSON *current_item = NULL;\n\n    if (input_buffer-\u003edepth \u003e= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer-\u003edepth++;\n\n    if (buffer_at_offset(input_buffer)[0] != '[')\n    {\n        /* not an array */\n        goto fail;\n    }\n\n    input_buffer-\u003eoffset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ']'))\n    {\n        /* empty array */\n        goto success;\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer-\u003eoffset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer-\u003eoffset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(\u0026(input_buffer-\u003ehooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item-\u003enext = new_item;\n            new_item-\u003eprev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse next value */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')\n    {\n        goto fail; /* expected end of array */\n    }\n\nsuccess:\n    input_buffer-\u003edepth--;\n\n    item-\u003etype = cJSON_Array;\n    item-\u003echild = head;\n\n    input_buffer-\u003eoffset++;\n\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1435,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"160615":{"score":0.9413445,"function_name":"print_array","code":"static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_element = item-\u003echild;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output array. */\n    /* opening square bracket */\n    output_pointer = ensure(output_buffer, 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer = '[';\n    output_buffer-\u003eoffset++;\n    output_buffer-\u003edepth++;\n\n    while (current_element != NULL)\n    {\n        if (!print_value(current_element, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n        if (current_element-\u003enext)\n        {\n            length = (size_t) (output_buffer-\u003eformat ? 2 : 1);\n            output_pointer = ensure(output_buffer, length + 1);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            *output_pointer++ = ',';\n            if(output_buffer-\u003eformat)\n            {\n                *output_pointer++ = ' ';\n            }\n            *output_pointer = '\\0';\n            output_buffer-\u003eoffset += length;\n        }\n        current_element = current_element-\u003enext;\n    }\n\n    output_pointer = ensure(output_buffer, 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    *output_pointer++ = ']';\n    *output_pointer = '\\0';\n    output_buffer-\u003edepth--;\n\n    return true;\n}","filepath":"cJSON.c","line_number":1529,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"161012":{"score":0.9348674,"function_name":"parse_object","code":"static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)\n{\n    cJSON *head = NULL; /* linked list head */\n    cJSON *current_item = NULL;\n\n    if (input_buffer-\u003edepth \u003e= CJSON_NESTING_LIMIT)\n    {\n        return false; /* to deeply nested */\n    }\n    input_buffer-\u003edepth++;\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))\n    {\n        goto fail; /* not an object */\n    }\n\n    input_buffer-\u003eoffset++;\n    buffer_skip_whitespace(input_buffer);\n    if (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == '}'))\n    {\n        goto success; /* empty object */\n    }\n\n    /* check if we skipped to the end of the buffer */\n    if (cannot_access_at_index(input_buffer, 0))\n    {\n        input_buffer-\u003eoffset--;\n        goto fail;\n    }\n\n    /* step back to character in front of the first element */\n    input_buffer-\u003eoffset--;\n    /* loop through the comma separated array elements */\n    do\n    {\n        /* allocate next item */\n        cJSON *new_item = cJSON_New_Item(\u0026(input_buffer-\u003ehooks));\n        if (new_item == NULL)\n        {\n            goto fail; /* allocation failure */\n        }\n\n        /* attach next item to list */\n        if (head == NULL)\n        {\n            /* start the linked list */\n            current_item = head = new_item;\n        }\n        else\n        {\n            /* add to the end and advance */\n            current_item-\u003enext = new_item;\n            new_item-\u003eprev = current_item;\n            current_item = new_item;\n        }\n\n        /* parse the name of the child */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_string(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse name */\n        }\n        buffer_skip_whitespace(input_buffer);\n\n        /* swap valuestring and string, because we parsed the name */\n        current_item-\u003estring = current_item-\u003evaluestring;\n        current_item-\u003evaluestring = NULL;\n\n        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))\n        {\n            goto fail; /* invalid object */\n        }\n\n        /* parse the value */\n        input_buffer-\u003eoffset++;\n        buffer_skip_whitespace(input_buffer);\n        if (!parse_value(current_item, input_buffer))\n        {\n            goto fail; /* failed to parse value */\n        }\n        buffer_skip_whitespace(input_buffer);\n    }\n    while (can_access_at_index(input_buffer, 0) \u0026\u0026 (buffer_at_offset(input_buffer)[0] == ','));\n\n    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))\n    {\n        goto fail; /* expected end of object */\n    }\n\nsuccess:\n    input_buffer-\u003edepth--;\n\n    item-\u003etype = cJSON_Object;\n    item-\u003echild = head;\n\n    input_buffer-\u003eoffset++;\n    return true;\n\nfail:\n    if (head != NULL)\n    {\n        cJSON_Delete(head);\n    }\n\n    return false;\n}","filepath":"cJSON.c","line_number":1591,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"161733":{"score":0.94088715,"function_name":"print_object","code":"static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output_pointer = NULL;\n    size_t length = 0;\n    cJSON *current_item = item-\u003echild;\n\n    if (output_buffer == NULL)\n    {\n        return false;\n    }\n\n    /* Compose the output: */\n    length = (size_t) (output_buffer-\u003eformat ? 2 : 1); /* fmt: {\\n */\n    output_pointer = ensure(output_buffer, length + 1);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n\n    *output_pointer++ = '{';\n    output_buffer-\u003edepth++;\n    if (output_buffer-\u003eformat)\n    {\n        *output_pointer++ = '\\n';\n    }\n    output_buffer-\u003eoffset += length;\n\n    while (current_item)\n    {\n        if (output_buffer-\u003eformat)\n        {\n            size_t i;\n            output_pointer = ensure(output_buffer, output_buffer-\u003edepth);\n            if (output_pointer == NULL)\n            {\n                return false;\n            }\n            for (i = 0; i \u003c output_buffer-\u003edepth; i++)\n            {\n                *output_pointer++ = '\\t';\n            }\n            output_buffer-\u003eoffset += output_buffer-\u003edepth;\n        }\n\n        /* print key */\n        if (!print_string_ptr((unsigned char*)current_item-\u003estring, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        length = (size_t) (output_buffer-\u003eformat ? 2 : 1);\n        output_pointer = ensure(output_buffer, length);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        *output_pointer++ = ':';\n        if (output_buffer-\u003eformat)\n        {\n            *output_pointer++ = '\\t';\n        }\n        output_buffer-\u003eoffset += length;\n\n        /* print value */\n        if (!print_value(current_item, output_buffer))\n        {\n            return false;\n        }\n        update_offset(output_buffer);\n\n        /* print comma if not last */\n        length = ((size_t)(output_buffer-\u003eformat ? 1 : 0) + (size_t)(current_item-\u003enext ? 1 : 0));\n        output_pointer = ensure(output_buffer, length + 1);\n        if (output_pointer == NULL)\n        {\n            return false;\n        }\n        if (current_item-\u003enext)\n        {\n            *output_pointer++ = ',';\n        }\n\n        if (output_buffer-\u003eformat)\n        {\n            *output_pointer++ = '\\n';\n        }\n        *output_pointer = '\\0';\n        output_buffer-\u003eoffset += length;\n\n        current_item = current_item-\u003enext;\n    }\n\n    output_pointer = ensure(output_buffer, output_buffer-\u003eformat ? (output_buffer-\u003edepth + 1) : 2);\n    if (output_pointer == NULL)\n    {\n        return false;\n    }\n    if (output_buffer-\u003eformat)\n    {\n        size_t i;\n        for (i = 0; i \u003c (output_buffer-\u003edepth - 1); i++)\n        {\n            *output_pointer++ = '\\t';\n        }\n    }\n    *output_pointer++ = '}';\n    *output_pointer = '\\0';\n    output_buffer-\u003edepth--;\n\n    return true;\n}","filepath":"cJSON.c","line_number":1700,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"162554":{"score":0.913613,"function_name":"cJSON_GetArraySize","code":"CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)\n{\n    cJSON *child = NULL;\n    size_t size = 0;\n\n    if (array == NULL)\n    {\n        return 0;\n    }\n\n    child = array-\u003echild;\n\n    while(child != NULL)\n    {\n        size++;\n        child = child-\u003enext;\n    }\n\n    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */\n\n    return (int)size;\n}","filepath":"cJSON.c","line_number":1814,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"162631":{"score":0.950401,"function_name":"get_array_item","code":"static cJSON* get_array_item(const cJSON *array, size_t index)\n{\n    cJSON *current_child = NULL;\n\n    if (array == NULL)\n    {\n        return NULL;\n    }\n\n    current_child = array-\u003echild;\n    while ((current_child != NULL) \u0026\u0026 (index \u003e 0))\n    {\n        index--;\n        current_child = current_child-\u003enext;\n    }\n\n    return current_child;\n}","filepath":"cJSON.c","line_number":1837,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"162707":{"score":0.799464,"function_name":"cJSON_GetArrayItem","code":"CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)\n{\n    if (index \u003c 0)\n    {\n        return NULL;\n    }\n\n    return get_array_item(array, (size_t)index);\n}","filepath":"cJSON.c","line_number":1856,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"162750":{"score":0.92254543,"function_name":"get_object_item","code":"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object-\u003echild;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) \u0026\u0026 (current_element-\u003estring != NULL) \u0026\u0026 (strcmp(name, current_element-\u003estring) != 0))\n        {\n            current_element = current_element-\u003enext;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) \u0026\u0026 (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element-\u003estring)) != 0))\n        {\n            current_element = current_element-\u003enext;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element-\u003estring == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}","filepath":"cJSON.c","line_number":1866,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163085":{"score":0.9533847,"function_name":"create_reference","code":"static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)\n{\n    cJSON *reference = NULL;\n    if (item == NULL)\n    {\n        return NULL;\n    }\n\n    reference = cJSON_New_Item(hooks);\n    if (reference == NULL)\n    {\n        return NULL;\n    }\n\n    memcpy(reference, item, sizeof(cJSON));\n    reference-\u003estring = NULL;\n    reference-\u003etype |= cJSON_IsReference;\n    reference-\u003enext = reference-\u003eprev = NULL;\n    return reference;\n}","filepath":"cJSON.c","line_number":1921,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163228":{"score":0.76545775,"function_name":"add_item_to_array","code":"static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)\n{\n    cJSON *child = NULL;\n\n    if ((item == NULL) || (array == NULL) || (array == item))\n    {\n        return false;\n    }\n\n    child = array-\u003echild;\n    /*\n     * To find the last item in array quickly, we use prev in array\n     */\n    if (child == NULL)\n    {\n        /* list is empty, start new one */\n        array-\u003echild = item;\n        item-\u003eprev = item;\n        item-\u003enext = NULL;\n    }\n    else\n    {\n        /* append to the end */\n        if (child-\u003eprev)\n        {\n            suffix_object(child-\u003eprev, item);\n            array-\u003echild-\u003eprev = item;\n        }\n        else\n        {\n            while (child-\u003enext)\n            {\n                child = child-\u003enext;\n            }\n            suffix_object(child, item);\n            array-\u003echild-\u003eprev = item;\n        }\n    }\n\n    return true;\n}","filepath":"cJSON.c","line_number":1942,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163382":{"score":0.83603513,"function_name":"add_item_to_object","code":"static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)\n{\n    char *new_key = NULL;\n    int new_type = cJSON_Invalid;\n\n    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))\n    {\n        return false;\n    }\n\n    if (constant_key)\n    {\n        new_key = (char*)cast_away_const(string);\n        new_type = item-\u003etype | cJSON_StringIsConst;\n    }\n    else\n    {\n        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);\n        if (new_key == NULL)\n        {\n            return false;\n        }\n\n        new_type = item-\u003etype \u0026 ~cJSON_StringIsConst;\n    }\n\n    if (!(item-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (item-\u003estring != NULL))\n    {\n        hooks-\u003edeallocate(item-\u003estring);\n    }\n\n    item-\u003estring = new_key;\n    item-\u003etype = new_type;\n\n    return add_item_to_array(object, item);\n}","filepath":"cJSON.c","line_number":2006,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163698":{"score":0.56773674,"function_name":"cJSON_AddItemReferenceToArray","code":"CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\n{\n    if (array == NULL)\n    {\n        return false;\n    }\n\n    return add_item_to_array(array, create_reference(item, \u0026global_hooks));\n}","filepath":"cJSON.c","line_number":2054,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163761":{"score":0.609587,"function_name":"cJSON_AddItemReferenceToObject","code":"CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)\n{\n    if ((object == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    return add_item_to_object(object, string, create_reference(item, \u0026global_hooks), \u0026global_hooks, false);\n}","filepath":"cJSON.c","line_number":2064,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"163849":{"score":0.6731259,"function_name":"cJSON_AddArrayToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)\n{\n    cJSON *array = cJSON_CreateArray();\n    if (add_item_to_object(object, name, array, \u0026global_hooks, false))\n    {\n        return array;\n    }\n\n    cJSON_Delete(array);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2170,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"164113":{"score":0.6219869,"function_name":"cJSON_AddBoolToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)\n{\n    cJSON *bool_item = cJSON_CreateBool(boolean);\n    if (add_item_to_object(object, name, bool_item, \u0026global_hooks, false))\n    {\n        return bool_item;\n    }\n\n    cJSON_Delete(bool_item);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2110,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"164210":{"score":0.5623885,"function_name":"cJSON_AddNumberToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)\n{\n    cJSON *number_item = cJSON_CreateNumber(number);\n    if (add_item_to_object(object, name, number_item, \u0026global_hooks, false))\n    {\n        return number_item;\n    }\n\n    cJSON_Delete(number_item);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2122,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"164419":{"score":0.7070545,"function_name":"cJSON_AddStringToObject","code":"CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)\n{\n    cJSON *string_item = cJSON_CreateString(string);\n    if (add_item_to_object(object, name, string_item, \u0026global_hooks, false))\n    {\n        return string_item;\n    }\n\n    cJSON_Delete(string_item);\n    return NULL;\n}","filepath":"cJSON.c","line_number":2134,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"164692":{"score":0.9106645,"function_name":"cJSON_DetachItemViaPointer","code":"CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)\n{\n    if ((parent == NULL) || (item == NULL))\n    {\n        return NULL;\n    }\n\n    if (item != parent-\u003echild)\n    {\n        /* not the first element */\n        item-\u003eprev-\u003enext = item-\u003enext;\n    }\n    if (item-\u003enext != NULL)\n    {\n        /* not the last element */\n        item-\u003enext-\u003eprev = item-\u003eprev;\n    }\n\n    if (item == parent-\u003echild)\n    {\n        /* first element */\n        parent-\u003echild = item-\u003enext;\n    }\n    /* make sure the detached item doesn't point anywhere anymore */\n    item-\u003eprev = NULL;\n    item-\u003enext = NULL;\n\n    return item;\n}","filepath":"cJSON.c","line_number":2182,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"164816":{"score":0.7541063,"function_name":"cJSON_DetachItemFromArray","code":"CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)\n{\n    if (which \u003c 0)\n    {\n        return NULL;\n    }\n\n    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));\n}","filepath":"cJSON.c","line_number":2212,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165122":{"score":0.64108205,"function_name":"cJSON_InsertItemInArray","code":"CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)\n{\n    cJSON *after_inserted = NULL;\n\n    if (which \u003c 0)\n    {\n        return false;\n    }\n\n    after_inserted = get_array_item(array, (size_t)which);\n    if (after_inserted == NULL)\n    {\n        return add_item_to_array(array, newitem);\n    }\n\n    newitem-\u003enext = after_inserted;\n    newitem-\u003eprev = after_inserted-\u003eprev;\n    after_inserted-\u003eprev = newitem;\n    if (after_inserted == array-\u003echild)\n    {\n        array-\u003echild = newitem;\n    }\n    else\n    {\n        newitem-\u003eprev-\u003enext = newitem;\n    }\n    return true;\n}","filepath":"cJSON.c","line_number":2252,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165258":{"score":0.9684269,"function_name":"cJSON_ReplaceItemViaPointer","code":"CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)\n{\n    if ((parent == NULL) || (replacement == NULL) || (item == NULL))\n    {\n        return false;\n    }\n\n    if (replacement == item)\n    {\n        return true;\n    }\n\n    replacement-\u003enext = item-\u003enext;\n    replacement-\u003eprev = item-\u003eprev;\n\n    if (replacement-\u003enext != NULL)\n    {\n        replacement-\u003enext-\u003eprev = replacement;\n    }\n    if (parent-\u003echild == item)\n    {\n        parent-\u003echild = replacement;\n    }\n    else\n    {   /*\n         * To find the last item in array quickly, we use prev in array.\n         * We can't modify the last item's next pointer where this item was the parent's child\n         */\n        if (replacement-\u003eprev != NULL)\n        {\n            replacement-\u003eprev-\u003enext = replacement;\n        }\n    }\n\n    item-\u003enext = NULL;\n    item-\u003eprev = NULL;\n    cJSON_Delete(item);\n\n    return true;\n}","filepath":"cJSON.c","line_number":2281,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165500":{"score":0.84717983,"function_name":"replace_item_in_object","code":"static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)\n{\n    if ((replacement == NULL) || (string == NULL))\n    {\n        return false;\n    }\n\n    /* replace the name in the replacement */\n    if (!(replacement-\u003etype \u0026 cJSON_StringIsConst) \u0026\u0026 (replacement-\u003estring != NULL))\n    {\n        cJSON_free(replacement-\u003estring);\n    }\n    replacement-\u003estring = (char*)cJSON_strdup((const unsigned char*)string, \u0026global_hooks);\n    replacement-\u003etype \u0026= ~cJSON_StringIsConst;\n\n    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);\n}","filepath":"cJSON.c","line_number":2332,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165869":{"score":0.81809634,"function_name":"cJSON_CreateTrue","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_True;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2372,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165927":{"score":0.8626498,"function_name":"cJSON_CreateBool","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = boolean ? cJSON_True : cJSON_False;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2394,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"165999":{"score":0.7875086,"function_name":"cJSON_CreateNumber","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_Number;\n        item-\u003evaluedouble = num;\n\n        /* use saturation in case of overflow */\n        if (num \u003e= INT_MAX)\n        {\n            item-\u003evalueint = INT_MAX;\n        }\n        else if (num \u003c= (double)INT_MIN)\n        {\n            item-\u003evalueint = INT_MIN;\n        }\n        else\n        {\n            item-\u003evalueint = (int)num;\n        }\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2405,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"166172":{"score":0.87139153,"function_name":"cJSON_CreateString","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype = cJSON_String;\n        item-\u003evaluestring = (char*)cJSON_strdup((const unsigned char*)string, \u0026global_hooks);\n        if(!item-\u003evaluestring)\n        {\n            cJSON_Delete(item);\n            return NULL;\n        }\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2431,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"166295":{"score":0.75274736,"function_name":"cJSON_CreateStringReference","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if (item != NULL)\n    {\n        item-\u003etype = cJSON_String | cJSON_IsReference;\n        item-\u003evaluestring = (char*)cast_away_const(string);\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2448,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"166658":{"score":0.8244626,"function_name":"cJSON_CreateArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)\n{\n    cJSON *item = cJSON_New_Item(\u0026global_hooks);\n    if(item)\n    {\n        item-\u003etype=cJSON_Array;\n    }\n\n    return item;\n}","filepath":"cJSON.c","line_number":2498,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"166774":{"score":0.84937906,"function_name":"cJSON_CreateFloatArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for(i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber((double)numbers[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"cJSON.c","line_number":2556,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"167206":{"score":0.8537227,"function_name":"cJSON_CreateIntArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n    for(i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"cJSON.c","line_number":2521,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"167417":{"score":0.8482225,"function_name":"cJSON_CreateStringArray","code":"CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count \u003c 0) || (strings == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n\n    for (i = 0; a \u0026\u0026 (i \u003c (size_t)count); i++)\n    {\n        n = cJSON_CreateString(strings[i]);\n        if(!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a-\u003echild = n;\n        }\n        else\n        {\n            suffix_object(p,n);\n        }\n        p = n;\n    }\n\n    return a;\n}","filepath":"cJSON.c","line_number":2628,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"167622":{"score":0.85478723,"function_name":"cJSON_Duplicate","code":"CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)\n{\n    cJSON *newitem = NULL;\n    cJSON *child = NULL;\n    cJSON *next = NULL;\n    cJSON *newchild = NULL;\n\n    /* Bail on bad ptr */\n    if (!item)\n    {\n        goto fail;\n    }\n    /* Create new item */\n    newitem = cJSON_New_Item(\u0026global_hooks);\n    if (!newitem)\n    {\n        goto fail;\n    }\n    /* Copy over all vars */\n    newitem-\u003etype = item-\u003etype \u0026 (~cJSON_IsReference);\n    newitem-\u003evalueint = item-\u003evalueint;\n    newitem-\u003evaluedouble = item-\u003evaluedouble;\n    if (item-\u003evaluestring)\n    {\n        newitem-\u003evaluestring = (char*)cJSON_strdup((unsigned char*)item-\u003evaluestring, \u0026global_hooks);\n        if (!newitem-\u003evaluestring)\n        {\n            goto fail;\n        }\n    }\n    if (item-\u003estring)\n    {\n        newitem-\u003estring = (item-\u003etype\u0026cJSON_StringIsConst) ? item-\u003estring : (char*)cJSON_strdup((unsigned char*)item-\u003estring, \u0026global_hooks);\n        if (!newitem-\u003estring)\n        {\n            goto fail;\n        }\n    }\n    /* If non-recursive, then we're done! */\n    if (!recurse)\n    {\n        return newitem;\n    }\n    /* Walk the -\u003enext chain for the child. */\n    child = item-\u003echild;\n    while (child != NULL)\n    {\n        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the -\u003enext chain */\n        if (!newchild)\n        {\n            goto fail;\n        }\n        if (next != NULL)\n        {\n            /* If newitem-\u003echild already set, then crosswire -\u003eprev and -\u003enext and move on */\n            next-\u003enext = newchild;\n            newchild-\u003eprev = next;\n            next = newchild;\n        }\n        else\n        {\n            /* Set newitem-\u003echild and move to it */\n            newitem-\u003echild = newchild;\n            next = newchild;\n        }\n        child = child-\u003enext;\n    }\n\n    return newitem;\n\nfail:\n    if (newitem != NULL)\n    {\n        cJSON_Delete(newitem);\n    }\n\n    return NULL;\n}","filepath":"cJSON.c","line_number":2665,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168039":{"score":0.8377651,"function_name":"skip_oneline_comment","code":"static void skip_oneline_comment(char **input)\n{\n    *input += static_strlen(\"//\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if ((*input)[0] == '\\n') {\n            *input += static_strlen(\"\\n\");\n            return;\n        }\n    }\n}","filepath":"cJSON.c","line_number":2744,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168121":{"score":0.8358731,"function_name":"skip_multiline_comment","code":"static void skip_multiline_comment(char **input)\n{\n    *input += static_strlen(\"/*\");\n\n    for (; (*input)[0] != '\\0'; ++(*input))\n    {\n        if (((*input)[0] == '*') \u0026\u0026 ((*input)[1] == '/'))\n        {\n            *input += static_strlen(\"*/\");\n            return;\n        }\n    }\n}","filepath":"cJSON.c","line_number":2757,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168218":{"score":0.8770279,"function_name":"minify_string","code":"static void minify_string(char **input, char **output) {\n    (*output)[0] = (*input)[0];\n    *input += static_strlen(\"\\\"\");\n    *output += static_strlen(\"\\\"\");\n\n\n    for (; (*input)[0] != '\\0'; (void)++(*input), ++(*output)) {\n        (*output)[0] = (*input)[0];\n\n        if ((*input)[0] == '\\\"') {\n            (*output)[0] = '\\\"';\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n            return;\n        } else if (((*input)[0] == '\\\\') \u0026\u0026 ((*input)[1] == '\\\"')) {\n            (*output)[1] = (*input)[1];\n            *input += static_strlen(\"\\\"\");\n            *output += static_strlen(\"\\\"\");\n        }\n    }\n}","filepath":"cJSON.c","line_number":2771,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168456":{"score":0.9041346,"function_name":"cJSON_Minify","code":"CJSON_PUBLIC(void) cJSON_Minify(char *json)\n{\n    char *into = json;\n\n    if (json == NULL)\n    {\n        return;\n    }\n\n    while (json[0] != '\\0')\n    {\n        switch (json[0])\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                json++;\n                break;\n\n            case '/':\n                if (json[1] == '/')\n                {\n                    skip_oneline_comment(\u0026json);\n                }\n                else if (json[1] == '*')\n                {\n                    skip_multiline_comment(\u0026json);\n                } else {\n                    json++;\n                }\n                break;\n\n            case '\\\"':\n                minify_string(\u0026json, (char**)\u0026into);\n                break;\n\n            default:\n                into[0] = json[0];\n                json++;\n                into++;\n        }\n    }\n\n    /* and null-terminate. */\n    *into = '\\0';\n}","filepath":"cJSON.c","line_number":2793,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168712":{"score":0.85602534,"function_name":"cJSON_IsInvalid","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xFF) == cJSON_Invalid;\n}","filepath":"cJSON.c","line_number":2841,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168757":{"score":0.90385455,"function_name":"cJSON_IsTrue","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xff) == cJSON_True;\n}","filepath":"cJSON.c","line_number":2861,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168849":{"score":0.8766283,"function_name":"cJSON_IsBool","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 (cJSON_True | cJSON_False)) != 0;\n}","filepath":"cJSON.c","line_number":2872,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"168986":{"score":0.9086259,"function_name":"cJSON_IsString","code":"CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)\n{\n    if (item == NULL)\n    {\n        return false;\n    }\n\n    return (item-\u003etype \u0026 0xFF) == cJSON_String;\n}","filepath":"cJSON.c","line_number":2901,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"169172":{"score":0.85296434,"function_name":"cJSON_Compare","code":"CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)\n{\n    if ((a == NULL) || (b == NULL) || ((a-\u003etype \u0026 0xFF) != (b-\u003etype \u0026 0xFF)) || cJSON_IsInvalid(a))\n    {\n        return false;\n    }\n\n    /* check if type is valid */\n    switch (a-\u003etype \u0026 0xFF)\n    {\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n        case cJSON_Number:\n        case cJSON_String:\n        case cJSON_Raw:\n        case cJSON_Array:\n        case cJSON_Object:\n            break;\n\n        default:\n            return false;\n    }\n\n    /* identical objects are equal */\n    if (a == b)\n    {\n        return true;\n    }\n\n    switch (a-\u003etype \u0026 0xFF)\n    {\n        /* in these cases and equal type is enough */\n        case cJSON_False:\n        case cJSON_True:\n        case cJSON_NULL:\n            return true;\n\n        case cJSON_Number:\n            if (compare_double(a-\u003evaluedouble, b-\u003evaluedouble))\n            {\n                return true;\n            }\n            return false;\n\n        case cJSON_String:\n        case cJSON_Raw:\n            if ((a-\u003evaluestring == NULL) || (b-\u003evaluestring == NULL))\n            {\n                return false;\n            }\n            if (strcmp(a-\u003evaluestring, b-\u003evaluestring) == 0)\n            {\n                return true;\n            }\n\n            return false;\n\n        case cJSON_Array:\n        {\n            cJSON *a_element = a-\u003echild;\n            cJSON *b_element = b-\u003echild;\n\n            for (; (a_element != NULL) \u0026\u0026 (b_element != NULL);)\n            {\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n\n                a_element = a_element-\u003enext;\n                b_element = b_element-\u003enext;\n            }\n\n            /* one of the arrays is longer than the other */\n            if (a_element != b_element) {\n                return false;\n            }\n\n            return true;\n        }\n\n        case cJSON_Object:\n        {\n            cJSON *a_element = NULL;\n            cJSON *b_element = NULL;\n            cJSON_ArrayForEach(a_element, a)\n            {\n                /* TODO This has O(n^2) runtime, which is horrible! */\n                b_element = get_object_item(b, a_element-\u003estring, case_sensitive);\n                if (b_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(a_element, b_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            /* doing this twice, once on a and b to prevent true comparison if a subset of b\n             * TODO: Do this the proper way, this is just a fix for now */\n            cJSON_ArrayForEach(b_element, b)\n            {\n                a_element = get_object_item(a, b_element-\u003estring, case_sensitive);\n                if (a_element == NULL)\n                {\n                    return false;\n                }\n\n                if (!cJSON_Compare(b_element, a_element, case_sensitive))\n                {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        default:\n            return false;\n    }\n}","filepath":"cJSON.c","line_number":2941,"entry_url":"https://github.com/DaveGamble/cJSON.git","slot_name":"v1.7.13"},"170047":{"score":0.783677,"function_name":"mbedtls_ctr_drbg_seed_entropy_len","code":"int mbedtls_ctr_drbg_seed_entropy_len(\n                   mbedtls_ctr_drbg_context *ctx,\n                   int (*f_entropy)(void *, unsigned char *, size_t),\n                   void *p_entropy,\n                   const unsigned char *custom,\n                   size_t len,\n                   size_t entropy_len )\n{\n    int ret;\n    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];\n\n    memset( key, 0, MBEDTLS_CTR_DRBG_KEYSIZE );\n\n    mbedtls_aes_init( \u0026ctx-\u003eaes_ctx );\n\n    ctx-\u003ef_entropy = f_entropy;\n    ctx-\u003ep_entropy = p_entropy;\n\n    ctx-\u003eentropy_len = entropy_len;\n    ctx-\u003ereseed_interval = MBEDTLS_CTR_DRBG_RESEED_INTERVAL;\n\n    /*\n     * Initialize with an empty key\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026ctx-\u003eaes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( ( ret = mbedtls_ctr_drbg_reseed( ctx, custom, len ) ) != 0 )\n    {\n        return( ret );\n    }\n    return( 0 );\n}","filepath":"library/ctr_drbg.c","line_number":81,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"170328":{"score":0.82687545,"function_name":"mbedtls_ctr_drbg_free","code":"void mbedtls_ctr_drbg_free( mbedtls_ctr_drbg_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_THREADING_C)\n    mbedtls_mutex_free( \u0026ctx-\u003emutex );\n#endif\n    mbedtls_aes_free( \u0026ctx-\u003eaes_ctx );\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_ctr_drbg_context ) );\n}","filepath":"library/ctr_drbg.c","line_number":127,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"170472":{"score":0.89926904,"function_name":"block_cipher_df","code":"static int block_cipher_df( unsigned char *output,\n                            const unsigned char *data, size_t data_len )\n{\n    unsigned char buf[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16];\n    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char key[MBEDTLS_CTR_DRBG_KEYSIZE];\n    unsigned char chain[MBEDTLS_CTR_DRBG_BLOCKSIZE];\n    unsigned char *p, *iv;\n    mbedtls_aes_context aes_ctx;\n    int ret = 0;\n\n    int i, j;\n    size_t buf_len, use_len;\n\n    if( data_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( buf, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT + MBEDTLS_CTR_DRBG_BLOCKSIZE + 16 );\n    mbedtls_aes_init( \u0026aes_ctx );\n\n    /*\n     * Construct IV (16 bytes) and S in buffer\n     * IV = Counter (in 32-bits) padded to 16 with zeroes\n     * S = Length input string (in 32-bits) || Length of output (in 32-bits) ||\n     *     data || 0x80\n     *     (Total is padded to a multiple of 16-bytes with zeroes)\n     */\n    p = buf + MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    *p++ = ( data_len \u003e\u003e 24 ) \u0026 0xff;\n    *p++ = ( data_len \u003e\u003e 16 ) \u0026 0xff;\n    *p++ = ( data_len \u003e\u003e 8  ) \u0026 0xff;\n    *p++ = ( data_len       ) \u0026 0xff;\n    p += 3;\n    *p++ = MBEDTLS_CTR_DRBG_SEEDLEN;\n    memcpy( p, data, data_len );\n    p[data_len] = 0x80;\n\n    buf_len = MBEDTLS_CTR_DRBG_BLOCKSIZE + 8 + data_len + 1;\n\n    for( i = 0; i \u003c MBEDTLS_CTR_DRBG_KEYSIZE; i++ )\n        key[i] = i;\n\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026aes_ctx, key, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        goto exit;\n    }\n\n    /*\n     * Reduce data to MBEDTLS_CTR_DRBG_SEEDLEN bytes of data\n     */\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        p = buf;\n        memset( chain, 0, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n        use_len = buf_len;\n\n        while( use_len \u003e 0 )\n        {\n            for( i = 0; i \u003c MBEDTLS_CTR_DRBG_BLOCKSIZE; i++ )\n                chain[i] ^= p[i];\n            p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n            use_len -= ( use_len \u003e= MBEDTLS_CTR_DRBG_BLOCKSIZE ) ?\n                       MBEDTLS_CTR_DRBG_BLOCKSIZE : use_len;\n\n            if( ( ret = mbedtls_aes_crypt_ecb( \u0026aes_ctx, MBEDTLS_AES_ENCRYPT, chain, chain ) ) != 0 )\n            {\n                goto exit;\n            }\n        }\n\n        memcpy( tmp + j, chain, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n\n        /*\n         * Update IV\n         */\n        buf[3]++;\n    }\n\n    /*\n     * Do final encryption with reduced data\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026aes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n    {\n        goto exit;\n    }\n    iv = tmp + MBEDTLS_CTR_DRBG_KEYSIZE;\n    p = output;\n\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026aes_ctx, MBEDTLS_AES_ENCRYPT, iv, iv ) ) != 0 )\n        {\n            goto exit;\n        }\n        memcpy( p, iv, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    }\nexit:\n    mbedtls_aes_free( \u0026aes_ctx );\n    /*\n    * tidy up the stack\n    */\n    mbedtls_platform_zeroize( buf, sizeof( buf ) );\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    mbedtls_platform_zeroize( key, sizeof( key ) );\n    mbedtls_platform_zeroize( chain, sizeof( chain ) );\n    if( 0 != ret )\n    {\n        /*\n        * wipe partial seed from memory\n        */\n        mbedtls_platform_zeroize( output, MBEDTLS_CTR_DRBG_SEEDLEN );\n    }\n\n    return( ret );\n}","filepath":"library/ctr_drbg.c","line_number":154,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"171563":{"score":0.884328,"function_name":"ctr_drbg_update_internal","code":"static int ctr_drbg_update_internal( mbedtls_ctr_drbg_context *ctx,\n                              const unsigned char data[MBEDTLS_CTR_DRBG_SEEDLEN] )\n{\n    unsigned char tmp[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char *p = tmp;\n    int i, j;\n    int ret = 0;\n\n    memset( tmp, 0, MBEDTLS_CTR_DRBG_SEEDLEN );\n\n    for( j = 0; j \u003c MBEDTLS_CTR_DRBG_SEEDLEN; j += MBEDTLS_CTR_DRBG_BLOCKSIZE )\n    {\n        /*\n         * Increase counter\n         */\n        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i \u003e 0; i-- )\n            if( ++ctx-\u003ecounter[i - 1] != 0 )\n                break;\n\n        /*\n         * Crypt counter block\n         */\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026ctx-\u003eaes_ctx, MBEDTLS_AES_ENCRYPT, ctx-\u003ecounter, p ) ) != 0 )\n            goto exit;\n\n        p += MBEDTLS_CTR_DRBG_BLOCKSIZE;\n    }\n\n    for( i = 0; i \u003c MBEDTLS_CTR_DRBG_SEEDLEN; i++ )\n        tmp[i] ^= data[i];\n\n    /*\n     * Update key and counter\n     */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026ctx-\u003eaes_ctx, tmp, MBEDTLS_CTR_DRBG_KEYBITS ) ) != 0 )\n        goto exit;\n    memcpy( ctx-\u003ecounter, tmp + MBEDTLS_CTR_DRBG_KEYSIZE, MBEDTLS_CTR_DRBG_BLOCKSIZE );\n\nexit:\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    return( ret );\n}","filepath":"library/ctr_drbg.c","line_number":279,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"171912":{"score":0.7643197,"function_name":"mbedtls_ctr_drbg_update_ret","code":"int mbedtls_ctr_drbg_update_ret( mbedtls_ctr_drbg_context *ctx,\n                                 const unsigned char *additional,\n                                 size_t add_len )\n{\n    unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];\n    int ret;\n\n    if( add_len == 0 )\n        return( 0 );\n\n    if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )\n        goto exit;\n    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_platform_zeroize( add_input, sizeof( add_input ) );\n    return( ret );\n}","filepath":"library/ctr_drbg.c","line_number":334,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"172066":{"score":0.77404046,"function_name":"mbedtls_ctr_drbg_update","code":"void mbedtls_ctr_drbg_update( mbedtls_ctr_drbg_context *ctx,\n                              const unsigned char *additional,\n                              size_t add_len )\n{\n    /* MAX_INPUT would be more logical here, but we have to match\n     * block_cipher_df()'s limits since we can't propagate errors */\n    if( add_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT )\n        add_len = MBEDTLS_CTR_DRBG_MAX_SEED_INPUT;\n    (void) mbedtls_ctr_drbg_update_ret( ctx, additional, add_len );\n}","filepath":"library/ctr_drbg.c","line_number":355,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"172121":{"score":0.8834583,"function_name":"mbedtls_ctr_drbg_reseed","code":"int mbedtls_ctr_drbg_reseed( mbedtls_ctr_drbg_context *ctx,\n                     const unsigned char *additional, size_t len )\n{\n    unsigned char seed[MBEDTLS_CTR_DRBG_MAX_SEED_INPUT];\n    size_t seedlen = 0;\n    int ret;\n\n    if( ctx-\u003eentropy_len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT ||\n        len \u003e MBEDTLS_CTR_DRBG_MAX_SEED_INPUT - ctx-\u003eentropy_len )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( seed, 0, MBEDTLS_CTR_DRBG_MAX_SEED_INPUT );\n\n    /*\n     * Gather entropy_len bytes of entropy to seed state\n     */\n    if( 0 != ctx-\u003ef_entropy( ctx-\u003ep_entropy, seed,\n                             ctx-\u003eentropy_len ) )\n    {\n        return( MBEDTLS_ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED );\n    }\n\n    seedlen += ctx-\u003eentropy_len;\n\n    /*\n     * Add additional data\n     */\n    if( additional \u0026\u0026 len )\n    {\n        memcpy( seed + seedlen, additional, len );\n        seedlen += len;\n    }\n\n    /*\n     * Reduce to 384 bits\n     */\n    if( ( ret = block_cipher_df( seed, seed, seedlen ) ) != 0 )\n        goto exit;\n\n    /*\n     * Update state\n     */\n    if( ( ret = ctr_drbg_update_internal( ctx, seed ) ) != 0 )\n        goto exit;\n    ctx-\u003ereseed_counter = 1;\n\nexit:\n    mbedtls_platform_zeroize( seed, sizeof( seed ) );\n    return( ret );\n}","filepath":"library/ctr_drbg.c","line_number":379,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"172548":{"score":0.84088695,"function_name":"mbedtls_ctr_drbg_random_with_add","code":"int mbedtls_ctr_drbg_random_with_add( void *p_rng,\n                              unsigned char *output, size_t output_len,\n                              const unsigned char *additional, size_t add_len )\n{\n    int ret = 0;\n    mbedtls_ctr_drbg_context *ctx = (mbedtls_ctr_drbg_context *) p_rng;\n    unsigned char add_input[MBEDTLS_CTR_DRBG_SEEDLEN];\n    unsigned char *p = output;\n    unsigned char tmp[MBEDTLS_CTR_DRBG_BLOCKSIZE];\n    int i;\n    size_t use_len;\n\n    if( output_len \u003e MBEDTLS_CTR_DRBG_MAX_REQUEST )\n        return( MBEDTLS_ERR_CTR_DRBG_REQUEST_TOO_BIG );\n\n    if( add_len \u003e MBEDTLS_CTR_DRBG_MAX_INPUT )\n        return( MBEDTLS_ERR_CTR_DRBG_INPUT_TOO_BIG );\n\n    memset( add_input, 0, MBEDTLS_CTR_DRBG_SEEDLEN );\n\n    if( ctx-\u003ereseed_counter \u003e ctx-\u003ereseed_interval ||\n        ctx-\u003eprediction_resistance )\n    {\n        if( ( ret = mbedtls_ctr_drbg_reseed( ctx, additional, add_len ) ) != 0 )\n        {\n            return( ret );\n        }\n        add_len = 0;\n    }\n\n    if( add_len \u003e 0 )\n    {\n        if( ( ret = block_cipher_df( add_input, additional, add_len ) ) != 0 )\n            goto exit;\n        if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n            goto exit;\n    }\n\n    while( output_len \u003e 0 )\n    {\n        /*\n         * Increase counter\n         */\n        for( i = MBEDTLS_CTR_DRBG_BLOCKSIZE; i \u003e 0; i-- )\n            if( ++ctx-\u003ecounter[i - 1] != 0 )\n                break;\n\n        /*\n         * Crypt counter block\n         */\n        if( ( ret = mbedtls_aes_crypt_ecb( \u0026ctx-\u003eaes_ctx, MBEDTLS_AES_ENCRYPT, ctx-\u003ecounter, tmp ) ) != 0 )\n            goto exit;\n\n        use_len = ( output_len \u003e MBEDTLS_CTR_DRBG_BLOCKSIZE ) ? MBEDTLS_CTR_DRBG_BLOCKSIZE :\n                                                       output_len;\n        /*\n         * Copy random block to destination\n         */\n        memcpy( p, tmp, use_len );\n        p += use_len;\n        output_len -= use_len;\n    }\n\n    if( ( ret = ctr_drbg_update_internal( ctx, add_input ) ) != 0 )\n        goto exit;\n\n    ctx-\u003ereseed_counter++;\n\nexit:\n    mbedtls_platform_zeroize( add_input, sizeof( add_input ) );\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    return( 0 );\n}","filepath":"library/ctr_drbg.c","line_number":449,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"173138":{"score":0.77366376,"function_name":"entropy_init","code":"void entropy_init( entropy_context *ctx )\n{\n    memset( ctx, 0, sizeof(entropy_context) );\n\n    sha4_starts( \u0026ctx-\u003eaccumulator, 0 );\n#if defined(POLARSSL_HAVEGE_C)\n    havege_init( \u0026ctx-\u003ehavege_data );\n#endif\n\n#if !defined(POLARSSL_NO_DEFAULT_ENTROPY_SOURCES)\n#if !defined(POLARSSL_NO_PLATFORM_ENTROPY)\n    entropy_add_source( ctx, platform_entropy_poll, NULL,\n                        ENTROPY_MIN_PLATFORM );\n#endif\n#if defined(POLARSSL_TIMING_C)\n    entropy_add_source( ctx, hardclock_poll, NULL, ENTROPY_MIN_HARDCLOCK );\n#endif\n#if defined(POLARSSL_HAVEGE_C)\n    entropy_add_source( ctx, havege_poll, \u0026ctx-\u003ehavege_data,\n                        ENTROPY_MIN_HAVEGE );\n#endif\n#endif /* POLARSSL_NO_DEFAULT_ENTROPY_SOURCES */\n}","filepath":"library/entropy.c","line_number":40,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.13"},"173345":{"score":0.9236666,"function_name":"entropy_add_source","code":"int entropy_add_source( entropy_context *ctx,\n                        f_source_ptr f_source, void *p_source,\n                        size_t threshold )\n{\n    int index = ctx-\u003esource_count;\n\n    if( index \u003e= ENTROPY_MAX_SOURCES )\n        return( POLARSSL_ERR_ENTROPY_MAX_SOURCES );\n\n    ctx-\u003esource[index].f_source = f_source;\n    ctx-\u003esource[index].p_source = p_source;\n    ctx-\u003esource[index].threshold = threshold;\n\n    ctx-\u003esource_count++;\n\n    return( 0 );\n}","filepath":"library/entropy.c","line_number":64,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.13"},"173874":{"score":0.8767951,"function_name":"entropy_gather","code":"int entropy_gather( entropy_context *ctx )\n{\n    int ret, i;\n    unsigned char buf[ENTROPY_MAX_GATHER];\n    size_t olen;\n    \n    if( ctx-\u003esource_count == 0 )\n        return( POLARSSL_ERR_ENTROPY_NO_SOURCES_DEFINED );\n\n    /*\n     * Run through our entropy sources\n     */\n    for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n    {\n        olen = 0;\n        if ( ( ret = ctx-\u003esource[i].f_source( ctx-\u003esource[i].p_source,\n                        buf, ENTROPY_MAX_GATHER, \u0026olen ) ) != 0 )\n        {\n            return( ret );\n        }\n\n        /*\n         * Add if we actually gathered something\n         */\n        if( olen \u003e 0 )\n        {\n            entropy_update( ctx, (unsigned char) i, buf, olen );\n            ctx-\u003esource[i].size += olen;\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/entropy.c","line_number":119,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.13"},"174425":{"score":0.81771946,"function_name":"entropy_func","code":"int entropy_func( void *data, unsigned char *output, size_t len )\n{\n    int ret, count = 0, i, reached;\n    entropy_context *ctx = (entropy_context *) data;\n    unsigned char buf[ENTROPY_BLOCK_SIZE];\n\n    if( len \u003e ENTROPY_BLOCK_SIZE )\n        return( POLARSSL_ERR_ENTROPY_SOURCE_FAILED );\n\n    /*\n     * Always gather extra entropy before a call\n     */\n    do\n    {\n        if( count++ \u003e ENTROPY_MAX_LOOP )\n            return( POLARSSL_ERR_ENTROPY_SOURCE_FAILED );\n\n        if( ( ret = entropy_gather( ctx ) ) != 0 )\n            return( ret );\n\n        reached = 0;\n\n        for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n            if( ctx-\u003esource[i].size \u003e= ctx-\u003esource[i].threshold )\n                reached++;\n    }\n    while( reached != ctx-\u003esource_count );\n\n    memset( buf, 0, ENTROPY_BLOCK_SIZE );\n\n    sha4_finish( \u0026ctx-\u003eaccumulator, buf );\n\n    /*\n     * Reset accumulator and counters and recycle existing entropy\n     */\n    memset( \u0026ctx-\u003eaccumulator, 0, sizeof( sha4_context ) );\n    sha4_starts( \u0026ctx-\u003eaccumulator, 0 );\n    sha4_update( \u0026ctx-\u003eaccumulator, buf, ENTROPY_BLOCK_SIZE );\n\n    /*\n     * Perform second SHA-512 on entropy\n     */\n    sha4( buf, ENTROPY_BLOCK_SIZE, buf, 0 );\n\n    for( i = 0; i \u003c ctx-\u003esource_count; i++ )\n        ctx-\u003esource[i].size = 0;\n\n    memcpy( output, buf, len );\n\n    return( 0 );\n}","filepath":"library/entropy.c","line_number":153,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.2.13"},"175318":{"score":0.86685616,"function_name":"mbedtls_net_connect","code":"int mbedtls_net_connect( mbedtls_net_context *ctx, const char *host,\n                         const char *port, int proto )\n{\n    int ret;\n    struct addrinfo hints, *addr_list, *cur;\n\n    if( ( ret = net_prepare() ) != 0 )\n        return( ret );\n\n    /* Do name resolution with both IPv6 and IPv4 */\n    memset( \u0026hints, 0, sizeof( hints ) );\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;\n    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;\n\n    if( getaddrinfo( host, port, \u0026hints, \u0026addr_list ) != 0 )\n        return( MBEDTLS_ERR_NET_UNKNOWN_HOST );\n\n    /* Try the sockaddrs until a connection succeeds */\n    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;\n    for( cur = addr_list; cur != NULL; cur = cur-\u003eai_next )\n    {\n        ctx-\u003efd = (int) socket( cur-\u003eai_family, cur-\u003eai_socktype,\n                            cur-\u003eai_protocol );\n        if( ctx-\u003efd \u003c 0 )\n        {\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        if( connect( ctx-\u003efd, cur-\u003eai_addr, MSVC_INT_CAST cur-\u003eai_addrlen ) == 0 )\n        {\n            ret = 0;\n            break;\n        }\n\n        close( ctx-\u003efd );\n        ret = MBEDTLS_ERR_NET_CONNECT_FAILED;\n    }\n\n    freeaddrinfo( addr_list );\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":141,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"175695":{"score":0.85940576,"function_name":"mbedtls_net_bind","code":"int mbedtls_net_bind( mbedtls_net_context *ctx, const char *bind_ip, const char *port, int proto )\n{\n    int n, ret;\n    struct addrinfo hints, *addr_list, *cur;\n\n    if( ( ret = net_prepare() ) != 0 )\n        return( ret );\n\n    /* Bind to IPv6 and/or IPv4, but only in the desired protocol */\n    memset( \u0026hints, 0, sizeof( hints ) );\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = proto == MBEDTLS_NET_PROTO_UDP ? SOCK_DGRAM : SOCK_STREAM;\n    hints.ai_protocol = proto == MBEDTLS_NET_PROTO_UDP ? IPPROTO_UDP : IPPROTO_TCP;\n    if( bind_ip == NULL )\n        hints.ai_flags = AI_PASSIVE;\n\n    if( getaddrinfo( bind_ip, port, \u0026hints, \u0026addr_list ) != 0 )\n        return( MBEDTLS_ERR_NET_UNKNOWN_HOST );\n\n    /* Try the sockaddrs until a binding succeeds */\n    ret = MBEDTLS_ERR_NET_UNKNOWN_HOST;\n    for( cur = addr_list; cur != NULL; cur = cur-\u003eai_next )\n    {\n        ctx-\u003efd = (int) socket( cur-\u003eai_family, cur-\u003eai_socktype,\n                            cur-\u003eai_protocol );\n        if( ctx-\u003efd \u003c 0 )\n        {\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        n = 1;\n        if( setsockopt( ctx-\u003efd, SOL_SOCKET, SO_REUSEADDR,\n                        (const char *) \u0026n, sizeof( n ) ) != 0 )\n        {\n            close( ctx-\u003efd );\n            ret = MBEDTLS_ERR_NET_SOCKET_FAILED;\n            continue;\n        }\n\n        if( bind( ctx-\u003efd, cur-\u003eai_addr, MSVC_INT_CAST cur-\u003eai_addrlen ) != 0 )\n        {\n            close( ctx-\u003efd );\n            ret = MBEDTLS_ERR_NET_BIND_FAILED;\n            continue;\n        }\n\n        /* Listen only makes sense for TCP */\n        if( proto == MBEDTLS_NET_PROTO_TCP )\n        {\n            if( listen( ctx-\u003efd, MBEDTLS_NET_LISTEN_BACKLOG ) != 0 )\n            {\n                close( ctx-\u003efd );\n                ret = MBEDTLS_ERR_NET_LISTEN_FAILED;\n                continue;\n            }\n        }\n\n        /* Bind was successful */\n        ret = 0;\n        break;\n    }\n\n    freeaddrinfo( addr_list );\n\n    return( ret );\n\n}","filepath":"library/net_sockets.c","line_number":189,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"176209":{"score":0.9216577,"function_name":"net_would_block","code":"static int net_would_block( const mbedtls_net_context *ctx )\n{\n    int err = errno;\n\n    /*\n     * Never return 'WOULD BLOCK' on a non-blocking socket\n     */\n    if( ( fcntl( ctx-\u003efd, F_GETFL ) \u0026 O_NONBLOCK ) != O_NONBLOCK )\n    {\n        errno = err;\n        return( 0 );\n    }\n\n    switch( errno = err )\n    {\n#if defined EAGAIN\n        case EAGAIN:\n#endif\n#if defined EWOULDBLOCK \u0026\u0026 EWOULDBLOCK != EAGAIN\n        case EWOULDBLOCK:\n#endif\n            return( 1 );\n    }\n    return( 0 );\n}","filepath":"library/net_sockets.c","line_number":276,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"176321":{"score":0.92924565,"function_name":"mbedtls_net_accept","code":"int mbedtls_net_accept( mbedtls_net_context *bind_ctx,\n                        mbedtls_net_context *client_ctx,\n                        void *client_ip, size_t buf_size, size_t *ip_len )\n{\n    int ret;\n    int type;\n\n    struct sockaddr_storage client_addr;\n\n#if defined(__socklen_t_defined) || defined(_SOCKLEN_T) ||  \\\n    defined(_SOCKLEN_T_DECLARED) || defined(__DEFINED_socklen_t)\n    socklen_t n = (socklen_t) sizeof( client_addr );\n    socklen_t type_len = (socklen_t) sizeof( type );\n#else\n    int n = (int) sizeof( client_addr );\n    int type_len = (int) sizeof( type );\n#endif\n\n    /* Is this a TCP or UDP socket? */\n    if( getsockopt( bind_ctx-\u003efd, SOL_SOCKET, SO_TYPE,\n                    (void *) \u0026type, \u0026type_len ) != 0 ||\n        ( type != SOCK_STREAM \u0026\u0026 type != SOCK_DGRAM ) )\n    {\n        return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n    }\n\n    if( type == SOCK_STREAM )\n    {\n        /* TCP: actual accept() */\n        ret = client_ctx-\u003efd = (int) accept( bind_ctx-\u003efd,\n                                             (struct sockaddr *) \u0026client_addr, \u0026n );\n    }\n    else\n    {\n        /* UDP: wait for a message, but keep it in the queue */\n        char buf[1] = { 0 };\n\n        ret = (int) recvfrom( bind_ctx-\u003efd, buf, sizeof( buf ), MSG_PEEK,\n                        (struct sockaddr *) \u0026client_addr, \u0026n );\n\n#if defined(_WIN32)\n        if( ret == SOCKET_ERROR \u0026\u0026\n            WSAGetLastError() == WSAEMSGSIZE )\n        {\n            /* We know buf is too small, thanks, just peeking here */\n            ret = 0;\n        }\n#endif\n    }\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( bind_ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n\n        return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n    }\n\n    /* UDP: hijack the listening socket to communicate with the client,\n     * then bind a new socket to accept new connections */\n    if( type != SOCK_STREAM )\n    {\n        struct sockaddr_storage local_addr;\n        int one = 1;\n\n        if( connect( bind_ctx-\u003efd, (struct sockaddr *) \u0026client_addr, n ) != 0 )\n            return( MBEDTLS_ERR_NET_ACCEPT_FAILED );\n\n        client_ctx-\u003efd = bind_ctx-\u003efd;\n        bind_ctx-\u003efd   = -1; /* In case we exit early */\n\n        n = sizeof( struct sockaddr_storage );\n        if( getsockname( client_ctx-\u003efd,\n                         (struct sockaddr *) \u0026local_addr, \u0026n ) != 0 ||\n            ( bind_ctx-\u003efd = (int) socket( local_addr.ss_family,\n                                           SOCK_DGRAM, IPPROTO_UDP ) ) \u003c 0 ||\n            setsockopt( bind_ctx-\u003efd, SOL_SOCKET, SO_REUSEADDR,\n                        (const char *) \u0026one, sizeof( one ) ) != 0 )\n        {\n            return( MBEDTLS_ERR_NET_SOCKET_FAILED );\n        }\n\n        if( bind( bind_ctx-\u003efd, (struct sockaddr *) \u0026local_addr, n ) != 0 )\n        {\n            return( MBEDTLS_ERR_NET_BIND_FAILED );\n        }\n    }\n\n    if( client_ip != NULL )\n    {\n        if( client_addr.ss_family == AF_INET )\n        {\n            struct sockaddr_in *addr4 = (struct sockaddr_in *) \u0026client_addr;\n            *ip_len = sizeof( addr4-\u003esin_addr.s_addr );\n\n            if( buf_size \u003c *ip_len )\n                return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );\n\n            memcpy( client_ip, \u0026addr4-\u003esin_addr.s_addr, *ip_len );\n        }\n        else\n        {\n            struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *) \u0026client_addr;\n            *ip_len = sizeof( addr6-\u003esin6_addr.s6_addr );\n\n            if( buf_size \u003c *ip_len )\n                return( MBEDTLS_ERR_NET_BUFFER_TOO_SMALL );\n\n            memcpy( client_ip, \u0026addr6-\u003esin6_addr.s6_addr, *ip_len);\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/net_sockets.c","line_number":306,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"177240":{"score":0.9157376,"function_name":"mbedtls_net_set_nonblock","code":"int mbedtls_net_set_nonblock( mbedtls_net_context *ctx )\n{\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n    u_long n = 1;\n    return( ioctlsocket( ctx-\u003efd, FIONBIO, \u0026n ) );\n#else\n    return( fcntl( ctx-\u003efd, F_SETFL, fcntl( ctx-\u003efd, F_GETFL ) | O_NONBLOCK ) );\n#endif\n}","filepath":"library/net_sockets.c","line_number":435,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"177307":{"score":0.901911,"function_name":"mbedtls_net_poll","code":"int mbedtls_net_poll( mbedtls_net_context *ctx, uint32_t rw, uint32_t timeout )\n{\n    int ret;\n    struct timeval tv;\n\n    fd_set read_fds;\n    fd_set write_fds;\n\n    int fd = ctx-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n#if defined(__has_feature)\n#if __has_feature(memory_sanitizer)\n    /* Ensure that memory sanitizers consider read_fds and write_fds as\n     * initialized even on platforms such as Glibc/x86_64 where FD_ZERO\n     * is implemented in assembly. */\n    memset( \u0026read_fds, 0, sizeof( read_fds ) );\n    memset( \u0026write_fds, 0, sizeof( write_fds ) );\n#endif\n#endif\n\n    FD_ZERO( \u0026read_fds );\n    if( rw \u0026 MBEDTLS_NET_POLL_READ )\n    {\n        rw \u0026= ~MBEDTLS_NET_POLL_READ;\n        FD_SET( fd, \u0026read_fds );\n    }\n\n    FD_ZERO( \u0026write_fds );\n    if( rw \u0026 MBEDTLS_NET_POLL_WRITE )\n    {\n        rw \u0026= ~MBEDTLS_NET_POLL_WRITE;\n        FD_SET( fd, \u0026write_fds );\n    }\n\n    if( rw != 0 )\n        return( MBEDTLS_ERR_NET_BAD_INPUT_DATA );\n\n    tv.tv_sec  = timeout / 1000;\n    tv.tv_usec = ( timeout % 1000 ) * 1000;\n\n    do\n    {\n        ret = select( fd + 1, \u0026read_fds, \u0026write_fds, NULL,\n                      timeout == (uint32_t) -1 ? NULL : \u0026tv );\n    }\n    while( IS_EINTR( ret ) );\n\n    if( ret \u003c 0 )\n        return( MBEDTLS_ERR_NET_POLL_FAILED );\n\n    ret = 0;\n    if( FD_ISSET( fd, \u0026read_fds ) )\n        ret |= MBEDTLS_NET_POLL_READ;\n    if( FD_ISSET( fd, \u0026write_fds ) )\n        ret |= MBEDTLS_NET_POLL_WRITE;\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":450,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178095":{"score":0.89511144,"function_name":"mbedtls_net_recv","code":"int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len )\n{\n    int ret;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    ret = (int) read( fd, buf, len );\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n#else\n        if( errno == EPIPE || errno == ECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#endif\n\n        return( MBEDTLS_ERR_NET_RECV_FAILED );\n    }\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":535,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178253":{"score":0.8664153,"function_name":"mbedtls_net_recv_timeout","code":"int mbedtls_net_recv_timeout( void *ctx, unsigned char *buf,\n                              size_t len, uint32_t timeout )\n{\n    int ret;\n    struct timeval tv;\n    fd_set read_fds;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    FD_ZERO( \u0026read_fds );\n    FD_SET( fd, \u0026read_fds );\n\n    tv.tv_sec  = timeout / 1000;\n    tv.tv_usec = ( timeout % 1000 ) * 1000;\n\n    ret = select( fd + 1, \u0026read_fds, NULL, NULL, timeout == 0 ? NULL : \u0026tv );\n\n    /* Zero fds ready means we timed out */\n    if( ret == 0 )\n        return( MBEDTLS_ERR_SSL_TIMEOUT );\n\n    if( ret \u003c 0 )\n    {\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAEINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#else\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_READ );\n#endif\n\n        return( MBEDTLS_ERR_NET_RECV_FAILED );\n    }\n\n    /* This call will not block */\n    return( mbedtls_net_recv( ctx, buf, len ) );\n}","filepath":"library/net_sockets.c","line_number":571,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178666":{"score":0.8852291,"function_name":"mbedtls_net_send","code":"int mbedtls_net_send( void *ctx, const unsigned char *buf, size_t len )\n{\n    int ret;\n    int fd = ((mbedtls_net_context *) ctx)-\u003efd;\n\n    if( fd \u003c 0 )\n        return( MBEDTLS_ERR_NET_INVALID_CONTEXT );\n\n    ret = (int) write( fd, buf, len );\n\n    if( ret \u003c 0 )\n    {\n        if( net_would_block( ctx ) != 0 )\n            return( MBEDTLS_ERR_SSL_WANT_WRITE );\n\n#if ( defined(_WIN32) || defined(_WIN32_WCE) ) \u0026\u0026 !defined(EFIX64) \u0026\u0026 \\\n    !defined(EFI32)\n        if( WSAGetLastError() == WSAECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n#else\n        if( errno == EPIPE || errno == ECONNRESET )\n            return( MBEDTLS_ERR_NET_CONN_RESET );\n\n        if( errno == EINTR )\n            return( MBEDTLS_ERR_SSL_WANT_WRITE );\n#endif\n\n        return( MBEDTLS_ERR_NET_SEND_FAILED );\n    }\n\n    return( ret );\n}","filepath":"library/net_sockets.c","line_number":615,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"178824":{"score":0.9468817,"function_name":"mbedtls_net_free","code":"void mbedtls_net_free( mbedtls_net_context *ctx )\n{\n    if( ctx-\u003efd == -1 )\n        return;\n\n    shutdown( ctx-\u003efd, 2 );\n    close( ctx-\u003efd );\n\n    ctx-\u003efd = -1;\n}","filepath":"library/net_sockets.c","line_number":651,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.11.0"},"179087":{"score":0.9003952,"function_name":"mbedtls_sha512_starts_ret","code":"int mbedtls_sha512_starts_ret( mbedtls_sha512_context *ctx, int is384 )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    if( is384 == 0 )\n    {\n        /* SHA-512 */\n        ctx-\u003estate[0] = UL64(0x6A09E667F3BCC908);\n        ctx-\u003estate[1] = UL64(0xBB67AE8584CAA73B);\n        ctx-\u003estate[2] = UL64(0x3C6EF372FE94F82B);\n        ctx-\u003estate[3] = UL64(0xA54FF53A5F1D36F1);\n        ctx-\u003estate[4] = UL64(0x510E527FADE682D1);\n        ctx-\u003estate[5] = UL64(0x9B05688C2B3E6C1F);\n        ctx-\u003estate[6] = UL64(0x1F83D9ABFB41BD6B);\n        ctx-\u003estate[7] = UL64(0x5BE0CD19137E2179);\n    }\n    else\n    {\n        /* SHA-384 */\n        ctx-\u003estate[0] = UL64(0xCBBB9D5DC1059ED8);\n        ctx-\u003estate[1] = UL64(0x629A292A367CD507);\n        ctx-\u003estate[2] = UL64(0x9159015A3070DD17);\n        ctx-\u003estate[3] = UL64(0x152FECD8F70E5939);\n        ctx-\u003estate[4] = UL64(0x67332667FFC00B31);\n        ctx-\u003estate[5] = UL64(0x8EB44A8768581511);\n        ctx-\u003estate[6] = UL64(0xDB0C2E0D64F98FA7);\n        ctx-\u003estate[7] = UL64(0x47B5481DBEFA4FA4);\n    }\n\n    ctx-\u003eis384 = is384;\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":117,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"feature-opaque-keys-2.7-rc1"},"179469":{"score":0.8218781,"function_name":"mbedtls_internal_sha512_process","code":"int mbedtls_internal_sha512_process( mbedtls_sha512_context *ctx,\n                                     const unsigned char data[128] )\n{\n    int i;\n    uint64_t temp1, temp2, W[80];\n    uint64_t A, B, C, D, E, F, G, H;\n\n#define  SHR(x,n) (x \u003e\u003e n)\n#define ROTR(x,n) (SHR(x,n) | (x \u003c\u003c (64 - n)))\n\n#define S0(x) (ROTR(x, 1) ^ ROTR(x, 8) ^  SHR(x, 7))\n#define S1(x) (ROTR(x,19) ^ ROTR(x,61) ^  SHR(x, 6))\n\n#define S2(x) (ROTR(x,28) ^ ROTR(x,34) ^ ROTR(x,39))\n#define S3(x) (ROTR(x,14) ^ ROTR(x,18) ^ ROTR(x,41))\n\n#define F0(x,y,z) ((x \u0026 y) | (z \u0026 (x | y)))\n#define F1(x,y,z) (z ^ (x \u0026 (y ^ z)))\n\n#define P(a,b,c,d,e,f,g,h,x,K)                  \\\n{                                               \\\n    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \\\n    temp2 = S2(a) + F0(a,b,c);                  \\\n    d += temp1; h = temp1 + temp2;              \\\n}\n\n    for( i = 0; i \u003c 16; i++ )\n    {\n        GET_UINT64_BE( W[i], data, i \u003c\u003c 3 );\n    }\n\n    for( ; i \u003c 80; i++ )\n    {\n        W[i] = S1(W[i -  2]) + W[i -  7] +\n               S0(W[i - 15]) + W[i - 16];\n    }\n\n    A = ctx-\u003estate[0];\n    B = ctx-\u003estate[1];\n    C = ctx-\u003estate[2];\n    D = ctx-\u003estate[3];\n    E = ctx-\u003estate[4];\n    F = ctx-\u003estate[5];\n    G = ctx-\u003estate[6];\n    H = ctx-\u003estate[7];\n    i = 0;\n\n    do\n    {\n        P( A, B, C, D, E, F, G, H, W[i], K[i] ); i++;\n        P( H, A, B, C, D, E, F, G, W[i], K[i] ); i++;\n        P( G, H, A, B, C, D, E, F, W[i], K[i] ); i++;\n        P( F, G, H, A, B, C, D, E, W[i], K[i] ); i++;\n        P( E, F, G, H, A, B, C, D, W[i], K[i] ); i++;\n        P( D, E, F, G, H, A, B, C, W[i], K[i] ); i++;\n        P( C, D, E, F, G, H, A, B, W[i], K[i] ); i++;\n        P( B, C, D, E, F, G, H, A, W[i], K[i] ); i++;\n    }\n    while( i \u003c 80 );\n\n    ctx-\u003estate[0] += A;\n    ctx-\u003estate[1] += B;\n    ctx-\u003estate[2] += C;\n    ctx-\u003estate[3] += D;\n    ctx-\u003estate[4] += E;\n    ctx-\u003estate[5] += F;\n    ctx-\u003estate[6] += G;\n    ctx-\u003estate[7] += H;\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":209,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"feature-opaque-keys-2.7-rc1"},"186987":{"score":0.8632126,"function_name":"mbedtls_sha512_update_ret","code":"int mbedtls_sha512_update_ret( mbedtls_sha512_context *ctx,\n                               const unsigned char *input,\n                               size_t ilen )\n{\n    int ret;\n    size_t fill;\n    unsigned int left;\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = (unsigned int) (ctx-\u003etotal[0] \u0026 0x7F);\n    fill = 128 - left;\n\n    ctx-\u003etotal[0] += (uint64_t) ilen;\n\n    if( ctx-\u003etotal[0] \u003c (uint64_t) ilen )\n        ctx-\u003etotal[1]++;\n\n    if( left \u0026\u0026 ilen \u003e= fill )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, fill );\n\n        if( ( ret = mbedtls_internal_sha512_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen \u003e= 128 )\n    {\n        if( ( ret = mbedtls_internal_sha512_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 128;\n        ilen  -= 128;\n    }\n\n    if( ilen \u003e 0 )\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, ilen );\n\n    return( 0 );\n}","filepath":"library/sha512.c","line_number":293,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"feature-opaque-keys-2.7-rc1"},"190555":{"score":0.65103555,"function_name":"ssl_check_timer","code":"static int ssl_check_timer( mbedtls_ssl_context *ssl )\n{\n    if( ssl-\u003ef_get_timer == NULL )\n        return( 0 );\n\n    if( ssl-\u003ef_get_timer( ssl-\u003ep_timer ) == 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 3, ( \"timer expired\" ) );\n        return( -1 );\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":88,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"190628":{"score":0.87009525,"function_name":"ssl_session_copy","code":"static int ssl_session_copy( mbedtls_ssl_session *dst, const mbedtls_ssl_session *src )\n{\n    mbedtls_ssl_session_free( dst );\n    memcpy( dst, src, sizeof( mbedtls_ssl_session ) );\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( src-\u003epeer_cert != NULL )\n    {\n        int ret;\n\n        dst-\u003epeer_cert = mbedtls_calloc( 1, sizeof(mbedtls_x509_crt) );\n        if( dst-\u003epeer_cert == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        mbedtls_x509_crt_init( dst-\u003epeer_cert );\n\n        if( ( ret = mbedtls_x509_crt_parse_der( dst-\u003epeer_cert, src-\u003epeer_cert-\u003eraw.p,\n                                        src-\u003epeer_cert-\u003eraw.len ) ) != 0 )\n        {\n            mbedtls_free( dst-\u003epeer_cert );\n            dst-\u003epeer_cert = NULL;\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_X509_CRT_PARSE_C */\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    if( src-\u003eticket != NULL )\n    {\n        dst-\u003eticket = mbedtls_calloc( 1, src-\u003eticket_len );\n        if( dst-\u003eticket == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        memcpy( dst-\u003eticket, src-\u003eticket, src-\u003eticket_len );\n    }\n#endif /* MBEDTLS_SSL_SESSION_TICKETS \u0026\u0026 MBEDTLS_SSL_CLI_C */\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":274,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"190844":{"score":0.8521205,"function_name":"tls_prf_generic","code":"static int tls_prf_generic( mbedtls_md_type_t md_type,\n                            const unsigned char *secret, size_t slen,\n                            const char *label,\n                            const unsigned char *random, size_t rlen,\n                            unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k, md_len;\n    unsigned char tmp[128];\n    unsigned char h_i[MBEDTLS_MD_MAX_SIZE];\n    const mbedtls_md_info_t *md_info;\n    mbedtls_md_context_t md_ctx;\n    int ret;\n\n    mbedtls_md_init( \u0026md_ctx );\n\n    if( ( md_info = mbedtls_md_info_from_type( md_type ) ) == NULL )\n        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n\n    md_len = mbedtls_md_get_size( md_info );\n\n    if( sizeof( tmp ) \u003c md_len + strlen( label ) + rlen )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    nb = strlen( label );\n    memcpy( tmp + md_len, label, nb );\n    memcpy( tmp + md_len + nb, random, rlen );\n    nb += rlen;\n\n    /*\n     * Compute P_\u003chash\u003e(secret, label + random)[0..dlen]\n     */\n    if ( ( ret = mbedtls_md_setup( \u0026md_ctx, md_info, 1 ) ) != 0 )\n        return( ret );\n\n    mbedtls_md_hmac_starts( \u0026md_ctx, secret, slen );\n    mbedtls_md_hmac_update( \u0026md_ctx, tmp + md_len, nb );\n    mbedtls_md_hmac_finish( \u0026md_ctx, tmp );\n\n    for( i = 0; i \u003c dlen; i += md_len )\n    {\n        mbedtls_md_hmac_reset ( \u0026md_ctx );\n        mbedtls_md_hmac_update( \u0026md_ctx, tmp, md_len + nb );\n        mbedtls_md_hmac_finish( \u0026md_ctx, h_i );\n\n        mbedtls_md_hmac_reset ( \u0026md_ctx );\n        mbedtls_md_hmac_update( \u0026md_ctx, tmp, md_len );\n        mbedtls_md_hmac_finish( \u0026md_ctx, tmp );\n\n        k = ( i + md_len \u003e dlen ) ? dlen % md_len : md_len;\n\n        for( j = 0; j \u003c k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n\n    mbedtls_md_free( \u0026md_ctx );\n\n    mbedtls_platform_zeroize( tmp, sizeof( tmp ) );\n    mbedtls_platform_zeroize( h_i, sizeof( h_i ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":493,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"194548":{"score":0.8945347,"function_name":"ssl_read_memory","code":"static void ssl_read_memory( unsigned char *p, size_t len )\n{\n    unsigned char acc = 0;\n    volatile unsigned char force;\n\n    for( ; len != 0; p++, len-- )\n        acc ^= *p;\n\n    force = acc;\n    (void) force;\n}","filepath":"library/ssl_tls.c","line_number":1589,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"198982":{"score":0.6250833,"function_name":"ssl_check_hs_header","code":"static int ssl_check_hs_header( mbedtls_ssl_context const *ssl )\n{\n    uint32_t msg_len, frag_off, frag_len;\n\n    msg_len  = ssl_get_hs_total_len( ssl );\n    frag_off = ssl_get_hs_frag_off( ssl );\n    frag_len = ssl_get_hs_frag_len( ssl );\n\n    if( frag_off \u003e msg_len )\n        return( -1 );\n\n    if( frag_len \u003e msg_len - frag_off )\n        return( -1 );\n\n    if( frag_len + 12 \u003e ssl-\u003ein_msglen )\n        return( -1 );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":3671,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"199090":{"score":0.6577099,"function_name":"mbedtls_ssl_update_handshake_status","code":"void mbedtls_ssl_update_handshake_status( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_handshake_params * const hs = ssl-\u003ehandshake;\n\n    if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER \u0026\u0026 hs != NULL )\n    {\n        ssl-\u003ehandshake-\u003eupdate_checksum( ssl, ssl-\u003ein_msg, ssl-\u003ein_hslen );\n    }\n\n    /* Handshake message is complete, increment counter */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL )\n    {\n        unsigned offset;\n        mbedtls_ssl_hs_buffer *hs_buf;\n\n        /* Increment handshake sequence number */\n        hs-\u003ein_msg_seq++;\n\n        /*\n         * Clear up handshake buffering and reassembly structure.\n         */\n\n        /* Free first entry */\n        ssl_buffering_free_slot( ssl, 0 );\n\n        /* Shift all other entries */\n        for( offset = 0, hs_buf = \u0026hs-\u003ebuffering.hs[0];\n             offset + 1 \u003c MBEDTLS_SSL_MAX_BUFFERED_HS;\n             offset++, hs_buf++ )\n        {\n            *hs_buf = *(hs_buf + 1);\n        }\n\n        /* Create a fresh last entry */\n        memset( hs_buf, 0, sizeof( mbedtls_ssl_hs_buffer ) );\n    }\n#endif\n}","filepath":"library/ssl_tls.c","line_number":3868,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"199923":{"score":0.617464,"function_name":"ssl_consume_current_message","code":"static int ssl_consume_current_message( mbedtls_ssl_context *ssl )\n{\n    /*\n     * Consume last content-layer message and potentially\n     * update in_msglen which keeps track of the contents'\n     * consumption state.\n     *\n     * (1) Handshake messages:\n     *     Remove last handshake message, move content\n     *     and adapt in_msglen.\n     *\n     * (2) Alert messages:\n     *     Consume whole record content, in_msglen = 0.\n     *\n     * (3) Change cipher spec:\n     *     Consume whole record content, in_msglen = 0.\n     *\n     * (4) Application data:\n     *     Don't do anything - the record layer provides\n     *     the application data as a stream transport\n     *     and consumes through mbedtls_ssl_read only.\n     *\n     */\n\n    /* Case (1): Handshake messages */\n    if( ssl-\u003ein_hslen != 0 )\n    {\n        /* Hard assertion to be sure that no application data\n         * is in flight, as corrupting ssl-\u003ein_msglen during\n         * ssl-\u003ein_offt != NULL is fatal. */\n        if( ssl-\u003ein_offt != NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n        }\n\n        /*\n         * Get next Handshake message in the current record\n         */\n\n        /* Notes:\n         * (1) in_hslen is not necessarily the size of the\n         *     current handshake content: If DTLS handshake\n         *     fragmentation is used, that's the fragment\n         *     size instead. Using the total handshake message\n         *     size here is faulty and should be changed at\n         *     some point.\n         * (2) While it doesn't seem to cause problems, one\n         *     has to be very careful not to assume that in_hslen\n         *     is always \u003c= in_msglen in a sensible communication.\n         *     Again, it's wrong for DTLS handshake fragmentation.\n         *     The following check is therefore mandatory, and\n         *     should not be treated as a silently corrected assertion.\n         *     Additionally, ssl-\u003ein_hslen might be arbitrarily out of\n         *     bounds after handling a DTLS message with an unexpected\n         *     sequence number, see mbedtls_ssl_prepare_handshake_record.\n         */\n        if( ssl-\u003ein_hslen \u003c ssl-\u003ein_msglen )\n        {\n            ssl-\u003ein_msglen -= ssl-\u003ein_hslen;\n            memmove( ssl-\u003ein_msg, ssl-\u003ein_msg + ssl-\u003ein_hslen,\n                     ssl-\u003ein_msglen );\n\n            MBEDTLS_SSL_DEBUG_BUF( 4, \"remaining content in record\",\n                                   ssl-\u003ein_msg, ssl-\u003ein_msglen );\n        }\n        else\n        {\n            ssl-\u003ein_msglen = 0;\n        }\n\n        ssl-\u003ein_hslen   = 0;\n    }\n    /* Case (4): Application data */\n    else if( ssl-\u003ein_offt != NULL )\n    {\n        return( 0 );\n    }\n    /* Everything else (CCS \u0026 Alerts) */\n    else\n    {\n        ssl-\u003ein_msglen = 0;\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":4894,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"200358":{"score":0.57782704,"function_name":"mbedtls_ssl_handle_message_type","code":"int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    /*\n     * Handle particular types of records\n     */\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )\n        {\n            return( ret );\n        }\n    }\n\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )\n    {\n        if( ssl-\u003ein_msglen != 1 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid CCS message, len: %d\",\n                           ssl-\u003ein_msglen ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n        if( ssl-\u003ein_msg[0] != 1 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid CCS message, content: %02x\",\n                                        ssl-\u003ein_msg[0] ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n        if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n            ssl-\u003estate != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC    \u0026\u0026\n            ssl-\u003estate != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )\n        {\n            if( ssl-\u003ehandshake == NULL )\n            {\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"dropping ChangeCipherSpec outside handshake\" ) );\n                return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );\n            }\n\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"received out-of-order ChangeCipherSpec - remember\" ) );\n            return( MBEDTLS_ERR_SSL_EARLY_MESSAGE );\n        }\n#endif\n    }\n\n    if( ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_ALERT )\n    {\n        if( ssl-\u003ein_msglen != 2 )\n        {\n            /* Note: Standard allows for more than one 2 byte alert\n               to be packed in a single message, but Mbed TLS doesn't\n               currently support this. */\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"invalid alert message, len: %d\",\n                           ssl-\u003ein_msglen ) );\n            return( MBEDTLS_ERR_SSL_INVALID_RECORD );\n        }\n\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"got an alert message, type: [%d:%d]\",\n                       ssl-\u003ein_msg[0], ssl-\u003ein_msg[1] ) );\n\n        /*\n         * Ignore non-fatal alerts, except close_notify and no_renegotiation\n         */\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"is a fatal alert message (msg %d)\",\n                           ssl-\u003ein_msg[1] ) );\n            return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );\n        }\n\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a close notify message\" ) );\n            return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );\n        }\n\n#if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)\n        if( ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a SSLv3 no renegotiation alert\" ) );\n            /* Will be handled when trying to parse ServerHello */\n            return( 0 );\n        }\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n        if( ssl-\u003eminor_ver == MBEDTLS_SSL_MINOR_VERSION_0 \u0026\u0026\n            ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n            ssl-\u003ein_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING \u0026\u0026\n            ssl-\u003ein_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 2, ( \"is a SSLv3 no_cert\" ) );\n            /* Will be handled in mbedtls_ssl_parse_certificate() */\n            return( 0 );\n        }\n#endif /* MBEDTLS_SSL_PROTO_SSL3 \u0026\u0026 MBEDTLS_SSL_SRV_C */\n\n        /* Silently ignore: fetch new message */\n        return MBEDTLS_ERR_SSL_NON_FATAL;\n    }\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM \u0026\u0026\n        ssl-\u003ehandshake != NULL \u0026\u0026\n        ssl-\u003estate == MBEDTLS_SSL_HANDSHAKE_OVER  )\n    {\n        ssl_handshake_wrapup_free_hs_transform( ssl );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5272,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"200603":{"score":0.74332947,"function_name":"mbedtls_ssl_send_fatal_handshake_failure","code":"int mbedtls_ssl_send_fatal_handshake_failure( mbedtls_ssl_context *ssl )\n{\n    int ret;\n\n    if( ( ret = mbedtls_ssl_send_alert_message( ssl,\n                    MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                    MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5390,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"200658":{"score":0.6754657,"function_name":"mbedtls_ssl_send_alert_message","code":"int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,\n                            unsigned char level,\n                            unsigned char message )\n{\n    int ret;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e send alert message\" ) );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"send alert level=%u message=%u\", level, message ));\n\n    ssl-\u003eout_msgtype = MBEDTLS_SSL_MSG_ALERT;\n    ssl-\u003eout_msglen = 2;\n    ssl-\u003eout_msg[0] = level;\n    ssl-\u003eout_msg[1] = message;\n\n    if( ( ret = mbedtls_ssl_write_record( ssl, SSL_FORCE_FLUSH ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_write_record\", ret );\n        return( ret );\n    }\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= send alert message\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5404,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"201326":{"score":0.58036447,"function_name":"ssl_parse_certificate_chain","code":"static int ssl_parse_certificate_chain( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    size_t i, n;\n    uint8_t alert;\n\n#if defined(MBEDTLS_SSL_SRV_C)\n#if defined(MBEDTLS_SSL_PROTO_SSL3)\n    /*\n     * Check if the client sent an empty certificate\n     */\n    if( ssl-\u003econf-\u003eendpoint  == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ssl-\u003eminor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( ssl-\u003ein_msglen  == 2                        \u0026\u0026\n            ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_ALERT            \u0026\u0026\n            ssl-\u003ein_msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  \u0026\u0026\n            ssl-\u003ein_msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"SSLv3 client has no certificate\" ) );\n\n            /* The client was asked for a certificate but didn't send\n               one. The client should know what's going on, so we\n               don't send an alert. */\n            ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_MISSING;\n            return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_SSL3 */\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl-\u003econf-\u003eendpoint  == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ssl-\u003eminor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )\n    {\n        if( ssl-\u003ein_hslen   == 3 + mbedtls_ssl_hs_hdr_len( ssl ) \u0026\u0026\n            ssl-\u003ein_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    \u0026\u0026\n            ssl-\u003ein_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   \u0026\u0026\n            memcmp( ssl-\u003ein_msg + mbedtls_ssl_hs_hdr_len( ssl ), \"\\0\\0\\0\", 3 ) == 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"TLSv1 client has no certificate\" ) );\n\n            /* The client was asked for a certificate but didn't send\n               one. The client should know what's going on, so we\n               don't send an alert. */\n            ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_MISSING;\n            return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \\\n          MBEDTLS_SSL_PROTO_TLS1_2 */\n#endif /* MBEDTLS_SSL_SRV_C */\n\n    if( ssl-\u003ein_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );\n        return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    if( ssl-\u003ein_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||\n        ssl-\u003ein_hslen \u003c mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    i = mbedtls_ssl_hs_hdr_len( ssl );\n\n    /*\n     * Same message structure as in mbedtls_ssl_write_certificate()\n     */\n    n = ( ssl-\u003ein_msg[i+1] \u003c\u003c 8 ) | ssl-\u003ein_msg[i+2];\n\n    if( ssl-\u003ein_msg[i] != 0 ||\n        ssl-\u003ein_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n    }\n\n    /* In case we tried to reuse a session but it failed */\n    if( ssl-\u003esession_negotiate-\u003epeer_cert != NULL )\n    {\n        mbedtls_x509_crt_free( ssl-\u003esession_negotiate-\u003epeer_cert );\n        mbedtls_free( ssl-\u003esession_negotiate-\u003epeer_cert );\n    }\n\n    if( ( ssl-\u003esession_negotiate-\u003epeer_cert = mbedtls_calloc( 1,\n                    sizeof( mbedtls_x509_crt ) ) ) == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\",\n                       sizeof( mbedtls_x509_crt ) ) );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n    }\n\n    mbedtls_x509_crt_init( ssl-\u003esession_negotiate-\u003epeer_cert );\n\n    i += 3;\n\n    while( i \u003c ssl-\u003ein_hslen )\n    {\n        if ( i + 3 \u003e ssl-\u003ein_hslen ) {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                           MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n        if( ssl-\u003ein_msg[i] != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        n = ( (unsigned int) ssl-\u003ein_msg[i + 1] \u003c\u003c 8 )\n            | (unsigned int) ssl-\u003ein_msg[i + 2];\n        i += 3;\n\n        if( n \u003c 128 || i + n \u003e ssl-\u003ein_hslen )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = mbedtls_x509_crt_parse_der( ssl-\u003esession_negotiate-\u003epeer_cert,\n                                  ssl-\u003ein_msg + i, n );\n        switch( ret )\n        {\n        case 0: /*ok*/\n        case MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND:\n            /* Ignore certificate with an unknown algorithm: maybe a\n               prior certificate was already trusted. */\n            break;\n\n        case MBEDTLS_ERR_X509_ALLOC_FAILED:\n            alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;\n            goto crt_parse_der_failed;\n\n        case MBEDTLS_ERR_X509_UNKNOWN_VERSION:\n            alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            goto crt_parse_der_failed;\n\n        default:\n            alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;\n        crt_parse_der_failed:\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert );\n            MBEDTLS_SSL_DEBUG_RET( 1, \" mbedtls_x509_crt_parse_der\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    MBEDTLS_SSL_DEBUG_CRT( 3, \"peer certificate\", ssl-\u003esession_negotiate-\u003epeer_cert );\n\n    /*\n     * On client, make sure the server cert doesn't change during renego to\n     * avoid \"triple handshake\" attack: https://secure-resumption.com/\n     */\n#if defined(MBEDTLS_SSL_RENEGOTIATION) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT \u0026\u0026\n        ssl-\u003erenego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n    {\n        if( ssl-\u003esession-\u003epeer_cert == NULL )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"new server cert during renegotiation\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        if( ssl-\u003esession-\u003epeer_cert-\u003eraw.len !=\n            ssl-\u003esession_negotiate-\u003epeer_cert-\u003eraw.len ||\n            memcmp( ssl-\u003esession-\u003epeer_cert-\u003eraw.p,\n                    ssl-\u003esession_negotiate-\u003epeer_cert-\u003eraw.p,\n                    ssl-\u003esession-\u003epeer_cert-\u003eraw.len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"server cert changed during renegotiation\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );\n            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n    }\n#endif /* MBEDTLS_SSL_RENEGOTIATION \u0026\u0026 MBEDTLS_SSL_CLI_C */\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":5605,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"202096":{"score":0.6107453,"function_name":"mbedtls_ssl_parse_certificate","code":"int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    const mbedtls_ssl_ciphersuite_t * const ciphersuite_info =\n          ssl-\u003etransform_negotiate-\u003eciphersuite_info;\n#if defined(MBEDTLS_SSL_SRV_C) \u0026\u0026 defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    const int authmode = ssl-\u003ehandshake-\u003esni_authmode != MBEDTLS_SSL_VERIFY_UNSET\n                       ? ssl-\u003ehandshake-\u003esni_authmode\n                       : ssl-\u003econf-\u003eauthmode;\n#else\n    const int authmode = ssl-\u003econf-\u003eauthmode;\n#endif\n    void *rs_ctx = NULL;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e parse certificate\" ) );\n\n    if( ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_SSL_SRV_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        ciphersuite_info-\u003ekey_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER \u0026\u0026\n        authmode == MBEDTLS_SSL_VERIFY_NONE )\n    {\n        ssl-\u003esession_negotiate-\u003everify_result = MBEDTLS_X509_BADCERT_SKIP_VERIFY;\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate\" ) );\n\n        ssl-\u003estate++;\n        return( 0 );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    if( ssl-\u003ehandshake-\u003eecrs_enabled \u0026\u0026\n        ssl-\u003ehandshake-\u003eecrs_state == ssl_ecrs_crt_verify )\n    {\n        goto crt_verify;\n    }\n#endif\n\n    if( ( ret = mbedtls_ssl_read_record( ssl, 1 ) ) != 0 )\n    {\n        /* mbedtls_ssl_read_record may have sent an alert already. We\n           let it decide whether to alert. */\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_read_record\", ret );\n        return( ret );\n    }\n\n    if( ( ret = ssl_parse_certificate_chain( ssl ) ) != 0 )\n    {\n#if defined(MBEDTLS_SSL_SRV_C)\n        if( ret == MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE \u0026\u0026\n            authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )\n        {\n            ret = 0;\n        }\n#endif\n\n        ssl-\u003estate++;\n        return( ret );\n    }\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    if( ssl-\u003ehandshake-\u003eecrs_enabled)\n        ssl-\u003ehandshake-\u003eecrs_state = ssl_ecrs_crt_verify;\n\ncrt_verify:\n    if( ssl-\u003ehandshake-\u003eecrs_enabled)\n        rs_ctx = \u0026ssl-\u003ehandshake-\u003eecrs_ctx;\n#endif\n\n    if( authmode != MBEDTLS_SSL_VERIFY_NONE )\n    {\n        mbedtls_x509_crt *ca_chain;\n        mbedtls_x509_crl *ca_crl;\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n        if( ssl-\u003ehandshake-\u003esni_ca_chain != NULL )\n        {\n            ca_chain = ssl-\u003ehandshake-\u003esni_ca_chain;\n            ca_crl   = ssl-\u003ehandshake-\u003esni_ca_crl;\n        }\n        else\n#endif\n        {\n            ca_chain = ssl-\u003econf-\u003eca_chain;\n            ca_crl   = ssl-\u003econf-\u003eca_crl;\n        }\n\n        /*\n         * Main check: verify certificate\n         */\n        ret = mbedtls_x509_crt_verify_restartable(\n                                ssl-\u003esession_negotiate-\u003epeer_cert,\n                                ca_chain, ca_crl,\n                                ssl-\u003econf-\u003ecert_profile,\n                                ssl-\u003ehostname,\n                               \u0026ssl-\u003esession_negotiate-\u003everify_result,\n                                ssl-\u003econf-\u003ef_vrfy, ssl-\u003econf-\u003ep_vrfy, rs_ctx );\n\n        if( ret != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"x509_verify_cert\", ret );\n        }\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n        if( ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n            return( MBEDTLS_ERR_SSL_CRYPTO_IN_PROGRESS );\n#endif\n\n        /*\n         * Secondary checks: always done, but change 'ret' only if it was 0\n         */\n\n#if defined(MBEDTLS_ECP_C)\n        {\n            const mbedtls_pk_context *pk = \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk;\n\n            /* If certificate uses an EC key, make sure the curve is OK */\n            if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) \u0026\u0026\n                mbedtls_ssl_check_curve( ssl, mbedtls_pk_ec( *pk )-\u003egrp.id ) != 0 )\n            {\n                ssl-\u003esession_negotiate-\u003everify_result |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n                MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate (EC key curve)\" ) );\n                if( ret == 0 )\n                    ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;\n            }\n        }\n#endif /* MBEDTLS_ECP_C */\n\n        if( mbedtls_ssl_check_cert_usage( ssl-\u003esession_negotiate-\u003epeer_cert,\n                                 ciphersuite_info,\n                                 ! ssl-\u003econf-\u003eendpoint,\n                                 \u0026ssl-\u003esession_negotiate-\u003everify_result ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad certificate (usage extensions)\" ) );\n            if( ret == 0 )\n                ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;\n        }\n\n        /* mbedtls_x509_crt_verify_with_profile is supposed to report a\n         * verification failure through MBEDTLS_ERR_X509_CERT_VERIFY_FAILED,\n         * with details encoded in the verification flags. All other kinds\n         * of error codes, including those from the user provided f_vrfy\n         * functions, are treated as fatal and lead to a failure of\n         * ssl_parse_certificate even if verification was optional. */\n        if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL \u0026\u0026\n            ( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||\n              ret == MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE ) )\n        {\n            ret = 0;\n        }\n\n        if( ca_chain == NULL \u0026\u0026 authmode == MBEDTLS_SSL_VERIFY_REQUIRED )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no CA chain\" ) );\n            ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;\n        }\n\n        if( ret != 0 )\n        {\n            uint8_t alert;\n\n            /* The certificate may have been rejected for several reasons.\n               Pick one and send the corresponding alert. Which alert to send\n               may be a subject of debate in some cases. */\n            if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_OTHER )\n                alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_CN_MISMATCH )\n                alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_KEY_USAGE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_EXT_KEY_USAGE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_NS_CERT_TYPE )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_BAD_PK )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_BAD_KEY )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_EXPIRED )\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_REVOKED )\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;\n            else if( ssl-\u003esession_negotiate-\u003everify_result \u0026 MBEDTLS_X509_BADCERT_NOT_TRUSTED )\n                alert = MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA;\n            else\n                alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            alert );\n        }\n\n#if defined(MBEDTLS_DEBUG_C)\n        if( ssl-\u003esession_negotiate-\u003everify_result != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"! Certificate verification flags %x\",\n                                        ssl-\u003esession_negotiate-\u003everify_result ) );\n        }\n        else\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 3, ( \"Certificate verification flags clear\" ) );\n        }\n#endif /* MBEDTLS_DEBUG_C */\n    }\n\n    ssl-\u003estate++;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= parse certificate\" ) );\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":5804,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"205286":{"score":0.7294063,"function_name":"ssl_handshake_params_init","code":"static void ssl_handshake_params_init( mbedtls_ssl_handshake_params *handshake )\n{\n    memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n     mbedtls_md5_init(   \u0026handshake-\u003efin_md5  );\n    mbedtls_sha1_init(   \u0026handshake-\u003efin_sha1 );\n     mbedtls_md5_starts_ret( \u0026handshake-\u003efin_md5  );\n    mbedtls_sha1_starts_ret( \u0026handshake-\u003efin_sha1 );\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_SHA256_C)\n    mbedtls_sha256_init(   \u0026handshake-\u003efin_sha256    );\n    mbedtls_sha256_starts_ret( \u0026handshake-\u003efin_sha256, 0 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n    mbedtls_sha512_init(   \u0026handshake-\u003efin_sha512    );\n    mbedtls_sha512_starts_ret( \u0026handshake-\u003efin_sha512, 1 );\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n    handshake-\u003eupdate_checksum = ssl_update_checksum_start;\n\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2) \u0026\u0026 \\\n    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)\n    mbedtls_ssl_sig_hash_set_init( \u0026handshake-\u003ehash_algs );\n#endif\n\n#if defined(MBEDTLS_DHM_C)\n    mbedtls_dhm_init( \u0026handshake-\u003edhm_ctx );\n#endif\n#if defined(MBEDTLS_ECDH_C)\n    mbedtls_ecdh_init( \u0026handshake-\u003eecdh_ctx );\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    mbedtls_ecjpake_init( \u0026handshake-\u003eecjpake_ctx );\n#if defined(MBEDTLS_SSL_CLI_C)\n    handshake-\u003eecjpake_cache = NULL;\n    handshake-\u003eecjpake_cache_len = 0;\n#endif\n#endif\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    mbedtls_x509_crt_restart_init( \u0026handshake-\u003eecrs_ctx );\n#endif\n\n#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    handshake-\u003esni_authmode = MBEDTLS_SSL_VERIFY_UNSET;\n#endif\n}","filepath":"library/ssl_tls.c","line_number":6760,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"205476":{"score":0.8307788,"function_name":"ssl_transform_init","code":"static void ssl_transform_init( mbedtls_ssl_transform *transform )\n{\n    memset( transform, 0, sizeof(mbedtls_ssl_transform) );\n\n    mbedtls_cipher_init( \u0026transform-\u003ecipher_ctx_enc );\n    mbedtls_cipher_init( \u0026transform-\u003ecipher_ctx_dec );\n\n    mbedtls_md_init( \u0026transform-\u003emd_ctx_enc );\n    mbedtls_md_init( \u0026transform-\u003emd_ctx_dec );\n}","filepath":"library/ssl_tls.c","line_number":6812,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"206178":{"score":0.82327425,"function_name":"ssl_update_in_pointers","code":"static void ssl_update_in_pointers( mbedtls_ssl_context *ssl,\n                                    mbedtls_ssl_transform *transform )\n{\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003ein_ctr = ssl-\u003ein_hdr +  3;\n        ssl-\u003ein_len = ssl-\u003ein_hdr + 11;\n        ssl-\u003ein_iv  = ssl-\u003ein_hdr + 13;\n    }\n    else\n#endif\n    {\n        ssl-\u003ein_ctr = ssl-\u003ein_hdr - 8;\n        ssl-\u003ein_len = ssl-\u003ein_hdr + 3;\n        ssl-\u003ein_iv  = ssl-\u003ein_hdr + 5;\n    }\n\n    /* Offset in_msg from in_iv to allow space for explicit IV, if used. */\n    if( transform != NULL \u0026\u0026\n        ssl-\u003eminor_ver \u003e= MBEDTLS_SSL_MINOR_VERSION_2 )\n    {\n        ssl-\u003ein_msg = ssl-\u003ein_iv + transform-\u003eivlen - transform-\u003efixed_ivlen;\n    }\n    else\n        ssl-\u003ein_msg = ssl-\u003ein_iv;\n}","filepath":"library/ssl_tls.c","line_number":6970,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"206346":{"score":0.63766545,"function_name":"ssl_reset_in_out_pointers","code":"static void ssl_reset_in_out_pointers( mbedtls_ssl_context *ssl )\n{\n    /* Set the incoming and outgoing record pointers. */\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        ssl-\u003eout_hdr = ssl-\u003eout_buf;\n        ssl-\u003ein_hdr  = ssl-\u003ein_buf;\n    }\n    else\n#endif /* MBEDTLS_SSL_PROTO_DTLS */\n    {\n        ssl-\u003eout_hdr = ssl-\u003eout_buf + 8;\n        ssl-\u003ein_hdr  = ssl-\u003ein_buf  + 8;\n    }\n\n    /* Derive other internal pointers. */\n    ssl_update_out_pointers( ssl, NULL /* no transform enabled */ );\n    ssl_update_in_pointers ( ssl, NULL /* no transform enabled */ );\n}","filepath":"library/ssl_tls.c","line_number":7010,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"206424":{"score":0.87536347,"function_name":"mbedtls_ssl_setup","code":"int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,\n                       const mbedtls_ssl_config *conf )\n{\n    int ret;\n\n    ssl-\u003econf = conf;\n\n    /*\n     * Prepare base structures\n     */\n\n    /* Set to NULL in case of an error condition */\n    ssl-\u003eout_buf = NULL;\n\n    ssl-\u003ein_buf = mbedtls_calloc( 1, MBEDTLS_SSL_IN_BUFFER_LEN );\n    if( ssl-\u003ein_buf == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\", MBEDTLS_SSL_IN_BUFFER_LEN) );\n        ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;\n        goto error;\n    }\n\n    ssl-\u003eout_buf = mbedtls_calloc( 1, MBEDTLS_SSL_OUT_BUFFER_LEN );\n    if( ssl-\u003eout_buf == NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"alloc(%d bytes) failed\", MBEDTLS_SSL_OUT_BUFFER_LEN) );\n        ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;\n        goto error;\n    }\n\n    ssl_reset_in_out_pointers( ssl );\n\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        goto error;\n\n    return( 0 );\n\nerror:\n    mbedtls_free( ssl-\u003ein_buf );\n    mbedtls_free( ssl-\u003eout_buf );\n\n    ssl-\u003econf = NULL;\n\n    ssl-\u003ein_buf = NULL;\n    ssl-\u003eout_buf = NULL;\n\n    ssl-\u003ein_hdr = NULL;\n    ssl-\u003ein_ctr = NULL;\n    ssl-\u003ein_len = NULL;\n    ssl-\u003ein_iv = NULL;\n    ssl-\u003ein_msg = NULL;\n\n    ssl-\u003eout_hdr = NULL;\n    ssl-\u003eout_ctr = NULL;\n    ssl-\u003eout_len = NULL;\n    ssl-\u003eout_iv = NULL;\n    ssl-\u003eout_msg = NULL;\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":7031,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"207596":{"score":0.8459462,"function_name":"mbedtls_ssl_set_timer_cb","code":"void mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,\n                               void *p_timer,\n                               mbedtls_ssl_set_timer_t *f_set_timer,\n                               mbedtls_ssl_get_timer_t *f_get_timer )\n{\n    ssl-\u003ep_timer        = p_timer;\n    ssl-\u003ef_set_timer    = f_set_timer;\n    ssl-\u003ef_get_timer    = f_get_timer;\n\n    /* Make sure we start with no timer running */\n    ssl_set_timer( ssl, 0 );\n}","filepath":"library/ssl_tls.c","line_number":7321,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"207658":{"score":0.8804012,"function_name":"mbedtls_ssl_set_session","code":"int mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session )\n{\n    int ret;\n\n    if( ssl == NULL ||\n        session == NULL ||\n        ssl-\u003esession_negotiate == NULL ||\n        ssl-\u003econf-\u003eendpoint != MBEDTLS_SSL_IS_CLIENT )\n    {\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    if( ( ret = ssl_session_copy( ssl-\u003esession_negotiate, session ) ) != 0 )\n        return( ret );\n\n    ssl-\u003ehandshake-\u003eresume = 1;\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":7347,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"207777":{"score":0.7224325,"function_name":"mbedtls_ssl_conf_ciphersuites","code":"void mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,\n                                   const int *ciphersuites )\n{\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] = ciphersuites;\n    conf-\u003eciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] = ciphersuites;\n}","filepath":"library/ssl_tls.c","line_number":7368,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"207828":{"score":0.7436093,"function_name":"mbedtls_ssl_conf_ciphersuites_for_version","code":"void mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,\n                                       const int *ciphersuites,\n                                       int major, int minor )\n{\n    if( major != MBEDTLS_SSL_MAJOR_VERSION_3 )\n        return;\n\n    if( minor \u003c MBEDTLS_SSL_MINOR_VERSION_0 || minor \u003e MBEDTLS_SSL_MINOR_VERSION_3 )\n        return;\n\n    conf-\u003eciphersuite_list[minor] = ciphersuites;\n}","filepath":"library/ssl_tls.c","line_number":7377,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"207904":{"score":0.90110314,"function_name":"ssl_append_key_cert","code":"static int ssl_append_key_cert( mbedtls_ssl_key_cert **head,\n                                mbedtls_x509_crt *cert,\n                                mbedtls_pk_context *key )\n{\n    mbedtls_ssl_key_cert *new_cert;\n\n    new_cert = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );\n    if( new_cert == NULL )\n        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n    new_cert-\u003ecert = cert;\n    new_cert-\u003ekey  = key;\n    new_cert-\u003enext = NULL;\n\n    /* Update head is the list was null, else add to the end */\n    if( *head == NULL )\n    {\n        *head = new_cert;\n    }\n    else\n    {\n        mbedtls_ssl_key_cert *cur = *head;\n        while( cur-\u003enext != NULL )\n            cur = cur-\u003enext;\n        cur-\u003enext = new_cert;\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":7398,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"208298":{"score":0.93122536,"function_name":"mbedtls_ssl_set_hostname","code":"int mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname )\n{\n    /* Initialize to suppress unnecessary compiler warning */\n    size_t hostname_len = 0;\n\n    /* Check if new hostname is valid before\n     * making any change to current one */\n    if( hostname != NULL )\n    {\n        hostname_len = strlen( hostname );\n\n        if( hostname_len \u003e MBEDTLS_SSL_MAX_HOST_NAME_LEN )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /* Now it's clear that we will overwrite the old hostname,\n     * so we can free it safely */\n\n    if( ssl-\u003ehostname != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ehostname, strlen( ssl-\u003ehostname ) );\n        mbedtls_free( ssl-\u003ehostname );\n    }\n\n    /* Passing NULL as hostname shall clear the old one */\n\n    if( hostname == NULL )\n    {\n        ssl-\u003ehostname = NULL;\n    }\n    else\n    {\n        ssl-\u003ehostname = mbedtls_calloc( 1, hostname_len + 1 );\n        if( ssl-\u003ehostname == NULL )\n            return( MBEDTLS_ERR_SSL_ALLOC_FAILED );\n\n        memcpy( ssl-\u003ehostname, hostname, hostname_len );\n\n        ssl-\u003ehostname[hostname_len] = '\\0';\n    }\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":7750,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"208911":{"score":0.89708704,"function_name":"mbedtls_ssl_get_verify_result","code":"uint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl )\n{\n    if( ssl-\u003esession != NULL )\n        return( ssl-\u003esession-\u003everify_result );\n\n    if( ssl-\u003esession_negotiate != NULL )\n        return( ssl-\u003esession_negotiate-\u003everify_result );\n\n    return( 0xFFFFFFFF );\n}","filepath":"library/ssl_tls.c","line_number":8069,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"209041":{"score":0.86769575,"function_name":"mbedtls_ssl_get_version","code":"const char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl )\n{\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl-\u003econf-\u003etransport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )\n    {\n        switch( ssl-\u003eminor_ver )\n        {\n            case MBEDTLS_SSL_MINOR_VERSION_2:\n                return( \"DTLSv1.0\" );\n\n            case MBEDTLS_SSL_MINOR_VERSION_3:\n                return( \"DTLSv1.2\" );\n\n            default:\n                return( \"unknown (DTLS)\" );\n        }\n    }\n#endif\n\n    switch( ssl-\u003eminor_ver )\n    {\n        case MBEDTLS_SSL_MINOR_VERSION_0:\n            return( \"SSLv3.0\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_1:\n            return( \"TLSv1.0\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_2:\n            return( \"TLSv1.1\" );\n\n        case MBEDTLS_SSL_MINOR_VERSION_3:\n            return( \"TLSv1.2\" );\n\n        default:\n            return( \"unknown\" );\n    }\n}","filepath":"library/ssl_tls.c","line_number":8088,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"209128":{"score":0.8013146,"function_name":"mbedtls_ssl_get_record_expansion","code":"int mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl )\n{\n    size_t transform_expansion = 0;\n    const mbedtls_ssl_transform *transform = ssl-\u003etransform_out;\n    unsigned block_size;\n\n    if( transform == NULL )\n        return( (int) mbedtls_ssl_hdr_len( ssl ) );\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    if( ssl-\u003esession_out-\u003ecompression != MBEDTLS_SSL_COMPRESS_NULL )\n        return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );\n#endif\n\n    switch( mbedtls_cipher_get_cipher_mode( \u0026transform-\u003ecipher_ctx_enc ) )\n    {\n        case MBEDTLS_MODE_GCM:\n        case MBEDTLS_MODE_CCM:\n        case MBEDTLS_MODE_CHACHAPOLY:\n        case MBEDTLS_MODE_STREAM:\n            transform_expansion = transform-\u003eminlen;\n            break;\n\n        case MBEDTLS_MODE_CBC:\n\n            block_size = mbedtls_cipher_get_block_size(\n                \u0026transform-\u003ecipher_ctx_enc );\n\n            /* Expansion due to the addition of the MAC. */\n            transform_expansion += transform-\u003emaclen;\n\n            /* Expansion due to the addition of CBC padding;\n             * Theoretically up to 256 bytes, but we never use\n             * more than the block size of the underlying cipher. */\n            transform_expansion += block_size;\n\n            /* For TLS 1.1 or higher, an explicit IV is added\n             * after the record header. */\n#if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)\n            if( ssl-\u003eminor_ver \u003e= MBEDTLS_SSL_MINOR_VERSION_2 )\n                transform_expansion += block_size;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */\n\n            break;\n\n        default:\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"should never happen\" ) );\n            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );\n    }\n\n    return( (int)( mbedtls_ssl_hdr_len( ssl ) + transform_expansion ) );\n}","filepath":"library/ssl_tls.c","line_number":8126,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"209382":{"score":0.82596505,"function_name":"mbedtls_ssl_get_session","code":"int mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst )\n{\n    if( ssl == NULL ||\n        dst == NULL ||\n        ssl-\u003esession == NULL ||\n        ssl-\u003econf-\u003eendpoint != MBEDTLS_SSL_IS_CLIENT )\n    {\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    return( ssl_session_copy( dst, ssl-\u003esession ) );\n}","filepath":"library/ssl_tls.c","line_number":8283,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"209466":{"score":0.7244241,"function_name":"mbedtls_ssl_handshake_step","code":"int mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_SSL_CLI_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_CLIENT )\n        ret = mbedtls_ssl_handshake_client_step( ssl );\n#endif\n#if defined(MBEDTLS_SSL_SRV_C)\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER )\n        ret = mbedtls_ssl_handshake_server_step( ssl );\n#endif\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":8300,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"209555":{"score":0.62675107,"function_name":"mbedtls_ssl_handshake","code":"int mbedtls_ssl_handshake( mbedtls_ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e handshake\" ) );\n\n    while( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER )\n    {\n        ret = mbedtls_ssl_handshake_step( ssl );\n\n        if( ret != 0 )\n            break;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= handshake\" ) );\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":8322,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"210578":{"score":0.6656367,"function_name":"mbedtls_ssl_renegotiate","code":"int mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n\n    if( ssl == NULL || ssl-\u003econf == NULL )\n        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_SSL_SRV_C)\n    /* On server, just send the request */\n    if( ssl-\u003econf-\u003eendpoint == MBEDTLS_SSL_IS_SERVER )\n    {\n        if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n        ssl-\u003erenego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;\n\n        /* Did we already try/start sending HelloRequest? */\n        if( ssl-\u003eout_left != 0 )\n            return( mbedtls_ssl_flush_output( ssl ) );\n\n        return( ssl_write_hello_request( ssl ) );\n    }\n#endif /* MBEDTLS_SSL_SRV_C */\n\n#if defined(MBEDTLS_SSL_CLI_C)\n    /*\n     * On client, either start the renegotiation process or,\n     * if already in progress, continue the handshake\n     */\n    if( ssl-\u003erenego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )\n    {\n        if( ssl-\u003estate != MBEDTLS_SSL_HANDSHAKE_OVER )\n            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );\n\n        if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"ssl_start_renegotiation\", ret );\n            return( ret );\n        }\n    }\n    else\n    {\n        if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_ssl_handshake\", ret );\n            return( ret );\n        }\n    }\n#endif /* MBEDTLS_SSL_CLI_C */\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":8420,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"210695":{"score":0.7960899,"function_name":"mbedtls_ssl_transform_free","code":"void mbedtls_ssl_transform_free( mbedtls_ssl_transform *transform )\n{\n    if( transform == NULL )\n        return;\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    deflateEnd( \u0026transform-\u003ectx_deflate );\n    inflateEnd( \u0026transform-\u003ectx_inflate );\n#endif\n\n    mbedtls_cipher_free( \u0026transform-\u003ecipher_ctx_enc );\n    mbedtls_cipher_free( \u0026transform-\u003ecipher_ctx_dec );\n\n    mbedtls_md_free( \u0026transform-\u003emd_ctx_enc );\n    mbedtls_md_free( \u0026transform-\u003emd_ctx_dec );\n\n    mbedtls_platform_zeroize( transform, sizeof( mbedtls_ssl_transform ) );\n}","filepath":"library/ssl_tls.c","line_number":8991,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"210820":{"score":0.7738155,"function_name":"ssl_key_cert_free","code":"static void ssl_key_cert_free( mbedtls_ssl_key_cert *key_cert )\n{\n    mbedtls_ssl_key_cert *cur = key_cert, *next;\n\n    while( cur != NULL )\n    {\n        next = cur-\u003enext;\n        mbedtls_free( cur );\n        cur = next;\n    }\n}","filepath":"library/ssl_tls.c","line_number":9011,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"210887":{"score":0.7165979,"function_name":"mbedtls_ssl_handshake_free","code":"void mbedtls_ssl_handshake_free( mbedtls_ssl_context *ssl )\n{\n    mbedtls_ssl_handshake_params *handshake = ssl-\u003ehandshake;\n\n    if( handshake == NULL )\n        return;\n\n#if defined(MBEDTLS_SSL_ASYNC_PRIVATE)\n    if( ssl-\u003econf-\u003ef_async_cancel != NULL \u0026\u0026 handshake-\u003easync_in_progress != 0 )\n    {\n        ssl-\u003econf-\u003ef_async_cancel( ssl );\n        handshake-\u003easync_in_progress = 0;\n    }\n#endif /* MBEDTLS_SSL_ASYNC_PRIVATE */\n\n#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \\\n    defined(MBEDTLS_SSL_PROTO_TLS1_1)\n    mbedtls_md5_free(    \u0026handshake-\u003efin_md5  );\n    mbedtls_sha1_free(   \u0026handshake-\u003efin_sha1 );\n#endif\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n#if defined(MBEDTLS_SHA256_C)\n    mbedtls_sha256_free(   \u0026handshake-\u003efin_sha256    );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n    mbedtls_sha512_free(   \u0026handshake-\u003efin_sha512    );\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n\n#if defined(MBEDTLS_DHM_C)\n    mbedtls_dhm_free( \u0026handshake-\u003edhm_ctx );\n#endif\n#if defined(MBEDTLS_ECDH_C)\n    mbedtls_ecdh_free( \u0026handshake-\u003eecdh_ctx );\n#endif\n#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    mbedtls_ecjpake_free( \u0026handshake-\u003eecjpake_ctx );\n#if defined(MBEDTLS_SSL_CLI_C)\n    mbedtls_free( handshake-\u003eecjpake_cache );\n    handshake-\u003eecjpake_cache = NULL;\n    handshake-\u003eecjpake_cache_len = 0;\n#endif\n#endif\n\n#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \\\n    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)\n    /* explicit void pointer cast for buggy MS compiler */\n    mbedtls_free( (void *) handshake-\u003ecurves );\n#endif\n\n#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)\n    if( handshake-\u003epsk != NULL )\n    {\n        mbedtls_platform_zeroize( handshake-\u003epsk, handshake-\u003epsk_len );\n        mbedtls_free( handshake-\u003epsk );\n    }\n#endif\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C) \u0026\u0026 \\\n    defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)\n    /*\n     * Free only the linked list wrapper, not the keys themselves\n     * since the belong to the SNI callback\n     */\n    if( handshake-\u003esni_key_cert != NULL )\n    {\n        mbedtls_ssl_key_cert *cur = handshake-\u003esni_key_cert, *next;\n\n        while( cur != NULL )\n        {\n            next = cur-\u003enext;\n            mbedtls_free( cur );\n            cur = next;\n        }\n    }\n#endif /* MBEDTLS_X509_CRT_PARSE_C \u0026\u0026 MBEDTLS_SSL_SERVER_NAME_INDICATION */\n\n#if defined(MBEDTLS_SSL__ECP_RESTARTABLE)\n    mbedtls_x509_crt_restart_free( \u0026handshake-\u003eecrs_ctx );\n#endif\n\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    mbedtls_free( handshake-\u003everify_cookie );\n    ssl_flight_free( handshake-\u003eflight );\n    ssl_buffering_free( ssl );\n#endif\n\n    mbedtls_platform_zeroize( handshake,\n                              sizeof( mbedtls_ssl_handshake_params ) );\n}","filepath":"library/ssl_tls.c","line_number":9060,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"211092":{"score":0.7965993,"function_name":"mbedtls_ssl_session_free","code":"void mbedtls_ssl_session_free( mbedtls_ssl_session *session )\n{\n    if( session == NULL )\n        return;\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( session-\u003epeer_cert != NULL )\n    {\n        mbedtls_x509_crt_free( session-\u003epeer_cert );\n        mbedtls_free( session-\u003epeer_cert );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_SESSION_TICKETS) \u0026\u0026 defined(MBEDTLS_SSL_CLI_C)\n    mbedtls_free( session-\u003eticket );\n#endif\n\n    mbedtls_platform_zeroize( session, sizeof( mbedtls_ssl_session ) );\n}","filepath":"library/ssl_tls.c","line_number":9151,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"211186":{"score":0.70668244,"function_name":"mbedtls_ssl_free","code":"void mbedtls_ssl_free( mbedtls_ssl_context *ssl )\n{\n    if( ssl == NULL )\n        return;\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=\u003e free\" ) );\n\n    if( ssl-\u003eout_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003eout_buf, MBEDTLS_SSL_OUT_BUFFER_LEN );\n        mbedtls_free( ssl-\u003eout_buf );\n    }\n\n    if( ssl-\u003ein_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ein_buf, MBEDTLS_SSL_IN_BUFFER_LEN );\n        mbedtls_free( ssl-\u003ein_buf );\n    }\n\n#if defined(MBEDTLS_ZLIB_SUPPORT)\n    if( ssl-\u003ecompress_buf != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ecompress_buf, MBEDTLS_SSL_COMPRESS_BUFFER_LEN );\n        mbedtls_free( ssl-\u003ecompress_buf );\n    }\n#endif\n\n    if( ssl-\u003etransform )\n    {\n        mbedtls_ssl_transform_free( ssl-\u003etransform );\n        mbedtls_free( ssl-\u003etransform );\n    }\n\n    if( ssl-\u003ehandshake )\n    {\n        mbedtls_ssl_handshake_free( ssl );\n        mbedtls_ssl_transform_free( ssl-\u003etransform_negotiate );\n        mbedtls_ssl_session_free( ssl-\u003esession_negotiate );\n\n        mbedtls_free( ssl-\u003ehandshake );\n        mbedtls_free( ssl-\u003etransform_negotiate );\n        mbedtls_free( ssl-\u003esession_negotiate );\n    }\n\n    if( ssl-\u003esession )\n    {\n        mbedtls_ssl_session_free( ssl-\u003esession );\n        mbedtls_free( ssl-\u003esession );\n    }\n\n#if defined(MBEDTLS_X509_CRT_PARSE_C)\n    if( ssl-\u003ehostname != NULL )\n    {\n        mbedtls_platform_zeroize( ssl-\u003ehostname, strlen( ssl-\u003ehostname ) );\n        mbedtls_free( ssl-\u003ehostname );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)\n    if( mbedtls_ssl_hw_record_finish != NULL )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 2, ( \"going for mbedtls_ssl_hw_record_finish()\" ) );\n        mbedtls_ssl_hw_record_finish( ssl );\n    }\n#endif\n\n#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) \u0026\u0026 defined(MBEDTLS_SSL_SRV_C)\n    mbedtls_free( ssl-\u003ecli_id );\n#endif\n\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"\u003c= free\" ) );\n\n    /* Actually clear after last debug message */\n    mbedtls_platform_zeroize( ssl, sizeof( mbedtls_ssl_context ) );\n}","filepath":"library/ssl_tls.c","line_number":9174,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212119":{"score":0.80770475,"function_name":"mbedtls_ssl_sig_from_pk_alg","code":"unsigned char mbedtls_ssl_sig_from_pk_alg( mbedtls_pk_type_t type )\n{\n    switch( type ) {\n        case MBEDTLS_PK_RSA:\n            return( MBEDTLS_SSL_SIG_RSA );\n        case MBEDTLS_PK_ECDSA:\n        case MBEDTLS_PK_ECKEY:\n            return( MBEDTLS_SSL_SIG_ECDSA );\n        default:\n            return( MBEDTLS_SSL_SIG_ANON );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9514,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212216":{"score":0.810992,"function_name":"mbedtls_ssl_sig_hash_set_find","code":"mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find( mbedtls_ssl_sig_hash_set_t *set,\n                                                 mbedtls_pk_type_t sig_alg )\n{\n    switch( sig_alg )\n    {\n        case MBEDTLS_PK_RSA:\n            return( set-\u003ersa );\n        case MBEDTLS_PK_ECDSA:\n            return( set-\u003eecdsa );\n        default:\n            return( MBEDTLS_MD_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9549,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212266":{"score":0.9019961,"function_name":"mbedtls_ssl_sig_hash_set_add","code":"void mbedtls_ssl_sig_hash_set_add( mbedtls_ssl_sig_hash_set_t *set,\n                                   mbedtls_pk_type_t sig_alg,\n                                   mbedtls_md_type_t md_alg )\n{\n    switch( sig_alg )\n    {\n        case MBEDTLS_PK_RSA:\n            if( set-\u003ersa == MBEDTLS_MD_NONE )\n                set-\u003ersa = md_alg;\n            break;\n\n        case MBEDTLS_PK_ECDSA:\n            if( set-\u003eecdsa == MBEDTLS_MD_NONE )\n                set-\u003eecdsa = md_alg;\n            break;\n\n        default:\n            break;\n    }\n}","filepath":"library/ssl_tls.c","line_number":9564,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212374":{"score":0.7873869,"function_name":"mbedtls_ssl_md_alg_from_hash","code":"mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash( unsigned char hash )\n{\n    switch( hash )\n    {\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_SSL_HASH_MD5:\n            return( MBEDTLS_MD_MD5 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_SSL_HASH_SHA1:\n            return( MBEDTLS_MD_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_SSL_HASH_SHA224:\n            return( MBEDTLS_MD_SHA224 );\n        case MBEDTLS_SSL_HASH_SHA256:\n            return( MBEDTLS_MD_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_SSL_HASH_SHA384:\n            return( MBEDTLS_MD_SHA384 );\n        case MBEDTLS_SSL_HASH_SHA512:\n            return( MBEDTLS_MD_SHA512 );\n#endif\n        default:\n            return( MBEDTLS_MD_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9599,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212461":{"score":0.73993754,"function_name":"mbedtls_ssl_hash_from_md_alg","code":"unsigned char mbedtls_ssl_hash_from_md_alg( int md )\n{\n    switch( md )\n    {\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_MD_MD5:\n            return( MBEDTLS_SSL_HASH_MD5 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_MD_SHA1:\n            return( MBEDTLS_SSL_HASH_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_MD_SHA224:\n            return( MBEDTLS_SSL_HASH_SHA224 );\n        case MBEDTLS_MD_SHA256:\n            return( MBEDTLS_SSL_HASH_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_MD_SHA384:\n            return( MBEDTLS_SSL_HASH_SHA384 );\n        case MBEDTLS_MD_SHA512:\n            return( MBEDTLS_SSL_HASH_SHA512 );\n#endif\n        default:\n            return( MBEDTLS_SSL_HASH_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9631,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212541":{"score":0.9092805,"function_name":"mbedtls_ssl_check_curve","code":"int mbedtls_ssl_check_curve( const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id )\n{\n    const mbedtls_ecp_group_id *gid;\n\n    if( ssl-\u003econf-\u003ecurve_list == NULL )\n        return( -1 );\n\n    for( gid = ssl-\u003econf-\u003ecurve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )\n        if( *gid == grp_id )\n            return( 0 );\n\n    return( -1 );\n}","filepath":"library/ssl_tls.c","line_number":9665,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212825":{"score":0.86029303,"function_name":"mbedtls_ssl_set_calc_verify_md","code":"int mbedtls_ssl_set_calc_verify_md( mbedtls_ssl_context *ssl, int md )\n{\n#if defined(MBEDTLS_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )\n        return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n\n    switch( md )\n    {\n#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)\n#if defined(MBEDTLS_MD5_C)\n        case MBEDTLS_SSL_HASH_MD5:\n            return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n#endif\n#if defined(MBEDTLS_SHA1_C)\n        case MBEDTLS_SSL_HASH_SHA1:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls;\n            break;\n#endif\n#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */\n#if defined(MBEDTLS_SHA512_C)\n        case MBEDTLS_SSL_HASH_SHA384:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls_sha384;\n            break;\n#endif\n#if defined(MBEDTLS_SHA256_C)\n        case MBEDTLS_SSL_HASH_SHA256:\n            ssl-\u003ehandshake-\u003ecalc_verify = ssl_calc_verify_tls_sha256;\n            break;\n#endif\n        default:\n            return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n    }\n\n    return 0;\n#else /* !MBEDTLS_SSL_PROTO_TLS1_2 */\n    (void) ssl;\n    (void) md;\n\n    return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;\n#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */\n}","filepath":"library/ssl_tls.c","line_number":9845,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"212923":{"score":0.62485665,"function_name":"mbedtls_ssl_get_key_exchange_md_tls1_2","code":"int mbedtls_ssl_get_key_exchange_md_tls1_2( mbedtls_ssl_context *ssl,\n                                            unsigned char *hash, size_t *hashlen,\n                                            unsigned char *data, size_t data_len,\n                                            mbedtls_md_type_t md_alg )\n{\n    int ret = 0;\n    mbedtls_md_context_t ctx;\n    const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );\n    *hashlen = mbedtls_md_get_size( md_info );\n\n    mbedtls_md_init( \u0026ctx );\n\n    /*\n     * digitally-signed struct {\n     *     opaque client_random[32];\n     *     opaque server_random[32];\n     *     ServerDHParams params;\n     * };\n     */\n    if( ( ret = mbedtls_md_setup( \u0026ctx, md_info, 0 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_setup\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_starts( \u0026ctx ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_starts\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_update( \u0026ctx, ssl-\u003ehandshake-\u003erandbytes, 64 ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_update\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_update( \u0026ctx, data, data_len ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_update\", ret );\n        goto exit;\n    }\n    if( ( ret = mbedtls_md_finish( \u0026ctx, hash ) ) != 0 )\n    {\n        MBEDTLS_SSL_DEBUG_RET( 1, \"mbedtls_md_finish\", ret );\n        goto exit;\n    }\n\nexit:\n    mbedtls_md_free( \u0026ctx );\n\n    if( ret != 0 )\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );\n\n    return( ret );\n}","filepath":"library/ssl_tls.c","line_number":9975,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"213277":{"score":0.55615824,"function_name":"ssl_bitmask_check","code":"static int ssl_bitmask_check( unsigned char *mask, size_t len )\n{\n    size_t i;\n\n    for( i = 0; i \u003c len / 8; i++ )\n        if( mask[i] != 0xFF )\n            return( -1 );\n\n    for( i = 0; i \u003c len % 8; i++ )\n        if( ( mask[len / 8] \u0026 ( 1 \u003c\u003c ( 7 - i ) ) ) == 0 )\n            return( -1 );\n\n    return( 0 );\n}","filepath":"library/ssl_tls.c","line_number":3737,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"229001":{"score":0.88977945,"function_name":"iot_command_send","code":"iot_error_t iot_command_send(struct iot_context *ctx,\n\tenum iot_command_type new_cmd, const void *param, int param_size)\n{\n\tstruct iot_command cmd_data;\n\tint ret;\n\tiot_error_t err;\n\n\tif (param \u0026\u0026 (param_size \u003e 0)) {\n\t\tcmd_data.param = malloc(param_size);\n\t\tif (!cmd_data.param) {\n\t\t\tIOT_ERROR(\"failed to malloc for iot_command param\");\n\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\n\t\tmemcpy(cmd_data.param, param, param_size);\n\t} else {\n\t\tcmd_data.param = NULL;\n\t}\n\n\tcmd_data.cmd_type = new_cmd;\n\n\tret = iot_os_queue_send(ctx-\u003ecmd_queue, \u0026cmd_data, 0);\n\tif (ret != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"Cannot put the cmd into cmd_queue\");\n\t\tif (cmd_data.param)\n\t\t\tfree(cmd_data.param);\n\t\terr = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\t_set_cmd_status(ctx, new_cmd);\n\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_COMMAND);\n\t\terr = IOT_ERROR_NONE;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":48,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"229339":{"score":0.9308369,"function_name":"iot_wifi_ctrl_request","code":"iot_error_t iot_wifi_ctrl_request(struct iot_context *ctx,\n\t\tiot_wifi_mode_t wifi_mode)\n{\n\tiot_error_t iot_err = IOT_ERROR_BAD_REQ;\n\tiot_wifi_conf wifi_conf;\n\tbool send_cmd = true;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx\\n\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tmemset(\u0026wifi_conf, 0, sizeof(wifi_conf));\n\twifi_conf.mode = wifi_mode;\n\n\tswitch (wifi_mode) {\n\tcase IOT_WIFI_MODE_OFF:\n\t\t/* fall through */\n\tcase IOT_WIFI_MODE_STATION:\n\t\t/* easysetup resource deinit \u0026 free for both */\n\t\tif (ctx-\u003ees_http_ready) {\n\t\t\tctx-\u003ees_http_ready = false;\n\t\t\tiot_easysetup_deinit(ctx);\n\t\t}\n\n\t\tif (ctx-\u003escan_result) {\n\t\t\tfree(ctx-\u003escan_result);\n\t\t\tctx-\u003escan_result = NULL;\n\t\t}\n\t\tctx-\u003escan_num = 0;\n\n\t\tif (wifi_mode == IOT_WIFI_MODE_STATION) {\n\t\t\tmemcpy(wifi_conf.ssid, ctx-\u003eprov_data.wifi.ssid,\n\t\t\t\tstrlen(ctx-\u003eprov_data.wifi.ssid));\n\t\t\tmemcpy(wifi_conf.pass, ctx-\u003eprov_data.wifi.password,\n\t\t\t\tstrlen(ctx-\u003eprov_data.wifi.password));\n\t\t\tif (ctx-\u003eprov_data.wifi.mac_str[0] != '\\0') {\n\t\t\t\tmemcpy(wifi_conf.bssid, ctx-\u003eprov_data.wifi.bssid.addr,\n\t\t\t\t\tIOT_WIFI_MAX_BSSID_LEN);\n\t\t\t}\n\t\t\twifi_conf.authmode = ctx-\u003eprov_data.wifi.security_type;\n\t\t} else {\t/* For IOT_WIFI_MODE_OFF case */\n\t\t\tsend_cmd = false;\n\n\t\t\tiot_err = iot_bsp_wifi_set_mode(\u0026wifi_conf);\n\t\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to set wifi_set_mode for scan\\n\");\n\t\t\t\treturn iot_err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_DISCOVERY_SSID)\n\tcase IOT_WIFI_MODE_SOFTAP:\n\t\t/*wifi soft-ap mode w/ ssid E4 format*/\n\t\tiot_err = iot_easysetup_create_ssid(\u0026(ctx-\u003edevconf),\n\t\t\t\t\twifi_conf.ssid, IOT_WIFI_MAX_SSID_LEN);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't create ssid for easysetup.(%d)\", iot_err);\n\t\t\treturn iot_err;\n\t\t}\n\n\t\tsnprintf(wifi_conf.pass, sizeof(wifi_conf.pass), \"1111122222\");\n\t\twifi_conf.authmode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t\tbreak;\n#endif\n\tcase IOT_WIFI_MODE_SCAN:\n\t\tsend_cmd = false;\n\n\t\tiot_err = iot_bsp_wifi_set_mode(\u0026wifi_conf);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to set wifi_set_mode for scan\\n\");\n\t\t\treturn iot_err;\n\t\t}\n\n\t\tif (!ctx-\u003escan_result) {\n\t\t\tctx-\u003escan_result = (iot_wifi_scan_result_t *)iot_os_malloc(IOT_WIFI_MAX_SCAN_RESULT * sizeof(iot_wifi_scan_result_t));\n\t\t\tif (!ctx-\u003escan_result) {\n\t\t\t\tIOT_ERROR(\"failed to malloc for iot_wifi_scan_result_t\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset(ctx-\u003escan_result, 0x0, (IOT_WIFI_MAX_SCAN_RESULT * sizeof(iot_wifi_scan_result_t)));\n\t\t}\n\n\t\tctx-\u003escan_num = iot_bsp_wifi_get_scan_result(ctx-\u003escan_result);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported wifi ctrl mode[%d]\\n\", wifi_mode);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (send_cmd) {\n\t\tiot_err = iot_command_send(ctx,\n\t\t\t\tIOT_COMMAND_NETWORK_MODE,\n\t\t\t\t\t\u0026wifi_conf, sizeof(wifi_conf));\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":86,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"230373":{"score":0.86346424,"function_name":"iot_easysetup_request","code":"iot_error_t iot_easysetup_request(struct iot_context *ctx,\n\t\t\t\tenum iot_easysetup_step step, const void *payload)\n{\n\tstruct iot_easysetup_payload request;\n\tint ret;\n\tiot_error_t err;\n\n\tif (payload) {\n\t\trequest.payload = (char *)payload;\n\t} else {\n\t\trequest.payload = NULL;\n\t}\n\n\trequest.step = step;\n\n\tif (ctx-\u003eeasysetup_req_queue) {\n\t\tret = iot_os_queue_send(ctx-\u003eeasysetup_req_queue, \u0026request, 0);\n\t\tif (ret != IOT_OS_TRUE) {\n\t\t\tIOT_ERROR(\"Cannot put the request into easysetup_req_queue\");\n\t\t\terr = IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR;\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\t\tIOT_EVENT_BIT_EASYSETUP_REQ);\n\t\t\terr = IOT_ERROR_NONE;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"easysetup_req_queue is deleted\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"230641":{"score":0.8710324,"function_name":"iot_state_update","code":"iot_error_t iot_state_update(struct iot_context *ctx,\n\tiot_state_t new_state, int opt)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t err;\n\n\tif ((new_state == IOT_STATE_PROV_CONFIRM)\n\t\t\t\u0026\u0026 (opt == IOT_STATE_OPT_NEED_INTERACT)) {\n\t\tIOT_INFO(\"Trigger PROV_CONFIRM\");\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_PROV_CONFIRM);\n\t}\n\n\tstate_data.iot_state = new_state;\n\tstate_data.opt = opt;\n\n\terr = iot_command_send(ctx, IOT_COMMNAD_STATE_UPDATE,\n                           \u0026state_data, sizeof(struct iot_state_data));\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":221,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"230806":{"score":0.7756517,"function_name":"iot_state_timeout_change","code":"iot_error_t iot_state_timeout_change(struct iot_context *ctx, iot_state_t target_state,\n\tunsigned int new_timeout_ms)\n{\n\tstruct iot_state_data state_data;\n\tiot_error_t err;\n\n\tif (target_state \u003c= IOT_STATE_INITIALIZED)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tif (new_timeout_ms \u003e IOT_STATE_TIMEOUT_MAX_MS)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tstate_data.iot_state = target_state;\n\tstate_data.opt = (int)new_timeout_ms;\n\n\terr = iot_command_send(ctx, IOT_COMMAND_CHANGE_STATE_TIMEOUT,\n                           \u0026state_data, sizeof(struct iot_state_data));\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":243,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"230924":{"score":0.91638696,"function_name":"iot_api_onboarding_config_mem_free","code":"void iot_api_onboarding_config_mem_free(struct iot_devconf_prov_data *devconf)\n{\n\tif (!devconf)\n\t\treturn;\n\n\tif (devconf-\u003edevice_onboarding_id)\n\t\tiot_os_free(devconf-\u003edevice_onboarding_id);\n\tif (devconf-\u003emnid)\n\t\tiot_os_free(devconf-\u003emnid);\n\tif (devconf-\u003esetupid)\n\t\tiot_os_free(devconf-\u003esetupid);\n\tif (devconf-\u003evid)\n\t\tiot_os_free(devconf-\u003evid);\n\tif (devconf-\u003edevice_type)\n\t\tiot_os_free(devconf-\u003edevice_type);\n\tif (devconf-\u003edip)\n\t\tiot_os_free(devconf-\u003edip);\n}","filepath":"src/iot_api.c","line_number":264,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"231126":{"score":0.8929762,"function_name":"is_valid_onboarding_id_len","code":"static bool is_valid_onboarding_id_len(size_t len, unsigned char ssid_version)\n{\n\tsize_t max_len;\n\n\tmax_len = (ssid_version == 4 ? ONBOARDINGID_E4_MAX_LEN : ONBOARDINGID_E5_MAX_LEN);\n\tif (len \u003e max_len) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}","filepath":"src/iot_api.c","line_number":283,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"231191":{"score":0.7226975,"function_name":"mbedtls_ssl_pk_alg_from_sig","code":"mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig( unsigned char sig )\n{\n    switch( sig )\n    {\n#if defined(MBEDTLS_RSA_C)\n        case MBEDTLS_SSL_SIG_RSA:\n            return( MBEDTLS_PK_RSA );\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n        case MBEDTLS_SSL_SIG_ECDSA:\n            return( MBEDTLS_PK_ECDSA );\n#endif\n        default:\n            return( MBEDTLS_PK_NONE );\n    }\n}","filepath":"library/ssl_tls.c","line_number":9527,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.15.0"},"231239":{"score":0.82691175,"function_name":"iot_api_onboarding_config_load","code":"iot_error_t iot_api_onboarding_config_load(unsigned char *onboarding_config,\n\t\tunsigned int onboarding_config_len, struct iot_devconf_prov_data *devconf)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *config = NULL;\n\tJSON_H *dip = NULL;\n\tJSON_H *item = NULL;\n\tchar *data = NULL;\n\tchar *device_onboarding_id = NULL;\n\tchar *mnid = NULL;\n\tchar *setupid = NULL;\n\tchar *vid = NULL;\n\tchar *devicetypeid = NULL;\n\tunsigned char ssid_version;\n\tunsigned int ownership_validation_type = 0;\n\tiot_security_key_type_t pk_type;\n\tsize_t str_len = 0;\n\tint i;\n\tstruct iot_dip_data *new_dip = NULL;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!onboarding_config || !devconf || onboarding_config_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) onboarding_config_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, onboarding_config, onboarding_config_len);\n\tdata[onboarding_config_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tconfig = JSON_GET_OBJECT_ITEM(root, name_onboardingConfig);\n\tif (!config) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_onboardingConfig;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* SSID version, Optional */\n\titem = JSON_GET_OBJECT_ITEM(config, name_ssidVersion);\n\tif (item) {\n\t\tssid_version = (unsigned char) JSON_GET_NUMBER_VALUE(item);\n\t\tif (!is_valid_ssid_version(ssid_version))\n\t\t{\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\t\tcurrent_name = (char *)name_ssidVersion;\n#endif\n\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\tgoto load_out;\n\t\t}\n\t} else {\n\t\t/* default version 4 */\n\t\tssid_version = 4;\n\t}\n\n\t/* device_onboarding_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_deviceOnboardingId);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t}\n\tif(!item || !is_valid_onboarding_id_len(str_len, ssid_version)) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceOnboardingId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\tdevice_onboarding_id = iot_os_malloc(str_len + 1);\n\tif (!device_onboarding_id) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(device_onboarding_id, JSON_GET_STRING_VALUE(item), str_len);\n\tdevice_onboarding_id[str_len] = '\\0';\n\n\t/* mnid */\n\titem = JSON_GET_OBJECT_ITEM(config, name_mnId);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"MNID\")) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_mnId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tmnid = iot_os_malloc(str_len + 1);\n\tif (!mnid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(mnid, JSON_GET_STRING_VALUE(item), str_len);\n\tmnid[str_len] = '\\0';\n\n\t/* setup_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_setupId);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_setupId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tsetupid = iot_os_malloc(str_len + 1);\n\tif (!setupid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(setupid, JSON_GET_STRING_VALUE(item), str_len);\n\tsetupid[str_len] = '\\0';\n\n\t/* vid */\n\titem = JSON_GET_OBJECT_ITEM(config, name_vid);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_vid;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tvid = iot_os_malloc(str_len + 1);\n\tif (!vid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(vid, JSON_GET_STRING_VALUE(item), str_len);\n\tvid[str_len] = '\\0';\n\n\t/* device_type_id */\n\titem = JSON_GET_OBJECT_ITEM(config, name_deviceTypeId);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"TYPE\")) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceTypeId;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tdevicetypeid = iot_os_malloc(str_len + 1);\n\tif (!devicetypeid) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(devicetypeid, JSON_GET_STRING_VALUE(item), str_len);\n\tdevicetypeid[str_len] = '\\0';\n\n\t/* ownership validation type */\n\titem = JSON_GET_OBJECT_ITEM(config, name_ownershipValidationTypes);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tfor (i = 0; i \u003c JSON_GET_ARRAY_SIZE(item); i++) {\n\t\tJSON_H *ovf = JSON_GET_ARRAY_ITEM(item, i);\n\t\tif (ovf \u0026\u0026 JSON_IS_STRING(ovf)) {\n\t\t\tif (!strcmp(JSON_GET_STRING_VALUE(ovf), \"JUSTWORKS\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_JUSTWORKS;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"BUTTON\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_BUTTON;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"PIN\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_PIN;\n\t\t\telse if (!strcmp(JSON_GET_STRING_VALUE(ovf), \"QR\"))\n\t\t\t\townership_validation_type |= (unsigned int) IOT_OVF_TYPE_QR;\n\t\t\telse {\n\t\t\t\tIOT_ERROR(\"Unknown validation type: %s\", JSON_GET_STRING_VALUE(ovf));\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\t\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\t\tgoto load_out;\n\t\t\t}\n\t\t}\n\t}\n\tif (ownership_validation_type == 0)\n\t{\n\t\tIOT_ERROR(\"No ownership validation type selected\");\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_ownershipValidationTypes;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* device identity */\n\titem = JSON_GET_OBJECT_ITEM(config, name_identityType);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), \"ED25519\")) {\n\t\tpk_type = IOT_SECURITY_KEY_TYPE_ED25519;\n\t} else if (!strcmp(JSON_GET_STRING_VALUE(item), \"X509\")) {\n\t\tpk_type = IOT_SECURITY_KEY_TYPE_ECCP256;\n\t} else {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_identityType;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* Device Integration Profile, optional */\n\tdip = JSON_GET_OBJECT_ITEM(config, name_deviceIntegrationProfileId);\n\tif (dip) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceIntegrationProfileId;\n#endif\n\t\tnew_dip = iot_os_malloc(sizeof(struct iot_dip_data));\n\t\tif (!new_dip) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tmemset(new_dip, 0, sizeof(struct iot_dip_data));\n\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"id\");\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"Can't get id (NULL)\");\n\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\tgoto load_out;\n\t\t}\n\n\t\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\t\t\u0026new_dip-\u003edip_id);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert uuid for dip_id(%d)\", iot_err);\n\t\t\tgoto load_out;\n\t\t}\n\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"majorVersion\");\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"Can't get majorVersion (NULL)\");\n\t\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\t\tgoto load_out;\n\t\t}\n\t\tnew_dip-\u003edip_major_version = item-\u003evalueint;\n\n\t\t/* minorVersion is optional, default 0 */\n\t\titem = JSON_GET_OBJECT_ITEM(dip, \"minorVersion\");\n\t\tif (item) {\n\t\t\tnew_dip-\u003edip_minor_version = item-\u003evalueint;\n\t\t}\n\t}\n\n\tdevconf-\u003edevice_onboarding_id = device_onboarding_id;\n\tdevconf-\u003emnid = mnid;\n\tdevconf-\u003esetupid = setupid;\n\tdevconf-\u003evid = vid;\n\tdevconf-\u003edevice_type = devicetypeid;\n\tdevconf-\u003eownership_validation_type = ownership_validation_type;\n\tdevconf-\u003epk_type = pk_type;\n\tif (new_dip) {\n\t\tdevconf-\u003edip = new_dip;\n\t}\n\tdevconf-\u003essid_version = ssid_version;\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\treturn iot_err;\n\nload_out:\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tif (item \u0026\u0026 JSON_IS_STRING(item)) {\n\t\t\tIOT_ERROR(\"[%s] wrong onboarding config value detected: %s\",\n\t\t\t\t\tcurrent_name, JSON_GET_STRING_VALUE(item));\n\t\t}\n\t\telse {\n\t\t\tIOT_ERROR(\"[%s] wrong onboarding config value detected\", current_name);\n\t\t}\n\t}\n\tif (device_onboarding_id) {\n\t\tiot_os_free(device_onboarding_id);\n\t}\n\tif (mnid) {\n\t\tiot_os_free(mnid);\n\t}\n\tif (setupid) {\n\t\tiot_os_free(setupid);\n\t}\n\tif (vid) {\n\t\tiot_os_free(vid);\n\t}\n\tif (devicetypeid) {\n\t\tiot_os_free(devicetypeid);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (data) {\n\t\tiot_os_free(data);\n\t}\n\tif (new_dip) {\n\t\tiot_os_free(new_dip);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":314,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"234012":{"score":0.8845947,"function_name":"iot_get_time_in_sec","code":"iot_error_t iot_get_time_in_sec(char *buf, size_t buf_len)\n{\n\tstruct timeval tv_now;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\tsnprintf(buf, buf_len, \"%ld\", tv_now.tv_sec);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":622,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"234168":{"score":0.901866,"function_name":"iot_get_time_in_sec_by_long","code":"iot_error_t iot_get_time_in_sec_by_long(long *sec)\n{\n\tstruct timeval tv_now;\n\n\tif (!sec) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\t*sec = tv_now.tv_sec;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":637,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"234311":{"score":0.9062587,"function_name":"iot_get_time_in_ms","code":"iot_error_t iot_get_time_in_ms(char *buf, size_t buf_len)\n{\n\tstruct timeval tv_now;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buffer for time is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tgettimeofday(\u0026tv_now, NULL);\n\tsnprintf(buf, buf_len, \"%ld%03ld\",\n\t\ttv_now.tv_sec, (tv_now.tv_usec / 1000));\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":652,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"234493":{"score":0.9396163,"function_name":"iot_api_device_info_mem_free","code":"void iot_api_device_info_mem_free(struct iot_device_info *device_info)\n{\n\tif (!device_info)\n\t\treturn;\n\n\tdevice_info-\u003eopt_info = 0;\n\n\tif (device_info-\u003efirmware_version) {\n\t\tiot_os_free(device_info-\u003efirmware_version);\n\t\tdevice_info-\u003efirmware_version = NULL;\n\t}\n\n\tif (device_info-\u003emodel_number) {\n\t\tiot_os_free(device_info-\u003emodel_number);\n\t\tdevice_info-\u003emodel_number = NULL;\n\t}\n\n\tif (device_info-\u003emarketing_name) {\n\t\tiot_os_free(device_info-\u003emarketing_name);\n\t\tdevice_info-\u003emarketing_name = NULL;\n\t}\n\n\tif (device_info-\u003emanufacturer_name) {\n\t\tiot_os_free(device_info-\u003emanufacturer_name);\n\t\tdevice_info-\u003emanufacturer_name = NULL;\n\t}\n\n\tif (device_info-\u003emanufacturer_code) {\n\t\tiot_os_free(device_info-\u003emanufacturer_code);\n\t\tdevice_info-\u003emanufacturer_code = NULL;\n\t}\n}","filepath":"src/iot_api.c","line_number":668,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"234801":{"score":0.8221419,"function_name":"iot_api_device_info_load","code":"iot_error_t iot_api_device_info_load(unsigned char *device_info,\n\t\tunsigned int device_info_len, struct iot_device_info *info)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *profile = NULL;\n\tJSON_H *item = NULL;\n\tchar *firmware_version = NULL;\n\tchar *model_number = NULL;\n\tchar *marketing_name = NULL;\n\tchar *manufacturer_name = NULL;\n\tchar *manufacturer_code = NULL;\n\tchar *data = NULL;\n\tsize_t str_len = 0;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!device_info || !info || device_info_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) device_info_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, device_info, device_info_len);\n\tdata[device_info_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tprofile = JSON_GET_OBJECT_ITEM(root, name_deviceInfo);\n\tif (!profile) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_deviceInfo;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\t/* version */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_version);\n\tif (!item) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)name_version;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tfirmware_version = iot_os_malloc(str_len + 1);\n\tif (!firmware_version) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\tstrncpy(firmware_version, JSON_GET_STRING_VALUE(item), str_len);\n\tfirmware_version[str_len] = '\\0';\n\n\tinfo-\u003efirmware_version = firmware_version;\n\tinfo-\u003eopt_info = 0;\n\n\t/* name_model_number */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_model_number);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmodel_number = iot_os_malloc(str_len + 1);\n\t\tif (!model_number) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(model_number, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmodel_number[str_len] = '\\0';\n\t\tinfo-\u003emodel_number = model_number;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emodel_number = NULL;\n\t}\n\n\t/* name_marketing */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_marketing);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmarketing_name = iot_os_malloc(str_len + 1);\n\t\tif (!marketing_name) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(marketing_name, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmarketing_name[str_len] = '\\0';\n\n\t\tinfo-\u003emarketing_name = marketing_name;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emarketing_name = NULL;\n\t}\n\n\t/* name_manufacturer */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_manufacturer);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmanufacturer_name = iot_os_malloc(str_len + 1);\n\t\tif (!manufacturer_name) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(manufacturer_name, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmanufacturer_name[str_len] = '\\0';\n\n\t\tinfo-\u003emanufacturer_name = manufacturer_name;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emanufacturer_name = NULL;\n\t}\n\n\t/* manufacturerCode */\n\titem = JSON_GET_OBJECT_ITEM(profile, name_manufacturer_code);\n\tif (item) {\n\t\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\t\tmanufacturer_code = iot_os_malloc(str_len + 1);\n\t\tif (!manufacturer_code) {\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto load_out;\n\t\t}\n\t\tstrncpy(manufacturer_code, JSON_GET_STRING_VALUE(item), str_len);\n\t\tmanufacturer_code[str_len] = '\\0';\n\n\t\tinfo-\u003emanufacturer_code = manufacturer_code;\n\t\tinfo-\u003eopt_info++;\n\t} else {\n\t\tinfo-\u003emanufacturer_code = NULL;\n\t}\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\t_dump_device_info(info);\n\n\treturn iot_err;\n\nload_out:\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tIOT_ERROR(\"[%s] wrong device info value detected\", current_name);\n\t}\n#endif\n\n\tif (firmware_version)\n\t\tiot_os_free(firmware_version);\n\tif (marketing_name)\n\t\tiot_os_free(marketing_name);\n\tif (model_number)\n\t\tiot_os_free(model_number);\n\tif (manufacturer_name)\n\t\tiot_os_free(manufacturer_name);\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\tif (data)\n\t\tiot_os_free(data);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":716,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"236204":{"score":0.9019791,"function_name":"iot_api_prov_data_mem_free","code":"void iot_api_prov_data_mem_free(struct iot_device_prov_data *prov)\n{\n\tif (!prov)\n\t\treturn;\n\n\tif (prov-\u003ecloud.broker_url)\n\t\tiot_os_free(prov-\u003ecloud.broker_url);\n\n\tif (prov-\u003ecloud.label)\n\t\tiot_os_free(prov-\u003ecloud.label);\n}","filepath":"src/iot_api.c","line_number":880,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"236298":{"score":0.83603054,"function_name":"iot_api_read_device_identity","code":"iot_error_t iot_api_read_device_identity(unsigned char* nv_prof,\n\t\tunsigned int nv_prof_len, const char* object, char** nv_data)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tJSON_H *root = NULL;\n\tJSON_H *profile = NULL;\n\tJSON_H *item = NULL;\n\tchar *data = NULL;\n\tchar *object_data = NULL;\n\tsize_t str_len = 0;\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\tchar *current_name = NULL;\n#endif\n\n\tif (!nv_prof || !nv_data || nv_prof_len == 0)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\tdata = iot_os_malloc((size_t) nv_prof_len + 1);\n\tif (!data) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemcpy(data, nv_prof, nv_prof_len);\n\tdata[nv_prof_len] = '\\0';\n\n\troot = JSON_PARSE((char *)data);\n\tprofile = JSON_GET_OBJECT_ITEM(root, name_deviceInfo);\n\tif (!profile) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char*)name_deviceInfo;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(profile, object);\n\tif (!item || !strcmp(JSON_GET_STRING_VALUE(item), object)) {\n#if defined(CONFIG_STDK_IOT_CORE_LOG_LEVEL_ERROR)\n\t\tcurrent_name = (char *)object;\n#endif\n\t\tiot_err = IOT_ERROR_UNINITIALIZED;\n\t\tgoto load_out;\n\t}\n\n\tstr_len = strlen(JSON_GET_STRING_VALUE(item));\n\tobject_data = iot_os_malloc(str_len + 1);\n\tif (!object_data) {\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\tgoto load_out;\n\t}\n\n\tstrncpy(object_data, JSON_GET_STRING_VALUE(item), str_len);\n\tobject_data[str_len] = '\\0';\n\n\t*nv_data = object_data;\n\n\tif (root)\n\t\tJSON_DELETE(root);\n\n\tiot_os_free(data);\n\n\treturn iot_err;\n\nload_out:\n\tif (iot_err == IOT_ERROR_UNINITIALIZED) {\n\t\tif (item \u0026\u0026 JSON_IS_STRING(item)) {\n\t\t\tIOT_ERROR(\"[%s] wrong nv profile value detected: %s\",\n\t\t\t\t\tcurrent_name, JSON_GET_STRING_VALUE(item));\n\t\t}\n\t\telse {\n\t\t\tIOT_ERROR(\"[%s] wrong nv profile value detected\", current_name);\n\t\t}\n\t}\n\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (data) {\n\t\tiot_os_free(data);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":893,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"236950":{"score":0.93815887,"function_name":"iot_device_cleanup","code":"iot_error_t iot_device_cleanup(struct iot_context *ctx)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tiot_wifi_conf config;\n\n\tIOT_INFO(\"start to erase device information\");\n\n\tmemset(\u0026config, 0x0, sizeof(iot_wifi_conf));\n\n\tiot_api_prov_data_mem_free(\u0026(ctx-\u003eprov_data));\n\tmemset(\u0026(ctx-\u003eprov_data), 0x0, sizeof(ctx-\u003eprov_data));\n\n\tiot_err = iot_nv_erase_prov_data();\n\tif ((iot_err != IOT_ERROR_NONE) \u0026\u0026 (iot_err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\tIOT_ERROR(\"%s: failed to erase provisioning data: %d\", __func__, iot_err);\n\t}\n\n\tiot_err = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\tif ((iot_err != IOT_ERROR_NONE) \u0026\u0026 (iot_err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\tIOT_ERROR(\"%s: failed to erase device ID: %d\", __func__, iot_err);\n\t}\n\n\t/* if there is previous connection, disconnect it first. */\n\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\tiot_err = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s: evt_mqtt disconnect failed %d\", __func__, iot_err);\n\t\t}\n\t}\n\n\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\tiot_err = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s: reg_mqtt disconnect failed %d\", __func__, iot_err);\n\t\t}\n\t}\n\n\tif(ctx-\u003elookup_id) {\n\t\tfree(ctx-\u003elookup_id);\n\t\tctx-\u003elookup_id = NULL;\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":978,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"237590":{"score":0.8429258,"function_name":"_get_dip_from_json","code":"static iot_error_t _get_dip_from_json(JSON_H *json, struct iot_dip_data *dip)\n{\n\tstruct iot_dip_data curr_dip;\n\tJSON_H *sub_item = NULL;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\n\tsub_item = JSON_GET_OBJECT_ITEM(json, \"dip\");\n\tif (sub_item == NULL) {\n\t\tIOT_ERROR(\"There is no dip in misc_info\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"id\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no id in dip\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\u0026curr_dip.dip_id);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"maj\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no major-version in dip\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tcurr_dip.dip_major_version = item-\u003evalueint;\n\n\titem = JSON_GET_OBJECT_ITEM(sub_item, \"min\");\n\tif (item == NULL) {\n\t\tcurr_dip.dip_minor_version = 0;\n\t} else {\n\t\tcurr_dip.dip_minor_version = item-\u003evalueint;\n\t}\n\n\tmemcpy(dip, \u0026curr_dip, sizeof(curr_dip));\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1025,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"238072":{"score":0.8146209,"function_name":"_get_location_from_json","code":"static iot_error_t _get_location_from_json(JSON_H *json, struct iot_uuid *uuid)\n{\n\tstruct iot_uuid curr_uuid;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"loId\");\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"There is no locationId in misc_info\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tiot_err = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\t\u0026curr_uuid);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\tmemcpy(uuid, \u0026curr_uuid, sizeof(curr_uuid));\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":1069,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"238337":{"score":0.88770825,"function_name":"iot_misc_info_load","code":"iot_error_t iot_misc_info_load(iot_misc_info_t type, void *out_data)\n{\n\tchar *misc_info = NULL;\n\tsize_t misc_info_len = 0;\n\tJSON_H *json = NULL;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\n\tif (!out_data) {\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tgoto misc_info_load_out;\n\t}\n\n\tiot_err = iot_nv_get_misc_info(\u0026misc_info, \u0026misc_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't get misc_info from NV(%d)\", iot_err);\n\t\tgoto misc_info_load_out;\n\t}\n\n\tIOT_DEBUG(\"Load raw misc_info str:%s\", misc_info);\n\n\tjson = JSON_PARSE(misc_info);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"misc_info(%s) parsing failed\", misc_info);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tgoto misc_info_load_out;\n\t}\n\n\tswitch (type) {\n\tcase IOT_MISC_INFO_DIP:\n\t\tiot_err = _get_dip_from_json(json, (struct iot_dip_data *)out_data);\n\t\tbreak;\n\n\tcase IOT_MISC_INFO_LOCATION:\n\t\tiot_err = _get_location_from_json(json, (struct iot_uuid *)out_data);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported type(%d)\", type);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tbreak;\n\t}\n\nmisc_info_load_out:\n\tif (misc_info)\n\t\tiot_os_free(misc_info);\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1092,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"238744":{"score":0.84645826,"function_name":"_set_dip_to_json","code":"static iot_error_t _set_dip_to_json(JSON_H *json, struct iot_dip_data *new_dip)\n{\n\tJSON_H *sub_item = NULL;\n\tJSON_H *item = NULL;\n\tiot_error_t iot_err;\n\tchar dip_id_str[40];\n\n\tsub_item = JSON_CREATE_OBJECT();\n\tif (sub_item == NULL) {\n\t\tIOT_ERROR(\"Can't make new obj for dip\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tiot_err = iot_util_convert_uuid_str(\u0026new_dip-\u003edip_id,\n\t\t\t\tdip_id_str, sizeof(dip_id_str));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert uuid to str(%d)\", iot_err);\n\t\tJSON_DELETE(sub_item);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_CREATE_STRING(dip_id_str);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new string for dip's id\");\n\t\tJSON_DELETE(sub_item);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"id\", item);\n\n\titem = JSON_CREATE_NUMBER(new_dip-\u003edip_major_version);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new item for dip's major version\");\n\t\tJSON_DELETE(sub_item);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"maj\", item);\n\n\tif (new_dip-\u003edip_minor_version != 0) {\n\t\titem = JSON_CREATE_NUMBER(new_dip-\u003edip_minor_version);\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"Can't make new item for dip's minor version\");\n\t\t\tJSON_DELETE(sub_item);\n\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(sub_item, \"min\", item);\n\t}\n\n\tif (JSON_GET_OBJECT_ITEM(json, \"dip\") == NULL) {\n\t\tIOT_DEBUG(\"There is no dip in misc_info\");\n\t\tJSON_ADD_ITEM_TO_OBJECT(json, \"dip\", sub_item);\n\t} else {\n\t\tJSON_REPLACE_ITEM_IN_OBJ_CASESENS(json, \"dip\", sub_item);\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1144,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"239426":{"score":0.794598,"function_name":"_set_location_to_json","code":"static iot_error_t _set_location_to_json(JSON_H *json, struct iot_uuid *uuid)\n{\n\tJSON_H *item = NULL;\n\tchar location_id[IOT_REG_UUID_STR_LEN + 1];\n\tiot_error_t iot_err;\n\n\tiot_err = iot_util_convert_uuid_str(uuid,\n\t\t\t\tlocation_id, sizeof(location_id));\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't convert uuid to str(%d)\", iot_err);\n\t\treturn iot_err;\n\t}\n\n\titem = JSON_CREATE_STRING(location_id);\n\tif (item == NULL) {\n\t\tIOT_ERROR(\"Can't make new string for locationId\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tif (JSON_GET_OBJECT_ITEM(json, \"loId\") == NULL) {\n\t\tIOT_DEBUG(\"There is no locatinoId in misc_info\");\n\t\tJSON_ADD_ITEM_TO_OBJECT(json, \"loId\", item);\n\t} else {\n\t\tJSON_REPLACE_ITEM_IN_OBJ_CASESENS(json, \"loId\", item);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_api.c","line_number":1201,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"239725":{"score":0.8904726,"function_name":"iot_misc_info_store","code":"iot_error_t iot_misc_info_store(iot_misc_info_t type, const void *in_data)\n{\n\tchar *old_misc_info = NULL;\n\tsize_t old_misc_info_len = 0;\n\tchar *new_misc_info = NULL;\n\tJSON_H *json = NULL;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tunsigned char old_hash[IOT_SECURITY_SHA256_LEN] = {0,};\n\tunsigned char new_hash[IOT_SECURITY_SHA256_LEN] = {0,};\n\tbool hash_chk = false;\n\tbool old_misc_avail = false;\n\n\tif (!in_data) {\n\t\tiot_err = IOT_ERROR_INVALID_ARGS;\n\t\tgoto misc_info_store_out;\n\t}\n\n\tiot_err = iot_nv_get_misc_info(\u0026old_misc_info, \u0026old_misc_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_INFO(\"There is no old misc_info in NV\");\n\t\tjson = JSON_CREATE_OBJECT();\n\t} else {\n\t\tjson = JSON_PARSE(old_misc_info);\n\t\tif (json == NULL) {\n\t\t\tIOT_WARN(\"old misc_info(%s/%u) parsing failed\",\n\t\t\t\told_misc_info, (unsigned int)old_misc_info_len);\n\t\t\tjson = JSON_CREATE_OBJECT();\n\t\t} else {\n\t\t\told_misc_avail = true;\n\t\t}\n\t}\n\n\tif (old_misc_avail) {\n\t\tiot_err = iot_security_sha256((const unsigned char *)old_misc_info,\n\t\t\t\told_misc_info_len, old_hash, sizeof(old_hash));\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_WARN(\"Can't make hash for old_misc_info!!\");\n\t\t} else {\n\t\t\thash_chk = true;\n\t\t}\n\t}\n\n\tif (old_misc_info) {\n\t\tiot_os_free(old_misc_info);\n\t\told_misc_info = NULL;\n\t}\n\n\tswitch (type) {\n\tcase IOT_MISC_INFO_DIP:\n\t\tiot_err = _set_dip_to_json(json, (struct iot_dip_data *)in_data);\n\t\tbreak;\n\n\tcase IOT_MISC_INFO_LOCATION:\n\t\tiot_err = _set_location_to_json(json, (struct iot_uuid *)in_data);\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_ERROR(\"Unsupported type(%d)\", type);\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\tbreak;\n\t}\n\n\tif (iot_err != IOT_ERROR_NONE)\n\t\tgoto misc_info_store_out;\n\n\tnew_misc_info = JSON_PRINT(json);\n\tIOT_DEBUG(\"Store raw msic_info str : %s\", new_misc_info);\n\n\tif (hash_chk) {\n\t\tiot_err = iot_security_sha256((const unsigned char *)new_misc_info,\n\t\t\t\tstrlen(new_misc_info), new_hash, sizeof(new_hash));\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_WARN(\"Can't make hash for new_misc_info!!\");\n\t\t} else {\n\t\t\tif (!memcmp(old_hash, new_hash, IOT_SECURITY_SHA256_LEN)) {\n\t\t\t\tIOT_DEBUG(\"Same misc_info, skip NV update\");\n\t\t\t\tgoto misc_info_store_out;\n\t\t\t}\n\t\t}\n\t}\n\n\tiot_err = iot_nv_set_misc_info(new_misc_info);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Can't set new misc_info into NV : %s\", new_misc_info);\n\t}\n\nmisc_info_store_out:\n\tif (new_misc_info)\n\t\tiot_os_free(new_misc_info);\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn iot_err;\n}","filepath":"src/iot_api.c","line_number":1230,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"240545":{"score":0.8934404,"function_name":"iot_get_random_id_str","code":"iot_error_t iot_get_random_id_str(char *str, size_t max_sz)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_uuid uuid;\n\n\tif (str == NULL) {\n\t\tIOT_ERROR(\"There is no string arg\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_get_random_uuid_from_mac(\u0026uuid);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"To get uuid is failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\terr = iot_util_convert_uuid_str(\u0026uuid, str, max_sz);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to convert uuid to str (%d)\", err);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_api.c","line_number":1326,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"241823":{"score":0.8232951,"function_name":"iot_bsp_fs_open","code":"iot_error_t iot_bsp_fs_open(const char* filename, iot_bsp_fs_open_mode_t mode, iot_bsp_fs_handle_t* handle)\n{\n\tint fd;\n\tint open_mode;\n\n\tif (mode == FS_READONLY) {\n\t\tif (access(filename, F_OK) \u003c 0) {\n\t\t\tIOT_DEBUG(\"file doesn't exist\");\n\t\t\treturn IOT_ERROR_FS_NO_FILE;\n\t\t}\n\t\topen_mode = O_RDONLY;\n\t} else {\n\t\topen_mode = O_RDWR | O_CREAT;\n\t}\n\n\tfd = open(filename, open_mode, 0644);\n\tif (fd \u003e 0) {\n\t\thandle-\u003efd = fd;\n\t\tsnprintf(handle-\u003efilename, sizeof(handle-\u003efilename), \"%s\", filename);\n\t\treturn IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"file open failed [%s]\", strerror(errno));\n\t\treturn IOT_ERROR_FS_OPEN_FAIL;\n\t}\n}","filepath":"src/port/bsp/posix/iot_bsp_fs_posix.c","line_number":39,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"241976":{"score":0.88752234,"function_name":"iot_bsp_fs_open_from_stnv","code":"iot_error_t iot_bsp_fs_open_from_stnv(const char* filename, iot_bsp_fs_handle_t* handle)\n{\n\tint fd;\n\n\tif (access(filename, F_OK) \u003c 0) {\n\t\tIOT_DEBUG(\"file doesn't exist\");\n\t\treturn IOT_ERROR_FS_NO_FILE;\n\t}\n\tfd = open(filename, O_RDONLY);\n\tif (fd \u003e 0) {\n\t\thandle-\u003efd = fd;\n\t\tsnprintf(handle-\u003efilename, sizeof(handle-\u003efilename), \"%s\", filename);\n\t\treturn IOT_ERROR_NONE;\n\t} else {\n\t\tIOT_DEBUG(\"file open failed [%s]\", strerror(errno));\n\t\treturn IOT_ERROR_FS_OPEN_FAIL;\n\t}\n}","filepath":"src/port/bsp/posix/iot_bsp_fs_posix.c","line_number":65,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"242101":{"score":0.7837622,"function_name":"iot_bsp_fs_read","code":"iot_error_t iot_bsp_fs_read(iot_bsp_fs_handle_t handle, char* buffer, size_t *length)\n{\n    char* data;\n    ssize_t size;\n\n\tif (access(handle.filename, F_OK) == -1) {\n\t\tIOT_DEBUG(\"file does not exist\");\n\t\treturn IOT_ERROR_FS_NO_FILE;\n\t}\n\n\tdata = malloc(*length + 1);\n\tif (!data) {\n\t    IOT_DEBUG(\"malloc failed\");\n\t    return IOT_ERROR_FS_OPEN_FAIL;\n\t}\n\tsize = read(handle.fd, data, *length);\n\tif (size \u003c 0) {\n\t\tfree(data);\n\t\tIOT_DEBUG(\"read fail [%s]\", strerror(errno));\n\t\treturn IOT_ERROR_FS_READ_FAIL;\n\t}\n\n\tmemcpy(buffer, data, size);\n\tif (size \u003c *length) {\n\t\tbuffer[size] = '\\0';\n\t}\n\n\t*length = size;\n\n\tfree(data);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_fs_posix.c","line_number":84,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"242811":{"score":0.8518373,"function_name":"iot_bsp_system_get_time_in_sec","code":"iot_error_t iot_bsp_system_get_time_in_sec(char* buf, unsigned int buf_len)\n{\n\tIOT_WARN_CHECK(buf == NULL, IOT_ERROR_INVALID_ARGS, \"buffer for time is NULL\");\n\n\tstruct timespec ts = {0,};\n\n\tclock_gettime(CLOCK_REALTIME, \u0026ts);\n\tsnprintf(buf, buf_len, \"%ld\", ts.tv_sec);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":46,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"242978":{"score":0.85111684,"function_name":"iot_bsp_system_set_time_in_sec","code":"iot_error_t iot_bsp_system_set_time_in_sec(const char* time_in_sec)\n{\n\tIOT_WARN_CHECK(time_in_sec == NULL, IOT_ERROR_INVALID_ARGS, \"time data is NULL\");\n\n\tstruct timespec ts = {0,};\n\tint ret;\n\n\tsscanf(time_in_sec, \"%ld\", \u0026ts.tv_sec);\n\tret = clock_settime(CLOCK_REALTIME, \u0026ts);\n\tif (ret == -1)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":58,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"243161":{"score":0.95075774,"function_name":"iot_bsp_system_get_uniqueid","code":"iot_error_t iot_bsp_system_get_uniqueid(unsigned char **uid, size_t *olen)\n{\n\tunsigned long hostid = gethostid();\n\tunsigned char *id;\n\n\tid = (unsigned char*) malloc(4);\n\tif (!id) {\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tfor (int i = 0; i \u003c 4; i++) {\n\t\tid[i] = (unsigned char) hostid;\n\t\thostid = hostid \u003e\u003e 8u;\n\t}\n\n\t*uid = id;\n\t*olen = 4;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/bsp/posix/iot_bsp_system_posix.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244252":{"score":0.9094563,"function_name":"st_conn_ownership_confirm","code":"void st_conn_ownership_confirm(IOT_CTX *iot_ctx, bool confirm)\n{\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (ctx-\u003ecurr_otm_feature == OVF_BIT_BUTTON) {\n\t\tif (confirm == true) {\n\t\t\tIOT_INFO(\"button confirm asserted\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM);\n\t\t} else if (confirm == false) {\n\t\t\tIOT_INFO(\"button confirm denied\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_CONFIRM_DENIED, 0);\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY);\n\t\t}\n\t}\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244437":{"score":0.8806571,"function_name":"_es_json_parse_string","code":"STATIC_FUNCTION\nchar *_es_json_parse_string(JSON_H *json, const char *name)\n{\n\tchar *buf = NULL;\n\tJSON_H *recv = NULL;\n\tunsigned int buf_len;\n\n\tif (!json || !name) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn NULL;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(json, name)) == NULL) {\n\t\tIOT_INFO(\"failed to find '%s'\", name);\n\t\treturn NULL;\n\t}\n\tbuf_len = (strlen(recv-\u003evaluestring) + 1);\n\n\tIOT_DEBUG(\"'%s' (%d): %s\",\n\t\t\tname, buf_len, recv-\u003evaluestring);\n\n\tif ((buf = (char *)iot_os_malloc(buf_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for buf\");\n\t\treturn NULL;\n\t}\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, recv-\u003evaluestring, strlen(recv-\u003evaluestring));\n\n\treturn buf;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":59,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244761":{"score":0.92004526,"function_name":"_es_crypto_cipher_gen_iv","code":"STATIC_FUNCTION\niot_error_t _es_crypto_cipher_gen_iv(iot_security_buffer_t *iv_buffer)\n{\n\tint i;\n\tunsigned char *iv;\n\tsize_t iv_len = IOT_SECURITY_IV_LEN;\n\n\tif (!iv_buffer) {\n\t\tIOT_ERROR(\"iv buffer is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((iv = (unsigned char *)iot_os_malloc(iv_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for iv\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t}\n\n\tfor (i = 0; i \u003c iv_len; i++) {\n\t\tiv[i] = (unsigned char)iot_bsp_random();\n\t}\n\n\tiv_buffer-\u003ep = iv;\n\tiv_buffer-\u003elen = iv_len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"244971":{"score":0.9229817,"function_name":"_encrypt_and_encode","code":"STATIC_FUNCTION\niot_error_t _encrypt_and_encode(iot_security_context_t *security_context, unsigned char *plain_msg, size_t plain_msg_len, char **out_msg)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t msg_buf = { 0 };\n\tiot_security_buffer_t encrypt_buf = { 0 };\n\tiot_security_buffer_t encrypt_b64url_buf = { 0 };\n\tsize_t out_len;\n\n\tif (!security_context || !plain_msg || plain_msg_len == 0) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tmsg_buf.p = plain_msg;\n\tmsg_buf.len = plain_msg_len;\n\n\terr = iot_security_cipher_aes_encrypt(security_context, \u0026msg_buf, \u0026encrypt_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"aes encryption error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_AES256_ENCRYPTION_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_AES256_ENCRYPTION_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\tencrypt_b64url_buf.len = IOT_SECURITY_B64_ENCODE_LEN(encrypt_buf.len);\n\tencrypt_b64url_buf.p = (unsigned char *)iot_os_calloc(encrypt_b64url_buf.len, sizeof(unsigned char));\n\tif (!encrypt_b64url_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for encrypt b64url\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\terr = iot_security_base64_encode_urlsafe(encrypt_buf.p, encrypt_buf.len,\n\t\t\t\tencrypt_b64url_buf.p, encrypt_b64url_buf.len, \u0026out_len);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64url encode error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_ENCODE_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_ENCODE_ERROR;\n\t\tgoto enc_fail;\n\t}\n\n\tiot_os_free(encrypt_buf.p);\n\t*out_msg = (char *)encrypt_b64url_buf.p;\n\treturn IOT_ERROR_NONE;\n\nenc_fail:\n\tif (encrypt_buf.p) {\n\t\tiot_os_free(encrypt_buf.p);\n\t}\n\tif (encrypt_b64url_buf.p) {\n\t\tiot_os_free(encrypt_b64url_buf.p);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":118,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"245481":{"score":0.920995,"function_name":"_decode_and_decrypt","code":"STATIC_FUNCTION\niot_error_t _decode_and_decrypt(iot_security_context_t *security_context, unsigned char *encrypt_b64url_msg, size_t encrypt_b64url_msg_len, char **out_msg)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t decrypt_buf = {0 };\n\tiot_security_buffer_t plain_buf = { 0 };\n\tsize_t decoded_len;\n\n\tif (!security_context || !encrypt_b64url_msg || encrypt_b64url_msg_len == 0) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t// Decode\n\tdecrypt_buf.len = IOT_SECURITY_B64_DECODE_LEN(encrypt_b64url_msg_len);\n\tdecrypt_buf.p = (unsigned char*) iot_os_calloc(decrypt_buf.len, sizeof(unsigned char));\n\tif (!decrypt_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for decrypt\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\treturn IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR;\n\t}\n\n\terr = iot_security_base64_decode_urlsafe(encrypt_b64url_msg, encrypt_b64url_msg_len,\n\t\t\t\t\tdecrypt_buf.p, decrypt_buf.len, \u0026decoded_len);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64url decode error 0x%x\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_DECODE_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_DECODE_ERROR;\n\t\tgoto dec_fail;\n\t}\n\n\tdecrypt_buf.len = decoded_len;\n\n\terr = iot_security_cipher_aes_decrypt(security_context, \u0026decrypt_buf, \u0026plain_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"aes decrypt error %d\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_AES256_DECRYPTION_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_AES256_DECRYPTION_ERROR;\n\t\tgoto dec_fail;\n\t}\n\n\tiot_os_free(decrypt_buf.p);\n\t*out_msg = (char *)plain_buf.p;\n\treturn IOT_ERROR_NONE;\n\ndec_fail:\n\tif (decrypt_buf.p) {\n\t\tiot_os_free(decrypt_buf.p);\n\t}\n\tif (plain_buf.p) {\n\t\tiot_os_free(plain_buf.p);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":175,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"245959":{"score":0.91842556,"function_name":"_es_time_set","code":"STATIC_FUNCTION\niot_error_t _es_time_set(unsigned char *time)\n{\n\tchar time_str[11] = {0,};\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct tm tm = { 0 };\n\ttime_t now = 0;\n\n\tif (sscanf((char *)time, \"%4d-%2d-%2dT%2d.%2d.%2d\", \u0026tm.tm_year, \u0026tm.tm_mon, \u0026tm.tm_mday, \u0026tm.tm_hour, \u0026tm.tm_min, \u0026tm.tm_sec) != 6) {\n\t\tIOT_ERROR(\"Invalid UTC time!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_TIME;\n\t\treturn err;\n\t}\n\n\t/*\n\tThis code is applied by the Year 2038 problem.\n\tThe Year 2038 problem relates to representing time in many digital systems\n\tas the number of seconds passed since 00:00:00 UTC on 1 January 1970 and storing it as a signed 32-bit integer.\n\tSuch implementations cannot encode times after 03:14:07 UTC on 19 January 2038.\n\tThe Year 2038 problem is caused by insufficient capacity used to represent time.\n\tIf it meet the problem, the time info will be updated by SNTP.\n\t*/\n\tif (sizeof(time_t) == 4) {\n\t\tif (tm.tm_year \u003e= 2038) {\n\t\t\tIOT_ERROR(\"Not support time by year 2038 problem(Y2038 Problem)\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, 0);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\ttm.tm_year -= 1900;\n\ttm.tm_mon -= 1;\n\n\tnow = mktime(\u0026tm);\n\tsnprintf(time_str, sizeof(time_str), \"%ld\", now);\n\n\terr = iot_bsp_system_set_time_in_sec(time_str);\n\tif (err) {\n\t\tIOT_ERROR(\"Time set error!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_TIME, err);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_TIME;\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":230,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"246382":{"score":0.90927184,"function_name":"_es_parse_input_data","code":"STATIC_FUNCTION\nchar* _es_parse_input_data(iot_security_context_t *security_context, char *input_data)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *message_value = NULL;\n\tchar *in_payload = NULL;\n\tJSON_H *root = NULL;\n\n\tif (!input_data || !security_context) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\treturn NULL;\n\t}\n\n\troot = JSON_PARSE(input_data);\n\tif (!root) {\n\t\tIOT_ERROR(\"parse error\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\tgoto out;\n\t}\n\n\tmessage_value = _es_json_parse_string(root, \"message\");\n\tif (!message_value) {\n\t\tIOT_ERROR(\"Invalid message\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\tgoto out;\n\t}\n\n\terr = _decode_and_decrypt(security_context, (unsigned char*) message_value, strlen(message_value), \u0026in_payload);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"decrypt and decode fail 0x%x\", err);\n\t\tgoto out;\n\t}\n\nout:\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (message_value) {\n\t\tiot_os_free(message_value);\n\t}\n\n\treturn in_payload;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":276,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"246804":{"score":0.8935652,"function_name":"_es_build_output_data","code":"STATIC_FUNCTION\nchar* _es_build_output_data(iot_security_context_t *security_context, char *out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *encrypted_message = NULL;\n\tchar *output_data = NULL;\n\tJSON_H *root = NULL;\n\n\tif (!out_payload || !security_context) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\treturn NULL;\n\t}\n\n\terr = _encrypt_and_encode(security_context, (unsigned char*) out_payload, strlen(out_payload), \u0026encrypted_message);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"encrypt and encode fail 0x%x\", err);\n\t\tgoto out;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"message\", JSON_CREATE_STRING((char *) encrypted_message));\n\toutput_data = JSON_PRINT(root);\n\nout:\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\tif (encrypted_message) {\n\t\tiot_os_free(encrypted_message);\n\t}\n\n\treturn output_data;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"247198":{"score":0.887861,"function_name":"_es_deviceinfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_deviceinfo_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t iv_buf = { 0 };\n\tiot_security_cipher_params_t cipher_set_params = { 0 };\n\tsize_t base64_written = 0;\n\tsize_t encode_buf_len = 0;\n\tunsigned char *encode_buf = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid iot_context!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\treturn err;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"protocolVersion\", JSON_CREATE_STRING(STDK_D2D_PROTOCOL_VERSION));\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"firmwareVersion\", JSON_CREATE_STRING(ctx-\u003edevice_info.firmware_version));\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"hashedSn\", JSON_CREATE_STRING((char *)ctx-\u003edevconf.hashed_sn));\n\tJSON_ADD_NUMBER_TO_OBJECT(root, \"wifiSupportFrequency\", (double) iot_bsp_wifi_get_freq());\n\n\terr = _es_crypto_cipher_gen_iv(\u0026iv_buf);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to generate cipher iv!!\");\n\t\tgoto out;\n\t}\n\n\tcipher_set_params.type = IOT_SECURITY_KEY_TYPE_AES256;\n\tcipher_set_params.iv = iv_buf;\n\n\terr = iot_security_cipher_set_params(ctx-\u003eeasysetup_security_context, \u0026cipher_set_params);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to set cipher params\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CIPHER_PARAMS_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_CIPHER_PARAMS_ERROR;\n\t\tgoto out;\n\t}\n\n\tencode_buf_len = IOT_SECURITY_B64_ENCODE_LEN(iv_buf.len);\n\tif ((encode_buf = (unsigned char *)iot_os_malloc(encode_buf_len)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for encode_buf\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto out;\n\t}\n\n\terr = iot_security_base64_encode_urlsafe(iv_buf.p, iv_buf.len,\n\t\t\t\t\tencode_buf, encode_buf_len, \u0026base64_written);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"base64 encode error!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_BASE64_ENCODE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_BASE64_ENCODE_ERROR;\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"iv\", JSON_CREATE_STRING((char *)encode_buf));\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\nout:\n\tif (iv_buf.p)\n\t\tfree(iv_buf.p);\n\tif (encode_buf)\n\t\tfree(encode_buf);\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":361,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"251690":{"score":0.9182868,"function_name":"_es_confirm_check_manager","code":"STATIC_FUNCTION\niot_error_t _es_confirm_check_manager(struct iot_context *ctx, enum ownership_validation_feature confirm_feature, char *sn)\n{\n\tchar *dev_sn = NULL;\n\tunsigned char curr_event = 0;\n\tunsigned char is_qr = 0;\n\tsize_t devsn_len;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM | IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY);\n\tctx-\u003ecurr_otm_feature = confirm_feature;\n\n\tIOT_REMARK(\"IOT_STATE_PROV_CONFIRMING\");\n\n\terr = iot_state_update(ctx, IOT_STATE_PROV_CONFIRM,\n\t\t\tIOT_STATE_OPT_NEED_INTERACT);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed handle cmd (%d): %d\", IOT_STATE_PROV_CONFIRM, err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\tgoto out;\n\t}\n\n\tswitch (confirm_feature)\n\t{\n\t\tcase OVF_BIT_JUSTWORKS:\n\t\t\tIOT_INFO(\"There is no confirmation request. The check is skipped\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_JUSTWORK, 0);\n\t\t\tbreak;\n\t\tcase OVF_BIT_QR:\n\t\t\tis_qr = 1;\n\t\t\t// fall through\n\t\tcase OVF_BIT_SERIAL_NUMBER:\n\t\t\tIOT_INFO(\"The %s confirmation is requested\", is_qr ? \"QR code\" : \"serial number\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_QR, is_qr);\n\t\t\tif (sn == NULL) {\n\t\t\t\tIOT_ERROR(\"null serial number transferred\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_QR, is_qr);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_QR;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\terr = iot_nv_get_serial_number(\u0026dev_sn, \u0026devsn_len);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to load serial number\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SERIAL_NOT_FOUND, err);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_SERIAL_NOT_FOUND;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!strcmp(sn, dev_sn)) {\n\t\t\t\tIOT_INFO(\"confirm\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"confirm fail\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_SERIAL_NUMBER, is_qr);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_SERIAL_NUMBER;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OVF_BIT_BUTTON:\n\t\t\tIOT_INFO(\"The button confirmation is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_BUTTON, 0);\n\n\t\t\tcurr_event = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_CONFIRM | IOT_EVENT_BIT_EASYSETUP_CONFIRM_DENY, false, ES_CONFIRM_MAX_DELAY);\n\t\t\tIOT_DEBUG(\"curr_event = 0x%x\", curr_event);\n\n\t\t\tif (curr_event \u0026 IOT_EVENT_BIT_EASYSETUP_CONFIRM) {\n\t\t\t\tIOT_INFO(\"confirm\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_GET_OWNER_CONFIRM, 0);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"confirm failed\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CONFIRM_DENIED, 0);\n\n\t\t\t\t/* To report confirm failure to user, try to change iot-state timeout value shortly */\n\t\t\t\tif (iot_state_timeout_change(ctx, IOT_STATE_PROV_CONFIRM, ES_CONFIRM_FAIL_TIMEOUT) != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"Can't update prov_confirm state timeout\");\n\t\t\t\t}\n\n\t\t\t\terr = IOT_ERROR_EASYSETUP_CONFIRM_DENIED;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OVF_BIT_PIN:\n\t\t\tIOT_INFO(\"The pin number confirmation is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_PIN, 0);\n\t\t\treturn err;\n\t\tdefault:\n\t\t\tIOT_INFO(\"Not Supported confirmation type is requested\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_OTMTYPE_NOT_SUPPORTED, 0);\n\t\t\treturn err;\n\t}\n\nout:\n\tif (dev_sn)\n\t\tfree(dev_sn);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":712,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"252663":{"score":0.8983271,"function_name":"_es_confirminfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_confirminfo_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *recv = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *in_payload = NULL;\n\tchar *out_payload = NULL;\n\n\tif (!ctx || !input_data) {\n\t\tIOT_ERROR(\"Invalid data is reported\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\tif (!in_payload) {\n\t\tIOT_ERROR(\"Failed to get input payload\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(root, \"otmSupportFeature\")) == NULL) {\n\t\tIOT_ERROR(\"no otmsupportfeature info\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tIOT_INFO(\"otmSupportFeature = %d\", recv-\u003evalueint);\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_REPORTED_OTMTYPE, recv-\u003evalueint);\n\n\tif ((recv-\u003evalueint \u003e= OVF_BIT_JUSTWORKS) \u0026\u0026 (recv-\u003evalueint \u003c= OVF_BIT_SERIAL_NUMBER)) {\n\t\tchar *sn = NULL;\n\n\t\tif (recv-\u003evalueint == OVF_BIT_QR || recv-\u003evalueint == OVF_BIT_SERIAL_NUMBER)\n\t\t\tsn = _es_json_parse_string(root, \"sn\");\n\n\t\terr = _es_confirm_check_manager(ctx, recv-\u003evalueint, sn);\n\n\t\tif (sn) {\n\t\t\tiot_os_free(sn);\n\t\t}\n\t\tif (err != IOT_ERROR_NONE)\n\t\t\tgoto out;\n\t} else {\n\t\tIOT_ERROR(\"Not supported otmsupportfeature : %d\", recv-\u003evalueint);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CONFIRM_NOT_SUPPORT, recv-\u003evalueint);\n\t\terr = IOT_ERROR_EASYSETUP_CONFIRM_NOT_SUPPORT ;\n\t\tgoto out;\n\t}\n\tJSON_DELETE(root);\n\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (in_payload) {\n\t\tiot_os_free(in_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":811,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"253447":{"score":0.8710439,"function_name":"_es_confirm_handler","code":"STATIC_FUNCTION\niot_error_t _es_confirm_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tbool validation = true;\n\tchar pin[PIN_SIZE + 1];\n\tJSON_H *recv = NULL;\n\tJSON_H *root = NULL;\n\tint i;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\tchar *in_payload = NULL;\n\n\tif (!ctx || !ctx-\u003epin) {\n\t\tIOT_ERROR(\"no pin from device app\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_PIN_NOT_FOUND, 0);\n\t\terr = IOT_ERROR_EASYSETUP_PIN_NOT_FOUND;\n\t\treturn err;\n\t}\n\n\tif (ctx-\u003ecurr_otm_feature != OVF_BIT_PIN) {\n\t\tIOT_ERROR(\"otm is not pin.\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t\treturn err;\n\t}\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\tif (!in_payload) {\n\t\tIOT_ERROR(\"Failed to get input payload\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif ((recv = JSON_GET_OBJECT_ITEM(root, \"pin\")) == NULL) {\n\t\tIOT_ERROR(\"no pin info\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto out;\n\t}\n\n\tif (strlen(JSON_GET_STRING_VALUE(recv)) != PIN_SIZE) {\n\t\tIOT_ERROR(\"pin size mistmatch\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_PIN, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_PIN;\n\t\tgoto out;\n\t}\n\n\tstrncpy(pin, recv-\u003evaluestring, sizeof(pin) - 1);\n\tpin[PIN_SIZE] = '\\0';\n\tIOT_INFO(\"pin = %s\", pin);\n\tfor (i = 0; i \u003c PIN_SIZE; i++) {\n\t\tif (pin[i] \u003e '9' || pin[i] \u003c '0') {\n\t\t\tIOT_ERROR(\"invalid pin number from application\");\n\t\t\tvalidation = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!validation) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_PIN, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_PIN;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i \u003c PIN_SIZE; i++) {\n\t\tif (ctx-\u003epin-\u003epin[i] != pin[i]) {\n\t\t\tIOT_ERROR(\"the reported pin number is not matched[%d]\", i);\n\t\t\tvalidation = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!validation) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_PIN_NOT_MATCHED, 0);\n\t\terr = IOT_ERROR_EASYSETUP_PIN_NOT_MATCHED;\n\t\tgoto out;\n\t}\n\tJSON_DELETE(root);\n\n\t/*\n\t * output payload\n\t */\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tfree(out_payload);\n\t}\n\tif (in_payload) {\n\t\tfree(in_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":897,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"254517":{"score":0.9115299,"function_name":"_es_wifiscaninfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_wifiscaninfo_handler(struct iot_context *ctx, char **output_data)\n{\n\tchar wifi_bssid[WIFIINFO_BUFFER_SIZE] = {0, };\n\tJSON_H *root = NULL;\n\tJSON_H *array = NULL;\n\tJSON_H *array_obj = NULL;\n\tint i;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid iot_context!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\treturn err;\n\t}\n\n\t//optional : some chipsets don't support wifi scan mode during working AP mode\n\terr = iot_wifi_ctrl_request(ctx, IOT_WIFI_MODE_SCAN);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_INFO(\"Can't control WIFI mode scan.(%d)\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_WIFI_SCAN_NOT_FOUND, err);\n\t}\n\n\tif (!ctx-\u003escan_num) {\n\t\tIOT_ERROR(\"wifi AP isn't found!!\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_SCAN_NOT_FOUND, ctx-\u003escan_num);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_SCAN_NOT_FOUND;\n\t\treturn err;\n\t}\n\n\tarray = JSON_CREATE_ARRAY();\n\tif (!array) {\n\t\tIOT_ERROR(\"json_array create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\treturn err;\n\t}\n\n\tfor(i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\tif ((ctx-\u003escan_result[i].authmode \u003c  IOT_WIFI_AUTH_OPEN) ||\n\t\t\t(ctx-\u003escan_result[i].authmode \u003e= IOT_WIFI_AUTH_WPA2_ENTERPRISE)) {\n\t\t\tIOT_DEBUG(\"Unsupported authType %d, %s\", ctx-\u003escan_result[i].authmode,\n\t\t\t\t\t\t\t\t(char *)ctx-\u003escan_result[i].ssid);\n\t\t\tcontinue;\n\t\t}\n\t\tsnprintf(wifi_bssid, sizeof(wifi_bssid), \"%02X:%02X:%02X:%02X:%02X:%02X\",\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[0], ctx-\u003escan_result[i].bssid[1],\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[2], ctx-\u003escan_result[i].bssid[3],\n\t\t\t\t\t\tctx-\u003escan_result[i].bssid[4], ctx-\u003escan_result[i].bssid[5]);\n\n\t\tarray_obj = JSON_CREATE_OBJECT();\n\t\tif (!array_obj) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tif (array) {\n\t\t\t\tJSON_DELETE(array);\n\t\t\t}\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(array_obj, \"bssid\", JSON_CREATE_STRING(wifi_bssid));\n\t\tJSON_ADD_ITEM_TO_OBJECT(array_obj, \"ssid\", JSON_CREATE_STRING((char*)ctx-\u003escan_result[i].ssid));\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"rssi\", (double) ctx-\u003escan_result[i].rssi);\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"frequency\", (double) ctx-\u003escan_result[i].freq);\n\t\tJSON_ADD_NUMBER_TO_OBJECT(array_obj, \"authType\", ctx-\u003escan_result[i].authmode);\n\t\tJSON_ADD_ITEM_TO_ARRAY(array, array_obj);\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tif (array) {\n\t\t\tJSON_DELETE(array);\n\t\t}\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"wifiScanInfo\", array);\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tfree(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1010,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"255810":{"score":0.90027755,"function_name":"_decide_wifi_auth_mode","code":"STATIC_FUNCTION\niot_wifi_auth_mode_t _decide_wifi_auth_mode(const JSON_H *item, struct iot_wifi_prov_data *wifi_prov, const struct iot_context *ctx)\n{\n\tiot_wifi_auth_mode_t auth_mode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\tint i;\n\n\tif (!ctx || !wifi_prov) {\n\t\treturn IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t}\n\n\tif (item == NULL) {\n\t\tIOT_INFO(\"no authType\");\n\t\tfor (i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\t\tif (!strcmp(wifi_prov-\u003essid, (char *)ctx-\u003escan_result[i].ssid)) {\n\t\t\t\tauth_mode = ctx-\u003escan_result[i].authmode;\n\t\t\t\tIOT_DEBUG(\"%s is type %d\", wifi_prov-\u003essid, auth_mode);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ctx-\u003escan_num) {\n\t\t\tif (strlen(wifi_prov-\u003epassword) == 0) {\n\t\t\t\tIOT_DEBUG(\"%s doesn't exist in scan list. So assume it as Open\", wifi_prov-\u003essid);\n\t\t\t\tauth_mode = IOT_WIFI_AUTH_OPEN;\n\t\t\t} else {\n\t\t\t\tIOT_DEBUG(\"%s doesn't exist in scan list. So assume it as WPA\", wifi_prov-\u003essid);\n\t\t\t\tauth_mode = IOT_WIFI_AUTH_WPA_WPA2_PSK;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i \u003c ctx-\u003escan_num; i++) {\n\t\t\tif (!strcmp(wifi_prov-\u003essid, (char *)ctx-\u003escan_result[i].ssid)) {\n\t\t\t\tif (item-\u003evalueint == ctx-\u003escan_result[i].authmode) {\n\t\t\t\t\tauth_mode = item-\u003evalueint;\n\t\t\t\t} else {\n\t\t\t\t\tauth_mode = ctx-\u003escan_result[i].authmode;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == ctx-\u003escan_num) {\n\t\t\tauth_mode = item-\u003evalueint;\n\t\t}\n\t\tIOT_DEBUG(\"%s is type %d\", wifi_prov-\u003essid, auth_mode);\n\t}\n\n\treturn auth_mode;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1104,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"256272":{"score":0.909702,"function_name":"_es_wifi_prov_parse","code":"STATIC_FUNCTION\niot_error_t _es_wifi_prov_parse(struct iot_context *ctx, char *in_payload)\n{\n\tstruct iot_wifi_prov_data *wifi_prov = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *root = NULL;\n\tJSON_H *wifi_credential = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid args\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tif ((wifi_credential = JSON_GET_OBJECT_ITEM(root, \"wifiCredential\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find wifiCredential\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tif ((wifi_prov = (struct iot_wifi_prov_data *)malloc(sizeof(struct iot_wifi_prov_data))) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for wifi_prov_data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tmemset(wifi_prov, 0, sizeof(struct iot_wifi_prov_data));\n\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"ssid\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find ssid\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto wifi_parse_out;\n\t}\n\tstrncpy(wifi_prov-\u003essid, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003essid) - 1);\n\n\t// password is optional.\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"password\")) == NULL)\n\t\tIOT_INFO(\"No wifi password\");\n\telse\n\t\tstrncpy(wifi_prov-\u003epassword, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003epassword) - 1);\n\n\tif ((item = JSON_GET_OBJECT_ITEM(wifi_credential, \"macAddress\")) == NULL) {\n\t\tIOT_INFO(\"no macAddress\");\n\t} else {\n\t\tstrncpy(wifi_prov-\u003emac_str, JSON_GET_STRING_VALUE(item), sizeof(wifi_prov-\u003emac_str));\n\t\terr = iot_util_convert_str_mac(wifi_prov-\u003emac_str, \u0026wifi_prov-\u003ebssid);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"Failed to convert str to mac address (error : %d) : %s\", err, wifi_prov-\u003emac_str);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_MAC, err);\n\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_MAC;\n\t\t\tgoto wifi_parse_out;\n\t\t}\n\t}\n\n\n\twifi_prov-\u003esecurity_type =\n\t\t_decide_wifi_auth_mode(JSON_GET_OBJECT_ITEM(wifi_credential, \"authType\"), wifi_prov, ctx);\n\n\terr = iot_nv_set_wifi_prov_data(wifi_prov);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to set the cloud prov data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_DATA_WRITE_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_DATA_WRITE_FAIL;\n\t\tgoto wifi_parse_out;\n\t}\n\n\tIOT_INFO(\"ssid: %s\", wifi_prov-\u003essid);\n\tIOT_DEBUG(\"password: %s\", wifi_prov-\u003epassword);\n\tIOT_INFO(\"mac addr: %s\", wifi_prov-\u003emac_str);\n\nwifi_parse_out:\n\tif (wifi_prov)\n\t\tfree(wifi_prov);\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1152,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"257255":{"score":0.9184811,"function_name":"_es_cloud_prov_parse","code":"STATIC_FUNCTION\niot_error_t _es_cloud_prov_parse(struct iot_context *ctx, char *in_payload)\n{\n\tstruct iot_cloud_prov_data *cloud_prov = NULL;\n\tchar *full_url = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\turl_parse_t url = { .protocol = NULL, .domain = NULL, .port = 0};\n\n\troot = JSON_PARSE(in_payload);\n\tif (!root) {\n\t\tIOT_ERROR(\"Invalid payload json format\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tif ((cloud_prov = (struct iot_cloud_prov_data *)malloc(sizeof(struct iot_cloud_prov_data))) == NULL) {\n\t\tIOT_ERROR(\"failed to alloc mem\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tmemset(cloud_prov, 0, sizeof(struct iot_cloud_prov_data));\n\n\tif ((full_url = _es_json_parse_string(root, \"brokerUrl\")) == NULL) {\n\t\tIOT_ERROR(\"failed to find brokerUrl\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\tgoto cloud_parse_out;\n\t}\n\n\terr = iot_util_url_parse(full_url, \u0026url);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse broker url\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_BROKER_URL, err);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_BROKER_URL;\n\t\tgoto cloud_parse_out;\n\t}\n\n\tif ((cloud_prov-\u003elabel = _es_json_parse_string(root, \"deviceName\")) == NULL) {\n\t\tIOT_INFO(\"No deviceName\");\n\t}\n\n\tcloud_prov-\u003ebroker_url = url.domain;\n\tcloud_prov-\u003ebroker_port = url.port;\n\n\terr = iot_nv_set_cloud_prov_data(cloud_prov);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to set the cloud prov data\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CLOUD_DATA_WRITE_FAIL, err);\n\t\tcloud_prov-\u003ebroker_port = 0;\n\t\terr = IOT_ERROR_EASYSETUP_CLOUD_DATA_WRITE_FAIL;\n\t\tgoto cloud_prov_data_fail;\n\t}\n\n\tIOT_INFO(\"brokerUrl: %s:%d\", cloud_prov-\u003ebroker_url, cloud_prov-\u003ebroker_port);\n\tIOT_INFO(\"deviceName : %s\", cloud_prov-\u003elabel);\n\ncloud_prov_data_fail:\n\tif (cloud_prov-\u003elabel) {\n\t\tiot_os_free(cloud_prov-\u003elabel);\n\t}\ncloud_parse_out:\n\tif (url.domain) {\n\t\tiot_os_free(url.domain);\n\t}\n\tif (url.protocol) {\n\t\tiot_os_free(url.protocol);\n\t}\n\tif (full_url) {\n\t\tiot_os_free(full_url);\n\t}\n\tif (cloud_prov) {\n\t\tiot_os_free(cloud_prov);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1236,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258103":{"score":0.9261129,"function_name":"_es_wifiprovisioninginfo_handler","code":"STATIC_FUNCTION\niot_error_t _es_wifiprovisioninginfo_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *in_payload = NULL;\n\tchar *out_payload = NULL;\n\n\tin_payload = _es_parse_input_data(ctx-\u003eeasysetup_security_context, input_data);\n\n\terr = _es_wifi_prov_parse(ctx, (char *)in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse wifi_prov\");\n\t\tgoto out;\n\t}\n\n\terr = _es_cloud_prov_parse(ctx, (char *)in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"failed to parse cloud_prov\");\n\t\tgoto out;\n\t}\n\n\tif (ctx-\u003elookup_id == NULL) {\n\t\tctx-\u003elookup_id = iot_os_malloc(IOT_REG_UUID_STR_LEN + 1);\n\t}\n\n\terr = iot_get_random_id_str(ctx-\u003elookup_id,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get new lookup_id(%d)\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_LOOKUPID_GENERATE_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_LOOKUPID_GENERATE_FAIL;\n\t\tgoto out;\n\t}\n\n\tIOT_DEBUG(\"lookupid = %s\", ctx-\u003elookup_id);\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"lookupId\", JSON_CREATE_STRING(ctx-\u003elookup_id));\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\n\n\t/* Now we allow D2D process reentrant and prov_data could be loaded\n\t * at the init state or previous D2D, so free it first to avoid memory-leak\n\t */\n\tiot_api_prov_data_mem_free(\u0026ctx-\u003eprov_data);\n\terr = iot_nv_get_prov_data(\u0026ctx-\u003eprov_data);\n\tif (err) {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_WIFI_DATA_READ_FAIL, err);\n\t\terr = IOT_ERROR_EASYSETUP_WIFI_DATA_READ_FAIL;\n\t\tIOT_WARN(\"No provisining from nv\");\n\t} else {\n\t\tIOT_INFO(\"provisioning success\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_PROVISIONING_SUCCESS, 0);\n\t}\nout:\n\tif (in_payload) {\n\t\tiot_os_free(in_payload);\n\t}\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1319,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258795":{"score":0.85390544,"function_name":"_es_setupcomplete_handler","code":"STATIC_FUNCTION\niot_error_t _es_setupcomplete_handler(struct iot_context *ctx, char *input_data, char **output_data)\n{\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tchar *out_payload = NULL;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\tout_payload = JSON_PRINT(root);\n\t*output_data = _es_build_output_data(ctx-\u003eeasysetup_security_context, out_payload);\nout:\n\tif (out_payload) {\n\t\tiot_os_free(out_payload);\n\t}\n\tif (root) {\n\t\tJSON_DELETE(root);\n\t}\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1394,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"258992":{"score":0.86058265,"function_name":"_es_log_systeminfo_handler","code":"static iot_error_t _es_log_systeminfo_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"version\", JSON_CREATE_STRING(\"1.0\"));\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\n\nout:\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1421,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259186":{"score":0.8526932,"function_name":"_es_log_create_dump_handler","code":"static iot_error_t _es_log_create_dump_handler(struct iot_context *ctx, char *in_payload, char **out_payload)\n{\n\tchar *output_ptr = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\n\nout:\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1447,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259340":{"score":0.85252726,"function_name":"_es_log_get_dump_handler","code":"static iot_error_t _es_log_get_dump_handler(struct iot_context *ctx, char **out_payload)\n{\n\tchar *log_dump = NULL;\n\tchar *output_ptr = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *root = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tchar *sumo_dump = NULL;\n\tsize_t log_dump_size = 2048;\n\tsize_t sumo_dump_size = 200;\n\tsize_t written_size = 0;\n#endif\n\n\titem = JSON_CREATE_OBJECT();\n\tif (!item) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_JSON_CREATE_ERROR;\n\t\tgoto out;\n\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tlog_dump = iot_debug_get_log();\n#else\n\terr = st_create_log_dump((IOT_CTX *)ctx, \u0026log_dump, log_dump_size, \u0026written_size, IOT_DUMP_MODE_NEED_BASE64 | IOT_DUMP_MODE_NEED_DUMP_STATE);\n\tif (err \u003c 0) {\n\t\tIOT_ERROR(\"Fail to get log dump!\\n\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CREATE_LOGDUMP_FAIL, 0);\n\t\tgoto out;\n\t}\n\terr = st_create_log_dump((IOT_CTX *)ctx, \u0026sumo_dump, sumo_dump_size, \u0026written_size, IOT_DUMP_MODE_NEED_BASE64);\n\tif (err \u003c 0) {\n\t\tIOT_ERROR(\"Fail to get sumo dump!\\n\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CREATE_SUMODUMP_FAIL, 0);\n\t\tgoto out;\n\t}\n#endif\n\n\tJSON_ADD_NUMBER_TO_OBJECT(item, \"code\", 1);\n\tJSON_ADD_ITEM_TO_OBJECT(item, \"message\", JSON_CREATE_STRING(log_dump));\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tJSON_ADD_ITEM_TO_OBJECT(item, \"sumomessage\", JSON_CREATE_STRING(sumo_dump));\n#endif\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"json create failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\terr = IOT_ERROR_EASYSETUP_MEM_ALLOC_ERROR;\n\t\tif (item) {\n\t\t\tJSON_DELETE(item);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"error\", item);\n\n\toutput_ptr = JSON_PRINT(root);\n\n\t*out_payload = output_ptr;\nout:\n#if !defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tif (log_dump)\n\t\tfree(log_dump);\n\tif (sumo_dump)\n\t\tfree(sumo_dump);\n#endif\n\tif (root)\n\t\tJSON_DELETE(root);\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1471,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"259993":{"score":0.9011893,"function_name":"iot_easysetup_request_handler","code":"iot_error_t iot_easysetup_request_handler(struct iot_context *ctx, struct iot_easysetup_payload request)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tint ret = IOT_OS_TRUE;\n\tstruct iot_easysetup_payload response;\n\n\tif (!ctx)\n\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\n\tresponse.step = request.step;\n\tresponse.payload = NULL;\n\n\tswitch (request.step) {\n\tcase IOT_EASYSETUP_STEP_DEVICEINFO:\n\t\terr = _es_deviceinfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_WIFISCANINFO:\n\t\terr = _es_wifiscaninfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_KEYINFO:\n\t\terr = _es_keyinfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_CONFIRMINFO:\n\t\terr = _es_confirminfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_CONFIRM:\n\t\terr = _es_confirm_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO:\n\t\terr = _es_wifiprovisioninginfo_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_SETUPCOMPLETE:\n\t\terr = _es_setupcomplete_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_SYSTEMINFO:\n\t\terr = _es_log_systeminfo_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_CREATE_DUMP:\n\t\terr = _es_log_create_dump_handler(ctx, request.payload, \u0026response.payload);\n\t\tbreak;\n\tcase IOT_EASYSETUP_STEP_LOG_GET_DUMP:\n\t\terr = _es_log_get_dump_handler(ctx, \u0026response.payload);\n\t\tbreak;\n\tdefault:\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\tbreak;\n\t}\n\tif (err) {\n\t\tIOT_ERROR(\"failed to handle step %d (%d)\", request.step, err);\n\t}\n\n\tresponse.err = err;\n\n\tif (ctx-\u003eeasysetup_resp_queue) {\n\t\tret = iot_os_queue_send(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\t\tif (ret != IOT_OS_TRUE) {\n\t\t\tIOT_ERROR(\"Cannot put the response into easysetup_resp_queue\");\n\t\t\terr = IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR;\n\t\t} else {\n\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP);\n\t\t\terr = IOT_ERROR_NONE;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"easysetup_resp_queue is deleted\");\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t}\n\n\treturn err;\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_d2d_tcp.c","line_number":1544,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"262022":{"score":0.90669096,"function_name":"_iot_easysetup_gen_get_payload","code":"STATIC_FUNCTION\niot_error_t _iot_easysetup_gen_get_payload(struct iot_context *ctx, int cmd, char **out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload response;\n\tint cur_step;\n\tunsigned char curr_event;\n\tint ret;\n\n\tif (cmd == IOT_EASYSETUP_INVALID_STEP) {\n\t\tIOT_ERROR(\"Invalid command %d\", cmd);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, cmd);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t\tgoto get_exit;\n\t}\n\n\tcur_step = cmd;\n\n\tif (cur_step == IOT_EASYSETUP_STEP_DEVICEINFO) {\n\t\terr = iot_state_update(ctx, IOT_STATE_PROV_CONN_MOBILE, 0);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed handle cmd (%d): %d\", IOT_STATE_PROV_CONN_MOBILE, err);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err);\n\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\tgoto fail_status_update;\n\t\t}\n\t}\n\n\tif ((cur_step != ref_step) \u0026\u0026 (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)) {\n\t\tif ((cur_step == IOT_EASYSETUP_STEP_WIFISCANINFO) \u0026\u0026 (ref_step == IOT_EASYSETUP_STEP_CONFIRM)) {\n\t\t\tref_step = IOT_EASYSETUP_STEP_WIFISCANINFO;\n\t\t} else if ((cur_step == IOT_EASYSETUP_STEP_WIFISCANINFO) \u0026\u0026 (ref_step == IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO)) {\n\t\t\tref_step = IOT_EASYSETUP_STEP_WIFISCANINFO;\n\t\t} else {\n\t\t\tIOT_ERROR(\"Invalid command step %d\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, cmd);\n\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t\t\tgoto get_exit;\n\t\t}\n\t}\n\n\tif (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)\n\t\tref_step++;\n\telse\n\t\tref_step = 0;\n\n\terr = iot_easysetup_request(ctx, cur_step, NULL);\n\tif (err) {\n\t\tIOT_ERROR(\"easysetup request failed %d (%d)\", cur_step, err);\n\t\tif (err == IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR) {\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_QUEUE_FAIL, 1);\n\t\t} else {\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err);\n\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tgoto get_exit;\n\t}\n\tIOT_INFO(\"waiting.. response for [%d]\", cmd);\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_WAIT_RESPONSE, cmd);\n\tcurr_event = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP, true, IOT_OS_MAX_DELAY);\n\tif (curr_event \u0026 IOT_EVENT_BIT_EASYSETUP_RESP) {\n\t\tIOT_DEBUG(\"easysetup response for [%d]\", cmd);\n\t} else {\n\t\tIOT_ERROR(\"unexpected event for [%d]: 0x%x\", cmd, curr_event);\n\t}\n\tret = iot_os_queue_receive(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\tif ((ret == IOT_OS_TRUE) \u0026\u0026 (response.step != cur_step)) {\n\t\tIOT_ERROR(\"unexpected response %d:%d\", cur_step, response.step);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, response.step);\n\t\tif (response.payload)\n\t\t\tfree(response.payload);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t} else if (ret == IOT_OS_TRUE) {\n\t\tif (!response.err) {\n\t\t\t*out_payload = response.payload;\n\t\t\tIOT_DEBUG(\"payload: %s\", *out_payload);\n\t\t}\n\t\terr = response.err;\n\t} else {\n\t\tIOT_ERROR(\"easysetup response queue receive failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_QUEUE_FAIL, 0);\n\t\terr = IOT_ERROR_EASYSETUP_QUEUE_RECV_ERROR;\n\t}\n\nfail_status_update:\n\tif (err) {\n\t\tiot_error_t err1;\n\t\tref_step = 0;\n\t\tif (cur_step \u003e= IOT_EASYSETUP_STEP_LOG_SYSTEMINFO) {\n\t\t\terr1 = iot_state_update(ctx, IOT_STATE_CHANGE_FAILED, ctx-\u003ecurr_state);\n\t\t\tif (err1) {\n\t\t\t\tIOT_ERROR(\"cannot update state to failed (%d)\", err1);\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err1);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\nget_exit:\n\treturn err;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":94,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"262958":{"score":0.90969723,"function_name":"_iot_easysetup_gen_post_payload","code":"STATIC_FUNCTION\niot_error_t _iot_easysetup_gen_post_payload(struct iot_context *ctx, int cmd, char *in_payload, char **out_payload)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload response;\n\tint cur_step;\n\tunsigned char curr_event;\n\tint ret;\n\n\tif (!in_payload \u0026\u0026 cmd != IOT_EASYSETUP_STEP_SETUPCOMPLETE \u0026\u0026 cmd != IOT_EASYSETUP_STEP_LOG_CREATE_DUMP) {\n\t\tIOT_ERROR(\"Invalid payload\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_REQUEST, 0);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_REQUEST;\n\t\treturn err;\n\t}\n\n\tif (cmd == IOT_EASYSETUP_INVALID_STEP) {\n\t\tIOT_ERROR(\"Invalid command %d\", cmd);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, cmd);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t\tgoto post_exit;\n\t}\n\n\tcur_step = cmd;\n\n\tif ((cur_step != ref_step) \u0026\u0026 (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)) {\n\t\tif (cur_step == IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO) {\n\t\t   if ((ref_step == IOT_EASYSETUP_STEP_CONFIRM) || (ref_step == IOT_EASYSETUP_STEP_CONFIRMINFO))\n\t\t\t   ref_step = IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO;\n\t\t   else {\n\t\t\t   IOT_ERROR(\"Invalid command sequence %d\", cmd);\n\t\t\t   IOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_SEQUENCE, cmd);\n\t\t\t   err = IOT_ERROR_EASYSETUP_INVALID_SEQUENCE;\n\t\t\t   goto post_exit;\n\t\t   }\n\t\t} else {\n\t\t\tIOT_ERROR(\"Invalid command sequence %d\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_SEQUENCE, cmd);\n\t\t\terr = IOT_ERROR_EASYSETUP_INVALID_SEQUENCE;\n\t\t\tgoto post_exit;\n\t\t}\n\t}\n\n\tif (cur_step \u003c IOT_EASYSETUP_STEP_LOG_SYSTEMINFO)\n\t\tref_step++;\n\telse\n\t\tref_step = 0;\n\n\terr = iot_easysetup_request(ctx, cur_step, in_payload);\n\tif (err) {\n\t\tIOT_ERROR(\"easysetup request failed %d (%d)\", cur_step, err);\n\t\tif (err == IOT_ERROR_EASYSETUP_QUEUE_SEND_ERROR) {\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_QUEUE_FAIL, 1);\n\t\t} else {\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err);\n\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t\tgoto post_exit;\n\t}\n\tIOT_INFO(\"waiting.. response for [%d]\", cmd);\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_WAIT_RESPONSE, cmd);\n\n\tcurr_event = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_EASYSETUP_RESP, true, IOT_OS_MAX_DELAY);\n\tif (curr_event \u0026 IOT_EVENT_BIT_EASYSETUP_RESP) {\n\t\tIOT_DEBUG(\"easysetup response for [%d]\", cmd);\n\t} else {\n\t\tIOT_ERROR(\"unexpected event for [%d]: 0x%x\", cmd, curr_event);\n\t}\n\n\tret = iot_os_queue_receive(ctx-\u003eeasysetup_resp_queue, \u0026response, 0);\n\tif ((ret == IOT_OS_TRUE) \u0026\u0026 (response.step != cur_step)) {\n\t\tIOT_ERROR(\"unexpected response %d:%d\", cur_step, response.step);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, response.step);\n\t\tif (response.payload)\n\t\t\tfree(response.payload);\n\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t} else if (ret == IOT_OS_TRUE) {\n\t\tif (!response.err) {\n\t\t\t*out_payload = response.payload;\n\t\t\tIOT_DEBUG(\"payload: %s\", *out_payload);\n\t\t}\n\t\terr = response.err;\n\t} else {\n\t\tIOT_ERROR(\"easysetup response queue receive failed\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_QUEUE_FAIL, 0);\n\t\terr = IOT_ERROR_EASYSETUP_QUEUE_RECV_ERROR;\n\t}\n\n\tif (err) {\n\t\tiot_error_t err1;\n\t\tref_step = 0;\n\t\tif (cur_step \u003e= IOT_EASYSETUP_STEP_LOG_SYSTEMINFO) {\n\t\t\terr1 = iot_state_update(ctx, IOT_STATE_CHANGE_FAILED, ctx-\u003ecurr_state);\n\t\t\tif (err1) {\n\t\t\t\tIOT_ERROR(\"cannot update state to failed (%d)\", err1);\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err1);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tiot_error_t err1;\n\t\tswitch (cur_step) {\n\t\tcase IOT_EASYSETUP_STEP_SETUPCOMPLETE:\n\t\t\terr1 = iot_state_update(ctx, IOT_STATE_PROV_DONE, 0);\n\t\t\tif (err1) {\n\t\t\t\tIOT_ERROR(\"cannot update state to prov_done (%d)\", err1);\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, err1);\n\t\t\t\terr = IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IOT_EASYSETUP_STEP_CONFIRMINFO:\n\t\tcase IOT_EASYSETUP_STEP_CONFIRM:\n\t\tcase IOT_EASYSETUP_STEP_WIFIPROVIONINGINFO:\n\t\t\tbreak;\n\t\t}\n\t}\npost_exit:\n\treturn err;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":207,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"264051":{"score":0.808375,"function_name":"_is_400_error","code":"static inline bool _is_400_error(iot_error_t err)\n{\n\tif (err \u003c= IOT_ERROR_EASYSETUP_400_BASE\n\t\t\u0026\u0026 err \u003e IOT_ERROR_EASYSETUP_500_BASE)\n\t\treturn true;\n\telse\n\t\treturn false;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":327,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"264096":{"score":0.9238256,"function_name":"digit_count_payload","code":"unsigned int digit_count_payload (unsigned int payload_len)\n{\n\tunsigned int count = 0;\n\n\twhile (1)\n\t{\n\t\tpayload_len /= 10;\n\t\tcount++;\n\t\tif (!payload_len)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":336,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"264155":{"score":0.88776845,"function_name":"http_msg_handler","code":"void http_msg_handler(int cmd, char **buffer, enum cgi_type type, char* data_buf)\n{\n\tunsigned int buffer_len, payload_len;\n\tchar *buf = NULL;\n\tchar *payload = NULL;\n\tchar *ptr = NULL;\n\tcJSON *root = NULL;\n\tcJSON *item = NULL;\n\tiot_error_t err = IOT_ERROR_NONE;\n\n\tif (type == D2D_POST) {\n\t\terr = _iot_easysetup_gen_post_payload(context, cmd, data_buf, \u0026payload);\n\t\tif (!err) {\n\t\t\tpayload_len = strlen(payload);\n\t\t\tbuffer_len = payload_len + strlen(http_status_200) + strlen(http_header) + digit_count_payload(payload_len) + strlen(END_OF_HTTP_HEADER) + 1;\n\t\t\tbuf = malloc(buffer_len);\n\t\t\tif (!buf) {\n\t\t\t\tIOT_ERROR(\"failed to malloc buffer for the post msg\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\t\t\tgoto cgi_out;\n\t\t\t}\n\t\t\tsnprintf(buf, buffer_len, \"%s%s%u%s%s\",\n\t\t\t\t\thttp_status_200, http_header, payload_len, END_OF_HTTP_HEADER, payload);\n\t\t\tIOT_INFO(\"post cmd[%d] ok\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_CMD_SUCCESS, cmd);\n\t\t} else {\n\t\t\tIOT_INFO(\"post cmd[%d] not ok\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CMD_FAIL, cmd);\n\t\t}\n\t} else if (type == D2D_GET) {\n\t\terr = _iot_easysetup_gen_get_payload(context, cmd, \u0026payload);\n\t\tif (!err) {\n\t\t\tpayload_len = strlen(payload);\n\t\t\tbuffer_len = payload_len + strlen(http_status_200) + strlen(http_header) + digit_count_payload(payload_len) + strlen(END_OF_HTTP_HEADER) + 1;\n\t\t\tbuf = malloc(buffer_len);\n\t\t\tif (!buf) {\n\t\t\t\tIOT_ERROR(\"failed to malloc buffer for the get msg\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\t\t\tgoto cgi_out;\n\t\t\t}\n\t\t\tsnprintf(buf, buffer_len, \"%s%s%u%s%s\",\n\t\t\t\t\t\thttp_status_200, http_header, payload_len, END_OF_HTTP_HEADER, payload);\n\t\t\tIOT_INFO(\"get cmd[%d] ok\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_CMD_SUCCESS, cmd);\n\t\t} else {\n\t\t\tIOT_INFO(\"get cmd[%d] not ok\", cmd);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CMD_FAIL, cmd);\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"Not supported curl message type : %d\", type);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INVALID_CMD, type);\n\t\terr = IOT_ERROR_EASYSETUP_INVALID_CMD;\n\t}\n\n\tif (err) {\n\t\titem = cJSON_CreateObject();\n\t\tif (!item) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\t\tgoto cgi_out;\n\t\t}\n\t\tcJSON_AddItemToObject(item, \"code\", cJSON_CreateNumber((double) -(err)));\n\t\troot = cJSON_CreateObject();\n\t\tif (!root) {\n\t\t\tIOT_ERROR(\"json create failed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_JSON_CREATE_ERROR, 0);\n\t\t\tcJSON_Delete(item);\n\t\t\tgoto cgi_out;\n\t\t}\n\t\tcJSON_AddItemToObject(root, \"error\", (cJSON *)item);\n\n\t\tptr = cJSON_PrintUnformatted(root);\n\t\tIOT_DEBUG(\"%s\", ptr);\n\n\t\tpayload_len = strlen(ptr);\n\t\tbuffer_len = strlen(http_header) + digit_count_payload(payload_len) + payload_len + strlen(END_OF_HTTP_HEADER) + 1;\n\t\tif (_is_400_error(err)) {\n\t\t\tbuffer_len += strlen(http_status_400);\n\t\t\tbuf = malloc(buffer_len);\n\t\t\tif (!buf) {\n\t\t\t\tIOT_ERROR(\"failed to malloc buffer for the error msg\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\t\t\tgoto cgi_out;\n\t\t\t}\n\t\t\tsnprintf(buf, buffer_len, \"%s%s%u%s%s\",\n\t\t\t\thttp_status_400, http_header, payload_len, END_OF_HTTP_HEADER, ptr);\n\t\t} else {\n\t\t\tbuffer_len += strlen(http_status_500);\n\t\t\tbuf = malloc(buffer_len);\n\t\t\tif (!buf) {\n\t\t\t\tIOT_ERROR(\"failed to malloc buffer for the error msg\");\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\t\t\tgoto cgi_out;\n\t\t\t}\n\t\t\tsnprintf(buf, buffer_len, \"%s%s%u%s%s\",\n\t\t\t\thttp_status_500, http_header, payload_len, END_OF_HTTP_HEADER, ptr);\n\t\t}\n\t}\n\tIOT_DEBUG(\"%s\", buf);\n\t*buffer = buf;\n\ncgi_out:\n\tif (root)\n\t\tcJSON_Delete(root);\n\tif (payload)\n\t\tfree(payload);\n\tif (ptr)\n\t\tfree(ptr);\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":352,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"265511":{"score":0.76992583,"function_name":"iot_easysetup_init","code":"iot_error_t iot_easysetup_init(struct iot_context *ctx)\n{\n\tiot_error_t err;\n\n\tENTER();\n\tIOT_REMARK(\"IOT_STATE_PROV_ES_START\");\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_INIT, 0);\n\tif (!ctx)\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\n\terr = iot_security_cipher_init(ctx-\u003eeasysetup_security_context);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to init cipher\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_CIPHER_ERROR, err);\n\t\treturn IOT_ERROR_EASYSETUP_CIPHER_ERROR;\n\t}\n\n\tcontext = ctx;\n\n\tref_step = 0;\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tif ((log_buffer = (char *)malloc(CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SIZE)) == NULL) {\n\t\tIOT_ERROR(\"failed to malloc for log buffer\");\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_MEM_ALLOC_ERROR, 0);\n\t\tiot_security_cipher_deinit(ctx-\u003eeasysetup_security_context);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t}\n\tmemset(log_buffer, '\\0', CONFIG_STDK_IOT_CORE_EASYSETUP_HTTP_LOG_SIZE);\n\tlog_len = 0;\n\tdump_enable= true;\n#endif\n\n\tes_http_init();\n\n\tIOT_REMARK(\"IOT_STATE_PROV_ES_INIT_DONE\");\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_INIT, 1);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":462,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"265733":{"score":0.82582766,"function_name":"iot_easysetup_deinit","code":"void iot_easysetup_deinit(struct iot_context *ctx)\n{\n\tiot_error_t err;\n\n\tENTER();\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_DEINIT, 0);\n\tif (!ctx)\n\t\treturn;\n\n\tes_http_deinit();\n\n#if defined(CONFIG_STDK_IOT_CORE_EASYSETUP_LOG_SUPPORT_NO_USE_LOGFILE)\n\tif (log_buffer) {\n\t\tdump_enable = false;\n\t\tfree(log_buffer);\n\t\tlog_buffer = NULL;\n\t}\n#endif\n\tiot_os_eventgroup_clear_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_RESP);\n\n\terr = iot_security_cipher_deinit(ctx-\u003eeasysetup_security_context);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to iot_security_cipher_deinit, error (%d)\", err);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_DEINIT, err);\n\t} else {\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_DEINIT, 1);\n\t}\n\n\tIOT_REMARK(\"IOT_STATE_PROV_ES_DONE\");\n}","filepath":"src/easysetup/http/iot_easysetup_http.c","line_number":503,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"265962":{"score":0.9223256,"function_name":"process_accepted_connection","code":"static int process_accepted_connection(HTTP_CONN_H *handle)\n{\n\tchar rx_buffer[RX_BUFFER_MAX];\n\tiot_error_t err = IOT_ERROR_NONE;\n\tsize_t content_len = 0;\n\tchar *payload;\n\tint type, cmd;\n\tssize_t len;\n\n\thttp_try_configure_connection(handle);\n\n\twhile (1)\n\t{\n\t\tsize_t received_len = 0;\n\t\tsize_t tx_buffer_len = 0;\n\t\tsize_t http_request_header_len = 0;\n\n\t\t// start to process one http request\n\t\tmemset(rx_buffer, '\\0', sizeof(rx_buffer));\n\n\t\terr = http_packet_read(handle, rx_buffer, sizeof(rx_buffer), \u0026received_len, \u0026http_request_header_len);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tif (!is_es_http_deinit_processing() \u0026\u0026 err != IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED) {\n\t\t\t\tIOT_ERROR(\"failed to read http packet %d\", err);\n\t\t\t}\n\t\t\treturn err;\n\t\t}\n\n\t\tcontent_len = 0;\n\t\terr = es_msg_parser(rx_buffer, sizeof(rx_buffer), \u0026payload, \u0026cmd, \u0026type, \u0026content_len);\n\n\t\tif ((err == IOT_ERROR_NONE) \u0026\u0026 (type == D2D_POST)\n\t\t\t\t\u0026\u0026 payload \u0026\u0026 (content_len \u003e strlen((char *)payload)))\n\t\t{\n\t\t\tiot_error_t ret;\n\t\t\tret = http_packet_read_remaining(handle, rx_buffer, sizeof(rx_buffer), received_len, http_request_header_len + content_len);\n\t\t\tif (ret != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to read remaining http packet %d\", ret);\n\t\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t\t}\n\t\t\tpayload = rx_buffer + http_request_header_len;\n\t\t}\n\n\t\tif(err != IOT_ERROR_NONE) {\n\t\t\thttp_msg_handler(cmd, \u0026tx_buffer, D2D_ERROR, payload);\n\t\t}\n\t\telse {\n\t\t\thttp_msg_handler(cmd, \u0026tx_buffer, type, payload);\n\t\t}\n\n\t\tif (!tx_buffer) {\n\t\t\tIOT_ERROR(\"tx_buffer is NULL\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_INTERNAL_SERVER_ERROR, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\n\t\ttx_buffer_len = strlen((char *)tx_buffer);\n\t\ttx_buffer[tx_buffer_len] = 0;\n\n\t\tlen = http_packet_send(handle, tx_buffer, tx_buffer_len);\n\t\tfree(tx_buffer);\n\t\ttx_buffer = NULL;\n\t\tif (len \u003c 0) {\n\t\t\tIOT_ERROR(\"Error is occurred during sending: errno %d\", errno);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_SEND_FAIL, errno);\n\t\t\treturn IOT_ERROR_EASYSETUP_INTERNAL_SERVER_ERROR;\n\t\t}\n\t}\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":42,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"266836":{"score":0.9116108,"function_name":"es_tcp_task","code":"static void es_tcp_task(void *pvParameters)\n{\n\tiot_error_t err;\n\n\twhile (!is_es_http_deinit_processing()) {\n\t\terr = http_initialize_connection(\u0026es_http_conn_handle);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tbreak;\n\t\t}\n\n\t\twhile (1) {\n\t\t\terr = http_accept_connection(\u0026es_http_conn_handle);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tif (!is_es_http_deinit_processing()) {\n\t\t\t\t\tIOT_ERROR(\"Unable to accept connection: errno %d\", errno);\n\t\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_ACCEPT_FAIL, errno);\n\t\t\t\t\tIOT_ERROR(\"accept failed %d\", err);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = process_accepted_connection(\u0026es_http_conn_handle);\n\t\t\tif (!is_es_http_deinit_processing() \u0026\u0026 (err == IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED))\n\t\t\t{\n\t\t\t\thttp_cleanup_accepted_connection(\u0026es_http_conn_handle);\n\t\t\t}\n\t\t}\n\n\t\t//sock resources should be clean\n\t\tif (!is_es_http_deinit_processing()) {\n\t\t\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\t\t}\n\t}\n\n\tif (!is_es_http_deinit_processing()) {\n\t\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\t}\n\n\t/*set es_tcp_task_handle to null, prevent duplicate delete in es_tcp_deinit*/\n\tes_tcp_task_handle = NULL;\n\tiot_os_thread_delete(NULL);\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"267307":{"score":0.8979204,"function_name":"es_http_deinit","code":"void es_http_deinit(void)\n{\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_TCP_DEINIT, 0);\n\n\tes_http_deinit_processing_set(true);\n\t//sock resources should be clean\n\thttp_cleanup_all_connection(\u0026es_http_conn_handle);\n\n\tif (es_tcp_task_handle) {\n\t\tiot_os_thread_delete(es_tcp_task_handle);\n\t\tes_tcp_task_handle = NULL;\n\t}\n\n\tif (tx_buffer) {\n\t\tfree(tx_buffer);\n\t\ttx_buffer = NULL;\n\t}\n\n\tes_http_deinit_processing_set(false);\n\tIOT_INFO(\"http tcp deinit complete!\");\n\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_EASYSETUP_TCP_DEINIT, 1);\n}","filepath":"src/easysetup/http/tcp/iot_easysetup_httpd.c","line_number":165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"267983":{"score":0.8215836,"function_name":"mqtt_reg_sub_cb","code":"static void mqtt_reg_sub_cb(st_mqtt_msg *md, void *userData)\n{\n\tstruct iot_context *ctx = (struct iot_context *)userData;\n\tstruct iot_registered_data *reged_data = \u0026ctx-\u003eiot_reg_data;\n\tchar * mqtt_payload = md-\u003epayload;\n\tchar * registered_msg = NULL;\n\tJSON_H *json = NULL;\n\tJSON_H *item = NULL;\n\tJSON_H *event = NULL;\n\tJSON_H *cur_time = NULL;\n\tJSON_H *dip_key = NULL;\n\tJSON_H *dip_item = NULL;\n\tchar time_str[11] = {0,};\n\tchar *svr_did_str = NULL;\n\tenum iot_command_type iot_cmd;\n\tstruct iot_dip_data *reged_dip = NULL;\n\tstruct iot_uuid *reged_location = NULL;\n\tiot_error_t err;\n\n\t/*parsing mqtt_payload*/\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tchar *payload_json = NULL;\n\tsize_t payload_json_len = 0;\n\n\terr = iot_serialize_cbor2json((uint8_t *)mqtt_payload,\n\t\t\t(size_t)md-\u003epayloadlen,\n\t\t\t\u0026payload_json, \u0026payload_json_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_serialize_cbor2json = %d\", err);\n\t\tgoto reg_sub_out;\n\t}\n\n\tif ((payload_json == NULL) || (payload_json_len == 0)) {\n\t\tIOT_ERROR(\"cbor2json failed (json buffer is null)\");\n\t\tgoto reg_sub_out;\n\t}\n\n\tjson = JSON_PARSE(payload_json);\n\tfree(payload_json);\n#else\n\tjson = JSON_PARSE(mqtt_payload);\n#endif\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"mqtt_payload(%s) parsing failed\", mqtt_payload);\n\t\tgoto reg_sub_out;\n\t}\n\n\tregistered_msg = JSON_PRINT(json);\n\tif (registered_msg == NULL) {\n\t\tIOT_ERROR(\"There are no registered msg, payload : %s\", mqtt_payload);\n\t\tgoto reg_sub_out;\n\t}\n\tIOT_INFO(\"Registered MSG : %s\", registered_msg);\n\n\tevent = JSON_GET_OBJECT_ITEM(json, \"event\");\n\tif (event != NULL) {\n\t\tif (!strncmp(event-\u003evaluestring, \"expired.jwt\", 11)) {\n\t\t\tcur_time = JSON_GET_OBJECT_ITEM(json, \"currentTime\");\n\t\t\tif (cur_time == NULL) {\n\t\t\t\tIOT_ERROR(\"%s : there is no currentTime in json, mqtt_payload : \\n%s\",\n\t\t\t\t\t__func__, mqtt_payload);\n\t\t\t\tgoto reg_sub_out;\n\t\t\t}\n\n\t\t\tsnprintf(time_str, sizeof(time_str), \"%d\", cur_time-\u003evalueint);\n\t\t\tIOT_INFO(\"Set SNTP with current time %s\", time_str);\n\t\t\tiot_bsp_system_set_time_in_sec(time_str);\n\n\t\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERING;\n\t\t\tif (iot_command_send(ctx, iot_cmd, NULL, 0) != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Cannot send cloud registering cmd!!\");\n\t\t\t}\n\t\t} else if (!strncmp(event-\u003evaluestring, \"error\", 5)) {\n\t\t\tbool reboot;\n\t\t\treboot = true;\n\t\t\tiot_command_send(ctx, IOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\t\t\tgoto reg_sub_out;\n\t\t} else {\n\t\t\tIOT_ERROR(\"event type %s is not defined\", event-\u003evaluestring);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t}\n\n\t/* dip_key is optional values */\n\tdip_key =JSON_GET_OBJECT_ITEM(json, \"deviceIntegrationProfileKey\");\n\tif (dip_key != NULL) {\n\t\treged_dip = iot_os_malloc(sizeof(struct iot_dip_data));\n\t\tif (!reged_dip) {\n\t\t\tIOT_ERROR(\"Can't alloc iot_dip_data!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\tmemset(reged_dip, 0, sizeof(struct iot_dip_data));\n\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"id\");\n\t\tif (!dip_item) {\n\t\t\tIOT_ERROR(\"Can't find id for dip_key!!\");\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\terr = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(dip_item),\n\t\t\t\t\u0026reged_dip-\u003edip_id);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", err);\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"majorVersion\");\n\t\tif (!dip_item) {\n\t\t\tIOT_ERROR(\"Can't find majorVersion for dip_key!!\");\n\t\t\tiot_os_free(reged_dip);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\treged_dip-\u003edip_major_version = dip_item-\u003evalueint;\n\n\t\t/* minorVersion is optional, default 0 */\n\t\tdip_item = JSON_GET_OBJECT_ITEM(dip_key, \"minorVersion\");\n\t\tif (dip_item) {\n\t\t\treged_dip-\u003edip_minor_version = dip_item-\u003evalueint;\n\t\t}\n\n\t\tif (reged_data-\u003edip)\n\t\t\tiot_os_free(reged_data-\u003edip);\n\n\t\treged_data-\u003edip = reged_dip;\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"locationId\");\n\tif (item != NULL) {\n\t\treged_location = iot_os_malloc(sizeof(struct iot_uuid));\n\t\tif (!reged_location) {\n\t\t\tIOT_ERROR(\"Can't alloc iot_uuid for location!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\t\tmemset(reged_location, 0, sizeof(struct iot_uuid));\n\n\t\terr = iot_util_convert_str_uuid(JSON_GET_STRING_VALUE(item),\n\t\t\t\treged_location);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Can't convert str to uuid(%d)\", err);\n\t\t\tiot_os_free(reged_location);\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tif (reged_data-\u003elocationId)\n\t\t\tiot_os_free(reged_data-\u003elocationId);\n\n\t\treged_data-\u003elocationId = reged_location;\n\t} else {\n\t\tIOT_WARN(\"Server does not send locationId!!\");\n\t}\n\n\titem = JSON_GET_OBJECT_ITEM(json, \"deviceId\");\n\tif (item != NULL \u0026\u0026 !reged_data-\u003eupdated) {\n\t\tsvr_did_str = JSON_PRINT(item);\n\t\tif (svr_did_str == NULL) {\n\t\t\tIOT_ERROR(\"Can't print server's did str!!\");\n\t\t\tgoto reg_sub_out;\n\t\t}\n\n\t\tmemset(reged_data-\u003edeviceId, 0, IOT_REG_UUID_STR_LEN + 1);\n\t\t/* svr_did_str has/included [\"] also - \"xxxxx-xxxx-xxx\" */\n\t\tmemcpy(reged_data-\u003edeviceId, (svr_did_str + 1), IOT_REG_UUID_STR_LEN);\n\n\t\treged_data-\u003eupdated = true;\n\t\treged_data-\u003enew_reged = false;\n\n\t\tiot_cmd = IOT_COMMAND_CLOUD_REGISTERED;\n\t\tif (iot_command_send(ctx, iot_cmd, NULL, 0) != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Cannot send cloud registered cmd!!\");\n\t\t}\n\t}\n\nreg_sub_out:\n\tif (svr_did_str != NULL)\n\t\tfree(svr_did_str);\n\n\tif (registered_msg != NULL)\n\t\tfree(registered_msg);\n\n\tif (json != NULL)\n\t\tJSON_DELETE(json);\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":40,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"269845":{"score":0.9207654,"function_name":"_iot_mqtt_registration_client_callback","code":"STATIC_FUNCTION\nvoid _iot_mqtt_registration_client_callback(st_mqtt_event event, void *event_data, void *user_data)\n{\n\tswitch (event) {\n\t\tcase ST_MQTT_EVENT_MSG_DELIVERED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tif (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_REGISTRATION_PREFIX, IOT_SUB_TOPIC_REGISTRATION_PREFIX_SIZE)) {\n\t\t\t\t\tmqtt_reg_sub_cb(md, user_data);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"No msg delivery handler for %s\", md-\u003etopic);\n\t\t\t\t}\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, md-\u003epayload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tIOT_WARN(\"No MQTT event handler for %d\", event);\n\t\t\tbreak;\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":225,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270022":{"score":0.6774235,"function_name":"_iot_parse_sequence_num","code":"STATIC_FUNCTION\nint _iot_parse_sequence_num(char *payload)\n{\n\tJSON_H *json = NULL;\n\tJSON_H *device_events = NULL;\n\tJSON_H *first_event = NULL;\n\tJSON_H *provider_data = NULL;\n\tJSON_H *sequence_number = NULL;\n\tint seq_num = 0;\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tchar *payload_json = NULL;\n\tsize_t payload_json_len = 0;\n\n\tif (iot_serialize_cbor2json((uint8_t *)payload, strlen(payload), \u0026payload_json, \u0026payload_json_len)) {\n\t\tIOT_ERROR(\"cbor2json failed\");\n\t\treturn 0;\n\t}\n\n\tif ((payload_json == NULL) || (payload_json_len == 0)) {\n\t\tIOT_ERROR(\"json buffer is null\");\n\t\treturn 0;\n\t}\n\n\tjson = JSON_PARSE(payload_json);\n\tfree(payload_json);\n#else\n\tjson = JSON_PARSE(payload);\n#endif\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\treturn 0;\n\t}\n\n\tdevice_events = JSON_GET_OBJECT_ITEM(json, \"deviceEvents\");\n\tif (device_events == NULL) {\n\t\tIOT_ERROR(\"there is no events in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tfirst_event = JSON_GET_CHILD_ITEM(device_events);\n\tif (first_event == NULL) {\n\t\tIOT_ERROR(\"there is no event in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tprovider_data = JSON_GET_OBJECT_ITEM(first_event, \"providerData\");\n\tif (provider_data == NULL) {\n\t\tIOT_ERROR(\"there is no provider_data in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tsequence_number = JSON_GET_OBJECT_ITEM(provider_data, \"sequenceNumber\");\n\tif (sequence_number == NULL) {\n\t\tIOT_ERROR(\"there is no sequence number in raw_msgn\");\n\t\tgoto out;\n\t}\n\n\tseq_num = JSON_GET_NUMBER_VALUE(sequence_number);\nout:\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn seq_num;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":246,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270502":{"score":0.92083454,"function_name":"_iot_mqtt_signin_client_callback","code":"STATIC_FUNCTION\nvoid _iot_mqtt_signin_client_callback(st_mqtt_event event, void *event_data, void *user_data)\n{\n\tstruct iot_context *ctx = (struct iot_context *)user_data;\n\n\tswitch (event) {\n\t\tcase ST_MQTT_EVENT_MSG_DELIVERED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tchar *mqtt_payload = md-\u003epayload;\n\t\t\t\tif (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_COMMAND_PREFIX, IOT_SUB_TOPIC_COMMAND_PREFIX_SIZE)) {\n\t\t\t\t\tiot_cap_sub_cb(ctx-\u003ecap_handle_list, mqtt_payload);\n\t\t\t\t} else if (!strncmp(md-\u003etopic, IOT_SUB_TOPIC_NOTIFICATION_PREFIX, IOT_SUB_TOPIC_NOTIFICATION_PREFIX_SIZE)) {\n\t\t\t\t\tiot_noti_sub_cb(ctx, mqtt_payload);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"No msg delivery handler for %s\", md-\u003etopic);\n\t\t\t\t}\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, mqtt_payload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ST_MQTT_EVENT_PUBLISH_FAILED:\n\t\t\t{\n\t\t\t\tst_mqtt_msg *md = event_data;\n\t\t\t\tchar *mqtt_payload = md-\u003epayload;\n\t\t\t\tiot_noti_data_t noti_data;\n\n\t\t\t\tnoti_data.type = IOT_NOTI_TYPE_SEND_FAILED;\n\t\t\t\tnoti_data.raw.send_fail.failed_sequence_num = _iot_parse_sequence_num(mqtt_payload);\n\n\t\t\t\tif (noti_data.raw.send_fail.failed_sequence_num \u003c 0) {\n\t\t\t\t\tIOT_ERROR(\"No sequence number\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tiot_command_send(ctx, IOT_COMMAND_NOTIFICATION_RECEIVED,\n\t\t\t\t\t\u0026noti_data, sizeof(noti_data));\n\t\t\t\tIOT_DEBUG(\"raw msg (len:%d) : %s\", md-\u003epayloadlen, mqtt_payload);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIOT_WARN(\"No MQTT event handler for %d\", event);\n\t\t\tbreak;\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":311,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"270926":{"score":0.8681617,"function_name":"_iot_es_mqtt_registration_json","code":"STATIC_FUNCTION\nvoid *_iot_es_mqtt_registration_json(struct iot_context *ctx,\n\t\t\tchar *dip_id, size_t *msglen, bool self_reged)\n{\n\tstruct iot_devconf_prov_data *devconf;\n\tstruct iot_device_info *dev_info;\n\tstruct timeval tv = {0,};\n\tJSON_H *root = NULL;\n\tJSON_H *dip_key = NULL;\n\tchar *payload = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"ctx is null\");\n\t\treturn NULL;\n\t}\n\tdev_info = \u0026(ctx-\u003edevice_info);\n\n\tdevconf = \u0026ctx-\u003edevconf;\n\tif ((self_reged == false) \u0026\u0026 !devconf-\u003ehashed_sn) {\n\t\tIOT_ERROR(\"There are no hashed_sn\");\n\t\treturn NULL;\n\t}\n\n\troot = JSON_CREATE_OBJECT();\n\tif (!root) {\n\t\tIOT_ERROR(\"failed to create json\");\n\t\treturn NULL;\n\t}\n\n\t/* location id is optional value */\n\tif (ctx-\u003eprov_data.cloud.location) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"locationId\",\n\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.location));\n\t} else if (self_reged == true) {\n\t\t/* But location is mandatory for self-registration */\n\t\tIOT_ERROR(\"There is no location for self-registration!!\");\n\t\tJSON_DELETE(root);\n\t\treturn NULL;\n\t}\n\n\t/* label is optional value */\n\tif (ctx-\u003eprov_data.cloud.label) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"label\",\n\t\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.label));\n\t} else {\n\t\tIOT_WARN(\"There is no label for registration\");\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"mnId\",\n\t\tJSON_CREATE_STRING(devconf-\u003emnid));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"vid\",\n\t\tJSON_CREATE_STRING(devconf-\u003evid));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"deviceTypeId\",\n\t\tJSON_CREATE_STRING(devconf-\u003edevice_type));\n\n\tJSON_ADD_ITEM_TO_OBJECT(root, \"lookupId\",\n\t\tJSON_CREATE_STRING(ctx-\u003elookup_id));\n\n\tif (ctx-\u003eprov_data.cloud.room \u0026\u0026 (self_reged == false)) {\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"roomId\",\n\t\t\tJSON_CREATE_STRING(ctx-\u003eprov_data.cloud.room));\n\t} else if (self_reged == false) {\n\t\t/* Do not send serialHash \u0026 provisioningTs for self-registration */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"serialHash\",\n\t\t\tJSON_CREATE_STRING(devconf-\u003ehashed_sn));\n\n\t\tgettimeofday(\u0026tv, NULL);\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"provisioningTs\",\n\t\t\tJSON_CREATE_NUMBER(tv.tv_sec));\n\t}\n\n\t/* Add optional information if it available */\n\tif (dev_info-\u003eopt_info) {\n\t\t/* firmwareVersion is mandatory on the device_info */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"firmwareVersion\",\n\t\t\tJSON_CREATE_STRING(dev_info-\u003efirmware_version));\n\n\t\tif (dev_info-\u003emodel_number) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"modelNumber\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emodel_number));\n\t\t}\n\n\t\tif (dev_info-\u003emarketing_name) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"marketingName\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emarketing_name));\n\t\t}\n\n\t\tif (dev_info-\u003emanufacturer_name) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"manufacturerName\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emanufacturer_name));\n\t\t}\n\n\t\tif (dev_info-\u003emanufacturer_code) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"manufacturerCode\",\n\t\t\t\tJSON_CREATE_STRING(dev_info-\u003emanufacturer_code));\n\t\t}\n\n\t\tif (iot_os_get_os_name()) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"osType\",\n\t\t\t\tJSON_CREATE_STRING(iot_os_get_os_name()));\n\t\t}\n\n\t\tif (iot_os_get_os_version_string()) {\n\t\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"osVersion\",\n\t\t\t\tJSON_CREATE_STRING(iot_os_get_os_version_string()));\n\t\t}\n\n\t\t/* STDK release version */\n\t\tJSON_ADD_ITEM_TO_OBJECT(root, \"stdkVersion\",\n\t\t\tJSON_CREATE_STRING(STDK_VERSION_STRING));\n\t}\n\n\t/* dip is optional values */\n\tif (dip_id) {\n\t\tdip_key = JSON_CREATE_OBJECT();\n\t\tif (!dip_key) {\n\t\t\tIOT_WARN(\"Can't create dip_key obj\");\n\t\t\tgoto exit_json_making;\n\t\t}\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(dip_key, \"id\",\n\t\t\tJSON_CREATE_STRING(dip_id));\n\n\t\tJSON_ADD_NUMBER_TO_OBJECT(dip_key,\n\t\t\t\"majorVersion\", devconf-\u003edip-\u003edip_major_version);\n\n\t\tJSON_ADD_NUMBER_TO_OBJECT(dip_key,\n\t\t\t\"minorVersion\", devconf-\u003edip-\u003edip_minor_version);\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(root,\n\t\t\t\"deviceIntegrationProfileKey\", dip_key);\n\t}\n\nexit_json_making:\n\tpayload = JSON_PRINT(root);\n\n\t*msglen = strlen(payload);\n\n\tJSON_DELETE(root);\n\n\n\treturn (void *)payload;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":532,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"272501":{"score":0.94843435,"function_name":"_iot_es_mqtt_registration","code":"iot_error_t _iot_es_mqtt_registration(struct iot_context *ctx, st_mqtt_client mqtt_ctx)\n{\n\tint ret;\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tst_mqtt_msg msg;\n\tsize_t str_id_len = 40;\n\tchar *dip_id = NULL;\n\tsize_t msglen = 0;\n\n\tif (!mqtt_ctx) {\n\t\tIOT_ERROR(\"There is no iot_mqtt_ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* Step 2. Publish target's registration info to server */\n\tctx-\u003eiot_reg_data.updated = false;\n\n\t/* dip id is optional value */\n\tif (ctx-\u003edevconf.dip) {\n\t\tdip_id = (char *)malloc(str_id_len);\n\t\tif (!dip_id) {\n\t\t\tIOT_ERROR(\"malloc failed for DIP id\");\n\t\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t\t\tgoto failed_regist;\n\t\t}\n\t\tmemset(dip_id, 0, str_id_len);\n\n\t\tiot_err = iot_util_convert_uuid_str(\u0026ctx-\u003edevconf.dip-\u003edip_id,\n\t\t\t\t\tdip_id, str_id_len);\n\t\tif (iot_err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"%s error DIP_id convt (%d)\", __func__, iot_err);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t\tgoto failed_regist;\n\t\t}\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tmsg.payload = _iot_es_mqtt_registration_cbor(ctx, dip_id, \u0026msglen,\n\t\t\t\t\tctx-\u003eiot_reg_data.self_reged);\n#else\n\tmsg.payload = _iot_es_mqtt_registration_json(ctx, dip_id, \u0026msglen,\n\t\t\t\t\tctx-\u003eiot_reg_data.self_reged);\n#endif\n\tif (!msg.payload) {\n\t\tIOT_ERROR(\"Failed to make payload for MQTTpub\");\n\t\tiot_err = IOT_ERROR_MEM_ALLOC;\n\t} else {\n\t\tIOT_DEBUG(\"publish resource payload : \\n%s\", msg.payload);\n\n\t\tmsg.qos = st_mqtt_qos1;\n\t\tmsg.retained = false;\n\t\tmsg.payloadlen = (int)msglen;\n\t\tmsg.topic = IOT_PUB_TOPIC_REGISTRATION;\n\n\t\tret = st_mqtt_publish(mqtt_ctx, \u0026msg);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"error MQTTpub(%d)\", ret);\n\t\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\t\tfree(msg.payload);\n#else\n\t\tJSON_FREE(msg.payload);\n#endif\n\t}\n\nfailed_regist:\n\tif (dip_id)\n\t\tfree(dip_id);\n\n\treturn iot_err;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":680,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"273094":{"score":0.8897146,"function_name":"_iot_es_mqtt_disconnect","code":"void _iot_es_mqtt_disconnect(struct iot_context *ctx, st_mqtt_client target_cli)\n{\n\tint ret;\n\n#if defined(STDK_MQTT_TASK)\n\tst_mqtt_endtask(target_cli);\n#endif\n\n\t/* Internal MQTT connection was disconnected,\n\t * even if it returns errors\n\t */\n\tret = st_mqtt_disconnect(target_cli);\n\tif (ret) {\n\t\tIOT_WARN(\"Disconnect error(%d)\", ret);\n\t}\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":754,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"273183":{"score":0.8881883,"function_name":"_iot_es_mqtt_connect","code":"iot_error_t _iot_es_mqtt_connect(struct iot_context *ctx, st_mqtt_client target_cli,\n\t\tchar *username, char *sign_data)\n{\n\tst_mqtt_connect_data conn_data = st_mqtt_connect_data_initializer;\n\tst_mqtt_broker_info_t broker_info;\n\tint ret;\n\tiot_error_t iot_ret = IOT_ERROR_NONE;\n\tbool reboot;\n\tchar client_id[IOT_REG_UUID_STR_LEN + 1] = {0, };\n\tstruct iot_cloud_prov_data *cloud_prov;\n\tchar *root_cert = NULL;\n\tsize_t root_cert_len;\n\n\t/* Use mac based random client_id for GreatGate */\n\tiot_ret = iot_get_random_id_str(client_id, sizeof(client_id));\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Cannot get random_id for client_id\");\n\t\treturn iot_ret;\n\t}\n\n\tcloud_prov = \u0026ctx-\u003eprov_data.cloud;\n\tif (!cloud_prov-\u003ebroker_url) {\n\t\tIOT_ERROR(\"cloud_prov_data url does not exist!\");\n\t\tiot_ret = IOT_ERROR_INVALID_ARGS;\n\t\tgoto done_mqtt_connect;\n\t}\n\n\tiot_ret = iot_nv_get_certificate(IOT_SECURITY_CERT_ID_ROOT_CA, \u0026root_cert, \u0026root_cert_len);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get root cert\");\n\t\tgoto done_mqtt_connect;\n\t}\n\n\tbroker_info.url = cloud_prov-\u003ebroker_url;\n\tbroker_info.port = cloud_prov-\u003ebroker_port;\n\tbroker_info.ca_cert = (const unsigned char *)root_cert;\n\tbroker_info.ca_cert_len = root_cert_len;\n\tbroker_info.ssl = 1;\n\n\tIOT_INFO(\"url: %s, port: %d\", cloud_prov-\u003ebroker_url, cloud_prov-\u003ebroker_port);\n\n\tconn_data.clientid  = client_id;\n\tconn_data.username  = username;\n\tconn_data.password  = sign_data;\n\n\tIOT_INFO(\"mqtt connect,\\nid : %s\\nusername : %s\\npassword : %s\",\n\t\t conn_data.clientid,\n\t\t conn_data.username,\n\t\t conn_data.password);\n\n\tret = st_mqtt_connect(target_cli, \u0026broker_info, \u0026conn_data);\n\tif (ret) {\n\t\tIOT_ERROR(\"%s error(%d)\", __func__, ret);\n\t\tswitch (ret) {\n\t\tcase E_ST_MQTT_UNNACCEPTABLE_PROTOCOL:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_SERVER_UNAVAILABLE:\n\t\t\t/* This case means Server can't start service for MQTT Things\n\t\t\t * This case is totally server-side issue, so we just report it to Apps\n\t\t\t */\n\t\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t\t\tiot_ret = IOT_ERROR_MQTT_SERVER_UNAVAIL;\n\t\t\tbreak;\n\n\t\tcase E_ST_MQTT_CLIENTID_REJECTED:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_BAD_USERNAME_OR_PASSWORD:\n\t\t\t/* fall through */\n\t\tcase E_ST_MQTT_NOT_AUTHORIZED:\n\t\t\t/* These cases are related to device's clientID, serialNumber, deviceId \u0026 web token\n\t\t\t * So we try to cleanup all data \u0026 reboot\n\t\t\t */\n\t\t\tif (ctx-\u003emqtt_connect_critical_reject_count++ \u003c IOT_MQTT_CONNECT_CRITICAL_REJECT_MAX) {\n\t\t\t\tIOT_WARN(\"MQTT critical reject retry %d\", ctx-\u003emqtt_connect_critical_reject_count);\n\t\t\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIOT_WARN(\"Rejected by Server!! cleanup all \u0026 reboot\");\n\n\t\t\treboot = true;\n\t\t\tiot_command_send(ctx, IOT_COMMAND_SELF_CLEANUP, \u0026reboot, sizeof(bool));\n\t\t\tiot_ret = IOT_ERROR_MQTT_REJECT_CONNECT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/* On the others, we can't narrow down the causes. Some cases are related to\n\t\t\t * network conditions (outside of the device) or, related to WIFI conditions\n\t\t\t * (inside of the device). So we try to do re-connecting limitedly\n\t\t\t */\n\t\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tctx-\u003emqtt_connect_critical_reject_count = 0;\n\t}\n\n#if defined(STDK_MQTT_TASK)\n\tif ((ret = st_mqtt_starttask(target_cli)) \u003c 0) {\n\t\tIOT_ERROR(\"Returned code from start tasks is %d\", ret);\n\t\tst_mqtt_disconnect(target_cli);\n\t\tiot_ret = IOT_ERROR_MQTT_CONNECT_FAIL;\n\t\tgoto done_mqtt_connect;\n\t} else {\n\t\tIOT_INFO(\"Use MQTTStartTask\");\n\t}\n#endif\n\ndone_mqtt_connect:\n\tif (root_cert)\n\t\tfree((void *)root_cert);\n\n\treturn iot_ret;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":771,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"274192":{"score":0.8894124,"function_name":"iot_es_connect","code":"iot_error_t iot_es_connect(struct iot_context *ctx, int conn_type)\n{\n\tiot_security_buffer_t token_buf = { 0 };\n\tiot_wt_params_t wt_params = { 0 };\n\tst_mqtt_client mqtt_cli = NULL;\n\tchar *topicfilter = NULL;\n\tiot_error_t iot_ret;\n\tint ret;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif (!(iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tunsigned int remaining_time = iot_os_timer_left_ms(ctx-\u003erate_limit_timeout);\n\t\t\tIOT_WARN(\"Server rate limit break times.. please wait %d seconds to connect\", remaining_time/1000);\n\t\t\tiot_os_delay(remaining_time);\n\t\t}\n\t}\n\tctx-\u003erate_limit = false;\n\n\tiot_ret = iot_nv_get_serial_number((char **)\u0026wt_params.sn, \u0026wt_params.sn_len);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to get serial num\");\n\t\tgoto out;\n\t}\n\n\twt_params.mnid = iot_os_strdup(ctx-\u003edevconf.mnid);\n\tif (!wt_params.mnid) {\n\t\tIOT_ERROR(\"failed to strdup for mnid\");\n\t\tgoto out;\n\t} else {\n\t\twt_params.mnid_len = strlen(wt_params.mnid);\n\t}\n\n\tiot_ret = iot_wt_create((const iot_wt_params_t *)\u0026wt_params, \u0026token_buf);\n\tif (iot_ret != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to make wt-token\");\n\t\tgoto out;\n\t}\n\n\ttopicfilter = malloc(IOT_TOPIC_SIZE);\n\tif (!topicfilter) {\n\t\tIOT_ERROR(\"failed to malloc topicfilter\");\n\t\tiot_ret = IOT_ERROR_MEM_ALLOC;\n\t\tgoto out;\n\t}\n\tif (conn_type == IOT_CONNECT_TYPE_COMMUNICATION) {\n\t\tIOT_INFO(\"connect_type: log-in\");\n\t\t/* Using for new MQTT PUB/SUB connection after registration */\n\t\tif (!ctx-\u003eiot_reg_data.updated) {\n\t\t\tIOT_ERROR(\"failed to get user id\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = st_mqtt_create(\u0026mqtt_cli, _iot_mqtt_signin_client_callback, ctx);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"Cannot create mqtt client\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003emqtt_connection_try_count++;\n\t\tiot_ret = _iot_es_mqtt_connect(ctx, mqtt_cli, (char *)ctx-\u003eiot_reg_data.deviceId, (char *)token_buf.p);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to connect\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tctx-\u003emqtt_connection_success_count++;\n\t\t\tIOT_INFO(\"MQTT connect success sucess/try : %d/%d\", ctx-\u003emqtt_connection_success_count, ctx-\u003emqtt_connection_try_count);\n\t\t}\n\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_NOTIFICATION, ctx-\u003eiot_reg_data.deviceId);\n\t\tIOT_DEBUG(\"noti subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_WARN(\"subscribe error(%d)\", ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_COMMAND, ctx-\u003eiot_reg_data.deviceId);\n\t\tIOT_DEBUG(\"cmd subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_WARN(\"failed cmd sub registration(%d)\", ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003emqtt_event_topic = malloc(IOT_TOPIC_SIZE);\n\t\tif (!ctx-\u003emqtt_event_topic) {\n\t\t\tIOT_ERROR(\"failed to malloc for mqtt_event_topic\");\n\t\t\tiot_ret = IOT_ERROR_MEM_ALLOC;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\t\tsnprintf(ctx-\u003emqtt_event_topic, IOT_TOPIC_SIZE, IOT_PUB_TOPIC_EVENT, ctx-\u003eiot_reg_data.deviceId);\n\n\t\tctx-\u003eevt_mqttcli = mqtt_cli;\n\t} else {\n\t\tIOT_INFO(\"connect_type: registration\");\n\n\t\tret = st_mqtt_create(\u0026mqtt_cli, _iot_mqtt_registration_client_callback, ctx);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"Cannot create mqtt client\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tiot_ret = _iot_es_mqtt_connect(ctx, mqtt_cli, wt_params.sn, (char *)token_buf.p);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to connect\");\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tIOT_INFO(\"MQTT connect success\");\n\t\t}\n\n\t\t/* register notification subscribe for registration */\n\t\tsnprintf(topicfilter, IOT_TOPIC_SIZE, IOT_SUB_TOPIC_REGISTRATION, wt_params.sn);\n\t\tIOT_DEBUG(\"noti subscribe topic : %s\", topicfilter);\n\t\tret = st_mqtt_subscribe(mqtt_cli, topicfilter, st_mqtt_qos1);\n\t\tif (ret) {\n\t\t\tIOT_ERROR(\"%s error MQTTsub(%d)\", __func__, ret);\n\t\t\tiot_ret = IOT_ERROR_BAD_REQ;\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tiot_ret = _iot_es_mqtt_registration(ctx, mqtt_cli);\n\t\tif (iot_ret != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"failed to register\");\n\t\t\t_iot_es_mqtt_disconnect(ctx, mqtt_cli);\n\t\t\tgoto out;\n\t\t}\n\n\t\tctx-\u003ereg_mqttcli = mqtt_cli;\n\t}\n\nout:\n\tif (wt_params.sn)\n\t\tiot_os_free((void *)wt_params.sn);\n\n\tif (wt_params.mnid)\n\t\tiot_os_free((void *)wt_params.mnid);\n\n\tif (token_buf.p)\n\t\tfree(token_buf.p);\n\n\tif (topicfilter)\n\t\tfree(topicfilter);\n\n\tif (iot_ret)\n\t\tst_mqtt_destroy(mqtt_cli);\n\n\treturn iot_ret;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":886,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276289":{"score":0.90891457,"function_name":"iot_es_disconnect","code":"iot_error_t iot_es_disconnect(struct iot_context *ctx, int conn_type)\n{\n\tst_mqtt_client target_cli = NULL;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (conn_type == IOT_CONNECT_TYPE_COMMUNICATION) {\n\t\ttarget_cli = ctx-\u003eevt_mqttcli;\n\t\tif (ctx-\u003emqtt_event_topic)\n\t\t\tfree(ctx-\u003emqtt_event_topic);\n\t\tctx-\u003emqtt_event_topic = NULL;\n\t\tctx-\u003eevt_mqttcli = NULL;\n\t} else {\n\t\ttarget_cli = ctx-\u003ereg_mqttcli;\n\t\tctx-\u003ereg_mqttcli = NULL;\n\t}\n\n\tif (!target_cli) {\n\t\tIOT_ERROR(\"There is no mqtt_ctx!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tIOT_DEBUG(\"disconnect type %s\",\n\t\t(conn_type == IOT_CONNECT_TYPE_REGISTRATION) ?\n\t\t\t\"registration\" : \"communication\");\n\n\t_iot_es_mqtt_disconnect(ctx, target_cli);\n\n\tst_mqtt_destroy(target_cli);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/easysetup/iot_easysetup_st_mqtt.c","line_number":1046,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276584":{"score":0.8617425,"function_name":"_iot_security_be_check_context_and_params_is_valid","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_check_context_and_params_is_valid(iot_security_context_t *context, iot_security_sub_system_t sub_system)\n{\n\tif (!context) {\n\t\tIOT_ERROR(\"context is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_PK) {\n\t\tif (!context-\u003epk_params) {\n\t\t\tIOT_ERROR(\"pk params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(PK_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_CIPHER) {\n\t\tif (!context-\u003ecipher_params) {\n\t\t\tIOT_ERROR(\"cipher params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_ECDH) {\n\t\tif (!context-\u003eecdh_params) {\n\t\t\tIOT_ERROR(\"ecdh params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\tif (sub_system \u0026 IOT_SECURITY_SUB_STORAGE) {\n\t\tif (!context-\u003estorage_params) {\n\t\t\tIOT_ERROR(\"storage params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_PARAMS_NULL, 0);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":34,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"276931":{"score":0.93012047,"function_name":"_iot_security_be_software_buffer_free","code":"static inline void _iot_security_be_software_buffer_free(iot_security_buffer_t *buffer)\n{\n\tif (buffer) {\n\t\tif (buffer-\u003ep \u0026\u0026 buffer-\u003elen) {\n\t\t\tmemset(buffer-\u003ep, 0, buffer-\u003elen);\n\t\t\tiot_os_free(buffer-\u003ep);\n\t\t}\n\t\tmemset(buffer, 0, sizeof(iot_security_buffer_t));\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":73,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277042":{"score":0.8857786,"function_name":"_iot_security_be_software_buffer_wipe","code":"static inline void _iot_security_be_software_buffer_wipe(const iot_security_buffer_t *input_buf, size_t wiped_len)\n{\n\tif (input_buf \u0026\u0026 (input_buf-\u003elen \u003c wiped_len)) {\n\t\tint i;\n\t\tfor (i = input_buf-\u003elen; i \u003c wiped_len; i++) {\n\t\t\tinput_buf-\u003ep[i] = 0;\n\t\t}\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":84,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277113":{"score":0.8925257,"function_name":"_iot_security_be_software_id_key2storage","code":"static inline iot_security_storage_id_t _iot_security_be_software_id_key2storage(iot_security_key_id_t key_id)\n{\n\tiot_security_storage_id_t storage_id;\n\tconst iot_security_be_key2storage_id_map_t *k2s_id_map_list = key2storage_id_map;\n\tint c2s_id_map_list_len = sizeof(key2storage_id_map) / sizeof(key2storage_id_map[0]);\n\tint i;\n\n\tIOT_DEBUG(\"key id = %d\", key_id);\n\n\tfor (i = 0; i \u003c c2s_id_map_list_len; i++) {\n\t\tif (key_id == k2s_id_map_list[i].key_id) {\n\t\t\tstorage_id = k2s_id_map_list[i].storage_id;\n\t\t\tIOT_DEBUG(\"storage id = %d\", storage_id);\n\t\t\treturn storage_id;\n\t\t}\n\t}\n\n\tIOT_ERROR(\"'%d' is not a supported key id\", key_id);\n\n\treturn IOT_NVD_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":105,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277266":{"score":0.892314,"function_name":"_iot_security_be_software_id_cert2storage","code":"static inline iot_security_storage_id_t _iot_security_be_software_id_cert2storage(iot_security_cert_id_t cert_id)\n{\n\tiot_security_storage_id_t storage_id;\n\tconst iot_security_be_cert2storage_id_map_t *c2s_id_map_list = cert2storage_id_map;\n\tint c2s_id_map_list_len = sizeof(cert2storage_id_map) / sizeof(cert2storage_id_map[0]);\n\tint i;\n\n\tIOT_DEBUG(\"cert id = %d\", cert_id);\n\n\tfor (i = 0; i \u003c c2s_id_map_list_len; i++) {\n\t\tif (cert_id == c2s_id_map_list[i].cert_id) {\n\t\t\tstorage_id = c2s_id_map_list[i].storage_id;\n\t\t\tIOT_DEBUG(\"storage id = %d\", storage_id);\n\t\t\treturn storage_id;\n\t\t}\n\t}\n\n\tIOT_ERROR(\"'%d' is not a supported cert id\", cert_id);\n\n\treturn IOT_NVD_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":138,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277422":{"score":0.8028108,"function_name":"_iot_security_be_software_id_check_permission","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_id_check_permission(iot_security_storage_id_t id)\n{\n\tint no_exposed_list_len = sizeof(no_exposed_storage_id_list) / sizeof(no_exposed_storage_id_list[0]);\n\tint i;\n\n\tfor (i = 0; i \u003c no_exposed_list_len; i++) {\n\t\tif (id == no_exposed_storage_id_list[i]) {\n\t\t\tIOT_ERROR(\"'%d' cannot be exposed to apps\", id);\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_NO_PERMISSION, id);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":164,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277538":{"score":0.832616,"function_name":"_iot_security_be_software_bsp_fs_load","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_bsp_fs_load(iot_security_context_t *context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tconst iot_security_be_bsp_funcs_t *bsp_fn;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (!context-\u003ebe_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tbsp_fn = context-\u003ebe_context-\u003ebsp_fn;\n\n\tif (!bsp_fn || !bsp_fn-\u003ebsp_fs_load) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_LOAD_NULL, 0);\n\t}\n\n\terr = bsp_fn-\u003ebsp_fs_load(context-\u003ebe_context, storage_id, output_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":180,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"277665":{"score":0.87709165,"function_name":"_iot_security_be_software_pk_load_ed25519_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_load_ed25519_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\tiot_security_buffer_t key_b64_buf = { 0 };\n\tiot_security_buffer_t key_buf = { 0 };\n\tsize_t olen;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tstorage_id = _iot_security_be_software_id_key2storage(key_id);\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, \u0026key_b64_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tkey_buf.len = IOT_SECURITY_ED25519_LEN;\n\tkey_buf.p = (unsigned char *) iot_os_malloc(key_buf.len);\n\tif (!key_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for key_buf\");\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\t/* remove null character for base64 decoding */\n\tif (strlen((char *)key_b64_buf.p) == (key_b64_buf.len - 1)) {\n\t\tkey_b64_buf.len -= 1;\n\t}\n\n\terr = iot_security_base64_decode(key_b64_buf.p, key_b64_buf.len, key_buf.p, key_buf.len, \u0026olen);\n\tif (err) {\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\t_iot_security_be_software_buffer_free(\u0026key_buf);\n\t\treturn err;\n\t}\n\n\tif (olen != key_buf.len) {\n\t\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\t\t_iot_security_be_software_buffer_free(\u0026key_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_KEY_LEN, 0);\n\t}\n\n\t*output_buf = key_buf;\n\n\tIOT_DEBUG(\"key '%d' is loaded %d@%p\", key_id, (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\t_iot_security_be_software_buffer_free(\u0026key_b64_buf);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":209,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278206":{"score":0.8502903,"function_name":"_iot_security_be_software_pk_load_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_load_ed25519(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t seckey = { 0 };\n\tiot_security_buffer_t pubkey = { 0 };\n\n\terr = _iot_security_be_software_pk_load_ed25519_key(context, IOT_SECURITY_KEY_ID_DEVICE_PRIVATE, \u0026seckey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_pk_load_ed25519_key(context, IOT_SECURITY_KEY_ID_DEVICE_PUBLIC, \u0026pubkey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tcontext-\u003epk_params-\u003etype = IOT_SECURITY_KEY_TYPE_ED25519;\n\tcontext-\u003epk_params-\u003eseckey = seckey;\n\tcontext-\u003epk_params-\u003epubkey = pubkey;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":273,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278621":{"score":0.7747543,"function_name":"_iot_security_be_software_pk_get_key_type","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_get_key_type(iot_security_context_t *context, iot_security_key_type_t *key_type)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t*key_type = context-\u003epk_params-\u003etype;\n\n\tIOT_DEBUG(\"type = %d\", *key_type);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":444,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"278687":{"score":0.90481174,"function_name":"_iot_security_be_software_pk_sign_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_sign_ed25519(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\tiot_security_pk_params_t *pk_params;\n\tunsigned char skpk[crypto_sign_SECRETKEYBYTES];\n\tunsigned long long olen;\n\tsize_t ed25519_len = IOT_SECURITY_ED25519_LEN;\n\tint ret;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!sig_buf) {\n\t\tIOT_ERROR(\"sig buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tpk_params = context-\u003epk_params;\n\n\tif (!pk_params-\u003epubkey.p || (pk_params-\u003epubkey.len != ed25519_len)) {\n\t\tIOT_ERROR(\"pubkey is invalid with %d@%p\", (int)pk_params-\u003epubkey.len, pk_params-\u003epubkey.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_INVALID_PUBKEY, 0);\n\t}\n\n\tif (!pk_params-\u003eseckey.p || (pk_params-\u003eseckey.len != ed25519_len)) {\n\t\tIOT_ERROR(\"seckey is invalid with %d@%p\", (int)pk_params-\u003eseckey.len, pk_params-\u003eseckey.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_INVALID_SECKEY, 0);\n\t}\n\n\tIOT_DEBUG(\"input:  %3d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\tIOT_DEBUG(\"seckey: %3d@%p\", (int)pk_params-\u003eseckey.len, pk_params-\u003eseckey.p);\n\tIOT_DEBUG(\"pubkey: %3d@%p\", (int)pk_params-\u003epubkey.len, pk_params-\u003epubkey.p);\n\n\tmemcpy(skpk, pk_params-\u003eseckey.p, pk_params-\u003eseckey.len);\n\tmemcpy(skpk + ed25519_len, pk_params-\u003epubkey.p, pk_params-\u003epubkey.len);\n\n\tsig_buf-\u003elen = iot_security_pk_get_signature_len(pk_params-\u003etype);\n\tsig_buf-\u003ep = (unsigned char *)iot_os_malloc(sig_buf-\u003elen);\n\tif (!sig_buf-\u003ep) {\n\t\tIOT_ERROR(\"failed to malloc for sig\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tret = crypto_sign_detached(sig_buf-\u003ep, \u0026olen, input_buf-\u003ep, input_buf-\u003elen, skpk);\n\tif (ret) {\n\t\tIOT_ERROR(\"crypto_sign_detached = %d\", ret);\n\t\t_iot_security_be_software_buffer_free(sig_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_SIGN, ret);\n\t}\n\n\tif ((size_t)olen != sig_buf-\u003elen) {\n\t\tIOT_ERROR(\"signature length mismatch (%d != %d)\", (int)olen, (int)sig_buf-\u003elen);\n\t\t_iot_security_be_software_buffer_free(sig_buf);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_KEY_LEN, (int)sig_buf-\u003elen);\n\t}\n\n\tIOT_DEBUG(\"sig:    %3d@%p\", (int)sig_buf-\u003elen, sig_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":462,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279563":{"score":0.8022915,"function_name":"_iot_security_be_software_cipher_deinit","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tcipher_params = context-\u003ecipher_params;\n\n\tif (cipher_params-\u003ekey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026cipher_params-\u003ekey);\n\t}\n\n\tif (cipher_params-\u003eiv.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026cipher_params-\u003eiv);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":899,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279681":{"score":0.9045744,"function_name":"_iot_security_be_software_cipher_copy_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_copy_params(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tif (src-\u003ep) {\n\t\tif (src-\u003elen == 0) {\n\t\t\tIOT_ERROR(\"length of src is zero\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (dst-\u003ep) {\n\t\t\t_iot_security_be_software_buffer_free(dst);\n\t\t}\n\n\t\tdst-\u003ep = (unsigned char *)iot_os_malloc(src-\u003elen);\n\t\tif (!dst-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for dst params\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\n\t\tmemcpy(dst-\u003ep, src-\u003ep, src-\u003elen);\n\t\tdst-\u003elen = src-\u003elen;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":923,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"279927":{"score":0.9146322,"function_name":"_iot_security_be_software_cipher_set_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_set_params(iot_security_context_t *context, iot_security_cipher_params_t *cipher_set_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!cipher_set_params) {\n\t\tIOT_ERROR(\"cipher set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif ((cipher_set_params-\u003etype \u003e IOT_SECURITY_KEY_TYPE_UNKNOWN) \u0026\u0026\n\t\t(cipher_set_params-\u003etype \u003c IOT_SECURITY_KEY_TYPE_MAX)) {\n\t\tcontext-\u003ecipher_params-\u003etype = cipher_set_params-\u003etype;\n\t}\n\n\terr = _iot_security_be_software_cipher_copy_params(\u0026cipher_set_params-\u003ekey, \u0026context-\u003ecipher_params-\u003ekey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_cipher_copy_params(\u0026cipher_set_params-\u003eiv, \u0026context-\u003ecipher_params-\u003eiv);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":949,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"280154":{"score":0.87994677,"function_name":"_iot_security_be_software_cipher_aes_check_info","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_aes_check_info(iot_security_cipher_params_t *cipher_params, const mbedtls_cipher_info_t *mbed_cipher_info)\n{\n\tif (!cipher_params || !mbed_cipher_info) {\n\t\tIOT_ERROR(\"parameters are null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (cipher_params-\u003ekey.len != (mbed_cipher_info-\u003ekey_bitlen / 8)) {\n\t\tIOT_ERROR(\"key len mismatch, %d != %d\", cipher_params-\u003ekey.len, (mbed_cipher_info-\u003ekey_bitlen / 8));\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_KEY_LEN, (int)cipher_params-\u003ekey.len);\n\t}\n\n\tif (cipher_params-\u003eiv.len != mbed_cipher_info-\u003eiv_size) {\n\t\tIOT_ERROR(\"iv len mismatch, %d != %d\", cipher_params-\u003eiv.len, mbed_cipher_info-\u003eiv_size);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_IV_LEN, (int)cipher_params-\u003eiv.len);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":982,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"280408":{"score":0.91102004,"function_name":"_iot_security_be_software_cipher_aes","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_cipher_aes(iot_security_context_t *context, iot_security_cipher_mode_t cipher_mode, iot_security_buffer_t *input_buf, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\tconst mbedtls_cipher_info_t *mbed_cipher_info;\n\tmbedtls_cipher_type_t mbed_cipher_alg;\n\tmbedtls_cipher_context_t mbed_cipher_ctx;\n\tmbedtls_operation_t mbed_op_mode;\n\tsize_t required_len;\n\tsize_t expected_key_len;\n\tint ret;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (cipher_mode == IOT_SECURITY_CIPHER_ENCRYPT) {\n\t\tmbed_op_mode = MBEDTLS_ENCRYPT;\n\t} else if (cipher_mode == IOT_SECURITY_CIPHER_DECRYPT) {\n\t\tmbed_op_mode = MBEDTLS_DECRYPT;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not a supported cipher mode\", cipher_mode);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_MODE, cipher_mode);\n\t}\n\n\tcipher_params = context-\u003ecipher_params;\n\n\tif (cipher_params-\u003etype == IOT_SECURITY_KEY_TYPE_AES256) {\n\t\tmbed_cipher_alg = MBEDTLS_CIPHER_AES_256_CBC;\n\t\texpected_key_len = IOT_SECURITY_SECRET_LEN;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not a supported cipher algorithm\", cipher_params-\u003etype);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_ALGO, cipher_params-\u003etype);\n\t}\n\n\tif (!cipher_params-\u003ekey.p || (cipher_params-\u003ekey.len != expected_key_len)) {\n\t\tIOT_ERROR(\"key is invalid %d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_KEY, (int)cipher_params-\u003ekey.len);\n\t}\n\n\tif (!cipher_params-\u003eiv.p || (cipher_params-\u003eiv.len != IOT_SECURITY_IV_LEN)) {\n\t\tIOT_ERROR(\"iv is invalid %d@%p\", (int)cipher_params-\u003eiv.len, cipher_params-\u003eiv.p);\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_IV, (int)cipher_params-\u003eiv.len);\n\t}\n\n\tIOT_DEBUG(\"input: %3d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\tIOT_DEBUG(\"key:   %3d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\tIOT_DEBUG(\"iv:    %3d@%p\", (int)cipher_params-\u003eiv.len, cipher_params-\u003eiv.p);\n\n\tmbed_cipher_info = mbedtls_cipher_info_from_type(mbed_cipher_alg);\n\tif (!mbed_cipher_info) {\n\t\tIOT_ERROR(\"mbedtls_cipher_info_from_type returned null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INVALID_ALGO, 0);\n\t}\n\n\terr = _iot_security_be_software_cipher_aes_check_info(cipher_params, mbed_cipher_info);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tmbedtls_cipher_init(\u0026mbed_cipher_ctx);\n\n\tif (cipher_mode == IOT_SECURITY_CIPHER_ENCRYPT) {\n\t\trequired_len = iot_security_cipher_get_align_size(cipher_params-\u003etype, input_buf-\u003elen);\n\t} else {\n\t\trequired_len = input_buf-\u003elen;\n\t}\n\n\toutput_buf-\u003ep = (unsigned char *)iot_os_malloc(required_len);\n\tif (!output_buf-\u003ep) {\n\t\tIOT_ERROR(\"failed to malloc for output buffer\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tmemset(output_buf-\u003ep, 0, required_len);\n\n\tret = mbedtls_cipher_setup(\u0026mbed_cipher_ctx, mbed_cipher_info);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tret = mbedtls_cipher_setkey(\u0026mbed_cipher_ctx, cipher_params-\u003ekey.p, mbed_cipher_info-\u003ekey_bitlen, mbed_op_mode);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tret = mbedtls_cipher_crypt(\u0026mbed_cipher_ctx, cipher_params-\u003eiv.p, cipher_params-\u003eiv.len,\n\t\t\t\t   (const unsigned char *)input_buf-\u003ep, input_buf-\u003elen, output_buf-\u003ep, \u0026output_buf-\u003elen);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_crypt = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\tif (output_buf-\u003elen \u003e required_len) {\n\t\tIOT_ERROR(\"buffer overflow in cipher '%d' (%d \u003e %d)\", cipher_mode, (int)output_buf-\u003elen, (int)required_len);\n\t\terr = IOT_ERROR_SECURITY_CIPHER_BUF_OVERFLOW;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_output_buf;\n\t}\n\n\t_iot_security_be_software_buffer_wipe(output_buf, required_len);\n\n\tIOT_DEBUG(\"key:   %3d@%p\", (int)cipher_params-\u003ekey.len, cipher_params-\u003ekey.p);\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit;\n\nexit_free_output_buf:\n\t_iot_security_be_software_buffer_free(output_buf);\nexit:\n\tmbedtls_cipher_free(\u0026mbed_cipher_ctx);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1003,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"281846":{"score":0.9043531,"function_name":"_iot_security_be_software_manager_set_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_set_key(iot_security_context_t *context, iot_security_key_params_t *key_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_CIPHER);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_params) {\n\t\tIOT_ERROR(\"key params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (key_params-\u003ekey_id == IOT_SECURITY_KEY_ID_SHARED_SECRET) {\n\t\tiot_security_cipher_params_t *cipher_params = context-\u003ecipher_params;\n\t\tiot_security_cipher_params_t *cipher_set_params = \u0026key_params-\u003eparams.cipher;\n\n\t\tif (cipher_set_params-\u003ekey.p \u0026\u0026 cipher_set_params-\u003ekey.len) {\n\t\t\tcipher_params-\u003ekey = cipher_set_params-\u003ekey;\n\t\t}\n\n\t\tif (cipher_set_params-\u003eiv.p \u0026\u0026 cipher_set_params-\u003eiv.len) {\n\t\t\tcipher_params-\u003eiv = cipher_set_params-\u003eiv;\n\t\t}\n\t} else {\n\t\tIOT_ERROR(\"cannot set key for key index '%d'\", key_params-\u003ekey_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_INVALID_ID, 0);\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1154,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282118":{"score":0.9228294,"function_name":"_iot_security_be_software_manager_get_key","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_get_key(iot_security_context_t *context, iot_security_key_id_t key_id, iot_security_buffer_t *key_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_NONE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = _iot_security_be_software_id_key2storage(key_id);\n\n\terr = _iot_security_be_software_id_check_permission(storage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (key_id == IOT_SECURITY_KEY_ID_SHARED_SECRET) {\n\t\tif (!context-\u003ecipher_params) {\n\t\t\tIOT_ERROR(\"cipher params is null\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (!context-\u003ecipher_params-\u003ekey.p || (context-\u003ecipher_params-\u003ekey.len == 0)) {\n\t\t\tIOT_ERROR(\"shared secret not yet set\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(KEY_NOT_FOUND, 0);\n\t\t}\n\n\t\tkey_buf-\u003elen = context-\u003ecipher_params-\u003ekey.len;\n\t\tkey_buf-\u003ep = (unsigned char *)iot_os_malloc(key_buf-\u003elen);\n\t\tif (!key_buf-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for getting key\");\n\t\t\tkey_buf-\u003elen = 0;\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\t\tmemcpy(key_buf-\u003ep, context-\u003ecipher_params-\u003ekey.p, key_buf-\u003elen);\n\t} else {\n\t\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, key_buf);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1188,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282543":{"score":0.66343415,"function_name":"_iot_security_be_software_manager_get_certificate","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_manager_get_certificate(iot_security_context_t *context, iot_security_cert_id_t cert_id, iot_security_buffer_t *cert_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_NONE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = _iot_security_be_software_id_cert2storage(cert_id);\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CERT_INVALID_ID, cert_id);\n\t}\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, cert_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1235,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"282658":{"score":0.8962357,"function_name":"_iot_security_be_software_ecdh_load_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_load_ed25519(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_id_t storage_id;\n\tiot_security_ecdh_params_t *ecdh_params;\n\tiot_security_buffer_t seckey_b64_buf = { 0 };\n\tiot_security_buffer_t seckey_buf = { 0 };\n\tunsigned char *seckey_curve = NULL;\n\tsize_t olen;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_id = IOT_NVD_PRIVATE_KEY;\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_id, \u0026seckey_b64_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tseckey_buf.len = IOT_SECURITY_ED25519_LEN;\n\tseckey_buf.p = (unsigned char *)iot_os_malloc(seckey_buf.len);\n\tif (!seckey_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for seckey_buf\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey_b64;\n\t}\n\n\t/* remove null character for base64 decoding */\n\tif (strlen((char *)seckey_b64_buf.p) == (seckey_b64_buf.len - 1)) {\n\t\tseckey_b64_buf.len -= 1;\n\t}\n\n\terr = iot_security_base64_decode(seckey_b64_buf.p, seckey_b64_buf.len, seckey_buf.p, seckey_buf.len, \u0026olen);\n\tif (err) {\n\t\tgoto exit_free_seckey;\n\t}\n\n\tif (olen != seckey_buf.len) {\n\t\tIOT_ERROR(\"seckey_len '%d' is not '%d'\", (int)olen, (int)seckey_buf.len);\n\t\terr = IOT_ERROR_SECURITY_PK_KEY_LEN;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey;\n\t}\n\n\tseckey_curve = (unsigned char *)iot_os_malloc(seckey_buf.len);\n\tif (!seckey_curve) {\n\t\tIOT_ERROR(\"failed to malloc for seckey_buf curve\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_seckey;\n\t}\n\n\terr = iot_security_ed25519_convert_seckey(seckey_buf.p, seckey_curve);\n\tif (err) {\n\t\tgoto exit_free_seckey_curve;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\tecdh_params-\u003et_seckey.p = seckey_curve;\n\tecdh_params-\u003et_seckey.len = seckey_buf.len;\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit_free_seckey;\n\nexit_free_seckey_curve:\n\tiot_os_free(seckey_curve);\nexit_free_seckey:\n\t_iot_security_be_software_buffer_free(\u0026seckey_buf);\nexit_free_seckey_b64:\n\t_iot_security_be_software_buffer_free(\u0026seckey_b64_buf);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1260,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283284":{"score":0.73188186,"function_name":"_iot_security_be_software_ecdh_init","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_load(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1351,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283365":{"score":0.7947061,"function_name":"_iot_security_be_software_ecdh_deinit","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\tif (ecdh_params-\u003et_seckey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003et_seckey);\n\t}\n\n\tif (ecdh_params-\u003ec_pubkey.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003ec_pubkey);\n\t}\n\n\tif (ecdh_params-\u003esalt.p) {\n\t\t_iot_security_be_software_buffer_free(\u0026ecdh_params-\u003esalt);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1369,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283508":{"score":0.8785603,"function_name":"_iot_security_be_software_swap_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_swap_secret(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tunsigned char *p;\n\tsize_t len;\n\tint i;\n\n\tif (!src || !src-\u003ep || (src-\u003elen == 0) || !dst) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tlen = src-\u003elen;\n\tp = (unsigned char *)iot_os_malloc(len);\n\n\tif (!p) {\n\t\tIOT_ERROR(\"failed to malloc for swap\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tfor (i = 0; i \u003c len; i++) {\n\t\tp[(len - 1) - i] = src-\u003ep[i];\n\t}\n\n\tdst-\u003ep = p;\n\tdst-\u003elen = len;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1397,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"283726":{"score":0.89370763,"function_name":"_iot_security_be_software_ecdh_compute_premaster_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_compute_premaster_secret(\n\t\t\tiot_security_buffer_t *t_seckey_buf,\n\t\t\tiot_security_buffer_t *c_pubkey_buf,\n\t\t\tiot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tmbedtls_ecdh_context mbed_ecdh;\n\tmbedtls_ctr_drbg_context mbed_ctr_drbg;\n\tmbedtls_entropy_context mbed_entropy;\n\tmbedtls_ecp_group_id mbed_ecp_grp_id = MBEDTLS_ECP_DP_CURVE25519;\n\tconst char *pers = \"iot_security_ecdh\";\n\tiot_security_buffer_t pmsecret_buf = { 0 };\n\tiot_security_buffer_t swap_buf = { 0 };\n\tsize_t key_len;\n\tsize_t secret_len;\n\tint ret;\n\n\tif (!t_seckey_buf || !c_pubkey_buf || !output_buf) {\n\t\tIOT_ERROR(\"parameters is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tkey_len = IOT_SECURITY_ED25519_LEN;\n\tsecret_len = IOT_SECURITY_SECRET_LEN;\n\n\tif (t_seckey_buf-\u003elen \u003e key_len) {\n\t\tIOT_ERROR(\"things seckey is too large\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_INVALID_SECKEY, t_seckey_buf-\u003elen);\n\t}\n\n\tif (c_pubkey_buf-\u003elen \u003e key_len) {\n\t\tIOT_ERROR(\"cloud pubkey is too large\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(ECDH_INVALID_PUBKEY, c_pubkey_buf-\u003elen);\n\t}\n\n\tpmsecret_buf.len = secret_len;\n\tpmsecret_buf.p = (unsigned char *)iot_os_malloc(pmsecret_buf.len);\n\tif (!pmsecret_buf.p) {\n\t\tIOT_ERROR(\"malloc failed for pre master secret\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmbedtls_ecdh_init(\u0026mbed_ecdh);\n\tmbedtls_ctr_drbg_init(\u0026mbed_ctr_drbg);\n\tmbedtls_entropy_init(\u0026mbed_entropy);\n\n\tret = mbedtls_ctr_drbg_seed(\u0026mbed_ctr_drbg, mbedtls_entropy_func, \u0026mbed_entropy,\n\t\t\t\t\t\t\t\t(const unsigned char *)pers, strlen(pers));\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ctr_drbg_seed = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ecp_group_load(\u0026mbed_ecdh.grp, mbed_ecp_grp_id);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ecp_group_load = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\terr = _iot_security_be_software_swap_secret(t_seckey_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_read_binary(\u0026mbed_ecdh.d, swap_buf.p, swap_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_read_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\t\tgoto exit;\n\t}\n\n\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\n\terr = _iot_security_be_software_swap_secret(c_pubkey_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_read_binary(\u0026mbed_ecdh.Qp.X, swap_buf.p, swap_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_read_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\t\tgoto exit;\n\t}\n\n\t_iot_security_be_software_buffer_free(\u0026swap_buf);\n\n\tret = mbedtls_mpi_lset(\u0026mbed_ecdh.Qp.Z, 1);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_lset = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_ecdh_compute_shared(\u0026mbed_ecdh.grp, \u0026mbed_ecdh.z, \u0026mbed_ecdh.Qp, \u0026mbed_ecdh.d, mbedtls_ctr_drbg_random, \u0026mbed_ctr_drbg);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_ecdh_compute_shared = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\tret = mbedtls_mpi_write_binary(\u0026mbed_ecdh.z, pmsecret_buf.p, pmsecret_buf.len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_mpi_write_binary = -0x%04X\", -ret);\n\t\terr = IOT_ERROR_SECURITY_ECDH_LIBRARY;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit;\n\t}\n\n\terr = _iot_security_be_software_swap_secret(\u0026pmsecret_buf, \u0026swap_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\toutput_buf-\u003ep = swap_buf.p;\n\toutput_buf-\u003elen = swap_buf.len;\n\terr = IOT_ERROR_NONE;\n\nexit:\n\t_iot_security_be_software_buffer_free(\u0026pmsecret_buf);\n\tmbedtls_ecdh_free(\u0026mbed_ecdh);\n\tmbedtls_ctr_drbg_free(\u0026mbed_ctr_drbg);\n\tmbedtls_entropy_free(\u0026mbed_entropy);\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1426,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285391":{"score":0.9018025,"function_name":"_iot_security_be_software_ecdh_copy_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_copy_params(iot_security_buffer_t *src, iot_security_buffer_t *dst)\n{\n\tif (src-\u003ep) {\n\t\tif (src-\u003elen == 0) {\n\t\t\tIOT_ERROR(\"length of src is zero\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t\t}\n\n\t\tif (dst-\u003ep) {\n\t\t\t_iot_security_be_software_buffer_free(dst);\n\t\t}\n\n\t\tdst-\u003ep = (unsigned char *)iot_os_malloc(src-\u003elen);\n\t\tif (!dst-\u003ep) {\n\t\t\tIOT_ERROR(\"failed to malloc for dst params\");\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t\t}\n\n\t\tmemcpy(dst-\u003ep, src-\u003ep, src-\u003elen);\n\t\tdst-\u003elen = src-\u003elen;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1564,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285637":{"score":0.8883207,"function_name":"_iot_security_be_software_ecdh_set_params","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_set_params(iot_security_context_t *context, iot_security_ecdh_params_t *ecdh_set_params)\n{\n\tiot_error_t err;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!ecdh_set_params) {\n\t\tIOT_ERROR(\"ecdh set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003et_seckey, \u0026context-\u003eecdh_params-\u003et_seckey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003ec_pubkey, \u0026context-\u003eecdh_params-\u003ec_pubkey);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = _iot_security_be_software_ecdh_copy_params(\u0026ecdh_set_params-\u003esalt, \u0026context-\u003eecdh_params-\u003esalt);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1590,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"285870":{"score":0.9101789,"function_name":"_iot_security_be_software_ecdh_compute_shared_secret","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_ecdh_compute_shared_secret(iot_security_context_t *context, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\tiot_security_buffer_t pmsecret_buf = { 0 };\n\tiot_security_buffer_t secret_buf = { 0 };\n\tiot_security_buffer_t shared_secret_buf = { 0 };\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_ECDH);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tecdh_params = context-\u003eecdh_params;\n\n\terr = _iot_security_be_software_ecdh_compute_premaster_secret(\u0026ecdh_params-\u003et_seckey, \u0026ecdh_params-\u003ec_pubkey, \u0026pmsecret_buf);\n\tif (err) {\n\t\tgoto exit;\n\t}\n\n\tsecret_buf.len = pmsecret_buf.len + ecdh_params-\u003esalt.len;\n\tsecret_buf.p = (unsigned char *)iot_os_malloc(secret_buf.len);\n\tif (!secret_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for secret\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_pmsecret;\n\t}\n\n\tmemcpy(secret_buf.p, pmsecret_buf.p, pmsecret_buf.len);\n\tmemcpy(secret_buf.p + pmsecret_buf.len, ecdh_params-\u003esalt.p, ecdh_params-\u003esalt.len);\n\n\tshared_secret_buf.len = IOT_SECURITY_SHA256_LEN;\n\tshared_secret_buf.p = (unsigned char *)iot_os_malloc(shared_secret_buf.len);\n\tif (!shared_secret_buf.p) {\n\t\tIOT_ERROR(\"failed to malloc for shared secret\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\tgoto exit_free_secret;\n\t}\n\n\terr = iot_security_sha256(secret_buf.p, secret_buf.len, shared_secret_buf.p, shared_secret_buf.len);\n\tif (err) {\n\t\tgoto exit_free_shared_secret;\n\t}\n\n\tif (context-\u003esub_system \u0026 IOT_SECURITY_SUB_CIPHER) {\n\t\tiot_security_key_params_t shared_key_params = { 0 };\n\t\tshared_key_params.key_id = IOT_SECURITY_KEY_ID_SHARED_SECRET;\n\t\tshared_key_params.params.cipher.key = shared_secret_buf;\n\t\terr = _iot_security_be_software_manager_set_key(context, \u0026shared_key_params);\n\t\tif (err) {\n\t\t\tgoto exit_free_shared_secret;\n\t\t}\n\t}\n\n\tif (output_buf) {\n\t\t*output_buf = shared_secret_buf;\n\t}\n\n\terr = IOT_ERROR_NONE;\n\tgoto exit_free_secret;\n\nexit_free_shared_secret:\n\t_iot_security_be_software_buffer_free(\u0026shared_secret_buf);\nexit_free_secret:\n\t_iot_security_be_software_buffer_free(\u0026secret_buf);\nexit_free_pmsecret:\n\t_iot_security_be_software_buffer_free(\u0026pmsecret_buf);\nexit:\n\treturn err;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1623,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286496":{"score":0.79744303,"function_name":"_iot_security_be_software_storage_read","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_read(iot_security_context_t *context, iot_security_buffer_t *data_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\terr = _iot_security_be_software_bsp_fs_load(context, storage_params-\u003estorage_id, data_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1697,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286595":{"score":0.83937865,"function_name":"_iot_security_be_software_storage_write","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_write(iot_security_context_t *context, iot_security_buffer_t *data_buf)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\tif (!context-\u003ebe_context-\u003ebsp_fn ||\n\t\t!context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_store) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_STORE_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_store(context-\u003ebe_context, storage_params-\u003estorage_id, data_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1718,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286743":{"score":0.7913647,"function_name":"_iot_security_be_software_storage_remove","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_storage_remove(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_storage_params_t *storage_params;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_STORAGE);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tstorage_params = context-\u003estorage_params;\n\n\tif (!context-\u003ebe_context-\u003ebsp_fn ||\n\t\t!context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_remove) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BSP_FN_REMOVE_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003ebsp_fn-\u003ebsp_fs_remove(context-\u003ebe_context, storage_params-\u003estorage_id);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1744,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"286888":{"score":0.9248625,"function_name":"iot_security_be_init","code":"iot_security_be_context_t *iot_security_be_init(external_nv_callback external_nv_cb)\n{\n\tiot_error_t err;\n\tiot_security_be_context_t *be_context;\n\n\tbe_context = (iot_security_be_context_t *)iot_os_malloc(sizeof(iot_security_be_context_t));\n\tif (!be_context) {\n\t\tIOT_ERROR(\"failed to malloc for context\");\n\t\treturn NULL;\n\t}\n\n\tmemset(be_context, 0, sizeof(iot_security_be_context_t));\n\n\tbe_context-\u003ename = \"software\";\n\tbe_context-\u003efn = \u0026iot_security_be_software_funcs;\n\tbe_context-\u003eexternal_device_info_cb = external_nv_cb;\n\n\terr = iot_security_be_bsp_init(be_context);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_be_bsp_init = %d\", err);\n\t\tiot_os_free(be_context);\n\t\treturn NULL;\n\t}\n\n\tIOT_DEBUG(\"security backend is '%s'\", be_context-\u003ename);\n\n\treturn be_context;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1806,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287121":{"score":0.8658829,"function_name":"iot_security_be_deinit","code":"iot_error_t iot_security_be_deinit(iot_security_be_context_t *be_context)\n{\n\tif (!be_context) {\n\t\tIOT_ERROR(\"backend context is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tmemset(be_context, 0, sizeof(iot_security_be_context_t));\n\n\tiot_os_free(be_context);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":1835,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287272":{"score":0.5749213,"function_name":"_iot_security_be_software_pk_init","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\terr = _iot_security_be_software_pk_load_key(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":403,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287788":{"score":0.8946812,"function_name":"iot_security_pk_get_key_type","code":"iot_error_t iot_security_pk_get_key_type(iot_security_context_t *context, iot_security_key_type_t *key_type)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!key_type) {\n\t\tIOT_ERROR(\"key type is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003epk_get_key_type) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003epk_get_key_type is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003epk_get_key_type(context, key_type);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"type = %d\", *key_type);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":107,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"287995":{"score":0.83957285,"function_name":"iot_security_pk_sign","code":"iot_error_t iot_security_pk_sign(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!sig_buf) {\n\t\tIOT_ERROR(\"sig buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\tif (!context-\u003ebe_context-\u003efn-\u003epk_sign) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003epk_sign is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003epk_sign(context, input_buf, sig_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"sig = %d@%p\", (int)sig_buf-\u003elen, sig_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":136,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288285":{"score":0.785781,"function_name":"_iot_security_be_software_pk_verify_ed25519","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_software_pk_verify_ed25519(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *sig_buf)\n{\n\tiot_error_t err;\n\tiot_security_pk_params_t *pk_params;\n\tsize_t key_len = IOT_SECURITY_ED25519_LEN;\n\tint ret;\n\n\terr = _iot_security_be_check_context_and_params_is_valid(context, IOT_SECURITY_SUB_PK);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!sig_buf || !sig_buf-\u003ep || (sig_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"sig buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tpk_params = context-\u003epk_params;\n\n\tif (!pk_params-\u003epubkey.p || (pk_params-\u003epubkey.len == 0)) {\n\t\tIOT_ERROR(\"pubkey is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_INVALID_PUBKEY, 0);\n\t}\n\n\tIOT_DEBUG(\"input:  %3d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\tIOT_DEBUG(\"sig:    %3d@%p\", (int)sig_buf-\u003elen, sig_buf-\u003ep);\n\tIOT_DEBUG(\"pubkey: %3d@%p\", (int)pk_params-\u003epubkey.len, pk_params-\u003epubkey);\n\n\tif (pk_params-\u003epubkey.len != key_len) {\n\t\tIOT_ERROR(\"pubkey len '%d' is not '%d'\", (int)pk_params-\u003epubkey.len, (int)key_len);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_KEY_LEN, (int)pk_params-\u003epubkey.len);\n\t}\n\n\tret = crypto_sign_verify_detached(sig_buf-\u003ep, input_buf-\u003ep, input_buf-\u003elen, pk_params-\u003epubkey.p);\n\tif (ret) {\n\t\tIOT_ERROR(\"crypto_sign_verify_detached = %d\\n\", ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(PK_VERIFY, ret);\n\t}\n\n\tIOT_DEBUG(\"sign verify success\");\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_software.c","line_number":532,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288594":{"score":0.89210707,"function_name":"iot_security_cipher_init","code":"iot_error_t iot_security_cipher_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_cipher_params_t *cipher_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tcipher_params = (iot_security_cipher_params_t *)iot_os_malloc(sizeof(iot_security_cipher_params_t));\n\tif (!cipher_params) {\n\t\tIOT_ERROR(\"failed to malloc for cipher info\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset(cipher_params, 0, sizeof(iot_security_cipher_params_t));\n\n\tcontext-\u003ecipher_params = cipher_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003ecipher_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003ecipher_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003ecipher_params);\n\t\t\tcontext-\u003ecipher_params = NULL;\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(CIPHER_INIT, 0);\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_CIPHER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":207,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"288859":{"score":0.91933656,"function_name":"iot_security_cipher_deinit","code":"iot_error_t iot_security_cipher_deinit(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003ecipher_deinit) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003ecipher_deinit(context);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (context-\u003ecipher_params) {\n\t\tmemset(context-\u003ecipher_params, 0, sizeof(iot_security_cipher_params_t));\n\t\tiot_os_free(context-\u003ecipher_params);\n\t\tcontext-\u003ecipher_params = NULL;\n\t}\n\n\tcontext-\u003esub_system \u0026= ~IOT_SECURITY_SUB_CIPHER;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":242,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"289056":{"score":0.86724174,"function_name":"iot_security_cipher_get_align_size","code":"size_t iot_security_cipher_get_align_size(iot_security_key_type_t key_type, size_t data_size)\n{\n\tconst mbedtls_cipher_info_t *cipher_info;\n\tmbedtls_cipher_context_t cipher_ctx;\n\tmbedtls_cipher_type_t cipher_alg;\n\tunsigned int block_size;\n\tint ret;\n\n\tIOT_DEBUG(\"data size = %d, type = %d\", (int)data_size, key_type);\n\n\tif (key_type == IOT_SECURITY_KEY_TYPE_AES256) {\n\t\tcipher_alg = MBEDTLS_CIPHER_AES_256_CBC;\n\t} else {\n\t\tIOT_ERROR(\"'%d' is not supported cipher algorithm\", key_type);\n\t\treturn 0;\n\t}\n\n\tif (!data_size) {\n\t\tIOT_ERROR(\"input size is zero\");\n\t\treturn 0;\n\t}\n\n\tcipher_info = mbedtls_cipher_info_from_type(cipher_alg);\n\tif (!cipher_info) {\n\t\tIOT_ERROR(\"mbedtls_cipher_info_from_type returned null\");\n\t\treturn 0;\n\t}\n\n\tmbedtls_cipher_init(\u0026cipher_ctx);\n\n\tret = mbedtls_cipher_setup(\u0026cipher_ctx, cipher_info);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_cipher_setup = -0x%04X\", -ret);\n\t\tmbedtls_cipher_free(\u0026cipher_ctx);\n\t\treturn 0;\n\t}\n\n\tblock_size = mbedtls_cipher_get_block_size(\u0026cipher_ctx);\n\tif (block_size == 0) {\n\t\tIOT_ERROR(\"mbedtls_cipher_get_block_size returned zero\");\n\t\tmbedtls_cipher_free(\u0026cipher_ctx);\n\t\treturn 0;\n\t}\n\n\tdata_size = data_size + (block_size - (data_size % block_size));\n\n\tmbedtls_cipher_free(\u0026cipher_ctx);\n\n\tIOT_DEBUG(\"align size = %d\", (int)data_size);\n\n\treturn data_size;\n}","filepath":"src/security/iot_security_crypto.c","line_number":270,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"289532":{"score":0.86491144,"function_name":"iot_security_cipher_set_params","code":"iot_error_t iot_security_cipher_set_params(iot_security_context_t *context, iot_security_cipher_params_t *cipher_set_params)\n\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!cipher_set_params) {\n\t\tIOT_ERROR(\"cipher set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003ecipher_set_params) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003ecipher_set_params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003ecipher_set_params(context, cipher_set_params);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":323,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"289745":{"score":0.91128004,"function_name":"iot_security_cipher_aes_encrypt","code":"iot_error_t iot_security_cipher_aes_encrypt(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003ecipher_aes_encrypt) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003ecipher_aes_encrypt is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003ecipher_aes_encrypt(context, input_buf, output_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"output = %d@%p\", (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":351,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290056":{"score":0.9078085,"function_name":"iot_security_cipher_aes_decrypt","code":"iot_error_t iot_security_cipher_aes_decrypt(iot_security_context_t *context, iot_security_buffer_t *input_buf, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buf is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"input = %d@%p\", (int)input_buf-\u003elen, input_buf-\u003ep);\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tif (!context-\u003ebe_context-\u003efn-\u003ecipher_aes_decrypt) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003ecipher_aes_decrypt is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003ecipher_aes_decrypt(context, input_buf, output_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tIOT_DEBUG(\"output = %d@%p\", (int)output_buf-\u003elen, output_buf-\u003ep);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_crypto.c","line_number":389,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290367":{"score":0.9300438,"function_name":"iot_security_ecdh_init","code":"iot_error_t iot_security_ecdh_init(iot_security_context_t *context)\n{\n\tiot_error_t err;\n\tiot_security_ecdh_params_t *ecdh_params;\n\n\tif (!context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(CONTEXT_NULL, 0);\n\t}\n\n\tecdh_params = (iot_security_ecdh_params_t *)iot_os_malloc(sizeof(iot_security_ecdh_params_t));\n\tif (!ecdh_params) {\n\t\tIOT_ERROR(\"failed to malloc for ecdh params\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemset((void *)ecdh_params, 0, sizeof(iot_security_ecdh_params_t));\n\n\tcontext-\u003eecdh_params = ecdh_params;\n\n\tif (context-\u003ebe_context \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn \u0026\u0026\n\t\tcontext-\u003ebe_context-\u003efn-\u003eecdh_init) {\n\t\terr = context-\u003ebe_context-\u003efn-\u003eecdh_init(context);\n\t\tif (err) {\n\t\t\tiot_os_free(context-\u003eecdh_params);\n\t\t\tcontext-\u003eecdh_params = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tcontext-\u003esub_system |= IOT_SECURITY_SUB_ECDH;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":26,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"290824":{"score":0.873581,"function_name":"iot_security_ecdh_set_params","code":"iot_error_t iot_security_ecdh_set_params(iot_security_context_t *context, iot_security_ecdh_params_t *ecdh_set_params)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (!ecdh_set_params) {\n\t\tIOT_ERROR(\"ecdh set params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!context-\u003ebe_context-\u003efn-\u003eecdh_set_params) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003eecdh_set_params is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003eecdh_set_params(context, ecdh_set_params);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":89,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291031":{"score":0.9083129,"function_name":"iot_security_ecdh_compute_shared_secret","code":"iot_error_t iot_security_ecdh_compute_shared_secret(iot_security_context_t *context, iot_security_buffer_t *secret_buf)\n{\n\tiot_error_t err;\n\n\terr = iot_security_check_backend_funcs_entry_is_valid(context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\t/*\n\t * secret_buf can be null\n\t */\n\n\tif (!context-\u003ebe_context-\u003efn-\u003eecdh_compute_shared_secret) {\n\t\tIOT_ERROR(\"be-\u003efn-\u003eecdh_compute_shared_secret is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_FUNC_NULL, 0);\n\t}\n\n\terr = context-\u003ebe_context-\u003efn-\u003eecdh_compute_shared_secret(context, secret_buf);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/iot_security_ecdh.c","line_number":116,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291427":{"score":0.88761836,"function_name":"_iot_security_url_encode","code":"static iot_error_t _iot_security_url_encode(char *buf, size_t buf_len)\n{\n\tsize_t i;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!buf_len) {\n\t\tIOT_ERROR(\"length is zero\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tfor (i = 0; i \u003c buf_len; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase '+':\n\t\t\tbuf[i] = '-';\n\t\t\tbreak;\n\t\tcase '/':\n\t\t\tbuf[i] = '_';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":29,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"291631":{"score":0.88993,"function_name":"_iot_security_url_decode","code":"static iot_error_t _iot_security_url_decode(char *buf, size_t buf_len)\n{\n\tsize_t i;\n\n\tif (!buf) {\n\t\tIOT_ERROR(\"buf is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!buf_len) {\n\t\tIOT_ERROR(\"length is zero\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tfor (i = 0; i \u003c buf_len; i++) {\n\t\tswitch (buf[i]) {\n\t\tcase '-':\n\t\t\tbuf[i] = '+';\n\t\t\tbreak;\n\t\tcase '_':\n\t\t\tbuf[i] = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":59,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292126":{"score":0.8955282,"function_name":"iot_security_base64_encode","code":"iot_error_t iot_security_base64_encode(const unsigned char *src, size_t src_len,\n                                       unsigned char *dst, size_t dst_len,\n                                       size_t *out_len)\n{\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\tret = mbedtls_base64_encode(dst, dst_len, out_len, src, src_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_encode = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_ENCODE, -ret);\n\t}\n\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":89,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292429":{"score":0.9220173,"function_name":"iot_security_base64_encode_urlsafe","code":"iot_error_t iot_security_base64_encode_urlsafe(const unsigned char *src, size_t src_len,\n                                               unsigned char *dst, size_t dst_len,\n                                               size_t *out_len)\n{\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\tret = mbedtls_base64_encode(dst, dst_len, out_len, src, src_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_encode = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_ENCODE, -ret);\n\t}\n\n\tret = _iot_security_url_encode((char *)dst, *out_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"_iot_security_url_encode = %d\", ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_ENCODE, ret);\n\t}\n\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":157,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"292813":{"score":0.90305716,"function_name":"iot_security_base64_decode_urlsafe","code":"iot_error_t iot_security_base64_decode_urlsafe(const unsigned char *src, size_t src_len,\n                                             unsigned char *dst, size_t dst_len,\n                                             size_t *out_len)\n{\n\tunsigned char *src_dup = NULL;\n\tsize_t align_len;\n\tsize_t i;\n\tint ret;\n\n\tif (!src || (src_len == 0)) {\n\t\tIOT_ERROR(\"invalid src with %d@%p\", (int)src_len, src);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!dst || (dst_len == 0)) {\n\t\tIOT_ERROR(\"invalid dst with %d@%p\", (int)dst_len, dst);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!out_len) {\n\t\tIOT_ERROR(\"length output buffer is null\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tIOT_DEBUG(\"src: %d@%p, dst: %d@%p\", (int)src_len, src, (int)dst_len, dst);\n\n\talign_len = IOT_SECURITY_B64_ALIGN_LEN(src_len);\n\tsrc_dup = (unsigned char *)iot_os_malloc(align_len + 1);\n\tif (src_dup == NULL) {\n\t\tIOT_ERROR(\"malloc failed for align buffer\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\tmemcpy(src_dup, src, src_len);\n\t/* consider '=' removed from tail */\n\tfor (i = src_len; i \u003c align_len; i++) {\n\t\tsrc_dup[i] = '=';\n\t}\n\tsrc_dup[align_len] = '\\0';\n\n\tret = _iot_security_url_decode((char *)src_dup, align_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"_iot_security_url_decode = %d\", ret);\n\t\tiot_os_free(src_dup);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_DECODE, ret);\n\t}\n\n\tret = mbedtls_base64_decode(dst, dst_len, out_len, (const unsigned char *)src_dup, align_len);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_base64_decode = -0x%04X\", -ret);\n\t\tiot_os_free(src_dup);\n\t\tIOT_ERROR_DUMP_AND_RETURN(BASE64_URL_DECODE, -ret);\n\t}\n\n\tiot_os_free(src_dup);\n\tIOT_DEBUG(\"done: %d@%p\", (int)*out_len, dst);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":197,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"293393":{"score":0.8891457,"function_name":"iot_security_sha256","code":"iot_error_t iot_security_sha256(const unsigned char *input, size_t input_len, unsigned char *output, size_t output_len)\n{\n\tint ret;\n\n\tif (!input || (input_len == 0)) {\n\t\tIOT_ERROR(\"invalid input with %d@%p\", (int)input_len, input);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tif (!output || (output_len \u003c IOT_SECURITY_SHA256_LEN)) {\n\t\tIOT_ERROR(\"invalid output with %d@%p\", (int)output_len, output);\n\t\tIOT_ERROR_DUMP_AND_RETURN(INVALID_ARGS, 0);\n\t}\n\n\tret = mbedtls_sha256_ret(input, input_len, output, 0);\n\tif (ret) {\n\t\tIOT_ERROR(\"mbedtls_sha256_ret = -0x%04X\", -ret);\n\t\tIOT_ERROR_DUMP_AND_RETURN(SHA256, -ret);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/helper/mbedtls/iot_security_helper_mbedtls.c","line_number":257,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"293634":{"score":0.93532753,"function_name":"iot_get_random_uuid_from_mac","code":"iot_error_t iot_get_random_uuid_from_mac(struct iot_uuid *uuid)\n{\n\tiot_error_t err;\n\tstruct timeval tv;\n\tstruct iot_mac mac;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN];\n\tunsigned char *buf;\n\tsize_t buf_len;\n\tint ret;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"UUID ptr is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_bsp_wifi_get_mac(\u0026mac);\n\tif(err) {\n\t\tIOT_ERROR(\"iot_bsp_wifi_get_mac failed, ret = %d\", err);\n\t\treturn err;\n\t}\n\n\tret = gettimeofday(\u0026tv, NULL);\n\tif (ret) {\n\t\tIOT_ERROR(\"gettimeofday failed, ret = %d\", ret);\n\t\treturn IOT_ERROR_UUID_FAIL;\n\t}\n\n\tbuf_len = sizeof(mac) + sizeof(tv);\n\n\tbuf = (unsigned char *)iot_os_malloc(buf_len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"malloc failed for buf\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, \u0026mac, sizeof(mac));\n\tmemcpy(buf + sizeof(mac), \u0026tv, sizeof(tv));\n\n\t/*\n\t * uuid = first16byte(sha256(mac + usec))\n\t */\n\terr = iot_security_sha256(buf, buf_len, hash, sizeof(hash));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_sha256 failed, ret = %d\", err);\n\t\tfree((void *)buf);\n\t\treturn err;\n\t}\n\n\tmemcpy((void *)uuid, hash, sizeof(struct iot_uuid));\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tuuid-\u003eid[8] \u0026= 0x3f;\n\tuuid-\u003eid[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tuuid-\u003eid[6] \u0026= 0x0f;\n\tuuid-\u003eid[6] |= 0x40;\n\n\tfree((void *)buf);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":28,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"294215":{"score":0.9386993,"function_name":"iot_get_uuid_from_mac","code":"iot_error_t iot_get_uuid_from_mac(struct iot_uuid *uuid)\n{\n\tiot_error_t err;\n\tstruct iot_mac mac;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN];\n\tunsigned char *buf;\n\tsize_t buf_len;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"UUID ptr is null\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\terr = iot_bsp_wifi_get_mac(\u0026mac);\n\tif(err) {\n\t\tIOT_ERROR(\"iot_bsp_wifi_get_mac failed, ret = %d\", err);\n\t\treturn err;\n\t}\n\n\tbuf_len = sizeof(mac);\n\n\tbuf = (unsigned char *)iot_os_malloc(buf_len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"malloc failed for buf\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\n\tmemset(buf, 0, buf_len);\n\tmemcpy(buf, \u0026mac, buf_len);\n\n\t/*\n\t * uuid = first16byte(sha256(mac))\n\t */\n\terr = iot_security_sha256(buf, buf_len, hash, sizeof(hash));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_sha256 failed, err = %d\", err);\n\t\tfree((void *)buf);\n\t\treturn err;\n\t}\n\n\tmemcpy((void *)uuid, hash, sizeof(struct iot_uuid));\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tuuid-\u003eid[8] \u0026= 0x3f;\n\tuuid-\u003eid[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tuuid-\u003eid[6] \u0026= 0x0f;\n\tuuid-\u003eid[6] |= 0x40;\n\n\tfree((void *)buf);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":101,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"294712":{"score":0.8153945,"function_name":"iot_get_random_uuid","code":"iot_error_t iot_get_random_uuid(struct iot_uuid* uuid)\n{\n\tunsigned char* p;\n\tint i;\n\n\tif (!uuid) {\n\t\tIOT_ERROR(\"invalid args\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tp = (unsigned char *)uuid-\u003eid;\n\n\tfor (i = 0; i \u003c 4; i++) {\n\t\tunsigned int rand_value = iot_bsp_random();\n\n\t\tmemcpy(\u0026p[i * 4], (unsigned char*)\u0026rand_value, sizeof(unsigned int));\n\t}\n\n\t/* From RFC 4122\n\t * Set the two most significant bits of the\n\t * clock_seq_hi_and_reserved (8th octect) to\n\t * zero and one, respectively.\n\t */\n\tp[8] \u0026= 0x3f;\n\tp[8] |= 0x80;\n\n\t/* From RFC 4122\n\t * Set the four most significant bits of the\n\t * time_hi_and_version field (6th octect) to the\n\t * 4-bit version number from (0 1 0 0 =\u003e type 4)\n\t * Section 4.1.3.\n\t */\n\tp[6] \u0026= 0x0f;\n\tp[6] |= 0x40;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_uuid.c","line_number":165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"295149":{"score":0.88499373,"function_name":"_iot_wt_alloc_b64_buffer","code":"static iot_security_buffer_t *_iot_wt_alloc_b64_buffer(size_t plain_len)\n{\n\tiot_security_buffer_t *b64_buf;\n\tunsigned char *buf;\n\tsize_t len;\n\n\tb64_buf = (iot_security_buffer_t *)iot_os_malloc(sizeof(iot_security_buffer_t));\n\tif (!b64_buf) {\n\t\tIOT_ERROR(\"failed to malloc for b64 buffer\");\n\t\treturn NULL;\n\t}\n\n\tmemset(b64_buf, 0, sizeof(iot_security_buffer_t));\n\n\tlen = IOT_SECURITY_B64_ENCODE_LEN(plain_len);\n\tbuf = (unsigned char *)iot_os_malloc(len);\n\tif (!buf) {\n\t\tIOT_ERROR(\"failed to malloc for b64\");\n\t\tiot_os_free(b64_buf);\n\t\treturn NULL;\n\t}\n\n\tb64_buf-\u003ep = buf;\n\tb64_buf-\u003elen = len;\n\n\treturn b64_buf;\n}","filepath":"src/iot_wt.c","line_number":32,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"295384":{"score":0.8708969,"function_name":"_iot_jwt_header_rs256","code":"static char * _iot_jwt_header_rs256(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"RS256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"RSA\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":569,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"295922":{"score":0.869227,"function_name":"_iot_jwt_header_ed25519","code":"static char * _iot_jwt_header_ed25519(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"EdDSA\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"OKP\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"Ed25519\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":609,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"296460":{"score":0.85927016,"function_name":"_iot_jwt_header_eccp256","code":"static char * _iot_jwt_header_eccp256(const iot_wt_params_t *wt_params)\n{\n\tJSON_H *object;\n\tchar *object_str;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003esn) {\n\t\tIOT_ERROR(\"sn in params is null\");\n\t\treturn NULL;\n\t}\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"alg\", JSON_CREATE_STRING(\"ES256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kty\", JSON_CREATE_STRING(\"EC\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"crv\", JSON_CREATE_STRING(\"P256\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"typ\", JSON_CREATE_STRING(\"JWT\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"ver\", JSON_CREATE_STRING(\"0.0.1\"));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"kid\", JSON_CREATE_STRING(wt_params-\u003esn));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":649,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"296998":{"score":0.9032725,"function_name":"_iot_jwt_create_header","code":"static char * _iot_jwt_create_header(const iot_wt_params_t *wt_params, iot_security_key_type_t key_type)\n{\n\tchar *object_str;\n\n\tswitch(key_type) {\n\tcase IOT_SECURITY_KEY_TYPE_RSA2048:\n\t\tobject_str = _iot_jwt_header_rs256(wt_params);\n\t\tbreak;\n\tcase IOT_SECURITY_KEY_TYPE_ED25519:\n\t\tobject_str = _iot_jwt_header_ed25519(wt_params);\n\t\tbreak;\n\tcase IOT_SECURITY_KEY_TYPE_ECCP256:\n\t\tobject_str = _iot_jwt_header_eccp256(wt_params);\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"pubkey type (%d) is not supported\", key_type);\n\t\tobject_str = NULL;\n\t\tbreak;\n\t}\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":689,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"297152":{"score":0.912923,"function_name":"_iot_jwt_create_b64h","code":"static iot_error_t _iot_jwt_create_b64h(const iot_wt_params_t *wt_params,\n\t\t\t\t\tiot_security_key_type_t key_type,\n\t\t\t\t\tiot_security_buffer_t *b64h_buf)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t *b64_buf;\n\tchar *hdr;\n\tsize_t hdr_len;\n\tsize_t out_len;\n\n\tif (!wt_params || !b64h_buf) {\n\t\tIOT_ERROR(\"params is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\thdr = _iot_jwt_create_header(wt_params, key_type);\n\tif (!hdr) {\n\t\tIOT_ERROR(\"_iot_jwt_create_header returned NULL\");\n\t\terr = IOT_ERROR_WEBTOKEN_FAIL;\n\t\tgoto exit;\n\t}\n\n\thdr_len = strlen(hdr);\n\n\tb64_buf = _iot_wt_alloc_b64_buffer(hdr_len);\n\tif (!b64_buf) {\n\t\tgoto exit_hdr;\n\t}\n\n\terr = iot_security_base64_encode((unsigned char *)hdr, hdr_len, b64_buf-\u003ep, b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode = %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64h_buf-\u003ep = b64_buf-\u003ep;\n\tb64h_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(b64_buf);\nexit_hdr:\n\tfree(hdr);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":712,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"297565":{"score":0.8867284,"function_name":"_iot_jwt_create_payload","code":"static char * _iot_jwt_create_payload(const iot_wt_params_t *wt_params)\n{\n\tiot_error_t err;\n\tJSON_H *object;\n\tchar *object_str;\n\tchar time_in_sec[16]; /* 1559347200 is '2019-06-01 00:00:00 UTC' */\n\tchar uuid_str[40];    /* 4066c24f-cd48-4e92-a538-362e74337c7f */\n\tstruct iot_uuid uuid;\n\n\tif (!wt_params) {\n\t\tIOT_ERROR(\"wt_params is null\");\n\t\treturn NULL;\n\t}\n\n\tif (!wt_params-\u003emnid) {\n\t\tIOT_ERROR(\"mnid in params is null\");\n\t\treturn NULL;\n\t}\n\n\terr = iot_get_time_in_sec(time_in_sec, sizeof(time_in_sec));\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_get_time_in_sec returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\terr = iot_get_random_uuid(\u0026uuid);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_get_random_uuid returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\terr = iot_util_convert_uuid_str(\u0026uuid, uuid_str, sizeof(uuid_str));\n\tif (err) {\n\t\tIOT_ERROR(\"iot_util_convert_uuid_str returned error : %d\", err);\n\t\treturn NULL;\n\t}\n\n\n\tobject = JSON_CREATE_OBJECT();\n\tif (!object) {\n\t\tIOT_ERROR(\"JSON_CREATE_OBJECT returned NULL\");\n\t\treturn NULL;\n\t}\n\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"iat\", JSON_CREATE_STRING(time_in_sec));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"jti\", JSON_CREATE_STRING(uuid_str));\n\tJSON_ADD_ITEM_TO_OBJECT(object, \"mnId\", JSON_CREATE_STRING(wt_params-\u003emnid));\n\n\tobject_str = JSON_PRINT(object);\n\tif (!object_str) {\n\t\tIOT_ERROR(\"JSON_PRINT returned NULL\");\n\t\tJSON_DELETE(object);\n\t\treturn NULL;\n\t}\n\n\tJSON_DELETE(object);\n\n\treturn object_str;\n}","filepath":"src/iot_wt.c","line_number":761,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"298249":{"score":0.9088419,"function_name":"_iot_jwt_create_b64p","code":"static iot_error_t _iot_jwt_create_b64p(const iot_wt_params_t *wt_params,\n\t\t\tiot_security_buffer_t *b64p_buf)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_security_buffer_t *b64_buf;\n\tchar *payload;\n\tsize_t payload_len;\n\tsize_t out_len;\n\n\tif (!wt_params || !b64p_buf) {\n\t\tIOT_ERROR(\"params is NULL\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tpayload = _iot_jwt_create_payload(wt_params);\n\tif (!payload) {\n\t\tIOT_ERROR(\"_iot_jwt_create_payload returned NULL\");\n\t\terr = IOT_ERROR_WEBTOKEN_FAIL;\n\t\tgoto exit;\n\t}\n\n\tpayload_len = strlen(payload);\n\n\tb64_buf = _iot_wt_alloc_b64_buffer(payload_len);\n\tif (!b64_buf) {\n\t\tgoto exit_payload;\n\t}\n\n\terr = iot_security_base64_encode((unsigned char *)payload, payload_len, b64_buf-\u003ep, b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode returned error : %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64p_buf-\u003ep = b64_buf-\u003ep;\n\tb64p_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(b64_buf);\nexit_payload:\n\tfree(payload);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":821,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"298659":{"score":0.8940286,"function_name":"_iot_jwt_create_b64s","code":"static iot_error_t _iot_jwt_create_b64s(iot_security_context_t *security_context,\n                                        unsigned char *b64hp, size_t hp_len,\n                                        iot_security_buffer_t *b64s_buf)\n{\n\tiot_error_t err;\n\tiot_security_buffer_t hp_buf = {0 };\n\tiot_security_buffer_t sig_buf = { 0 };\n\tiot_security_buffer_t *sig_b64_buf;\n\tiot_security_key_type_t key_type;\n\tunsigned char hash[IOT_SECURITY_SHA256_LEN] = { 0 };\n\tsize_t out_len;\n\n\terr = iot_security_pk_get_key_type(security_context, \u0026key_type);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_pk_get_key_type returned error : %d\", err);\n\t\tgoto exit;\n\t}\n\n\tswitch (key_type) {\n\tcase IOT_SECURITY_KEY_TYPE_ED25519:\n\t\thp_buf.p = b64hp;\n\t\thp_buf.len = hp_len;\n\t\terr = iot_security_pk_sign(security_context, \u0026hp_buf, \u0026sig_buf);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_pk_sign returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = iot_security_sha256(b64hp, hp_len, hash, sizeof(hash));\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_sha256 returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\thp_buf.p = hash;\n\t\thp_buf.len = sizeof(hash);\n\t\terr = iot_security_pk_sign(security_context, \u0026hp_buf, \u0026sig_buf);\n\t\tif (err) {\n\t\t\tIOT_ERROR(\"iot_security_pk_sign returned error : %d\", err);\n\t\t\tgoto exit;\n\t\t}\n\t\tbreak;\n\t}\n\n\tsig_b64_buf = _iot_wt_alloc_b64_buffer(sig_buf.len);\n\tif (!sig_b64_buf) {\n\t\tgoto exit_sig;\n\t}\n\n\terr = iot_security_base64_encode(sig_buf.p, sig_buf.len, sig_b64_buf-\u003ep, sig_b64_buf-\u003elen, \u0026out_len);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_security_base64_encode returned error : %d\", err);\n\t\tgoto exit_b64_buf_p;\n\t}\n\n\tb64s_buf-\u003ep = sig_b64_buf-\u003ep;\n\tb64s_buf-\u003elen = out_len;\n\tgoto exit_b64_buf;\n\nexit_b64_buf_p:\n\tiot_os_free(sig_b64_buf-\u003ep);\nexit_b64_buf:\n\tiot_os_free(sig_b64_buf);\nexit_sig:\n\tiot_os_free(sig_buf.p);\nexit:\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":869,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"299331":{"score":0.92583716,"function_name":"_iot_jwt_create","code":"static iot_error_t _iot_jwt_create(const iot_wt_params_t *wt_params, iot_security_buffer_t *token_buf)\n{\n\tiot_error_t err;\n\tiot_security_context_t *security_context;\n\tiot_security_key_type_t key_type;\n\tiot_security_buffer_t b64h_buf = { 0 };\n\tiot_security_buffer_t b64p_buf = { 0 };\n\tiot_security_buffer_t b64s_buf = { 0 };\n\tunsigned char *tmp;\n\tsize_t sig_len;\n\tsize_t token_len;\n\tsize_t written = 0;\n\n\tif (!wt_params || !token_buf) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tsecurity_context = iot_security_init();\n\tif (!security_context) {\n\t\treturn IOT_ERROR_SECURITY_INIT;\n\t}\n\n\terr = iot_security_pk_init(security_context);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_security_pk_get_key_type(security_context, \u0026key_type);\n\tif (err) {\n\t\tgoto exit_payload;\n\t}\n\n\t/* b64h = b64(header) */\n\n\terr = _iot_jwt_create_b64h(wt_params, key_type, \u0026b64h_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64h = %d\", err);\n\t\tgoto exit;\n\t}\n\n\t/* b64p = b64(payload) */\n\n\terr = _iot_jwt_create_b64p(wt_params, \u0026b64p_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64p returned error : %d\", err);\n\t\tgoto exit_header;\n\t}\n\n\t/* b64h.b64 */\n\n\tsig_len = iot_security_pk_get_signature_len(key_type);\n\n\ttoken_len = b64h_buf.len + b64p_buf.len + IOT_SECURITY_B64_ENCODE_LEN(sig_len) + 3;\n\n\ttmp = (unsigned char *)iot_os_malloc(token_len);\n\tif (tmp == NULL) {\n\t\tIOT_ERROR(\"malloc returned NULL\");\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tgoto exit_payload;\n\t}\n\n\tmemcpy(tmp, b64h_buf.p, b64h_buf.len);\n\twritten += b64h_buf.len;\n\n\ttmp[written++] = '.';\n\n\tmemcpy(tmp + written, b64p_buf.p, b64p_buf.len);\n\twritten += b64p_buf.len;\n\n\t/* b64s = b64(sign(sha256(b64h.b64p))) */\n\n\terr = _iot_jwt_create_b64s(security_context, tmp, written, \u0026b64s_buf);\n\tif (err) {\n\t\tIOT_ERROR(\"_iot_jwt_create_b64s returned error : %d\", err);\n\t\tiot_os_free(tmp);\n\t\tgoto exit_payload;\n\t}\n\n\t/* token = b64h.b64p.b64s */\n\n\ttmp[written++] = '.';\n\n\tmemcpy(tmp + written, b64s_buf.p, b64s_buf.len);\n\twritten += b64s_buf.len;\n\n\ttmp[written] = '\\0';\n\n\tIOT_DEBUG(\"token: %s (%d)\", tmp, written);\n\n\ttoken_buf-\u003ep = tmp;\n\ttoken_buf-\u003elen = written;\n\terr = IOT_ERROR_NONE;\n\tgoto exit_signature;\n\nexit_signature:\n\tiot_os_free(b64s_buf.p);\nexit_payload:\n\tiot_os_free(b64p_buf.p);\nexit_header:\n\tiot_os_free(b64h_buf.p);\nexit:\n\t(void)iot_security_pk_deinit(security_context);\n\t(void)iot_security_deinit(security_context);\n\n\treturn err;\n}","filepath":"src/iot_wt.c","line_number":939,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"326781":{"score":0.9075617,"function_name":"crypto_sign_ed25519_seed_keypair","code":"int\ncrypto_sign_ed25519_seed_keypair(unsigned char *pk, unsigned char *sk,\n                                 const unsigned char *seed)\n{\n    ge25519_p3 A;\n\n    crypto_hash_sha512(sk, seed, 32);\n    sk[0] \u0026= 248;\n    sk[31] \u0026= 127;\n    sk[31] |= 64;\n\n    ge25519_scalarmult_base(\u0026A, sk);\n    ge25519_p3_tobytes(pk, \u0026A);\n\n    memmove(sk, seed, 32);\n    memmove(sk + 32, pk, 32);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":12,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327067":{"score":0.68803036,"function_name":"crypto_sign_ed25519_keypair","code":"int\ncrypto_sign_ed25519_keypair(unsigned char *pk, unsigned char *sk)\n{\n    unsigned char seed[32];\n    int           ret;\n\n    randombytes_buf(seed, sizeof seed);\n    ret = crypto_sign_ed25519_seed_keypair(pk, sk, seed);\n    sodium_memzero(seed, sizeof seed);\n\n    return ret;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":32,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327191":{"score":0.90502363,"function_name":"crypto_sign_ed25519_pk_to_curve25519","code":"int\ncrypto_sign_ed25519_pk_to_curve25519(unsigned char *curve25519_pk,\n                                     const unsigned char *ed25519_pk)\n{\n    ge25519_p3 A;\n    fe25519    x;\n    fe25519    one_minus_y;\n\n    if (ge25519_has_small_order(ed25519_pk) != 0 ||\n        ge25519_frombytes_negate_vartime(\u0026A, ed25519_pk) != 0 ||\n        ge25519_is_on_main_subgroup(\u0026A) == 0) {\n        return -1;\n    }\n    fe25519_1(one_minus_y);\n    fe25519_sub(one_minus_y, one_minus_y, A.Y);\n    fe25519_1(x);\n    fe25519_add(x, x, A.Y);\n    fe25519_invert(one_minus_y, one_minus_y);\n    fe25519_mul(x, x, one_minus_y);\n    fe25519_tobytes(curve25519_pk, x);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":45,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"327536":{"score":0.7655641,"function_name":"crypto_sign_ed25519_sk_to_curve25519","code":"int\ncrypto_sign_ed25519_sk_to_curve25519(unsigned char *curve25519_sk,\n                                     const unsigned char *ed25519_sk)\n{\n    unsigned char h[crypto_hash_sha512_BYTES];\n\n    crypto_hash_sha512(h, ed25519_sk, 32);\n    h[0] \u0026= 248;\n    h[31] \u0026= 127;\n    h[31] |= 64;\n    memcpy(curve25519_sk, h, crypto_scalarmult_curve25519_BYTES);\n    sodium_memzero(h, sizeof h);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/keypair.c","line_number":69,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"354041":{"score":0.5729518,"function_name":"randombytes_init_if_needed","code":"static void\nrandombytes_init_if_needed(void)\n{\n    if (implementation == NULL) {\n        implementation = RANDOMBYTES_DEFAULT_IMPLEMENTATION;\n        randombytes_stir();\n    }\n}","filepath":"deps/libsodium/src/libsodium/randombytes/randombytes.c","line_number":41,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"354195":{"score":0.6154105,"function_name":"randombytes_stir","code":"void\nrandombytes_stir(void)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation-\u003estir != NULL) {\n        implementation-\u003estir();\n    }\n#else\n    EM_ASM({\n        if (Module.getRandomValue === undefined) {\n            try {\n                var window_ = \"object\" === typeof window ? window : self,\n                    crypto_ = typeof window_.crypto !== \"undefined\" ? window_.crypto : window_.msCrypto,\n                    randomValuesStandard = function() {\n                        var buf = new Uint32Array(1);\n                        crypto_.getRandomValues(buf);\n                        return buf[0] \u003e\u003e\u003e 0;\n                    };\n                randomValuesStandard();\n                Module.getRandomValue = randomValuesStandard;\n            } catch (e) {\n                try {\n                    var crypto = require('crypto'),\n                        randomValueNodeJS = function() {\n                            var buf = crypto.randomBytes(4);\n                            return (buf[0] \u003c\u003c 24 | buf[1] \u003c\u003c 16 | buf[2] \u003c\u003c 8 | buf[3]) \u003e\u003e\u003e 0;\n                        };\n                    randomValueNodeJS();\n                    Module.getRandomValue = randomValueNodeJS;\n                } catch (e) {\n                    throw 'No secure random number generator found';\n                }\n            }\n        }","filepath":"deps/libsodium/src/libsodium/randombytes/randombytes.c","line_number":82,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"354249":{"score":0.5925107,"function_name":"randombytes_uniform","code":"uint32_t\nrandombytes_uniform(const uint32_t upper_bound)\n{\n    uint32_t min;\n    uint32_t r;\n\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (implementation-\u003euniform != NULL) {\n        return implementation-\u003euniform(upper_bound);\n    }\n#endif\n    if (upper_bound \u003c 2) {\n        return 0;\n    }","filepath":"deps/libsodium/src/libsodium/randombytes/randombytes.c","line_number":125,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"354370":{"score":0.6603686,"function_name":"randombytes_buf","code":"void\nrandombytes_buf(void * const buf, const size_t size)\n{\n#ifndef __EMSCRIPTEN__\n    randombytes_init_if_needed();\n    if (size \u003e (size_t) 0U) {\n        implementation-\u003ebuf(buf, size);\n    }\n#else\n    unsigned char *p = buf;\n    size_t         i;\n\n    for (i = (size_t) 0U; i \u003c size; i++) {\n        p[i] = (unsigned char) randombytes_random();\n    }\n#endif\n}","filepath":"deps/libsodium/src/libsodium/randombytes/randombytes.c","line_number":148,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"354508":{"score":0.9202728,"function_name":"randombytes_close","code":"int\nrandombytes_close(void)\n{\n    if (implementation != NULL \u0026\u0026 implementation-\u003eclose != NULL) {\n        return implementation-\u003eclose();\n    }\n    return 0;\n}","filepath":"deps/libsodium/src/libsodium/randombytes/randombytes.c","line_number":166,"entry_url":"https://github.com/sodium-friends/sodium-native.git","slot_name":"v0.0.1"},"354663":{"score":0.76899886,"function_name":"safe_read","code":"static ssize_t\nsafe_read(const int fd, void * const buf_, size_t size)\n{\n    unsigned char *buf = (unsigned char *) buf_;\n    ssize_t        readnb;\n\n    assert(size \u003e (size_t) 0U);\n    assert(size \u003c= SSIZE_MAX);\n    do {\n        while ((readnb = read(fd, buf, size)) \u003c (ssize_t) 0 \u0026\u0026\n               (errno == EINTR || errno == EAGAIN)); /* LCOV_EXCL_LINE */\n        if (readnb \u003c (ssize_t) 0) {\n            return readnb; /* LCOV_EXCL_LINE */\n        }\n        if (readnb == (ssize_t) 0) {\n            break; /* LCOV_EXCL_LINE */\n        }\n        size -= (size_t) readnb;\n        buf += readnb;\n    } while (size \u003e (ssize_t) 0);\n\n    return (ssize_t) (buf - (unsigned char *) buf_);\n}","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":106,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"354868":{"score":0.96851057,"function_name":"randombytes_block_on_dev_random","code":"static int\nrandombytes_block_on_dev_random(void)\n{\n    struct pollfd pfd;\n    int           fd;\n    int           pret;\n\n    fd = open(\"/dev/random\", O_RDONLY);\n    if (fd == -1) {\n        return 0;\n    }\n    pfd.fd = fd;\n    pfd.events = POLLIN;\n    pfd.revents = 0;\n    do {\n        pret = poll(\u0026pfd, 1, -1);\n    } while (pret \u003c 0 \u0026\u0026 (errno == EINTR || errno == EAGAIN));\n    if (pret != 1) {\n        (void) close(fd);\n        errno = EIO;\n        return -1;\n    }\n    return close(fd);\n}","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":133,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"355077":{"score":0.88600034,"function_name":"randombytes_salsa20_random_random_dev_open","code":"static int\nrandombytes_salsa20_random_random_dev_open(void)\n{\n/* LCOV_EXCL_START */\n    struct stat       st;\n    static const char *devices[] = {\n#  ifndef USE_BLOCKING_RANDOM\n        \"/dev/urandom\",\n#  endif\n        \"/dev/random\", NULL\n    };\n    const char **     device = devices;\n    int               fd;\n\n# if defined(__linux__) \u0026\u0026 !defined(USE_BLOCKING_RANDOM)\n    if (randombytes_block_on_dev_random() != 0) {\n        return -1;\n    }\n# endif\n    do {\n        fd = open(*device, O_RDONLY);\n        if (fd != -1) {\n            if (fstat(fd, \u0026st) == 0 \u0026\u0026\n# ifdef __COMPCERT__\n                1\n# elif defined(S_ISNAM)\n                (S_ISNAM(st.st_mode) || S_ISCHR(st.st_mode))\n# else\n                S_ISCHR(st.st_mode)\n# endif\n               ) {\n#  if defined(F_SETFD) \u0026\u0026 defined(FD_CLOEXEC)\n                (void) fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n#  endif\n                return fd;\n            }\n            (void) close(fd);\n        } else if (errno == EINTR) {\n            continue;\n        }\n        device++;\n    } while (*device != NULL);\n\n    errno = EIO;\n    return -1;\n/* LCOV_EXCL_STOP */\n}","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":160,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"355326":{"score":0.8739331,"function_name":"_randombytes_linux_getrandom","code":"static int\n_randombytes_linux_getrandom(void * const buf, const size_t size)\n{\n    int readnb;\n\n    assert(size \u003c= 256U);\n    do {\n        readnb = syscall(SYS_getrandom, buf, (int) size, 0);\n    } while (readnb \u003c 0 \u0026\u0026 (errno == EINTR || errno == EAGAIN));\n\n    return (readnb == (int) size) - 1;\n}","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":210,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"355464":{"score":0.918448,"function_name":"randombytes_linux_getrandom","code":"static int\nrandombytes_linux_getrandom(void * const buf_, size_t size)\n{\n    unsigned char *buf = (unsigned char *) buf_;\n    size_t         chunk_size = 256U;\n\n    do {\n        if (size \u003c chunk_size) {\n            chunk_size = size;\n            assert(chunk_size \u003e (size_t) 0U);\n        }\n        if (_randombytes_linux_getrandom(buf, chunk_size) != 0) {\n            return -1;\n        }\n        size -= chunk_size;\n        buf += chunk_size;\n    } while (size \u003e (size_t) 0U);\n\n    return 0;\n}","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":223,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"355841":{"score":0.8934815,"function_name":"randombytes_salsa20_random_close","code":"static int\nrandombytes_salsa20_random_close(void)\n{\n    int ret = -1;\n\n#ifndef _WIN32\n    if (stream.random_data_source_fd != -1 \u0026\u0026\n        close(stream.random_data_source_fd) == 0) {\n        stream.random_data_source_fd = -1;\n        stream.initialized = 0;\n# ifdef HAVE_GETPID\n        stream.pid = (pid_t) 0;\n# endif\n        ret = 0;\n    }\n\n# ifdef HAVE_SAFE_ARC4RANDOM\n    ret = 0;\n# endif\n\n# if defined(SYS_getrandom) \u0026\u0026 defined(__NR_getrandom)\n    if (stream.getrandom_available != 0) {\n        ret = 0;\n    }\n# endif\n\n#else /* _WIN32 */\n    if (stream.initialized != 0) {\n        stream.initialized = 0;\n        ret = 0;\n    }","filepath":"deps/libsodium/src/libsodium/randombytes/salsa20/randombytes_salsa20_random.c","line_number":374,"entry_url":"https://github.com/paixaop/node-sodium.git","slot_name":"1.1.7"},"381667":{"score":0.81096447,"function_name":"_crypto_sign_ed25519_ref10_hinit","code":"void\n_crypto_sign_ed25519_ref10_hinit(crypto_hash_sha512_state *hs, int prehashed)\n{\n    static const unsigned char DOM2PREFIX[32 + 2] = {\n        'S', 'i', 'g', 'E', 'd', '2', '5', '5', '1', '9', ' ',\n        'n', 'o', ' ',\n        'E', 'd', '2', '5', '5', '1', '9', ' ',\n        'c', 'o', 'l', 'l', 'i', 's', 'i', 'o', 'n', 's', 1, 0\n    };\n\n    crypto_hash_sha512_init(hs);\n    if (prehashed) {\n        crypto_hash_sha512_update(hs, DOM2PREFIX, sizeof DOM2PREFIX);\n    }\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/sign.c","line_number":10,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"381805":{"score":0.8562205,"function_name":"_crypto_sign_ed25519_detached","code":"int\n_crypto_sign_ed25519_detached(unsigned char *sig, unsigned long long *siglen_p,\n                              const unsigned char *m, unsigned long long mlen,\n                              const unsigned char *sk, int prehashed)\n{\n    crypto_hash_sha512_state hs;\n    unsigned char            az[64];\n    unsigned char            nonce[64];\n    unsigned char            hram[64];\n    ge_p3                    R;\n\n    crypto_hash_sha512(az, sk, 32);\n    az[0] \u0026= 248;\n    az[31] \u0026= 63;\n    az[31] |= 64;\n\n    _crypto_sign_ed25519_ref10_hinit(\u0026hs, prehashed);\n    crypto_hash_sha512_update(\u0026hs, az + 32, 32);\n    crypto_hash_sha512_update(\u0026hs, m, mlen);\n    crypto_hash_sha512_final(\u0026hs, nonce);\n\n    memmove(sig + 32, sk + 32, 32);\n\n    sc_reduce(nonce);\n    ge_scalarmult_base(\u0026R, nonce);\n    ge_p3_tobytes(sig, \u0026R);\n\n    _crypto_sign_ed25519_ref10_hinit(\u0026hs, prehashed);\n    crypto_hash_sha512_update(\u0026hs, sig, 64);\n    crypto_hash_sha512_update(\u0026hs, m, mlen);\n    crypto_hash_sha512_final(\u0026hs, hram);\n\n    sc_reduce(hram);\n    sc_muladd(sig + 32, hram, az, nonce);\n\n    sodium_memzero(az, sizeof az);\n\n    if (siglen_p != NULL) {\n        *siglen_p = 64U;\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/sign.c","line_number":26,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"382450":{"score":0.8535383,"function_name":"crypto_sign_ed25519","code":"int\ncrypto_sign_ed25519(unsigned char *sm, unsigned long long *smlen_p,\n                    const unsigned char *m, unsigned long long mlen,\n                    const unsigned char *sk)\n{\n    unsigned long long siglen;\n\n    memmove(sm + crypto_sign_ed25519_BYTES, m, mlen);\n    /* LCOV_EXCL_START */\n    if (crypto_sign_ed25519_detached(\n            sm, \u0026siglen, sm + crypto_sign_ed25519_BYTES, mlen, sk) != 0 ||\n        siglen != crypto_sign_ed25519_BYTES) {\n        if (smlen_p != NULL) {\n            *smlen_p = 0;\n        }\n        memset(sm, 0, mlen + crypto_sign_ed25519_BYTES);\n        return -1;\n    }\n    /* LCOV_EXCL_STOP */\n\n    if (smlen_p != NULL) {\n        *smlen_p = mlen + siglen;\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_sign/ed25519/ref10/sign.c","line_number":77,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.12"},"383658":{"score":0.59944624,"function_name":"crypto_stream_chacha20","code":"int\ncrypto_stream_chacha20(unsigned char *c, unsigned long long clen,\n                       const unsigned char *n, const unsigned char *k)\n{\n    if (clen \u003e crypto_stream_chacha20_MESSAGEBYTES_MAX) {\n        sodium_misuse();\n    }\n    return implementation-\u003estream(c, clen, n, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":53,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"383737":{"score":0.6278601,"function_name":"crypto_stream_chacha20_ietf_ext_xor_ic","code":"int\ncrypto_stream_chacha20_ietf_ext_xor_ic(unsigned char *c, const unsigned char *m,\n                                       unsigned long long mlen,\n                                       const unsigned char *n, uint32_t ic,\n                                       const unsigned char *k)\n{\n    if (mlen \u003e crypto_stream_chacha20_MESSAGEBYTES_MAX) {\n        sodium_misuse();\n    }\n    return implementation-\u003estream_ietf_ext_xor_ic(c, m, mlen, n, ic, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":96,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"383822":{"score":0.6216083,"function_name":"crypto_stream_chacha20_ietf_ext_xor","code":"static int\ncrypto_stream_chacha20_ietf_ext_xor(unsigned char *c, const unsigned char *m,\n                                    unsigned long long mlen, const unsigned char *n,\n                                    const unsigned char *k)\n{\n    if (mlen \u003e crypto_stream_chacha20_MESSAGEBYTES_MAX) {\n        sodium_misuse();\n    }\n    return implementation-\u003estream_ietf_ext_xor_ic(c, m, mlen, n, 0U, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":108,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"383979":{"score":0.7606977,"function_name":"crypto_stream_chacha20_ietf_xor_ic","code":"int\ncrypto_stream_chacha20_ietf_xor_ic(unsigned char *c, const unsigned char *m,\n                                   unsigned long long mlen,\n                                   const unsigned char *n, uint32_t ic,\n                                   const unsigned char *k)\n{\n    if ((unsigned long long) ic \u003e\n        (64ULL * (1ULL \u003c\u003c 32)) / 64ULL - (mlen + 63ULL) / 64ULL) {\n        sodium_misuse();\n    }\n    return crypto_stream_chacha20_ietf_ext_xor_ic(c, m, mlen, n, ic, k);\n}","filepath":"libs/libsodium/src/crypto_stream/chacha20/stream_chacha20.c","line_number":129,"entry_url":"https://github.com/miranda-ng/miranda-ng.git","slot_name":"v0.95.10"},"384336":{"score":0.7332518,"function_name":"sodium_memzero","code":"void\nsodium_memzero(void * const pnt, const size_t len)\n{\n#ifdef _WIN32\n    SecureZeroMemory(pnt, len);\n#elif defined(HAVE_MEMSET_S)\n    if (len \u003e 0U \u0026\u0026 memset_s(pnt, (rsize_t) len, 0, (rsize_t) len) != 0) {\n        sodium_misuse(); /* LCOV_EXCL_LINE */\n    }\n#elif defined(HAVE_EXPLICIT_BZERO)\n    explicit_bzero(pnt, len);\n#elif defined(HAVE_EXPLICIT_MEMSET)\n    explicit_memset(pnt, 0, len);\n#elif HAVE_WEAK_SYMBOLS\n    if (len \u003e 0U) {\n        memset(pnt, 0, len);\n        _sodium_dummy_symbol_to_prevent_memzero_lto(pnt, len);\n    }\n# ifdef HAVE_INLINE_ASM\n    __asm__ __volatile__ (\"\" : : \"r\"(pnt) : \"memory\");\n# endif\n#else\n    volatile unsigned char *volatile pnt_ =\n        (volatile unsigned char *volatile) pnt;\n    size_t i = (size_t) 0U;\n\n    while (i \u003c len) {\n        pnt_[i++] = 0U;\n    }\n#endif\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":117,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384435":{"score":0.8836212,"function_name":"sodium_memcmp","code":"int\nsodium_memcmp(const void *const b1_, const void *const b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = (const unsigned char *) b1_;\n    const unsigned char *b2 = (const unsigned char *) b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    size_t                 i;\n    volatile unsigned char d = 0U;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_memcmp_lto(b1, b2, len);\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        d |= b1[i] ^ b2[i];\n    }\n    return (1 \u0026 ((d - 1) \u003e\u003e 8)) - 1;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":176,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384580":{"score":0.8869225,"function_name":"sodium_compare","code":"int\nsodium_compare(const unsigned char *b1_, const unsigned char *b2_, size_t len)\n{\n#ifdef HAVE_WEAK_SYMBOLS\n    const unsigned char *b1 = b1_;\n    const unsigned char *b2 = b2_;\n#else\n    const volatile unsigned char *volatile b1 =\n        (const volatile unsigned char *volatile) b1_;\n    const volatile unsigned char *volatile b2 =\n        (const volatile unsigned char *volatile) b2_;\n#endif\n    size_t                 i;\n    volatile unsigned char gt = 0U;\n    volatile unsigned char eq = 1U;\n    uint16_t               x1, x2;\n\n#if HAVE_WEAK_SYMBOLS\n    _sodium_dummy_symbol_to_prevent_compare_lto(b1, b2, len);\n#endif\n    i = len;\n    while (i != 0U) {\n        i--;\n        x1 = b1[i];\n        x2 = b2[i];\n        gt |= ((x2 - x1) \u003e\u003e 8) \u0026 eq;\n        eq \u0026= ((x2 ^ x1) - 1) \u003e\u003e 8;\n    }\n    return (int) (gt + gt + eq) - 1;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":216,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384785":{"score":0.8841786,"function_name":"sodium_is_zero","code":"int\nsodium_is_zero(const unsigned char *n, const size_t nlen)\n{\n    size_t                 i;\n    volatile unsigned char d = 0U;\n\n    for (i = 0U; i \u003c nlen; i++) {\n        d |= n[i];\n    }\n    return 1 \u0026 ((d - 1) \u003e\u003e 8);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":247,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384864":{"score":0.81496596,"function_name":"sodium_increment","code":"void\nsodium_increment(unsigned char *n, const size_t nlen)\n{\n    size_t        i = 0U;\n    uint_fast16_t c = 1U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2;\n    uint32_t t32;\n\n    if (nlen == 12U) {\n        __asm__ __volatile__(\n            \"xorq %[t64], %[t64] \\n\"\n            \"xorl %[t32], %[t32] \\n\"\n            \"stc \\n\"\n            \"adcq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t32] \"=\u0026r\"(t32)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 24U) {\n        __asm__ __volatile__(\n            \"movq $1, %[t64] \\n\"\n            \"xorq %[t64_2], %[t64_2] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_2], 16(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t64_2] \"=\u0026r\"(t64_2)\n            : [out] \"D\"(n)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (nlen == 8U) {\n        __asm__ __volatile__(\"incq (%[out]) \\n\"\n                             :\n                             : [out] \"D\"(n)\n                             : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (; i \u003c nlen; i++) {\n        c += (uint_fast16_t) n[i];\n        n[i] = (unsigned char) c;\n        c \u003e\u003e= 8;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":259,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"384945":{"score":0.74380255,"function_name":"sodium_add","code":"void\nsodium_add(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    size_t        i;\n    uint_fast16_t c = 0U;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64, t64_2, t64_3;\n    uint32_t t32;\n\n    if (len == 12U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movl 8(%[in]), %[t32] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcl %[t32], 8(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t32] \"=\u0026r\"(t32)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 24U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"movq 8(%[in]), %[t64_2] \\n\"\n            \"movq 16(%[in]), %[t64_3] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            \"adcq %[t64_2], 8(%[out]) \\n\"\n            \"adcq %[t64_3], 16(%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64), [t64_2] \"=\u0026r\"(t64_2), [t64_3] \"=\u0026r\"(t64_3)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    } else if (len == 8U) {\n        __asm__ __volatile__(\n            \"movq (%[in]), %[t64] \\n\"\n            \"addq %[t64], (%[out]) \\n\"\n            : [t64] \"=\u0026r\"(t64)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        c += (uint_fast16_t) a[i] + (uint_fast16_t) b[i];\n        a[i] = (unsigned char) c;\n        c \u003e\u003e= 8;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":306,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385042":{"score":0.7799491,"function_name":"sodium_sub","code":"void\nsodium_sub(unsigned char *a, const unsigned char *b, const size_t len)\n{\n    uint_fast16_t c = 0U;\n    size_t        i;\n\n#ifdef HAVE_AMD64_ASM\n    uint64_t t64_1, t64_2, t64_3, t64_4;\n    uint64_t t64_5, t64_6, t64_7, t64_8;\n    uint32_t t32;\n\n    if (len == 64U) {\n        __asm__ __volatile__(\n            \"movq   (%[in]), %[t64_1] \\n\"\n            \"movq  8(%[in]), %[t64_2] \\n\"\n            \"movq 16(%[in]), %[t64_3] \\n\"\n            \"movq 24(%[in]), %[t64_4] \\n\"\n            \"movq 32(%[in]), %[t64_5] \\n\"\n            \"movq 40(%[in]), %[t64_6] \\n\"\n            \"movq 48(%[in]), %[t64_7] \\n\"\n            \"movq 56(%[in]), %[t64_8] \\n\"\n            \"subq %[t64_1],   (%[out]) \\n\"\n            \"sbbq %[t64_2],  8(%[out]) \\n\"\n            \"sbbq %[t64_3], 16(%[out]) \\n\"\n            \"sbbq %[t64_4], 24(%[out]) \\n\"\n            \"sbbq %[t64_5], 32(%[out]) \\n\"\n            \"sbbq %[t64_6], 40(%[out]) \\n\"\n            \"sbbq %[t64_7], 48(%[out]) \\n\"\n            \"sbbq %[t64_8], 56(%[out]) \\n\"\n            : [t64_1] \"=\u0026r\"(t64_1), [t64_2] \"=\u0026r\"(t64_2), [t64_3] \"=\u0026r\"(t64_3), [t64_4] \"=\u0026r\"(t64_4),\n              [t64_5] \"=\u0026r\"(t64_5), [t64_6] \"=\u0026r\"(t64_6), [t64_7] \"=\u0026r\"(t64_7), [t64_8] \"=\u0026r\"(t64_8)\n            : [in] \"S\"(b), [out] \"D\"(a)\n            : \"memory\", \"flags\", \"cc\");\n        return;\n    }\n#endif\n    for (i = 0U; i \u003c len; i++) {\n        c = (uint_fast16_t) a[i] - (uint_fast16_t) b[i] - c;\n        a[i] = (unsigned char) c;\n        c = (c \u003e\u003e 8) \u0026 1U;\n    }\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":355,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385242":{"score":0.79857266,"function_name":"sodium_mlock","code":"int\nsodium_mlock(void *const addr, const size_t len)\n{\n#if defined(MADV_DONTDUMP) \u0026\u0026 defined(HAVE_MADVISE)\n    (void) madvise(addr, len, MADV_DONTDUMP);\n#endif\n#ifdef HAVE_MLOCK\n    return mlock(addr, len);\n#elif defined(WINAPI_DESKTOP)\n    return -(VirtualLock(addr, len) == 0);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":423,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385474":{"score":0.92123055,"function_name":"sodium_malloc","code":"__attribute__((malloc)) void *\nsodium_malloc(const size_t size)\n{\n    void *ptr;\n\n    if ((ptr = _sodium_malloc(size)) == NULL) {\n        return NULL;\n    }\n    memset(ptr, (int) GARBAGE_VALUE, size);\n\n    return ptr;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":626,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385552":{"score":0.9129397,"function_name":"sodium_allocarray","code":"__attribute__((malloc)) void *\nsodium_allocarray(size_t count, size_t size)\n{\n    if (count \u003e (size_t) 0U \u0026\u0026 size \u003e= (size_t) SIZE_MAX / count) {\n        errno = ENOMEM;\n        return NULL;\n    }\n    return sodium_malloc(count * size);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":639,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"385835":{"score":0.9115896,"function_name":"sodium_pad","code":"int\nsodium_pad(size_t *padded_buflen_p, unsigned char *buf,\n           size_t unpadded_buflen, size_t blocksize, size_t max_buflen)\n{\n    unsigned char          *tail;\n    size_t                  i;\n    size_t                  xpadlen;\n    size_t                  xpadded_len;\n    volatile unsigned char  mask;\n    unsigned char           barrier_mask;\n\n    if (blocksize \u003c= 0U) {\n        return -1;\n    }\n    xpadlen = blocksize - 1U;\n    if ((blocksize \u0026 (blocksize - 1U)) == 0U) {\n        xpadlen -= unpadded_buflen \u0026 (blocksize - 1U);\n    } else {\n        xpadlen -= unpadded_buflen % blocksize;\n    }\n    if ((size_t) SIZE_MAX - unpadded_buflen \u003c= xpadlen) {\n        sodium_misuse();\n    }\n    xpadded_len = unpadded_buflen + xpadlen;\n    if (xpadded_len \u003e= max_buflen) {\n        return -1;\n    }\n    tail = \u0026buf[xpadded_len];\n    if (padded_buflen_p != NULL) {\n        *padded_buflen_p = xpadded_len + 1U;\n    }\n    mask = 0U;\n    for (i = 0; i \u003c blocksize; i++) {\n        barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U)\n           \u003e\u003e ((sizeof(size_t) - 1) * CHAR_BIT));\n        *(tail - i) = ((*(tail - i)) \u0026 mask) | (0x80 \u0026 barrier_mask);\n        mask |= barrier_mask;\n    }\n    return 0;\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":731,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"386106":{"score":0.9386639,"function_name":"sodium_unpad","code":"int\nsodium_unpad(size_t *unpadded_buflen_p, const unsigned char *buf,\n             size_t padded_buflen, size_t blocksize)\n{\n    const unsigned char *tail;\n    unsigned char        acc = 0U;\n    unsigned char        c;\n    unsigned char        valid = 0U;\n    volatile size_t      pad_len = 0U;\n    size_t               i;\n    size_t               is_barrier;\n\n    if (padded_buflen \u003c blocksize || blocksize \u003c= 0U) {\n        return -1;\n    }\n    tail = \u0026buf[padded_buflen - 1U];\n\n    for (i = 0U; i \u003c blocksize; i++) {\n        c = *(tail - i);\n        is_barrier =\n            (( (acc - 1U) \u0026 (pad_len - 1U) \u0026 ((c ^ 0x80) - 1U) ) \u003e\u003e 8) \u0026 1U;\n        acc |= c;\n        pad_len |= i \u0026 (1U + ~is_barrier);\n        valid |= (unsigned char) is_barrier;\n    }\n    *unpadded_buflen_p = padded_buflen - 1U - pad_len;\n\n    return (int) (valid - 1U);\n}","filepath":"src/libsodium/src/libsodium/sodium/utils.c","line_number":772,"entry_url":"https://github.com/pyca/pynacl.git","slot_name":"1.5.0"},"386574":{"score":0.91871655,"function_name":"aes_gen_tables","code":"static void aes_gen_tables( void )\n{\n    int i, x, y, z;\n    int pow[256];\n    int log[256];\n\n    /*\n     * compute pow and log tables over GF(2^8)\n     */\n    for( i = 0, x = 1; i \u003c 256; i++ )\n    {\n        pow[i] = x;\n        log[x] = i;\n        x = ( x ^ XTIME( x ) ) \u0026 0xFF;\n    }\n\n    /*\n     * calculate the round constants\n     */\n    for( i = 0, x = 1; i \u003c 10; i++ )\n    {\n        RCON[i] = (uint32_t) x;\n        x = XTIME( x ) \u0026 0xFF;\n    }\n\n    /*\n     * generate the forward and reverse S-boxes\n     */\n    FSb[0x00] = 0x63;\n    RSb[0x63] = 0x00;\n\n    for( i = 1; i \u003c 256; i++ )\n    {\n        x = pow[255 - log[i]];\n\n        y  = x; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y; y = ( ( y \u003c\u003c 1 ) | ( y \u003e\u003e 7 ) ) \u0026 0xFF;\n        x ^= y ^ 0x63;\n\n        FSb[i] = (unsigned char) x;\n        RSb[x] = (unsigned char) i;\n    }\n\n    /*\n     * generate the forward and reverse tables\n     */\n    for( i = 0; i \u003c 256; i++ )\n    {\n        x = FSb[i];\n        y = XTIME( x ) \u0026 0xFF;\n        z =  ( y ^ x ) \u0026 0xFF;\n\n        FT0[i] = ( (uint32_t) y       ) ^\n                 ( (uint32_t) x \u003c\u003c  8 ) ^\n                 ( (uint32_t) x \u003c\u003c 16 ) ^\n                 ( (uint32_t) z \u003c\u003c 24 );\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n        FT1[i] = ROTL8( FT0[i] );\n        FT2[i] = ROTL8( FT1[i] );\n        FT3[i] = ROTL8( FT2[i] );\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n\n        x = RSb[i];\n\n        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^\n                 ( (uint32_t) MUL( 0x09, x ) \u003c\u003c  8 ) ^\n                 ( (uint32_t) MUL( 0x0D, x ) \u003c\u003c 16 ) ^\n                 ( (uint32_t) MUL( 0x0B, x ) \u003c\u003c 24 );\n\n#if !defined(MBEDTLS_AES_FEWER_TABLES)\n        RT1[i] = ROTL8( RT0[i] );\n        RT2[i] = ROTL8( RT1[i] );\n        RT3[i] = ROTL8( RT2[i] );\n#endif /* !MBEDTLS_AES_FEWER_TABLES */\n    }\n}","filepath":"library/aes.c","line_number":429,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"388057":{"score":0.89807916,"function_name":"mbedtls_aes_setkey_enc","code":"int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    unsigned int i;\n    uint32_t *RK;\n\n    AES_VALIDATE_RET( ctx != NULL );\n    AES_VALIDATE_RET( key != NULL );\n\n    switch( keybits )\n    {\n        case 128: ctx-\u003enr = 10; break;\n        case 192: ctx-\u003enr = 12; break;\n        case 256: ctx-\u003enr = 14; break;\n        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );\n    }\n\n#if !defined(MBEDTLS_AES_ROM_TABLES)\n    if( aes_init_done == 0 )\n    {\n        aes_gen_tables();\n        aes_init_done = 1;\n    }\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) \u0026\u0026 defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx-\u003erk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx-\u003ebuf );\n    else\n#endif\n    ctx-\u003erk = RK = ctx-\u003ebuf;\n\n#if defined(MBEDTLS_AESNI_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx-\u003erk, key, keybits ) );\n#endif\n\n    for( i = 0; i \u003c ( keybits \u003e\u003e 5 ); i++ )\n    {\n        GET_UINT32_LE( RK[i], key, i \u003c\u003c 2 );\n    }\n\n    switch( ctx-\u003enr )\n    {\n        case 10:\n\n            for( i = 0; i \u003c 10; i++, RK += 4 )\n            {\n                RK[4]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[3] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[3]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[5]  = RK[1] ^ RK[4];\n                RK[6]  = RK[2] ^ RK[5];\n                RK[7]  = RK[3] ^ RK[6];\n            }\n            break;\n\n        case 12:\n\n            for( i = 0; i \u003c 8; i++, RK += 6 )\n            {\n                RK[6]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[5] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[5]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[7]  = RK[1] ^ RK[6];\n                RK[8]  = RK[2] ^ RK[7];\n                RK[9]  = RK[3] ^ RK[8];\n                RK[10] = RK[4] ^ RK[9];\n                RK[11] = RK[5] ^ RK[10];\n            }\n            break;\n\n        case 14:\n\n            for( i = 0; i \u003c 7; i++, RK += 8 )\n            {\n                RK[8]  = RK[0] ^ RCON[i] ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e  8 ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[7] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[7]       ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[9]  = RK[1] ^ RK[8];\n                RK[10] = RK[2] ^ RK[9];\n                RK[11] = RK[3] ^ RK[10];\n\n                RK[12] = RK[4] ^\n                ( (uint32_t) FSb[ ( RK[11]       ) \u0026 0xFF ]       ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n                ( (uint32_t) FSb[ ( RK[11] \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n                RK[13] = RK[5] ^ RK[12];\n                RK[14] = RK[6] ^ RK[13];\n                RK[15] = RK[7] ^ RK[14];\n            }\n            break;\n    }\n\n    return( 0 );\n}","filepath":"library/aes.c","line_number":581,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"389391":{"score":0.8030075,"function_name":"mbedtls_aes_setkey_dec","code":"int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,\n                    unsigned int keybits )\n{\n    int i, j, ret;\n    mbedtls_aes_context cty;\n    uint32_t *RK;\n    uint32_t *SK;\n\n    AES_VALIDATE_RET( ctx != NULL );\n    AES_VALIDATE_RET( key != NULL );\n\n    mbedtls_aes_init( \u0026cty );\n\n#if defined(MBEDTLS_PADLOCK_C) \u0026\u0026 defined(MBEDTLS_PADLOCK_ALIGN16)\n    if( aes_padlock_ace == -1 )\n        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );\n\n    if( aes_padlock_ace )\n        ctx-\u003erk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx-\u003ebuf );\n    else\n#endif\n    ctx-\u003erk = RK = ctx-\u003ebuf;\n\n    /* Also checks keybits */\n    if( ( ret = mbedtls_aes_setkey_enc( \u0026cty, key, keybits ) ) != 0 )\n        goto exit;\n\n    ctx-\u003enr = cty.nr;\n\n#if defined(MBEDTLS_AESNI_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n    {\n        mbedtls_aesni_inverse_key( (unsigned char *) ctx-\u003erk,\n                           (const unsigned char *) cty.rk, ctx-\u003enr );\n        goto exit;\n    }\n#endif\n\n    SK = cty.rk + cty.nr * 4;\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\n    for( i = ctx-\u003enr - 1, SK -= 8; i \u003e 0; i--, SK -= 8 )\n    {\n        for( j = 0; j \u003c 4; j++, SK++ )\n        {\n            *RK++ = AES_RT0( FSb[ ( *SK       ) \u0026 0xFF ] ) ^\n                    AES_RT1( FSb[ ( *SK \u003e\u003e  8 ) \u0026 0xFF ] ) ^\n                    AES_RT2( FSb[ ( *SK \u003e\u003e 16 ) \u0026 0xFF ] ) ^\n                    AES_RT3( FSb[ ( *SK \u003e\u003e 24 ) \u0026 0xFF ] );\n        }\n    }\n\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n    *RK++ = *SK++;\n\nexit:\n    mbedtls_aes_free( \u0026cty );\n\n    return( ret );\n}","filepath":"library/aes.c","line_number":697,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"390143":{"score":0.89762443,"function_name":"mbedtls_internal_aes_decrypt","code":"int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,\n                                  const unsigned char input[16],\n                                  unsigned char output[16] )\n{\n    int i;\n    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;\n\n    RK = ctx-\u003erk;\n\n    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;\n    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;\n    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;\n    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;\n\n    for( i = ( ctx-\u003enr \u003e\u003e 1 ) - 1; i \u003e 0; i-- )\n    {\n        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );\n    }\n\n    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );\n\n    X0 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y0       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X1 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y1       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X2 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y2       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y3 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    X3 = *RK++ ^ \\\n            ( (uint32_t) RSb[ ( Y3       ) \u0026 0xFF ]       ) ^\n            ( (uint32_t) RSb[ ( Y2 \u003e\u003e  8 ) \u0026 0xFF ] \u003c\u003c  8 ) ^\n            ( (uint32_t) RSb[ ( Y1 \u003e\u003e 16 ) \u0026 0xFF ] \u003c\u003c 16 ) ^\n            ( (uint32_t) RSb[ ( Y0 \u003e\u003e 24 ) \u0026 0xFF ] \u003c\u003c 24 );\n\n    PUT_UINT32_LE( X0, output,  0 );\n    PUT_UINT32_LE( X1, output,  4 );\n    PUT_UINT32_LE( X2, output,  8 );\n    PUT_UINT32_LE( X3, output, 12 );\n\n    mbedtls_platform_zeroize( \u0026X0, sizeof( X0 ) );\n    mbedtls_platform_zeroize( \u0026X1, sizeof( X1 ) );\n    mbedtls_platform_zeroize( \u0026X2, sizeof( X2 ) );\n    mbedtls_platform_zeroize( \u0026X3, sizeof( X3 ) );\n\n    mbedtls_platform_zeroize( \u0026Y0, sizeof( Y0 ) );\n    mbedtls_platform_zeroize( \u0026Y1, sizeof( Y1 ) );\n    mbedtls_platform_zeroize( \u0026Y2, sizeof( Y2 ) );\n    mbedtls_platform_zeroize( \u0026Y3, sizeof( Y3 ) );\n\n    mbedtls_platform_zeroize( \u0026RK, sizeof( RK ) );\n\n    return( 0 );\n}","filepath":"library/aes.c","line_number":975,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"394201":{"score":0.5707687,"function_name":"mbedtls_aes_crypt_ecb","code":"int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,\n                           int mode,\n                           const unsigned char input[16],\n                           unsigned char output[16] )\n{\n    AES_VALIDATE_RET( ctx != NULL );\n    AES_VALIDATE_RET( input != NULL );\n    AES_VALIDATE_RET( output != NULL );\n    AES_VALIDATE_RET( mode == MBEDTLS_AES_ENCRYPT ||\n                      mode == MBEDTLS_AES_DECRYPT );\n\n#if defined(MBEDTLS_AESNI_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86_64)\n    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )\n        return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );\n#endif\n\n#if defined(MBEDTLS_PADLOCK_C) \u0026\u0026 defined(MBEDTLS_HAVE_X86)\n    if( aes_padlock_ace )\n    {\n        if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )\n            return( 0 );\n\n        // If padlock data misaligned, we just fall back to\n        // unaccelerated mode\n        //\n    }\n#endif\n\n    if( mode == MBEDTLS_AES_ENCRYPT )\n        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );\n    else\n        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );\n}","filepath":"library/aes.c","line_number":1054,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"394641":{"score":0.8865956,"function_name":"asn1_get_len","code":"int asn1_get_len( unsigned char **p,\n                  const unsigned char *end,\n                  size_t *len )\n{\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( ( **p \u0026 0x80 ) == 0 )\n        *len = *(*p)++;\n    else\n    {\n        switch( **p \u0026 0x7F )\n        {\n        case 1:\n            if( ( end - *p ) \u003c 2 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = (*p)[1];\n            (*p) += 2;\n            break;\n\n        case 2:\n            if( ( end - *p ) \u003c 3 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (*p)[1] \u003c\u003c 8 ) | (*p)[2];\n            (*p) += 3;\n            break;\n\n        case 3:\n            if( ( end - *p ) \u003c 4 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (*p)[1] \u003c\u003c 16 ) | ( (*p)[2] \u003c\u003c 8 ) | (*p)[3];\n            (*p) += 4;\n            break;\n\n        case 4:\n            if( ( end - *p ) \u003c 5 )\n                return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n            *len = ( (*p)[1] \u003c\u003c 24 ) | ( (*p)[2] \u003c\u003c 16 ) | ( (*p)[3] \u003c\u003c 8 ) | (*p)[4];\n            (*p) += 5;\n            break;\n\n        default:\n            return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n        }\n    }\n\n    if( *len \u003e (size_t) ( end - *p ) )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    return( 0 );\n}"},"395190":{"score":0.84477496,"function_name":"asn1_get_tag","code":"int asn1_get_tag( unsigned char **p,\n                  const unsigned char *end,\n                  size_t *len, int tag )\n{\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != tag )\n        return( POLARSSL_ERR_ASN1_UNEXPECTED_TAG );\n\n    (*p)++;\n\n    return( asn1_get_len( p, end, len ) );\n}","filepath":"library/asn1parse.c","line_number":110,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"395281":{"score":0.9397337,"function_name":"asn1_get_bool","code":"int asn1_get_bool( unsigned char **p,\n                   const unsigned char *end,\n                   int *val )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_BOOLEAN ) ) != 0 )\n        return( ret );\n\n    if( len != 1 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n\n    *val = ( **p != 0 ) ? 1 : 0;\n    (*p)++;\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":125,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"395433":{"score":0.9183973,"function_name":"asn1_get_int","code":"int asn1_get_int( unsigned char **p,\n                  const unsigned char *end,\n                  int *val )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_INTEGER ) ) != 0 )\n        return( ret );\n\n    if( len \u003e sizeof( int ) || ( **p \u0026 0x80 ) != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n\n    *val = 0;\n\n    while( len-- \u003e 0 )\n    {\n        *val = ( *val \u003c\u003c 8 ) | **p;\n        (*p)++;\n    }\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":144,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"395635":{"score":0.8687656,"function_name":"asn1_get_mpi","code":"int asn1_get_mpi( unsigned char **p,\n                  const unsigned char *end,\n                  mpi *X )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len, ASN1_INTEGER ) ) != 0 )\n        return( ret );\n\n    ret = mpi_read_binary( X, *p, len );\n\n    *p += len;\n\n    return( ret );\n}","filepath":"library/asn1parse.c","line_number":169,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"395783":{"score":0.91811645,"function_name":"asn1_get_bitstring","code":"int asn1_get_bitstring( unsigned char **p, const unsigned char *end,\n                        asn1_bitstring *bs)\n{\n    int ret;\n\n    /* Certificate type is a single byte bitstring */\n    if( ( ret = asn1_get_tag( p, end, \u0026bs-\u003elen, ASN1_BIT_STRING ) ) != 0 )\n        return( ret );\n\n    /* Check length, subtract one for actual bit string length */\n    if ( bs-\u003elen \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n    bs-\u003elen -= 1;\n\n    /* Get number of unused bits, ensure unused bits \u003c= 7 */\n    bs-\u003eunused_bits = **p;\n    if( bs-\u003eunused_bits \u003e 7 )\n        return( POLARSSL_ERR_ASN1_INVALID_LENGTH );\n    (*p)++;\n\n    /* Get actual bitstring */\n    bs-\u003ep = *p;\n    *p += bs-\u003elen;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return 0;\n}","filepath":"library/asn1parse.c","line_number":187,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"395959":{"score":0.9456954,"function_name":"asn1_get_bitstring_null","code":"int asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,\n                             size_t *len )\n{\n    int ret;\n\n    if( ( ret = asn1_get_tag( p, end, len, ASN1_BIT_STRING ) ) != 0 )\n        return( ret );\n\n    if( (*len)-- \u003c 2 || *(*p)++ != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_DATA );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":220,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"396060":{"score":0.92222804,"function_name":"asn1_get_sequence_of","code":"int asn1_get_sequence_of( unsigned char **p,\n                          const unsigned char *end,\n                          asn1_sequence *cur,\n                          int tag)\n{\n    int ret;\n    size_t len;\n    asn1_buf *buf;\n\n    /* Get main sequence tag */\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( ret );\n\n    if( *p + len != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    while( *p \u003c end )\n    {\n        buf = \u0026(cur-\u003ebuf);\n        buf-\u003etag = **p;\n\n        if( ( ret = asn1_get_tag( p, end, \u0026buf-\u003elen, tag ) ) != 0 )\n            return( ret );\n\n        buf-\u003ep = *p;\n        *p += buf-\u003elen;\n\n        /* Allocate and assign next pointer */\n        if (*p \u003c end)\n        {\n            cur-\u003enext = (asn1_sequence *) polarssl_malloc(\n                 sizeof( asn1_sequence ) );\n\n            if( cur-\u003enext == NULL )\n                return( POLARSSL_ERR_ASN1_MALLOC_FAILED );\n\n            cur = cur-\u003enext;\n        }\n    }\n\n    /* Set final sequence entry's next pointer to NULL */\n    cur-\u003enext = NULL;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":239,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"396392":{"score":0.8753663,"function_name":"asn1_get_alg","code":"int asn1_get_alg( unsigned char **p,\n                  const unsigned char *end,\n                  asn1_buf *alg, asn1_buf *params )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( ret );\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    alg-\u003etag = **p;\n    end = *p + len;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026alg-\u003elen, ASN1_OID ) ) != 0 )\n        return( ret );\n\n    alg-\u003ep = *p;\n    *p += alg-\u003elen;\n\n    if( *p == end )\n    {\n        memset( params, 0, sizeof(asn1_buf) );\n        return( 0 );\n    }\n\n    params-\u003etag = **p;\n    (*p)++;\n\n    if( ( ret = asn1_get_len( p, end, \u0026params-\u003elen ) ) != 0 )\n        return( ret );\n\n    params-\u003ep = *p;\n    *p += params-\u003elen;\n\n    if( *p != end )\n        return( POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":289,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"396779":{"score":0.92845905,"function_name":"asn1_get_alg_null","code":"int asn1_get_alg_null( unsigned char **p,\n                       const unsigned char *end,\n                       asn1_buf *alg )\n{\n    int ret;\n    asn1_buf params;\n\n    memset( \u0026params, 0, sizeof(asn1_buf) );\n\n    if( ( ret = asn1_get_alg( p, end, alg, \u0026params ) ) != 0 )\n        return( ret );\n\n    if( ( params.tag != ASN1_NULL \u0026\u0026 params.tag != 0 ) || params.len != 0 )\n        return( POLARSSL_ERR_ASN1_INVALID_DATA );\n\n    return( 0 );\n}","filepath":"library/asn1parse.c","line_number":333,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"396938":{"score":0.8130188,"function_name":"asn1_free_named_data","code":"void asn1_free_named_data( asn1_named_data *cur )\n{\n    if( cur == NULL )\n        return;\n\n    polarssl_free( cur-\u003eoid.p );\n    polarssl_free( cur-\u003eval.p );\n\n    memset( cur, 0, sizeof( asn1_named_data ) );\n}","filepath":"library/asn1parse.c","line_number":351,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"397022":{"score":0.9542941,"function_name":"asn1_free_named_data_list","code":"void asn1_free_named_data_list( asn1_named_data **head )\n{\n    asn1_named_data *cur;\n\n    while( ( cur = *head ) != NULL )\n    {\n        *head = cur-\u003enext;\n        asn1_free_named_data( cur );\n        polarssl_free( cur );\n    }\n}","filepath":"library/asn1parse.c","line_number":362,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"397101":{"score":0.9506223,"function_name":"asn1_find_named_data","code":"asn1_named_data *asn1_find_named_data( asn1_named_data *list,\n                                       const char *oid, size_t len )\n{\n    while( list != NULL )\n    {\n        if( list-\u003eoid.len == len \u0026\u0026\n            memcmp( list-\u003eoid.p, oid, len ) == 0 )\n        {\n            break;\n        }\n\n        list = list-\u003enext;\n    }\n\n    return( list );\n}","filepath":"library/asn1parse.c","line_number":374,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.7"},"398656":{"score":0.8086478,"function_name":"mpi_free","code":"void mpi_free( mpi *X )\n{\n    if( X == NULL )\n        return;\n\n    if( X-\u003ep != NULL )\n    {\n        polarssl_zeroize( X-\u003ep, X-\u003en * ciL );\n        polarssl_free( X-\u003ep );\n    }\n\n    X-\u003es = 1;\n    X-\u003en = 0;\n    X-\u003ep = NULL;\n}","filepath":"library/bignum.c","line_number":96,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"398770":{"score":0.9116815,"function_name":"mpi_grow","code":"int mpi_grow( mpi *X, size_t nblimbs )\n{\n    t_uint *p;\n\n    if( nblimbs \u003e POLARSSL_MPI_MAX_LIMBS )\n        return( POLARSSL_ERR_MPI_MALLOC_FAILED );\n\n    if( X-\u003en \u003c nblimbs )\n    {\n        if( ( p = polarssl_malloc( nblimbs * ciL ) ) == NULL )\n            return( POLARSSL_ERR_MPI_MALLOC_FAILED );\n\n        memset( p, 0, nblimbs * ciL );\n\n        if( X-\u003ep != NULL )\n        {\n            memcpy( p, X-\u003ep, X-\u003en * ciL );\n            polarssl_zeroize( X-\u003ep, X-\u003en * ciL );\n            polarssl_free( X-\u003ep );\n        }\n\n        X-\u003en = nblimbs;\n        X-\u003ep = p;\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":115,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"398970":{"score":0.8739008,"function_name":"mpi_shrink","code":"int mpi_shrink( mpi *X, size_t nblimbs )\n{\n    t_uint *p;\n    size_t i;\n\n    /* Actually resize up in this case */\n    if( X-\u003en \u003c= nblimbs )\n        return( mpi_grow( X, nblimbs ) );\n\n    for( i = X-\u003en - 1; i \u003e 0; i-- )\n        if( X-\u003ep[i] != 0 )\n            break;\n    i++;\n\n    if( i \u003c nblimbs )\n        i = nblimbs;\n\n    if( ( p = polarssl_malloc( i * ciL ) ) == NULL )\n        return( POLARSSL_ERR_MPI_MALLOC_FAILED );\n\n    memset( p, 0, i * ciL );\n\n    if( X-\u003ep != NULL )\n    {\n        memcpy( p, X-\u003ep, i * ciL );\n        polarssl_zeroize( X-\u003ep, X-\u003en * ciL );\n        polarssl_free( X-\u003ep );\n    }\n\n    X-\u003en = i;\n    X-\u003ep = p;\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":147,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"399250":{"score":0.894898,"function_name":"mpi_copy","code":"int mpi_copy( mpi *X, const mpi *Y )\n{\n    int ret;\n    size_t i;\n\n    if( X == Y )\n        return( 0 );\n\n    if( Y-\u003ep == NULL )\n    {\n        mpi_free( X );\n        return( 0 );\n    }\n\n    for( i = Y-\u003en - 1; i \u003e 0; i-- )\n        if( Y-\u003ep[i] != 0 )\n            break;\n    i++;\n\n    X-\u003es = Y-\u003es;\n\n    MPI_CHK( mpi_grow( X, i ) );\n\n    memset( X-\u003ep, 0, X-\u003en * ciL );\n    memcpy( X-\u003ep, Y-\u003ep, i * ciL );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":185,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"399639":{"score":0.90446466,"function_name":"mpi_safe_cond_assign","code":"int mpi_safe_cond_assign( mpi *X, const mpi *Y, unsigned char assign )\n{\n    int ret = 0;\n    size_t i;\n\n    /* make sure assign is 0 or 1 in a time-constant manner */\n    assign = (assign | (unsigned char)-assign) \u003e\u003e 7;\n\n    MPI_CHK( mpi_grow( X, Y-\u003en ) );\n\n    X-\u003es = X-\u003es * ( 1 - assign ) + Y-\u003es * assign;\n\n    for( i = 0; i \u003c Y-\u003en; i++ )\n        X-\u003ep[i] = X-\u003ep[i] * ( 1 - assign ) + Y-\u003ep[i] * assign;\n\n    for( ; i \u003c X-\u003en; i++ )\n        X-\u003ep[i] *= ( 1 - assign );\n\ncleanup:\n    return( ret );\n}","filepath":"library/bignum.c","line_number":233,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"399937":{"score":0.9367036,"function_name":"mpi_safe_cond_swap","code":"int mpi_safe_cond_swap( mpi *X, mpi *Y, unsigned char swap )\n{\n    int ret, s;\n    size_t i;\n    t_uint tmp;\n\n    if( X == Y )\n        return( 0 );\n\n    /* make sure swap is 0 or 1 in a time-constant manner */\n    swap = (swap | (unsigned char)-swap) \u003e\u003e 7;\n\n    MPI_CHK( mpi_grow( X, Y-\u003en ) );\n    MPI_CHK( mpi_grow( Y, X-\u003en ) );\n\n    s = X-\u003es;\n    X-\u003es = X-\u003es * ( 1 - swap ) + Y-\u003es * swap;\n    Y-\u003es = Y-\u003es * ( 1 - swap ) +    s * swap;\n\n\n    for( i = 0; i \u003c X-\u003en; i++ )\n    {\n        tmp = X-\u003ep[i];\n        X-\u003ep[i] = X-\u003ep[i] * ( 1 - swap ) + Y-\u003ep[i] * swap;\n        Y-\u003ep[i] = Y-\u003ep[i] * ( 1 - swap ) +     tmp * swap;\n    }\n\ncleanup:\n    return( ret );\n}","filepath":"library/bignum.c","line_number":261,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"400346":{"score":0.8891877,"function_name":"mpi_lset","code":"int mpi_lset( mpi *X, t_sint z )\n{\n    int ret;\n\n    MPI_CHK( mpi_grow( X, 1 ) );\n    memset( X-\u003ep, 0, X-\u003en * ciL );\n\n    X-\u003ep[0] = ( z \u003c 0 ) ? -z : z;\n    X-\u003es    = ( z \u003c 0 ) ? -1 : 1;\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":295,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"400546":{"score":0.8885861,"function_name":"mpi_set_bit","code":"int mpi_set_bit( mpi *X, size_t pos, unsigned char val )\n{\n    int ret = 0;\n    size_t off = pos / biL;\n    size_t idx = pos % biL;\n\n    if( val != 0 \u0026\u0026 val != 1 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    if( X-\u003en * biL \u003c= pos )\n    {\n        if( val == 0 )\n            return( 0 );\n\n        MPI_CHK( mpi_grow( X, off + 1 ) );\n    }\n\n    X-\u003ep[off] \u0026= ~( (t_uint) 0x01 \u003c\u003c idx );\n    X-\u003ep[off] |= (t_uint) val \u003c\u003c idx;\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":324,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"400784":{"score":0.912036,"function_name":"mpi_lsb","code":"size_t mpi_lsb( const mpi *X )\n{\n    size_t i, j, count = 0;\n\n    for( i = 0; i \u003c X-\u003en; i++ )\n        for( j = 0; j \u003c biL; j++, count++ )\n            if( ( ( X-\u003ep[i] \u003e\u003e j ) \u0026 1 ) != 0 )\n                return( count );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":352,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"400898":{"score":0.85257995,"function_name":"int_clz","code":"static size_t int_clz( const t_uint x )\n{\n    size_t j;\n    t_uint mask = (t_uint) 1 \u003c\u003c (biL - 1);\n\n    for( j = 0; j \u003c biL; j++ )\n    {\n        if( x \u0026 mask ) break;\n\n        mask \u003e\u003e= 1;\n    }\n\n    return j;\n}","filepath":"library/bignum.c","line_number":367,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"400961":{"score":0.8388272,"function_name":"mpi_msb","code":"size_t mpi_msb( const mpi *X )\n{\n    size_t i, j;\n\n    if( X-\u003en == 0 )\n        return( 0 );\n\n    for( i = X-\u003en - 1; i \u003e 0; i-- )\n        if( X-\u003ep[i] != 0 )\n            break;\n\n    j = biL - int_clz( X-\u003ep[i] );\n\n    return( ( i * biL ) + j );\n}","filepath":"library/bignum.c","line_number":385,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"401125":{"score":0.9444468,"function_name":"mpi_get_digit","code":"static int mpi_get_digit( t_uint *d, int radix, char c )\n{\n    *d = 255;\n\n    if( c \u003e= 0x30 \u0026\u0026 c \u003c= 0x39 ) *d = c - 0x30;\n    if( c \u003e= 0x41 \u0026\u0026 c \u003c= 0x46 ) *d = c - 0x37;\n    if( c \u003e= 0x61 \u0026\u0026 c \u003c= 0x66 ) *d = c - 0x57;\n\n    if( *d \u003e= (t_uint) radix )\n        return( POLARSSL_ERR_MPI_INVALID_CHARACTER );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":412,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"401260":{"score":0.92402214,"function_name":"mpi_read_string","code":"int mpi_read_string( mpi *X, int radix, const char *s )\n{\n    int ret;\n    size_t i, j, slen, n;\n    t_uint d;\n    mpi T;\n\n    if( radix \u003c 2 || radix \u003e 16 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    mpi_init( \u0026T );\n\n    slen = strlen( s );\n\n    if( radix == 16 )\n    {\n        if( slen \u003e MPI_SIZE_T_MAX \u003e\u003e 2 )\n            return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n        n = BITS_TO_LIMBS( slen \u003c\u003c 2 );\n\n        MPI_CHK( mpi_grow( X, n ) );\n        MPI_CHK( mpi_lset( X, 0 ) );\n\n        for( i = slen, j = 0; i \u003e 0; i--, j++ )\n        {\n            if( i == 1 \u0026\u0026 s[i - 1] == '-' )\n            {\n                X-\u003es = -1;\n                break;\n            }\n\n            MPI_CHK( mpi_get_digit( \u0026d, radix, s[i - 1] ) );\n            X-\u003ep[j / ( 2 * ciL )] |= d \u003c\u003c ( ( j % ( 2 * ciL ) ) \u003c\u003c 2 );\n        }\n    }\n    else\n    {\n        MPI_CHK( mpi_lset( X, 0 ) );\n\n        for( i = 0; i \u003c slen; i++ )\n        {\n            if( i == 0 \u0026\u0026 s[i] == '-' )\n            {\n                X-\u003es = -1;\n                continue;\n            }\n\n            MPI_CHK( mpi_get_digit( \u0026d, radix, s[i] ) );\n            MPI_CHK( mpi_mul_int( \u0026T, X, radix ) );\n\n            if( X-\u003es == 1 )\n            {\n                MPI_CHK( mpi_add_int( X, \u0026T, d ) );\n            }\n            else\n            {\n                MPI_CHK( mpi_sub_int( X, \u0026T, d ) );\n            }\n        }\n    }\n\ncleanup:\n\n    mpi_free( \u0026T );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":429,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"401966":{"score":0.93486255,"function_name":"mpi_write_hlp","code":"static int mpi_write_hlp( mpi *X, int radix, char **p )\n{\n    int ret;\n    t_uint r;\n\n    if( radix \u003c 2 || radix \u003e 16 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    MPI_CHK( mpi_mod_int( \u0026r, X, radix ) );\n    MPI_CHK( mpi_div_int( X, NULL, X, radix ) );\n\n    if( mpi_cmp_int( X, 0 ) != 0 )\n        MPI_CHK( mpi_write_hlp( X, radix, p ) );\n\n    if( r \u003c 10 )\n        *(*p)++ = (char)( r + 0x30 );\n    else\n        *(*p)++ = (char)( r + 0x37 );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":501,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"402798":{"score":0.7973448,"function_name":"mpi_read_binary","code":"int mpi_read_binary( mpi *X, const unsigned char *buf, size_t buflen )\n{\n    int ret;\n    size_t i, j;\n    size_t const limbs = CHARS_TO_LIMBS( buflen );\n\n    /* Ensure that target MPI has exactly the necessary number of limbs */\n    if( X-\u003en != limbs )\n    {\n        mpi_free( X );\n        mpi_init( X );\n        MPI_CHK( mpi_grow( X, limbs ) );\n    }\n\n    MPI_CHK( mpi_lset( X, 0 ) );\n\n    for( i = buflen, j = 0; i \u003e 0; i--, j++ )\n        X-\u003ep[j / ciL] |= ((t_uint) buf[i - 1]) \u003c\u003c ((j % ciL) \u003c\u003c 3);\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":678,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"403039":{"score":0.76029015,"function_name":"mpi_write_binary","code":"int mpi_write_binary( const mpi *X, unsigned char *buf, size_t buflen )\n{\n    size_t i, j, n;\n\n    n = mpi_size( X );\n\n    if( buflen \u003c n )\n        return( POLARSSL_ERR_MPI_BUFFER_TOO_SMALL );\n\n    memset( buf, 0, buflen );\n\n    for( i = buflen - 1, j = 0; n \u003e 0; i--, j++, n-- )\n        buf[i] = (unsigned char)( X-\u003ep[j / ciL] \u003e\u003e ((j % ciL) \u003c\u003c 3) );\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":705,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"403278":{"score":0.86630535,"function_name":"mpi_shift_l","code":"int mpi_shift_l( mpi *X, size_t count )\n{\n    int ret;\n    size_t i, v0, t1;\n    t_uint r0 = 0, r1;\n\n    v0 = count / (biL    );\n    t1 = count \u0026 (biL - 1);\n\n    i = mpi_msb( X ) + count;\n\n    if( X-\u003en * biL \u003c i )\n        MPI_CHK( mpi_grow( X, BITS_TO_LIMBS( i ) ) );\n\n    ret = 0;\n\n    /*\n     * shift by count / limb_size\n     */\n    if( v0 \u003e 0 )\n    {\n        for( i = X-\u003en; i \u003e v0; i-- )\n            X-\u003ep[i - 1] = X-\u003ep[i - v0 - 1];\n\n        for( ; i \u003e 0; i-- )\n            X-\u003ep[i - 1] = 0;\n    }\n\n    /*\n     * shift by count % limb_size\n     */\n    if( t1 \u003e 0 )\n    {\n        for( i = v0; i \u003c X-\u003en; i++ )\n        {\n            r1 = X-\u003ep[i] \u003e\u003e (biL - t1);\n            X-\u003ep[i] \u003c\u003c= t1;\n            X-\u003ep[i] |= r0;\n            r0 = r1;\n        }\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":725,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"403694":{"score":0.9101846,"function_name":"mpi_shift_r","code":"int mpi_shift_r( mpi *X, size_t count )\n{\n    size_t i, v0, v1;\n    t_uint r0 = 0, r1;\n\n    v0 = count /  biL;\n    v1 = count \u0026 (biL - 1);\n\n    if( v0 \u003e X-\u003en || ( v0 == X-\u003en \u0026\u0026 v1 \u003e 0 ) )\n        return mpi_lset( X, 0 );\n\n    /*\n     * shift by count / limb_size\n     */\n    if( v0 \u003e 0 )\n    {\n        for( i = 0; i \u003c X-\u003en - v0; i++ )\n            X-\u003ep[i] = X-\u003ep[i + v0];\n\n        for( ; i \u003c X-\u003en; i++ )\n            X-\u003ep[i] = 0;\n    }\n\n    /*\n     * shift by count % limb_size\n     */\n    if( v1 \u003e 0 )\n    {\n        for( i = X-\u003en; i \u003e 0; i-- )\n        {\n            r1 = X-\u003ep[i - 1] \u003c\u003c (biL - v1);\n            X-\u003ep[i - 1] \u003e\u003e= v1;\n            X-\u003ep[i - 1] |= r0;\n            r0 = r1;\n        }\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":775,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"404086":{"score":0.94256896,"function_name":"mpi_cmp_abs","code":"int mpi_cmp_abs( const mpi *X, const mpi *Y )\n{\n    size_t i, j;\n\n    for( i = X-\u003en; i \u003e 0; i-- )\n        if( X-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = Y-\u003en; j \u003e 0; j-- )\n        if( Y-\u003ep[j - 1] != 0 )\n            break;\n\n    if( i == 0 \u0026\u0026 j == 0 )\n        return( 0 );\n\n    if( i \u003e j ) return(  1 );\n    if( j \u003e i ) return( -1 );\n\n    for( ; i \u003e 0; i-- )\n    {\n        if( X-\u003ep[i - 1] \u003e Y-\u003ep[i - 1] ) return(  1 );\n        if( X-\u003ep[i - 1] \u003c Y-\u003ep[i - 1] ) return( -1 );\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":818,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"404384":{"score":0.9527548,"function_name":"mpi_cmp_mpi","code":"int mpi_cmp_mpi( const mpi *X, const mpi *Y )\n{\n    size_t i, j;\n\n    for( i = X-\u003en; i \u003e 0; i-- )\n        if( X-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = Y-\u003en; j \u003e 0; j-- )\n        if( Y-\u003ep[j - 1] != 0 )\n            break;\n\n    if( i == 0 \u0026\u0026 j == 0 )\n        return( 0 );\n\n    if( i \u003e j ) return(  X-\u003es );\n    if( j \u003e i ) return( -Y-\u003es );\n\n    if( X-\u003es \u003e 0 \u0026\u0026 Y-\u003es \u003c 0 ) return(  1 );\n    if( Y-\u003es \u003e 0 \u0026\u0026 X-\u003es \u003c 0 ) return( -1 );\n\n    for( ; i \u003e 0; i-- )\n    {\n        if( X-\u003ep[i - 1] \u003e Y-\u003ep[i - 1] ) return(  X-\u003es );\n        if( X-\u003ep[i - 1] \u003c Y-\u003ep[i - 1] ) return( -X-\u003es );\n    }\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":848,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"404746":{"score":0.83544004,"function_name":"mpi_cmp_int","code":"int mpi_cmp_int( const mpi *X, t_sint z )\n{\n    mpi Y;\n    t_uint p[1];\n\n    *p  = ( z \u003c 0 ) ? -z : z;\n    Y.s = ( z \u003c 0 ) ? -1 : 1;\n    Y.n = 1;\n    Y.p = p;\n\n    return( mpi_cmp_mpi( X, \u0026Y ) );\n}","filepath":"library/bignum.c","line_number":881,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"404861":{"score":0.8958767,"function_name":"mpi_add_abs","code":"int mpi_add_abs( mpi *X, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t i, j;\n    t_uint *o, *p, c, tmp;\n\n    if( X == B )\n    {\n        const mpi *T = A; A = X; B = T;\n    }\n\n    if( X != A )\n        MPI_CHK( mpi_copy( X, A ) );\n\n    /*\n     * X should always be positive as a result of unsigned additions.\n     */\n    X-\u003es = 1;\n\n    for( j = B-\u003en; j \u003e 0; j-- )\n        if( B-\u003ep[j - 1] != 0 )\n            break;\n\n    MPI_CHK( mpi_grow( X, j ) );\n\n    o = B-\u003ep; p = X-\u003ep; c = 0;\n\n    /*\n     * tmp is used because it might happen that p == o\n     */\n    for( i = 0; i \u003c j; i++, o++, p++ )\n    {\n        tmp= *o;\n        *p +=  c; c  = ( *p \u003c  c );\n        *p += tmp; c += ( *p \u003c tmp );\n    }\n\n    while( c != 0 )\n    {\n        if( i \u003e= X-\u003en )\n        {\n            MPI_CHK( mpi_grow( X, i + 1 ) );\n            p = X-\u003ep + i;\n        }\n\n        *p += c; c = ( *p \u003c c ); i++; p++;\n    }\n\ncleanup:\n    return( ret );\n}","filepath":"library/bignum.c","line_number":897,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"405276":{"score":0.95538867,"function_name":"mpi_sub_hlp","code":"static void mpi_sub_hlp( size_t n, t_uint *s, t_uint *d )\n{\n    size_t i;\n    t_uint c, z;\n\n    for( i = c = 0; i \u003c n; i++, s++, d++ )\n    {\n        z = ( *d \u003c  c );     *d -=  c;\n        c = ( *d \u003c *s ) + z; *d -= *s;\n    }\n\n    while( c != 0 )\n    {\n        z = ( *d \u003c c ); *d -= c;\n        c = z; i++; d++;\n    }\n}","filepath":"library/bignum.c","line_number":952,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"405455":{"score":0.8729659,"function_name":"mpi_sub_abs","code":"int mpi_sub_abs( mpi *X, const mpi *A, const mpi *B )\n{\n    mpi TB;\n    int ret;\n    size_t n;\n\n    if( mpi_cmp_abs( A, B ) \u003c 0 )\n        return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );\n\n    mpi_init( \u0026TB );\n\n    if( X == B )\n    {\n        MPI_CHK( mpi_copy( \u0026TB, B ) );\n        B = \u0026TB;\n    }\n\n    if( X != A )\n        MPI_CHK( mpi_copy( X, A ) );\n\n    /*\n     * X should always be positive as a result of unsigned subtractions.\n     */\n    X-\u003es = 1;\n\n    ret = 0;\n\n    for( n = B-\u003en; n \u003e 0; n-- )\n        if( B-\u003ep[n - 1] != 0 )\n            break;\n\n    mpi_sub_hlp( n, B-\u003ep, X-\u003ep );\n\ncleanup:\n\n    mpi_free( \u0026TB );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":973,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"405756":{"score":0.9308776,"function_name":"mpi_add_mpi","code":"int mpi_add_mpi( mpi *X, const mpi *A, const mpi *B )\n{\n    int ret, s = A-\u003es;\n\n    if( A-\u003es * B-\u003es \u003c 0 )\n    {\n        if( mpi_cmp_abs( A, B ) \u003e= 0 )\n        {\n            MPI_CHK( mpi_sub_abs( X, A, B ) );\n            X-\u003es =  s;\n        }\n        else\n        {\n            MPI_CHK( mpi_sub_abs( X, B, A ) );\n            X-\u003es = -s;\n        }\n    }\n    else\n    {\n        MPI_CHK( mpi_add_abs( X, A, B ) );\n        X-\u003es = s;\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1016,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"405948":{"score":0.93318874,"function_name":"mpi_sub_mpi","code":"int mpi_sub_mpi( mpi *X, const mpi *A, const mpi *B )\n{\n    int ret, s = A-\u003es;\n\n    if( A-\u003es * B-\u003es \u003e 0 )\n    {\n        if( mpi_cmp_abs( A, B ) \u003e= 0 )\n        {\n            MPI_CHK( mpi_sub_abs( X, A, B ) );\n            X-\u003es =  s;\n        }\n        else\n        {\n            MPI_CHK( mpi_sub_abs( X, B, A ) );\n            X-\u003es = -s;\n        }\n    }\n    else\n    {\n        MPI_CHK( mpi_add_abs( X, A, B ) );\n        X-\u003es = s;\n    }\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1047,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"406267":{"score":0.79584855,"function_name":"mpi_add_int","code":"int mpi_add_int( mpi *X, const mpi *A, t_sint b )\n{\n    mpi _B;\n    t_uint p[1];\n\n    p[0] = ( b \u003c 0 ) ? -b : b;\n    _B.s = ( b \u003c 0 ) ? -1 : 1;\n    _B.n = 1;\n    _B.p = p;\n\n    return( mpi_add_mpi( X, A, \u0026_B ) );\n}","filepath":"library/bignum.c","line_number":1078,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"411634":{"score":0.863444,"function_name":"mpi_mul_mpi","code":"int mpi_mul_mpi( mpi *X, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t i, j;\n    mpi TA, TB;\n\n    mpi_init( \u0026TA ); mpi_init( \u0026TB );\n\n    if( X == A ) { MPI_CHK( mpi_copy( \u0026TA, A ) ); A = \u0026TA; }\n    if( X == B ) { MPI_CHK( mpi_copy( \u0026TB, B ) ); B = \u0026TB; }\n\n    for( i = A-\u003en; i \u003e 0; i-- )\n        if( A-\u003ep[i - 1] != 0 )\n            break;\n\n    for( j = B-\u003en; j \u003e 0; j-- )\n        if( B-\u003ep[j - 1] != 0 )\n            break;\n\n    MPI_CHK( mpi_grow( X, i + j ) );\n    MPI_CHK( mpi_lset( X, 0 ) );\n\n    for( i++; j \u003e 0; j-- )\n        mpi_mul_hlp( i - 1, A-\u003ep, X-\u003ep + j - 1, B-\u003ep[j - 1] );\n\n    X-\u003es = A-\u003es * B-\u003es;\n\ncleanup:\n\n    mpi_free( \u0026TB ); mpi_free( \u0026TA );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1182,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"412106":{"score":0.7716164,"function_name":"mpi_mul_int","code":"int mpi_mul_int( mpi *X, const mpi *A, t_sint b )\n{\n    mpi _B;\n    t_uint p[1];\n\n    _B.s = 1;\n    _B.n = 1;\n    _B.p = p;\n    p[0] = b;\n\n    return( mpi_mul_mpi( X, A, \u0026_B ) );\n}","filepath":"library/bignum.c","line_number":1219,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"412211":{"score":0.94812644,"function_name":"int_div_int","code":"static t_uint int_div_int( t_uint u1, t_uint u0, t_uint d, t_uint *r )\n{\n#if defined(POLARSSL_HAVE_UDBL)\n    t_udbl dividend, quotient;\n#else\n    const t_uint radix = (t_uint) 1 \u003c\u003c biH;\n    const t_uint uint_halfword_mask = ( (t_uint) 1 \u003c\u003c biH ) - 1;\n    t_uint d0, d1, q0, q1, rAX, r0, quotient;\n    t_uint u0_msw, u0_lsw;\n    size_t s;\n#endif\n\n    /*\n     * Check for overflow\n     */\n    if( 0 == d || u1 \u003e= d )\n    {\n        if ( r != NULL ) *r = ~0;\n\n        return ( ~0 );\n    }\n\n#if defined(POLARSSL_HAVE_UDBL)\n    dividend  = (t_udbl) u1 \u003c\u003c biL;\n    dividend |= (t_udbl) u0;\n    quotient = dividend / d;\n    if( quotient \u003e ( (t_udbl) 1 \u003c\u003c biL ) - 1 )\n        quotient = ( (t_udbl) 1 \u003c\u003c biL ) - 1;\n\n    if( r != NULL )\n        *r = (t_uint)( dividend - (quotient * d ) );\n\n    return (t_uint) quotient;\n#else\n\n    /*\n     * Algorithm D, Section 4.3.1 - The Art of Computer Programming\n     *   Vol. 2 - Seminumerical Algorithms, Knuth\n     */\n\n    /*\n     * Normalize the divisor, d, and dividend, u0, u1\n     */\n    s = int_clz( d );\n    d = d \u003c\u003c s;\n\n    u1 = u1 \u003c\u003c s;\n    u1 |= ( u0 \u003e\u003e ( biL - s ) ) \u0026 ( -(t_sint)s \u003e\u003e ( biL - 1 ) );\n    u0 =  u0 \u003c\u003c s;\n\n    d1 = d \u003e\u003e biH;\n    d0 = d \u0026 uint_halfword_mask;\n\n    u0_msw = u0 \u003e\u003e biH;\n    u0_lsw = u0 \u0026 uint_halfword_mask;\n\n    /*\n     * Find the first quotient and remainder\n     */\n    q1 = u1 / d1;\n    r0 = u1 - d1 * q1;\n\n    while( q1 \u003e= radix || ( q1 * d0 \u003e radix * r0 + u0_msw ) )\n    {\n        q1 -= 1;\n        r0 += d1;\n\n        if ( r0 \u003e= radix ) break;\n    }\n\n    rAX = ( u1 * radix ) + ( u0_msw - q1 * d );\n    q0 = rAX / d1;\n    r0 = rAX - q0 * d1;\n\n    while( q0 \u003e= radix || ( q0 * d0 \u003e radix * r0 + u0_lsw ) )\n    {\n        q0 -= 1;\n        r0 += d1;\n\n        if ( r0 \u003e= radix ) break;\n    }\n\n    if (r != NULL)\n        *r = ( rAX * radix + u0_lsw - q0 * d ) \u003e\u003e s;\n\n    quotient = q1 * radix + q0;\n\n    return quotient;\n#endif\n}","filepath":"library/bignum.c","line_number":1236,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"412649":{"score":0.86477554,"function_name":"mpi_div_mpi","code":"int mpi_div_mpi( mpi *Q, mpi *R, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t i, n, t, k;\n    mpi X, Y, Z, T1, T2;\n\n    if( mpi_cmp_int( B, 0 ) == 0 )\n        return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );\n\n    mpi_init( \u0026X ); mpi_init( \u0026Y ); mpi_init( \u0026Z );\n    mpi_init( \u0026T1 ); mpi_init( \u0026T2 );\n\n    if( mpi_cmp_abs( A, B ) \u003c 0 )\n    {\n        if( Q != NULL ) MPI_CHK( mpi_lset( Q, 0 ) );\n        if( R != NULL ) MPI_CHK( mpi_copy( R, A ) );\n        return( 0 );\n    }\n\n    MPI_CHK( mpi_copy( \u0026X, A ) );\n    MPI_CHK( mpi_copy( \u0026Y, B ) );\n    X.s = Y.s = 1;\n\n    MPI_CHK( mpi_grow( \u0026Z, A-\u003en + 2 ) );\n    MPI_CHK( mpi_lset( \u0026Z,  0 ) );\n    MPI_CHK( mpi_grow( \u0026T1, 2 ) );\n    MPI_CHK( mpi_grow( \u0026T2, 3 ) );\n\n    k = mpi_msb( \u0026Y ) % biL;\n    if( k \u003c biL - 1 )\n    {\n        k = biL - 1 - k;\n        MPI_CHK( mpi_shift_l( \u0026X, k ) );\n        MPI_CHK( mpi_shift_l( \u0026Y, k ) );\n    }\n    else k = 0;\n\n    n = X.n - 1;\n    t = Y.n - 1;\n    MPI_CHK( mpi_shift_l( \u0026Y, biL * ( n - t ) ) );\n\n    while( mpi_cmp_mpi( \u0026X, \u0026Y ) \u003e= 0 )\n    {\n        Z.p[n - t]++;\n        MPI_CHK( mpi_sub_mpi( \u0026X, \u0026X, \u0026Y ) );\n    }\n    MPI_CHK( mpi_shift_r( \u0026Y, biL * ( n - t ) ) );\n\n    for( i = n; i \u003e t ; i-- )\n    {\n        if( X.p[i] \u003e= Y.p[t] )\n            Z.p[i - t - 1] = ~0;\n        else\n        {\n            Z.p[i - t - 1] = int_div_int( X.p[i], X.p[i - 1], Y.p[t], NULL);\n        }\n\n        Z.p[i - t - 1]++;\n        do\n        {\n            Z.p[i - t - 1]--;\n\n            MPI_CHK( mpi_lset( \u0026T1, 0 ) );\n            T1.p[0] = ( t \u003c 1 ) ? 0 : Y.p[t - 1];\n            T1.p[1] = Y.p[t];\n            MPI_CHK( mpi_mul_int( \u0026T1, \u0026T1, Z.p[i - t - 1] ) );\n\n            MPI_CHK( mpi_lset( \u0026T2, 0 ) );\n            T2.p[0] = ( i \u003c 2 ) ? 0 : X.p[i - 2];\n            T2.p[1] = ( i \u003c 1 ) ? 0 : X.p[i - 1];\n            T2.p[2] = X.p[i];\n        }\n        while( mpi_cmp_mpi( \u0026T1, \u0026T2 ) \u003e 0 );\n\n        MPI_CHK( mpi_mul_int( \u0026T1, \u0026Y, Z.p[i - t - 1] ) );\n        MPI_CHK( mpi_shift_l( \u0026T1,  biL * ( i - t - 1 ) ) );\n        MPI_CHK( mpi_sub_mpi( \u0026X, \u0026X, \u0026T1 ) );\n\n        if( mpi_cmp_int( \u0026X, 0 ) \u003c 0 )\n        {\n            MPI_CHK( mpi_copy( \u0026T1, \u0026Y ) );\n            MPI_CHK( mpi_shift_l( \u0026T1, biL * ( i - t - 1 ) ) );\n            MPI_CHK( mpi_add_mpi( \u0026X, \u0026X, \u0026T1 ) );\n            Z.p[i - t - 1]--;\n        }\n    }\n\n    if( Q != NULL )\n    {\n        MPI_CHK( mpi_copy( Q, \u0026Z ) );\n        Q-\u003es = A-\u003es * B-\u003es;\n    }\n\n    if( R != NULL )\n    {\n        MPI_CHK( mpi_shift_r( \u0026X, k ) );\n        X.s = A-\u003es;\n        MPI_CHK( mpi_copy( R, \u0026X ) );\n\n        if( mpi_cmp_int( R, 0 ) == 0 )\n            R-\u003es = 1;\n    }\n\ncleanup:\n\n    mpi_free( \u0026X ); mpi_free( \u0026Y ); mpi_free( \u0026Z );\n    mpi_free( \u0026T1 ); mpi_free( \u0026T2 );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1330,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"414541":{"score":0.8323413,"function_name":"mpi_div_int","code":"int mpi_div_int( mpi *Q, mpi *R, const mpi *A, t_sint b )\n{\n    mpi _B;\n    t_uint p[1];\n\n    p[0] = ( b \u003c 0 ) ? -b : b;\n    _B.s = ( b \u003c 0 ) ? -1 : 1;\n    _B.n = 1;\n    _B.p = p;\n\n    return( mpi_div_mpi( Q, R, A, \u0026_B ) );\n}","filepath":"library/bignum.c","line_number":1444,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"414674":{"score":0.8807041,"function_name":"mpi_mod_mpi","code":"int mpi_mod_mpi( mpi *R, const mpi *A, const mpi *B )\n{\n    int ret;\n\n    if( mpi_cmp_int( B, 0 ) \u003c 0 )\n        return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );\n\n    MPI_CHK( mpi_div_mpi( NULL, R, A, B ) );\n\n    while( mpi_cmp_int( R, 0 ) \u003c 0 )\n      MPI_CHK( mpi_add_mpi( R, R, B ) );\n\n    while( mpi_cmp_mpi( R, B ) \u003e= 0 )\n      MPI_CHK( mpi_sub_mpi( R, R, B ) );\n\ncleanup:\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1460,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"414865":{"score":0.927367,"function_name":"mpi_mod_int","code":"int mpi_mod_int( t_uint *r, const mpi *A, t_sint b )\n{\n    size_t i;\n    t_uint x, y, z;\n\n    if( b == 0 )\n        return( POLARSSL_ERR_MPI_DIVISION_BY_ZERO );\n\n    if( b \u003c 0 )\n        return( POLARSSL_ERR_MPI_NEGATIVE_VALUE );\n\n    /*\n     * handle trivial cases\n     */\n    if( b == 1 )\n    {\n        *r = 0;\n        return( 0 );\n    }\n\n    if( b == 2 )\n    {\n        *r = A-\u003ep[0] \u0026 1;\n        return( 0 );\n    }\n\n    /*\n     * general case\n     */\n    for( i = A-\u003en, y = 0; i \u003e 0; i-- )\n    {\n        x  = A-\u003ep[i - 1];\n        y  = ( y \u003c\u003c biH ) | ( x \u003e\u003e biH );\n        z  = y / b;\n        y -= z * b;\n\n        x \u003c\u003c= biH;\n        y  = ( y \u003c\u003c biH ) | ( x \u003e\u003e biH );\n        z  = y / b;\n        y -= z * b;\n    }\n\n    /*\n     * If A is negative, then the current y represents a negative value.\n     * Flipping it to the positive side.\n     */\n    if( A-\u003es \u003c 0 \u0026\u0026 y != 0 )\n        y = b - y;\n\n    *r = y;\n\n    return( 0 );\n}","filepath":"library/bignum.c","line_number":1483,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"415162":{"score":0.8572868,"function_name":"mpi_montg_init","code":"static void mpi_montg_init( t_uint *mm, const mpi *N )\n{\n    t_uint x, m0 = N-\u003ep[0];\n    unsigned int i;\n\n    x  = m0;\n    x += ( ( m0 + 2 ) \u0026 4 ) \u003c\u003c 1;\n\n    for( i = biL; i \u003e= 8; i /= 2 )\n        x *= ( 2 - ( m0 * x ) );\n\n    *mm = ~x + 1;\n}","filepath":"library/bignum.c","line_number":1540,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"415270":{"score":0.6903893,"function_name":"mpi_montmul","code":"static void mpi_montmul( mpi *A, const mpi *B, const mpi *N, t_uint mm,\n                         const mpi *T )\n{\n    size_t i, n, m;\n    t_uint u0, u1, *d;\n\n    memset( T-\u003ep, 0, T-\u003en * ciL );\n\n    d = T-\u003ep;\n    n = N-\u003en;\n    m = ( B-\u003en \u003c n ) ? B-\u003en : n;\n\n    for( i = 0; i \u003c n; i++ )\n    {\n        /*\n         * T = (T + u0*B + u1*N) / 2^biL\n         */\n        u0 = A-\u003ep[i];\n        u1 = ( d[0] + u0 * B-\u003ep[0] ) * mm;\n\n        mpi_mul_hlp( m, B-\u003ep, d, u0 );\n        mpi_mul_hlp( n, N-\u003ep, d, u1 );\n\n        *d++ = u0; d[n + 1] = 0;\n    }\n\n    memcpy( A-\u003ep, d, ( n + 1 ) * ciL );\n\n    if( mpi_cmp_abs( A, N ) \u003e= 0 )\n        mpi_sub_hlp( n, N-\u003ep, A-\u003ep );\n    else\n        /* prevent timing attacks */\n        mpi_sub_hlp( n, A-\u003ep, T-\u003ep );\n}","filepath":"library/bignum.c","line_number":1557,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"415680":{"score":0.761308,"function_name":"mpi_montred","code":"static void mpi_montred( mpi *A, const mpi *N, t_uint mm, const mpi *T )\n{\n    t_uint z = 1;\n    mpi U;\n\n    U.n = U.s = (int) z;\n    U.p = \u0026z;\n\n    mpi_montmul( A, \u0026U, N, mm, T );\n}","filepath":"library/bignum.c","line_number":1595,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"418743":{"score":0.8158932,"function_name":"mpi_gcd","code":"int mpi_gcd( mpi *G, const mpi *A, const mpi *B )\n{\n    int ret;\n    size_t lz, lzt;\n    mpi TG, TA, TB;\n\n    mpi_init( \u0026TG ); mpi_init( \u0026TA ); mpi_init( \u0026TB );\n\n    MPI_CHK( mpi_copy( \u0026TA, A ) );\n    MPI_CHK( mpi_copy( \u0026TB, B ) );\n\n    lz = mpi_lsb( \u0026TA );\n    lzt = mpi_lsb( \u0026TB );\n\n    if( lzt \u003c lz )\n        lz = lzt;\n\n    MPI_CHK( mpi_shift_r( \u0026TA, lz ) );\n    MPI_CHK( mpi_shift_r( \u0026TB, lz ) );\n\n    TA.s = TB.s = 1;\n\n    while( mpi_cmp_int( \u0026TA, 0 ) != 0 )\n    {\n        MPI_CHK( mpi_shift_r( \u0026TA, mpi_lsb( \u0026TA ) ) );\n        MPI_CHK( mpi_shift_r( \u0026TB, mpi_lsb( \u0026TB ) ) );\n\n        if( mpi_cmp_mpi( \u0026TA, \u0026TB ) \u003e= 0 )\n        {\n            MPI_CHK( mpi_sub_abs( \u0026TA, \u0026TA, \u0026TB ) );\n            MPI_CHK( mpi_shift_r( \u0026TA, 1 ) );\n        }\n        else\n        {\n            MPI_CHK( mpi_sub_abs( \u0026TB, \u0026TB, \u0026TA ) );\n            MPI_CHK( mpi_shift_r( \u0026TB, 1 ) );\n        }\n    }\n\n    MPI_CHK( mpi_shift_l( \u0026TB, lz ) );\n    MPI_CHK( mpi_copy( G, \u0026TB ) );\n\ncleanup:\n\n    mpi_free( \u0026TG ); mpi_free( \u0026TA ); mpi_free( \u0026TB );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1817,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"419426":{"score":0.8894102,"function_name":"mpi_fill_random","code":"int mpi_fill_random( mpi *X, size_t size,\n                     int (*f_rng)(void *, unsigned char *, size_t),\n                     void *p_rng )\n{\n    int ret;\n    unsigned char buf[POLARSSL_MPI_MAX_SIZE];\n\n    if( size \u003e POLARSSL_MPI_MAX_SIZE )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    MPI_CHK( f_rng( p_rng, buf, size ) );\n    MPI_CHK( mpi_read_binary( X, buf, size ) );\n\ncleanup:\n    polarssl_zeroize( buf, sizeof( buf ) );\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1873,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"419640":{"score":0.8693104,"function_name":"mpi_inv_mod","code":"int mpi_inv_mod( mpi *X, const mpi *A, const mpi *N )\n{\n    int ret;\n    mpi G, TA, TU, U1, U2, TB, TV, V1, V2;\n\n    if( mpi_cmp_int( N, 1 ) \u003c= 0 )\n        return( POLARSSL_ERR_MPI_BAD_INPUT_DATA );\n\n    mpi_init( \u0026TA ); mpi_init( \u0026TU ); mpi_init( \u0026U1 ); mpi_init( \u0026U2 );\n    mpi_init( \u0026G ); mpi_init( \u0026TB ); mpi_init( \u0026TV );\n    mpi_init( \u0026V1 ); mpi_init( \u0026V2 );\n\n    MPI_CHK( mpi_gcd( \u0026G, A, N ) );\n\n    if( mpi_cmp_int( \u0026G, 1 ) != 0 )\n    {\n        ret = POLARSSL_ERR_MPI_NOT_ACCEPTABLE;\n        goto cleanup;\n    }\n\n    MPI_CHK( mpi_mod_mpi( \u0026TA, A, N ) );\n    MPI_CHK( mpi_copy( \u0026TU, \u0026TA ) );\n    MPI_CHK( mpi_copy( \u0026TB, N ) );\n    MPI_CHK( mpi_copy( \u0026TV, N ) );\n\n    MPI_CHK( mpi_lset( \u0026U1, 1 ) );\n    MPI_CHK( mpi_lset( \u0026U2, 0 ) );\n    MPI_CHK( mpi_lset( \u0026V1, 0 ) );\n    MPI_CHK( mpi_lset( \u0026V2, 1 ) );\n\n    do\n    {\n        while( ( TU.p[0] \u0026 1 ) == 0 )\n        {\n            MPI_CHK( mpi_shift_r( \u0026TU, 1 ) );\n\n            if( ( U1.p[0] \u0026 1 ) != 0 || ( U2.p[0] \u0026 1 ) != 0 )\n            {\n                MPI_CHK( mpi_add_mpi( \u0026U1, \u0026U1, \u0026TB ) );\n                MPI_CHK( mpi_sub_mpi( \u0026U2, \u0026U2, \u0026TA ) );\n            }\n\n            MPI_CHK( mpi_shift_r( \u0026U1, 1 ) );\n            MPI_CHK( mpi_shift_r( \u0026U2, 1 ) );\n        }\n\n        while( ( TV.p[0] \u0026 1 ) == 0 )\n        {\n            MPI_CHK( mpi_shift_r( \u0026TV, 1 ) );\n\n            if( ( V1.p[0] \u0026 1 ) != 0 || ( V2.p[0] \u0026 1 ) != 0 )\n            {\n                MPI_CHK( mpi_add_mpi( \u0026V1, \u0026V1, \u0026TB ) );\n                MPI_CHK( mpi_sub_mpi( \u0026V2, \u0026V2, \u0026TA ) );\n            }\n\n            MPI_CHK( mpi_shift_r( \u0026V1, 1 ) );\n            MPI_CHK( mpi_shift_r( \u0026V2, 1 ) );\n        }\n\n        if( mpi_cmp_mpi( \u0026TU, \u0026TV ) \u003e= 0 )\n        {\n            MPI_CHK( mpi_sub_mpi( \u0026TU, \u0026TU, \u0026TV ) );\n            MPI_CHK( mpi_sub_mpi( \u0026U1, \u0026U1, \u0026V1 ) );\n            MPI_CHK( mpi_sub_mpi( \u0026U2, \u0026U2, \u0026V2 ) );\n        }\n        else\n        {\n            MPI_CHK( mpi_sub_mpi( \u0026TV, \u0026TV, \u0026TU ) );\n            MPI_CHK( mpi_sub_mpi( \u0026V1, \u0026V1, \u0026U1 ) );\n            MPI_CHK( mpi_sub_mpi( \u0026V2, \u0026V2, \u0026U2 ) );\n        }\n    }\n    while( mpi_cmp_int( \u0026TU, 0 ) != 0 );\n\n    while( mpi_cmp_int( \u0026V1, 0 ) \u003c 0 )\n        MPI_CHK( mpi_add_mpi( \u0026V1, \u0026V1, N ) );\n\n    while( mpi_cmp_mpi( \u0026V1, N ) \u003e= 0 )\n        MPI_CHK( mpi_sub_mpi( \u0026V1, \u0026V1, N ) );\n\n    MPI_CHK( mpi_copy( X, \u0026V1 ) );\n\ncleanup:\n\n    mpi_free( \u0026TA ); mpi_free( \u0026TU ); mpi_free( \u0026U1 ); mpi_free( \u0026U2 );\n    mpi_free( \u0026G ); mpi_free( \u0026TB ); mpi_free( \u0026TV );\n    mpi_free( \u0026V1 ); mpi_free( \u0026V2 );\n\n    return( ret );\n}","filepath":"library/bignum.c","line_number":1894,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"421362":{"score":0.9274653,"function_name":"mbedtls_cipher_list","code":"const int *mbedtls_cipher_list( void )\n{\n    const mbedtls_cipher_definition_t *def;\n    int *type;\n\n    if( ! supported_init )\n    {\n        def = mbedtls_cipher_definitions;\n        type = mbedtls_cipher_supported;\n\n        while( def-\u003etype != 0 )\n            *type++ = (*def++).type;\n\n        *type = 0;\n\n        supported_init = 1;\n    }\n\n    return( mbedtls_cipher_supported );\n}","filepath":"library/cipher.c","line_number":120,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421473":{"score":0.80881983,"function_name":"mbedtls_cipher_info_from_type","code":"const mbedtls_cipher_info_t *mbedtls_cipher_info_from_type( const mbedtls_cipher_type_t cipher_type )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def-\u003einfo != NULL; def++ )\n        if( def-\u003etype == cipher_type )\n            return( def-\u003einfo );\n\n    return( NULL );\n}","filepath":"library/cipher.c","line_number":141,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421539":{"score":0.9005217,"function_name":"mbedtls_cipher_info_from_string","code":"const mbedtls_cipher_info_t *mbedtls_cipher_info_from_string( const char *cipher_name )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    if( NULL == cipher_name )\n        return( NULL );\n\n    for( def = mbedtls_cipher_definitions; def-\u003einfo != NULL; def++ )\n        if( !  strcmp( def-\u003einfo-\u003ename, cipher_name ) )\n            return( def-\u003einfo );\n\n    return( NULL );\n}","filepath":"library/cipher.c","line_number":152,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421641":{"score":0.8542825,"function_name":"mbedtls_cipher_info_from_values","code":"const mbedtls_cipher_info_t *mbedtls_cipher_info_from_values( const mbedtls_cipher_id_t cipher_id,\n                                              int key_bitlen,\n                                              const mbedtls_cipher_mode_t mode )\n{\n    const mbedtls_cipher_definition_t *def;\n\n    for( def = mbedtls_cipher_definitions; def-\u003einfo != NULL; def++ )\n        if( def-\u003einfo-\u003ebase-\u003ecipher == cipher_id \u0026\u0026\n            def-\u003einfo-\u003ekey_bitlen == (unsigned) key_bitlen \u0026\u0026\n            def-\u003einfo-\u003emode == mode )\n            return( def-\u003einfo );\n\n    return( NULL );\n}","filepath":"library/cipher.c","line_number":166,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421786":{"score":0.7787877,"function_name":"mbedtls_cipher_free","code":"void mbedtls_cipher_free( mbedtls_cipher_context_t *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n#if defined(MBEDTLS_CMAC_C)\n    if( ctx-\u003ecmac_ctx )\n    {\n       mbedtls_platform_zeroize( ctx-\u003ecmac_ctx,\n                                 sizeof( mbedtls_cmac_context_t ) );\n       mbedtls_free( ctx-\u003ecmac_ctx );\n    }\n#endif\n\n    if( ctx-\u003ecipher_ctx )\n        ctx-\u003ecipher_info-\u003ebase-\u003ectx_free_func( ctx-\u003ecipher_ctx );\n\n    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );\n}","filepath":"library/cipher.c","line_number":187,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421870":{"score":0.89066994,"function_name":"mbedtls_cipher_setup","code":"int mbedtls_cipher_setup( mbedtls_cipher_context_t *ctx, const mbedtls_cipher_info_t *cipher_info )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    if( cipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );\n\n    if( NULL == ( ctx-\u003ecipher_ctx = cipher_info-\u003ebase-\u003ectx_alloc_func() ) )\n        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );\n\n    ctx-\u003ecipher_info = cipher_info;\n\n#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)\n    /*\n     * Ignore possible errors caused by a cipher mode that doesn't use padding\n     */\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_PKCS7 );\n#else\n    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );\n#endif\n#endif /* MBEDTLS_CIPHER_MODE_WITH_PADDING */\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":207,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"421990":{"score":0.8732415,"function_name":"mbedtls_cipher_setkey","code":"int mbedtls_cipher_setkey( mbedtls_cipher_context_t *ctx,\n                           const unsigned char *key,\n                           int key_bitlen,\n                           const mbedtls_operation_t operation )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( key != NULL );\n    CIPHER_VALIDATE_RET( operation == MBEDTLS_ENCRYPT ||\n                         operation == MBEDTLS_DECRYPT );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003ecipher_info-\u003eflags \u0026 MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 \u0026\u0026\n        (int) ctx-\u003ecipher_info-\u003ekey_bitlen != key_bitlen )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    ctx-\u003ekey_bitlen = key_bitlen;\n    ctx-\u003eoperation = operation;\n\n    /*\n     * For OFB, CFB and CTR mode always use the encryption key schedule\n     */\n    if( MBEDTLS_ENCRYPT == operation ||\n        MBEDTLS_MODE_CFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_OFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_CTR == ctx-\u003ecipher_info-\u003emode )\n    {\n        return( ctx-\u003ecipher_info-\u003ebase-\u003esetkey_enc_func( ctx-\u003ecipher_ctx, key,\n                                                         ctx-\u003ekey_bitlen ) );\n    }\n\n    if( MBEDTLS_DECRYPT == operation )\n        return( ctx-\u003ecipher_info-\u003ebase-\u003esetkey_dec_func( ctx-\u003ecipher_ctx, key,\n                                                         ctx-\u003ekey_bitlen ) );\n\n    return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n}","filepath":"library/cipher.c","line_number":234,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"422219":{"score":0.8701217,"function_name":"mbedtls_cipher_set_iv","code":"int mbedtls_cipher_set_iv( mbedtls_cipher_context_t *ctx,\n                           const unsigned char *iv,\n                           size_t iv_len )\n{\n    size_t actual_iv_size;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( iv_len == 0 || iv != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    /* avoid buffer overflow in ctx-\u003eiv */\n    if( iv_len \u003e MBEDTLS_MAX_IV_LENGTH )\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n\n    if( ( ctx-\u003ecipher_info-\u003eflags \u0026 MBEDTLS_CIPHER_VARIABLE_IV_LEN ) != 0 )\n        actual_iv_size = iv_len;\n    else\n    {\n        actual_iv_size = ctx-\u003ecipher_info-\u003eiv_size;\n\n        /* avoid reading past the end of input buffer */\n        if( actual_iv_size \u003e iv_len )\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CHACHA20_C)\n    if ( ctx-\u003ecipher_info-\u003etype == MBEDTLS_CIPHER_CHACHA20 )\n    {\n        if ( 0 != mbedtls_chacha20_starts( (mbedtls_chacha20_context*)ctx-\u003ecipher_ctx,\n                                           iv,\n                                           0U ) ) /* Initial counter value */\n        {\n            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n        }\n    }\n#endif\n\n    if ( actual_iv_size != 0 )\n    {\n        memcpy( ctx-\u003eiv, iv, actual_iv_size );\n        ctx-\u003eiv_size = actual_iv_size;\n    }\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":274,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"422365":{"score":0.891704,"function_name":"mbedtls_cipher_reset","code":"int mbedtls_cipher_reset( mbedtls_cipher_context_t *ctx )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    ctx-\u003eunprocessed_len = 0;\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":321,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"422411":{"score":0.8812243,"function_name":"mbedtls_cipher_update","code":"int mbedtls_cipher_update( mbedtls_cipher_context_t *ctx, const unsigned char *input,\n                   size_t ilen, unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t block_size;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( ilen == 0 || input != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n    block_size = mbedtls_cipher_get_block_size( ctx );\n    if ( 0 == block_size )\n    {\n        return( MBEDTLS_ERR_CIPHER_INVALID_CONTEXT );\n    }\n\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_ECB )\n    {\n        if( ilen != block_size )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        *olen = ilen;\n\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003eecb_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_GCM_C)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_GCM )\n    {\n        *olen = ilen;\n        return( mbedtls_gcm_update( (mbedtls_gcm_context *) ctx-\u003ecipher_ctx, ilen, input,\n                                    output ) );\n    }\n#endif\n\n#if defined(MBEDTLS_CHACHAPOLY_C)\n    if ( ctx-\u003ecipher_info-\u003etype == MBEDTLS_CIPHER_CHACHA20_POLY1305 )\n    {\n        *olen = ilen;\n        return( mbedtls_chachapoly_update( (mbedtls_chachapoly_context*) ctx-\u003ecipher_ctx,\n                                           ilen, input, output ) );\n    }\n#endif\n\n    if( input == output \u0026\u0026\n       ( ctx-\u003eunprocessed_len != 0 || ilen % block_size ) )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CBC )\n    {\n        size_t copy_len = 0;\n\n        /*\n         * If there is not enough data for a full block, cache it.\n         */\n        if( ( ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026 NULL != ctx-\u003eadd_padding \u0026\u0026\n                ilen \u003c= block_size - ctx-\u003eunprocessed_len ) ||\n            ( ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026 NULL == ctx-\u003eadd_padding \u0026\u0026\n                ilen \u003c block_size - ctx-\u003eunprocessed_len ) ||\n             ( ctx-\u003eoperation == MBEDTLS_ENCRYPT \u0026\u0026\n                ilen \u003c block_size - ctx-\u003eunprocessed_len ) )\n        {\n            memcpy( \u0026( ctx-\u003eunprocessed_data[ctx-\u003eunprocessed_len] ), input,\n                    ilen );\n\n            ctx-\u003eunprocessed_len += ilen;\n            return( 0 );\n        }\n\n        /*\n         * Process cached data first\n         */\n        if( 0 != ctx-\u003eunprocessed_len )\n        {\n            copy_len = block_size - ctx-\u003eunprocessed_len;\n\n            memcpy( \u0026( ctx-\u003eunprocessed_data[ctx-\u003eunprocessed_len] ), input,\n                    copy_len );\n\n            if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, block_size, ctx-\u003eiv,\n                    ctx-\u003eunprocessed_data, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += block_size;\n            output += block_size;\n            ctx-\u003eunprocessed_len = 0;\n\n            input += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Cache final, incomplete block\n         */\n        if( 0 != ilen )\n        {\n            /* Encryption: only cache partial blocks\n             * Decryption w/ padding: always keep at least one whole block\n             * Decryption w/o padding: only cache partial blocks\n             */\n            copy_len = ilen % block_size;\n            if( copy_len == 0 \u0026\u0026\n                ctx-\u003eoperation == MBEDTLS_DECRYPT \u0026\u0026\n                NULL != ctx-\u003eadd_padding)\n            {\n                copy_len = block_size;\n            }\n\n            memcpy( ctx-\u003eunprocessed_data, \u0026( input[ilen - copy_len] ),\n                    copy_len );\n\n            ctx-\u003eunprocessed_len += copy_len;\n            ilen -= copy_len;\n        }\n\n        /*\n         * Process remaining full blocks\n         */\n        if( ilen )\n        {\n            if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                    ctx-\u003eoperation, ilen, ctx-\u003eiv, input, output ) ) )\n            {\n                return( ret );\n            }\n\n            *olen += ilen;\n        }\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n#if defined(MBEDTLS_CIPHER_MODE_CFB)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CFB )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecfb_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv,\n                input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_OFB)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_OFB )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003eofb_func( ctx-\u003ecipher_ctx,\n                ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_OFB */\n\n#if defined(MBEDTLS_CIPHER_MODE_CTR)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_CTR )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ectr_func( ctx-\u003ecipher_ctx,\n                ilen, \u0026ctx-\u003eunprocessed_len, ctx-\u003eiv,\n                ctx-\u003eunprocessed_data, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_CTR */\n\n#if defined(MBEDTLS_CIPHER_MODE_XTS)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_XTS )\n    {\n        if( ctx-\u003eunprocessed_len \u003e 0 ) {\n            /* We can only process an entire data unit at a time. */\n            return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n        }\n\n        ret = ctx-\u003ecipher_info-\u003ebase-\u003exts_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, ilen, ctx-\u003eiv, input, output );\n        if( ret != 0 )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_XTS */\n\n#if defined(MBEDTLS_CIPHER_MODE_STREAM)\n    if( ctx-\u003ecipher_info-\u003emode == MBEDTLS_MODE_STREAM )\n    {\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003estream_func( ctx-\u003ecipher_ctx,\n                                                    ilen, input, output ) ) )\n        {\n            return( ret );\n        }\n\n        *olen = ilen;\n\n        return( 0 );\n    }\n#endif /* MBEDTLS_CIPHER_MODE_STREAM */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}","filepath":"library/cipher.c","line_number":374,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"423235":{"score":0.86105144,"function_name":"add_pkcs_padding","code":"static void add_pkcs_padding( unsigned char *output, size_t output_len,\n        size_t data_len )\n{\n    size_t padding_len = output_len - data_len;\n    unsigned char i;\n\n    for( i = 0; i \u003c padding_len; i++ )\n        output[data_len + i] = (unsigned char) padding_len;\n}","filepath":"library/cipher.c","line_number":614,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"423307":{"score":0.94286585,"function_name":"get_pkcs_padding","code":"static int get_pkcs_padding( unsigned char *input, size_t input_len,\n        size_t *data_len )\n{\n    size_t i, pad_idx;\n    unsigned char padding_len, bad = 0;\n\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    padding_len = input[input_len - 1];\n    *data_len = input_len - padding_len;\n\n    /* Avoid logical || since it results in a branch */\n    bad |= padding_len \u003e input_len;\n    bad |= padding_len == 0;\n\n    /* The number of bytes checked must be independent of padding_len,\n     * so pick input_len, which is usually 8 or 16 (one block) */\n    pad_idx = input_len - padding_len;\n    for( i = 0; i \u003c input_len; i++ )\n        bad |= ( input[i] ^ padding_len ) * ( i \u003e= pad_idx );\n\n    return( MBEDTLS_ERR_CIPHER_INVALID_PADDING * ( bad != 0 ) );\n}","filepath":"library/cipher.c","line_number":624,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"423520":{"score":0.93321455,"function_name":"get_no_padding","code":"static int get_no_padding( unsigned char *input, size_t input_len,\n                              size_t *data_len )\n{\n    if( NULL == input || NULL == data_len )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *data_len = input_len;\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":769,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"423567":{"score":0.82754,"function_name":"mbedtls_cipher_finish","code":"int mbedtls_cipher_finish( mbedtls_cipher_context_t *ctx,\n                   unsigned char *output, size_t *olen )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n    if( ctx-\u003ecipher_info == NULL )\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n\n    *olen = 0;\n\n    if( MBEDTLS_MODE_CFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_OFB == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_CTR == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_GCM == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_XTS == ctx-\u003ecipher_info-\u003emode ||\n        MBEDTLS_MODE_STREAM == ctx-\u003ecipher_info-\u003emode )\n    {\n        return( 0 );\n    }\n\n    if ( ( MBEDTLS_CIPHER_CHACHA20          == ctx-\u003ecipher_info-\u003etype ) ||\n         ( MBEDTLS_CIPHER_CHACHA20_POLY1305 == ctx-\u003ecipher_info-\u003etype ) )\n    {\n        return( 0 );\n    }\n\n    if( MBEDTLS_MODE_ECB == ctx-\u003ecipher_info-\u003emode )\n    {\n        if( ctx-\u003eunprocessed_len != 0 )\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n        return( 0 );\n    }\n\n#if defined(MBEDTLS_CIPHER_MODE_CBC)\n    if( MBEDTLS_MODE_CBC == ctx-\u003ecipher_info-\u003emode )\n    {\n        int ret = 0;\n\n        if( MBEDTLS_ENCRYPT == ctx-\u003eoperation )\n        {\n            /* check for 'no padding' mode */\n            if( NULL == ctx-\u003eadd_padding )\n            {\n                if( 0 != ctx-\u003eunprocessed_len )\n                    return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n\n                return( 0 );\n            }\n\n            ctx-\u003eadd_padding( ctx-\u003eunprocessed_data, mbedtls_cipher_get_iv_size( ctx ),\n                    ctx-\u003eunprocessed_len );\n        }\n        else if( mbedtls_cipher_get_block_size( ctx ) != ctx-\u003eunprocessed_len )\n        {\n            /*\n             * For decrypt operations, expect a full block,\n             * or an empty block if no padding\n             */\n            if( NULL == ctx-\u003eadd_padding \u0026\u0026 0 == ctx-\u003eunprocessed_len )\n                return( 0 );\n\n            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );\n        }\n\n        /* cipher block */\n        if( 0 != ( ret = ctx-\u003ecipher_info-\u003ebase-\u003ecbc_func( ctx-\u003ecipher_ctx,\n                ctx-\u003eoperation, mbedtls_cipher_get_block_size( ctx ), ctx-\u003eiv,\n                ctx-\u003eunprocessed_data, output ) ) )\n        {\n            return( ret );\n        }\n\n        /* Set output size for decryption */\n        if( MBEDTLS_DECRYPT == ctx-\u003eoperation )\n            return( ctx-\u003eget_padding( output, mbedtls_cipher_get_block_size( ctx ),\n                                      olen ) );\n\n        /* Set output size for encryption */\n        *olen = mbedtls_cipher_get_block_size( ctx );\n        return( 0 );\n    }\n#else\n    ((void) output);\n#endif /* MBEDTLS_CIPHER_MODE_CBC */\n\n    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n}","filepath":"library/cipher.c","line_number":781,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"424133":{"score":0.7825073,"function_name":"mbedtls_cipher_set_padding_mode","code":"int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx,\n                                     mbedtls_cipher_padding_t mode )\n{\n    CIPHER_VALIDATE_RET( ctx != NULL );\n\n    if( NULL == ctx-\u003ecipher_info || MBEDTLS_MODE_CBC != ctx-\u003ecipher_info-\u003emode )\n    {\n        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );\n    }\n\n    switch( mode )\n    {\n#if defined(MBEDTLS_CIPHER_PADDING_PKCS7)\n    case MBEDTLS_PADDING_PKCS7:\n        ctx-\u003eadd_padding = add_pkcs_padding;\n        ctx-\u003eget_padding = get_pkcs_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS)\n    case MBEDTLS_PADDING_ONE_AND_ZEROS:\n        ctx-\u003eadd_padding = add_one_and_zeros_padding;\n        ctx-\u003eget_padding = get_one_and_zeros_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN)\n    case MBEDTLS_PADDING_ZEROS_AND_LEN:\n        ctx-\u003eadd_padding = add_zeros_and_len_padding;\n        ctx-\u003eget_padding = get_zeros_and_len_padding;\n        break;\n#endif\n#if defined(MBEDTLS_CIPHER_PADDING_ZEROS)\n    case MBEDTLS_PADDING_ZEROS:\n        ctx-\u003eadd_padding = add_zeros_padding;\n        ctx-\u003eget_padding = get_zeros_padding;\n        break;\n#endif\n    case MBEDTLS_PADDING_NONE:\n        ctx-\u003eadd_padding = NULL;\n        ctx-\u003eget_padding = get_no_padding;\n        break;\n\n    default:\n        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":872,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"424253":{"score":0.8601402,"function_name":"mbedtls_cipher_crypt","code":"int mbedtls_cipher_crypt( mbedtls_cipher_context_t *ctx,\n                  const unsigned char *iv, size_t iv_len,\n                  const unsigned char *input, size_t ilen,\n                  unsigned char *output, size_t *olen )\n{\n    int ret;\n    size_t finish_olen;\n\n    CIPHER_VALIDATE_RET( ctx != NULL );\n    CIPHER_VALIDATE_RET( iv_len == 0 || iv != NULL );\n    CIPHER_VALIDATE_RET( ilen == 0 || input != NULL );\n    CIPHER_VALIDATE_RET( output != NULL );\n    CIPHER_VALIDATE_RET( olen != NULL );\n\n    if( ( ret = mbedtls_cipher_set_iv( ctx, iv, iv_len ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_reset( ctx ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_update( ctx, input, ilen, output, olen ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_cipher_finish( ctx, output + *olen, \u0026finish_olen ) ) != 0 )\n        return( ret );\n\n    *olen += finish_olen;\n\n    return( 0 );\n}","filepath":"library/cipher.c","line_number":1019,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.8"},"424955":{"score":0.82077736,"function_name":"ecdh_compute_shared_restartable","code":"static int ecdh_compute_shared_restartable( mbedtls_ecp_group *grp,\n                         mbedtls_mpi *z,\n                         const mbedtls_ecp_point *Q, const mbedtls_mpi *d,\n                         int (*f_rng)(void *, unsigned char *, size_t),\n                         void *p_rng,\n                         mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_ecp_point P;\n\n    mbedtls_ecp_point_init( \u0026P );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, \u0026P, d, Q,\n                                                  f_rng, p_rng, rs_ctx ) );\n\n    if( mbedtls_ecp_is_zero( \u0026P ) )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( z, \u0026P.X ) );\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026P );\n\n    return( ret );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":100,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"425228":{"score":0.84781647,"function_name":"ecdh_init_internal","code":"static void ecdh_init_internal( mbedtls_ecdh_context_mbed *ctx )\n{\n    mbedtls_ecp_group_init( \u0026ctx-\u003egrp );\n    mbedtls_mpi_init( \u0026ctx-\u003ed  );\n    mbedtls_ecp_point_init( \u0026ctx-\u003eQ   );\n    mbedtls_ecp_point_init( \u0026ctx-\u003eQp  );\n    mbedtls_mpi_init( \u0026ctx-\u003ez  );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_init( \u0026ctx-\u003ers );\n#endif\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":146,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"425456":{"score":0.7252524,"function_name":"ecdh_setup_internal","code":"static int ecdh_setup_internal( mbedtls_ecdh_context_mbed *ctx,\n                                mbedtls_ecp_group_id grp_id )\n{\n    int ret;\n\n    ret = mbedtls_ecp_group_load( \u0026ctx-\u003egrp, grp_id );\n    if( ret != 0 )\n    {\n        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n    }\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":182,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"425671":{"score":0.79764223,"function_name":"ecp_restart_ma_free","code":"static void ecp_restart_ma_free( mbedtls_ecp_restart_muladd_ctx *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    mbedtls_ecp_point_free( \u0026ctx-\u003emP );\n    mbedtls_ecp_point_free( \u0026ctx-\u003eR );\n\n    ecp_restart_ma_init( ctx );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":231,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"425777":{"score":0.7748865,"function_name":"ecdh_make_params_internal","code":"static int ecdh_make_params_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      size_t *olen, int point_format,\n                                      unsigned char *buf, size_t blen,\n                                      int (*f_rng)(void *,\n                                                   unsigned char *,\n                                                   size_t),\n                                      void *p_rng,\n                                      int restart_enabled )\n{\n    int ret;\n    size_t grp_len, pt_len;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( restart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#else\n    (void) restart_enabled;\n#endif\n\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_gen_public_restartable( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                             f_rng, p_rng, rs_ctx ) ) != 0 )\n        return( ret );\n#else\n    if( ( ret = mbedtls_ecdh_gen_public( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                         f_rng, p_rng ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    if( ( ret = mbedtls_ecp_tls_write_group( \u0026ctx-\u003egrp, \u0026grp_len, buf,\n                                             blen ) ) != 0 )\n        return( ret );\n\n    buf += grp_len;\n    blen -= grp_len;\n\n    if( ( ret = mbedtls_ecp_tls_write_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQ, point_format,\n                                             \u0026pt_len, buf, blen ) ) != 0 )\n        return( ret );\n\n    *olen = grp_len + pt_len;\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":272,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426176":{"score":0.7458113,"function_name":"mbedtls_ecdh_read_params","code":"int mbedtls_ecdh_read_params( mbedtls_ecdh_context *ctx,\n                              const unsigned char **buf,\n                              const unsigned char *end )\n{\n    int ret;\n    mbedtls_ecp_group_id grp_id;\n    ECDH_VALIDATE_RET( ctx != NULL );\n    ECDH_VALIDATE_RET( buf != NULL );\n    ECDH_VALIDATE_RET( *buf != NULL );\n    ECDH_VALIDATE_RET( end != NULL );\n\n    if( ( ret = mbedtls_ecp_tls_read_group_id( \u0026grp_id, buf, end - *buf ) )\n            != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_ecdh_setup( ctx, grp_id ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)\n    return( ecdh_read_params_internal( ctx, buf, end ) );\n#else\n    switch( ctx-\u003evar )\n    {\n        case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:\n            return( ecdh_read_params_internal( \u0026ctx-\u003ectx.mbed_ecdh,\n                                               buf, end ) );\n        default:\n            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n    }\n#endif\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":379,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426344":{"score":0.87195563,"function_name":"ecdh_get_params_internal","code":"static int ecdh_get_params_internal( mbedtls_ecdh_context_mbed *ctx,\n                                     const mbedtls_ecp_keypair *key,\n                                     mbedtls_ecdh_side side )\n{\n    int ret;\n\n    /* If it's not our key, just import the public part as Qp */\n    if( side == MBEDTLS_ECDH_THEIRS )\n        return( mbedtls_ecp_copy( \u0026ctx-\u003eQp, \u0026key-\u003eQ ) );\n\n    /* Our key: import public (as Q) and private parts */\n    if( side != MBEDTLS_ECDH_OURS )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    if( ( ret = mbedtls_ecp_copy( \u0026ctx-\u003eQ, \u0026key-\u003eQ ) ) != 0 ||\n        ( ret = mbedtls_mpi_copy( \u0026ctx-\u003ed, \u0026key-\u003ed ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":411,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426501":{"score":0.6392184,"function_name":"mbedtls_ecdh_get_params","code":"int mbedtls_ecdh_get_params( mbedtls_ecdh_context *ctx,\n                             const mbedtls_ecp_keypair *key,\n                             mbedtls_ecdh_side side )\n{\n    int ret;\n    ECDH_VALIDATE_RET( ctx != NULL );\n    ECDH_VALIDATE_RET( key != NULL );\n    ECDH_VALIDATE_RET( side == MBEDTLS_ECDH_OURS ||\n                       side == MBEDTLS_ECDH_THEIRS );\n\n    if( ( ret = mbedtls_ecdh_setup( ctx, key-\u003egrp.id ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_ECDH_LEGACY_CONTEXT)\n    return( ecdh_get_params_internal( ctx, key, side ) );\n#else\n    switch( ctx-\u003evar )\n    {\n        case MBEDTLS_ECDH_VARIANT_MBEDTLS_2_0:\n            return( ecdh_get_params_internal( \u0026ctx-\u003ectx.mbed_ecdh,\n                                              key, side ) );\n        default:\n            return MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n    }\n#endif\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":435,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426573":{"score":0.7847198,"function_name":"ecdh_make_public_internal","code":"static int ecdh_make_public_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      size_t *olen, int point_format,\n                                      unsigned char *buf, size_t blen,\n                                      int (*f_rng)(void *,\n                                                   unsigned char *,\n                                                   size_t),\n                                      void *p_rng,\n                                      int restart_enabled )\n{\n    int ret;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( restart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#else\n    (void) restart_enabled;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_gen_public_restartable( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                             f_rng, p_rng, rs_ctx ) ) != 0 )\n        return( ret );\n#else\n    if( ( ret = mbedtls_ecdh_gen_public( \u0026ctx-\u003egrp, \u0026ctx-\u003ed, \u0026ctx-\u003eQ,\n                                         f_rng, p_rng ) ) != 0 )\n        return( ret );\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    return mbedtls_ecp_tls_write_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQ, point_format, olen,\n                                        buf, blen );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":462,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426766":{"score":0.8362347,"function_name":"ecdh_read_public_internal","code":"static int ecdh_read_public_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      const unsigned char *buf, size_t blen )\n{\n    int ret;\n    const unsigned char *p = buf;\n\n    if( ( ret = mbedtls_ecp_tls_read_point( \u0026ctx-\u003egrp, \u0026ctx-\u003eQp, \u0026p,\n                                            blen ) ) != 0 )\n        return( ret );\n\n    if( (size_t)( p - buf ) != blen )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    return( 0 );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":535,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"426947":{"score":0.8369876,"function_name":"ecdh_calc_secret_internal","code":"static int ecdh_calc_secret_internal( mbedtls_ecdh_context_mbed *ctx,\n                                      size_t *olen, unsigned char *buf,\n                                      size_t blen,\n                                      int (*f_rng)(void *,\n                                                   unsigned char *,\n                                                   size_t),\n                                      void *p_rng,\n                                      int restart_enabled )\n{\n    int ret;\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    mbedtls_ecp_restart_ctx *rs_ctx = NULL;\n#endif\n\n    if( ctx == NULL || ctx-\u003egrp.pbits == 0 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( restart_enabled )\n        rs_ctx = \u0026ctx-\u003ers;\n#else\n    (void) restart_enabled;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ( ret = ecdh_compute_shared_restartable( \u0026ctx-\u003egrp, \u0026ctx-\u003ez, \u0026ctx-\u003eQp,\n                                                 \u0026ctx-\u003ed, f_rng, p_rng,\n                                                 rs_ctx ) ) != 0 )\n    {\n        return( ret );\n    }\n#else\n    if( ( ret = mbedtls_ecdh_compute_shared( \u0026ctx-\u003egrp, \u0026ctx-\u003ez, \u0026ctx-\u003eQp,\n                                             \u0026ctx-\u003ed, f_rng, p_rng ) ) != 0 )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_ECP_RESTARTABLE */\n\n    if( mbedtls_mpi_size( \u0026ctx-\u003ez ) \u003e blen )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    *olen = ctx-\u003egrp.pbits / 8 + ( ( ctx-\u003egrp.pbits % 8 ) != 0 );\n    return mbedtls_mpi_write_binary( \u0026ctx-\u003ez, buf, *olen );\n}","filepath":"lib/libmbedtls/mbedtls/library/ecdh.c","line_number":574,"entry_url":"https://github.com/OP-TEE/optee_os.git","slot_name":"3.5.0-rc1"},"427236":{"score":0.88913983,"function_name":"mbedtls_ecp_grp_id_list","code":"const mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list( void )\n{\n    static int init_done = 0;\n\n    if( ! init_done )\n    {\n        size_t i = 0;\n        const mbedtls_ecp_curve_info *curve_info;\n\n        for( curve_info = mbedtls_ecp_curve_list();\n             curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n             curve_info++ )\n        {\n            ecp_supported_grp_id[i++] = curve_info-\u003egrp_id;\n        }\n        ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;\n\n        init_done = 1;\n    }\n\n    return( ecp_supported_grp_id );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":432,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427351":{"score":0.7142651,"function_name":"mbedtls_ecp_curve_info_from_grp_id","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id( mbedtls_ecp_group_id grp_id )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( curve_info-\u003egrp_id == grp_id )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":458,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427412":{"score":0.83832014,"function_name":"mbedtls_ecp_curve_info_from_tls_id","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id( uint16_t tls_id )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( curve_info-\u003etls_id == tls_id )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":476,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427483":{"score":0.8027932,"function_name":"mbedtls_ecp_curve_info_from_name","code":"const mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n\n    if( name == NULL )\n        return( NULL );\n\n    for( curve_info = mbedtls_ecp_curve_list();\n         curve_info-\u003egrp_id != MBEDTLS_ECP_DP_NONE;\n         curve_info++ )\n    {\n        if( strcmp( curve_info-\u003ename, name ) == 0 )\n            return( curve_info );\n    }\n\n    return( NULL );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":494,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427577":{"score":0.8299555,"function_name":"mbedtls_ecp_get_type","code":"mbedtls_ecp_curve_type mbedtls_ecp_get_type( const mbedtls_ecp_group *grp )\n{\n    if( grp-\u003eG.X.p == NULL )\n        return( MBEDTLS_ECP_TYPE_NONE );\n\n    if( grp-\u003eG.Y.p == NULL )\n        return( MBEDTLS_ECP_TYPE_MONTGOMERY );\n    else\n        return( MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":515,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427706":{"score":0.8122131,"function_name":"mbedtls_ecp_group_init","code":"void mbedtls_ecp_group_init( mbedtls_ecp_group *grp )\n{\n    ECP_VALIDATE( grp != NULL );\n\n    grp-\u003eid = MBEDTLS_ECP_DP_NONE;\n    mbedtls_mpi_init( \u0026grp-\u003eP );\n    mbedtls_mpi_init( \u0026grp-\u003eA );\n    mbedtls_mpi_init( \u0026grp-\u003eB );\n    mbedtls_ecp_point_init( \u0026grp-\u003eG );\n    mbedtls_mpi_init( \u0026grp-\u003eN );\n    grp-\u003epbits = 0;\n    grp-\u003enbits = 0;\n    grp-\u003eh = 0;\n    grp-\u003emodp = NULL;\n    grp-\u003et_pre = NULL;\n    grp-\u003et_post = NULL;\n    grp-\u003et_data = NULL;\n    grp-\u003eT = NULL;\n    grp-\u003eT_size = 0;\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":541,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"427996":{"score":0.8382923,"function_name":"mbedtls_ecp_point_free","code":"void mbedtls_ecp_point_free( mbedtls_ecp_point *pt )\n{\n    if( pt == NULL )\n        return;\n\n    mbedtls_mpi_free( \u0026( pt-\u003eX ) );\n    mbedtls_mpi_free( \u0026( pt-\u003eY ) );\n    mbedtls_mpi_free( \u0026( pt-\u003eZ ) );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":577,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428079":{"score":0.8758821,"function_name":"mbedtls_ecp_group_free","code":"void mbedtls_ecp_group_free( mbedtls_ecp_group *grp )\n{\n    size_t i;\n\n    if( grp == NULL )\n        return;\n\n    if( grp-\u003eh != 1 )\n    {\n        mbedtls_mpi_free( \u0026grp-\u003eP );\n        mbedtls_mpi_free( \u0026grp-\u003eA );\n        mbedtls_mpi_free( \u0026grp-\u003eB );\n        mbedtls_ecp_point_free( \u0026grp-\u003eG );\n        mbedtls_mpi_free( \u0026grp-\u003eN );\n    }\n\n    if( grp-\u003eT != NULL )\n    {\n        for( i = 0; i \u003c grp-\u003eT_size; i++ )\n            mbedtls_ecp_point_free( \u0026grp-\u003eT[i] );\n        mbedtls_free( grp-\u003eT );\n    }\n\n    mbedtls_platform_zeroize( grp, sizeof( mbedtls_ecp_group ) );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":590,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428317":{"score":0.88078684,"function_name":"mbedtls_ecp_keypair_free","code":"void mbedtls_ecp_keypair_free( mbedtls_ecp_keypair *key )\n{\n    if( key == NULL )\n        return;\n\n    mbedtls_ecp_group_free( \u0026key-\u003egrp );\n    mbedtls_mpi_free( \u0026key-\u003ed );\n    mbedtls_ecp_point_free( \u0026key-\u003eQ );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":619,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428402":{"score":0.79806596,"function_name":"mbedtls_ecp_copy","code":"int mbedtls_ecp_copy( mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )\n{\n    int ret;\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( Q != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eX, \u0026Q-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eY, \u0026Q-\u003eY ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026P-\u003eZ, \u0026Q-\u003eZ ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":632,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428572":{"score":0.84076893,"function_name":"mbedtls_ecp_set_zero","code":"int mbedtls_ecp_set_zero( mbedtls_ecp_point *pt )\n{\n    int ret;\n    ECP_VALIDATE_RET( pt != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eX , 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eY , 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ , 0 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":660,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428738":{"score":0.8215678,"function_name":"mbedtls_ecp_point_cmp","code":"int mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,\n                           const mbedtls_ecp_point *Q )\n{\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( Q != NULL );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026P-\u003eX, \u0026Q-\u003eX ) == 0 \u0026\u0026\n        mbedtls_mpi_cmp_mpi( \u0026P-\u003eY, \u0026Q-\u003eY ) == 0 \u0026\u0026\n        mbedtls_mpi_cmp_mpi( \u0026P-\u003eZ, \u0026Q-\u003eZ ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":686,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428854":{"score":0.7738409,"function_name":"mbedtls_ecp_point_read_string","code":"int mbedtls_ecp_point_read_string( mbedtls_ecp_point *P, int radix,\n                           const char *x, const char *y )\n{\n    int ret;\n    ECP_VALIDATE_RET( P != NULL );\n    ECP_VALIDATE_RET( x != NULL );\n    ECP_VALIDATE_RET( y != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( \u0026P-\u003eX, radix, x ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( \u0026P-\u003eY, radix, y ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026P-\u003eZ, 1 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":705,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"428976":{"score":0.7529938,"function_name":"mbedtls_ecp_point_write_binary","code":"int mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp,\n                                    const mbedtls_ecp_point *P,\n                                    int format, size_t *olen,\n                                    unsigned char *buf, size_t buflen )\n{\n    int ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;\n    size_t plen;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( P    != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( format == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n                      format == MBEDTLS_ECP_PF_COMPRESSED );\n\n    plen = mbedtls_mpi_size( \u0026grp-\u003eP );\n\n#if defined(ECP_MONTGOMERY)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        *olen = plen;\n        if( buflen \u003c *olen )\n            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary_le( \u0026P-\u003eX, buf, plen ) );\n    }\n#endif\n#if defined(ECP_SHORTWEIERSTRASS)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /*\n         * Common case: P == 0\n         */\n        if( mbedtls_mpi_cmp_int( \u0026P-\u003eZ, 0 ) == 0 )\n        {\n            if( buflen \u003c 1 )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x00;\n            *olen = 1;\n\n            return( 0 );\n        }\n\n        if( format == MBEDTLS_ECP_PF_UNCOMPRESSED )\n        {\n            *olen = 2 * plen + 1;\n\n            if( buflen \u003c *olen )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x04;\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eX, buf + 1, plen ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eY, buf + 1 + plen, plen ) );\n        }\n        else if( format == MBEDTLS_ECP_PF_COMPRESSED )\n        {\n            *olen = plen + 1;\n\n            if( buflen \u003c *olen )\n                return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n            buf[0] = 0x02 + mbedtls_mpi_get_bit( \u0026P-\u003eY, 0 );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( \u0026P-\u003eX, buf + 1, plen ) );\n        }\n    }\n#endif\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":724,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"429577":{"score":0.8768501,"function_name":"mbedtls_ecp_tls_read_point","code":"int mbedtls_ecp_tls_read_point( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point *pt,\n                                const unsigned char **buf, size_t buf_len )\n{\n    unsigned char data_len;\n    const unsigned char *buf_start;\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( pt  != NULL );\n    ECP_VALIDATE_RET( buf != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    /*\n     * We must have at least two bytes (1 for length, at least one for data)\n     */\n    if( buf_len \u003c 2 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    data_len = *(*buf)++;\n    if( data_len \u003c 1 || data_len \u003e buf_len - 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * Save buffer start for read_binary and update buf\n     */\n    buf_start = *buf;\n    *buf += data_len;\n\n    return( mbedtls_ecp_point_read_binary( grp, pt, buf_start, data_len ) );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":863,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"429700":{"score":0.9169677,"function_name":"mbedtls_ecp_tls_write_point","code":"int mbedtls_ecp_tls_write_point( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt,\n                         int format, size_t *olen,\n                         unsigned char *buf, size_t blen )\n{\n    int ret;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( pt   != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( format == MBEDTLS_ECP_PF_UNCOMPRESSED ||\n                      format == MBEDTLS_ECP_PF_COMPRESSED );\n\n    /*\n     * buffer length must be at least one, for our length byte\n     */\n    if( blen \u003c 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    if( ( ret = mbedtls_ecp_point_write_binary( grp, pt, format,\n                    olen, buf + 1, blen - 1) ) != 0 )\n        return( ret );\n\n    /*\n     * write length to the first byte and update total length\n     */\n    buf[0] = (unsigned char) *olen;\n    ++*olen;\n\n    return( 0 );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":899,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"429812":{"score":0.7396295,"function_name":"mbedtls_ecp_tls_read_group","code":"int mbedtls_ecp_tls_read_group( mbedtls_ecp_group *grp,\n                                const unsigned char **buf, size_t len )\n{\n    int ret;\n    mbedtls_ecp_group_id grp_id;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    if( ( ret = mbedtls_ecp_tls_read_group_id( \u0026grp_id, buf, len ) ) != 0 )\n        return( ret );\n\n    return( mbedtls_ecp_group_load( grp, grp_id ) );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":933,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"429928":{"score":0.8685712,"function_name":"mbedtls_ecp_tls_read_group_id","code":"int mbedtls_ecp_tls_read_group_id( mbedtls_ecp_group_id *grp,\n                                   const unsigned char **buf, size_t len )\n{\n    uint16_t tls_id;\n    const mbedtls_ecp_curve_info *curve_info;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( *buf != NULL );\n\n    /*\n     * We expect at least three bytes (see below)\n     */\n    if( len \u003c 3 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * First byte is curve_type; only named_curve is handled\n     */\n    if( *(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * Next two bytes are the namedcurve value\n     */\n    tls_id = *(*buf)++;\n    tls_id \u003c\u003c= 8;\n    tls_id |= *(*buf)++;\n\n    if( ( curve_info = mbedtls_ecp_curve_info_from_tls_id( tls_id ) ) == NULL )\n        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );\n\n    *grp = curve_info-\u003egrp_id;\n\n    return( 0 );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":952,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"430081":{"score":0.86137164,"function_name":"mbedtls_ecp_tls_write_group","code":"int mbedtls_ecp_tls_write_group( const mbedtls_ecp_group *grp, size_t *olen,\n                         unsigned char *buf, size_t blen )\n{\n    const mbedtls_ecp_curve_info *curve_info;\n    ECP_VALIDATE_RET( grp  != NULL );\n    ECP_VALIDATE_RET( buf  != NULL );\n    ECP_VALIDATE_RET( olen != NULL );\n\n    if( ( curve_info = mbedtls_ecp_curve_info_from_grp_id( grp-\u003eid ) ) == NULL )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /*\n     * We are going to write 3 bytes (see below)\n     */\n    *olen = 3;\n    if( blen \u003c *olen )\n        return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );\n\n    /*\n     * First byte is curve_type, always named_curve\n     */\n    *buf++ = MBEDTLS_ECP_TLS_NAMED_CURVE;\n\n    /*\n     * Next two bytes are the namedcurve value\n     */\n    buf[0] = curve_info-\u003etls_id \u003e\u003e 8;\n    buf[1] = curve_info-\u003etls_id \u0026 0xFF;\n\n    return( 0 );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":991,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"430205":{"score":0.9143777,"function_name":"ecp_modp","code":"static int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )\n{\n    int ret;\n\n    if( grp-\u003emodp == NULL )\n        return( mbedtls_mpi_mod_mpi( N, N, \u0026grp-\u003eP ) );\n\n    /* N-\u003es \u003c 0 is a much faster test, which fails only if N is 0 */\n    if( ( N-\u003es \u003c 0 \u0026\u0026 mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||\n        mbedtls_mpi_bitlen( N ) \u003e 2 * grp-\u003epbits )\n    {\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n    }\n\n    MBEDTLS_MPI_CHK( grp-\u003emodp( N ) );\n\n    /* N-\u003es \u003c 0 is a much faster test, which fails only if N is 0 */\n    while( N-\u003es \u003c 0 \u0026\u0026 mbedtls_mpi_cmp_int( N, 0 ) != 0 )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, \u0026grp-\u003eP ) );\n\n    while( mbedtls_mpi_cmp_mpi( N, \u0026grp-\u003eP ) \u003e= 0 )\n        /* we known P, N and the result are positive */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, \u0026grp-\u003eP ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1029,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"430496":{"score":0.7433015,"function_name":"ecp_normalize_jac","code":"static int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt )\n{\n    int ret;\n    mbedtls_mpi Zi, ZZi;\n\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eZ, 0 ) == 0 )\n        return( 0 );\n\n#if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_normalize_jac( grp, pt ) );\n#endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */\n\n    mbedtls_mpi_init( \u0026Zi ); mbedtls_mpi_init( \u0026ZZi );\n\n    /*\n     * X = X / Z^2  mod p\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( \u0026Zi,      \u0026pt-\u003eZ,     \u0026grp-\u003eP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026ZZi,     \u0026Zi,        \u0026Zi     ) ); MOD_MUL( ZZi );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026pt-\u003eX,   \u0026pt-\u003eX,     \u0026ZZi    ) ); MOD_MUL( pt-\u003eX );\n\n    /*\n     * Y = Y / Z^3  mod p\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026pt-\u003eY,   \u0026pt-\u003eY,     \u0026ZZi    ) ); MOD_MUL( pt-\u003eY );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026pt-\u003eY,   \u0026pt-\u003eY,     \u0026Zi     ) ); MOD_MUL( pt-\u003eY );\n\n    /*\n     * Z = 1\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026pt-\u003eZ, 1 ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026Zi ); mbedtls_mpi_free( \u0026ZZi );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1113,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"432458":{"score":0.80076927,"function_name":"ecp_safe_invert_jac","code":"static int ecp_safe_invert_jac( const mbedtls_ecp_group *grp,\n                            mbedtls_ecp_point *Q,\n                            unsigned char inv )\n{\n    int ret;\n    unsigned char nonzero;\n    mbedtls_mpi mQY;\n\n    mbedtls_mpi_init( \u0026mQY );\n\n    /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026mQY, \u0026grp-\u003eP, \u0026Q-\u003eY ) );\n    nonzero = mbedtls_mpi_cmp_int( \u0026Q-\u003eY, 0 ) != 0;\n    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026Q-\u003eY, \u0026mQY, inv \u0026 nonzero ) );\n\ncleanup:\n    mbedtls_mpi_free( \u0026mQY );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1253,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"432671":{"score":0.6371616,"function_name":"ecp_double_jac","code":"static int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                           const mbedtls_ecp_point *P )\n{\n    int ret;\n    mbedtls_mpi M, S, T, U;\n\n#if defined(MBEDTLS_SELF_TEST)\n    dbl_count++;\n#endif\n\n#if defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_double_jac( grp, R, P ) );\n#endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */\n\n    mbedtls_mpi_init( \u0026M ); mbedtls_mpi_init( \u0026S ); mbedtls_mpi_init( \u0026T ); mbedtls_mpi_init( \u0026U );\n\n    /* Special case for A = -3 */\n    if( grp-\u003eA.p == NULL )\n    {\n        /* M = 3(X + Z^2)(X - Z^2) */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026P-\u003eZ,  \u0026P-\u003eZ   ) ); MOD_MUL( S );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026T,  \u0026P-\u003eX,  \u0026S      ) ); MOD_ADD( T );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026U,  \u0026P-\u003eX,  \u0026S      ) ); MOD_SUB( U );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026T,     \u0026U      ) ); MOD_MUL( S );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( \u0026M,  \u0026S,     3       ) ); MOD_ADD( M );\n    }\n    else\n    {\n        /* M = 3.X^2 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026P-\u003eX,  \u0026P-\u003eX   ) ); MOD_MUL( S );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( \u0026M,  \u0026S,     3       ) ); MOD_ADD( M );\n\n        /* Optimize away for \"koblitz\" curves with A = 0 */\n        if( mbedtls_mpi_cmp_int( \u0026grp-\u003eA, 0 ) != 0 )\n        {\n            /* M += A.Z^4 */\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026P-\u003eZ,  \u0026P-\u003eZ   ) ); MOD_MUL( S );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T,  \u0026S,     \u0026S      ) ); MOD_MUL( T );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026T,     \u0026grp-\u003eA ) ); MOD_MUL( S );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026M,  \u0026M,     \u0026S      ) ); MOD_ADD( M );\n        }\n    }\n\n    /* S = 4.X.Y^2 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T,  \u0026P-\u003eY,  \u0026P-\u003eY   ) ); MOD_MUL( T );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( \u0026T,  1               ) ); MOD_ADD( T );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026P-\u003eX,  \u0026T      ) ); MOD_MUL( S );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( \u0026S,  1               ) ); MOD_ADD( S );\n\n    /* U = 8.Y^4 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026U,  \u0026T,     \u0026T      ) ); MOD_MUL( U );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( \u0026U,  1               ) ); MOD_ADD( U );\n\n    /* T = M^2 - 2.S */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T,  \u0026M,     \u0026M      ) ); MOD_MUL( T );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026T,  \u0026T,     \u0026S      ) ); MOD_SUB( T );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026T,  \u0026T,     \u0026S      ) ); MOD_SUB( T );\n\n    /* S = M(S - T) - U */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026S,  \u0026S,     \u0026T      ) ); MOD_SUB( S );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026S,  \u0026S,     \u0026M      ) ); MOD_MUL( S );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026S,  \u0026S,     \u0026U      ) ); MOD_SUB( S );\n\n    /* U = 2.Y.Z */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026U,  \u0026P-\u003eY,  \u0026P-\u003eZ   ) ); MOD_MUL( U );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( \u0026U,  1               ) ); MOD_ADD( U );\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eX, \u0026T ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eY, \u0026S ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026R-\u003eZ, \u0026U ) );\n\ncleanup:\n    mbedtls_mpi_free( \u0026M ); mbedtls_mpi_free( \u0026S ); mbedtls_mpi_free( \u0026T ); mbedtls_mpi_free( \u0026U );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1288,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"438235":{"score":0.9392398,"function_name":"ecp_comb_recode_core","code":"static void ecp_comb_recode_core( unsigned char x[], size_t d,\n                                  unsigned char w, const mbedtls_mpi *m )\n{\n    size_t i, j;\n    unsigned char c, cc, adjust;\n\n    memset( x, 0, d+1 );\n\n    /* First get the classical comb values (except for x_d = 0) */\n    for( i = 0; i \u003c d; i++ )\n        for( j = 0; j \u003c w; j++ )\n            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) \u003c\u003c j;\n\n    /* Now make sure x_1 .. x_d are odd */\n    c = 0;\n    for( i = 1; i \u003c= d; i++ )\n    {\n        /* Add carry and update it */\n        cc   = x[i] \u0026 c;\n        x[i] = x[i] ^ c;\n        c = cc;\n\n        /* Adjust if needed, avoiding branches */\n        adjust = 1 - ( x[i] \u0026 0x01 );\n        c   |= x[i] \u0026 ( x[i-1] * adjust );\n        x[i] = x[i] ^ ( x[i-1] * adjust );\n        x[i-1] |= adjust \u003c\u003c 7;\n    }\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1577,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"438636":{"score":0.68955725,"function_name":"ecp_precompute_comb","code":"static int ecp_precompute_comb( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point T[], const mbedtls_ecp_point *P,\n                                unsigned char w, size_t d,\n                                mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    unsigned char i;\n    size_t j = 0;\n    const unsigned char T_size = 1U \u003c\u003c ( w - 1 );\n    mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1];\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_dbl )\n            goto dbl;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_norm_dbl )\n            goto norm_dbl;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_add )\n            goto add;\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_norm_add )\n            goto norm_add;\n    }\n#else\n    (void) rs_ctx;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_dbl;\n\n        /* initial state for the loop */\n        rs_ctx-\u003ersm-\u003ei = 0;\n    }\n\ndbl:\n#endif\n    /*\n     * Set T[0] = P and\n     * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)\n     */\n    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( \u0026T[0], P ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003ei != 0 )\n        j = rs_ctx-\u003ersm-\u003ei;\n    else\n#endif\n        j = 0;\n\n    for( ; j \u003c d * ( w - 1 ); j++ )\n    {\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_DBL );\n\n        i = 1U \u003c\u003c ( j / d );\n        cur = T + i;\n\n        if( j % d == 0 )\n            MBEDTLS_MPI_CHK( mbedtls_ecp_copy( cur, T + ( i \u003e\u003e 1 ) ) );\n\n        MBEDTLS_MPI_CHK( ecp_double_jac( grp, cur, cur ) );\n    }\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_norm_dbl;\n\nnorm_dbl:\n#endif\n    /*\n     * Normalize current elements in T. As T has holes,\n     * use an auxiliary array of pointers to elements in T.\n     */\n    j = 0;\n    for( i = 1; i \u003c T_size; i \u003c\u003c= 1 )\n        TT[j++] = T + i;\n\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV + 6 * j - 2 );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, j ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_add;\n\nadd:\n#endif\n    /*\n     * Compute the remaining ones using the minimal number of additions\n     * Be careful to update T[2^l] only after using it!\n     */\n    MBEDTLS_ECP_BUDGET( ( T_size - 1 ) * MBEDTLS_ECP_OPS_ADD );\n\n    for( i = 1; i \u003c T_size; i \u003c\u003c= 1 )\n    {\n        j = i;\n        while( j-- )\n            MBEDTLS_MPI_CHK( ecp_add_mixed( grp, \u0026T[i + j], \u0026T[j], \u0026T[i] ) );\n    }\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_pre_norm_add;\n\nnorm_add:\n#endif\n    /*\n     * Normalize final elements in T. Even though there are no holes now, we\n     * still need the auxiliary array for homogeneity with the previous\n     * call. Also, skip T[0] which is already normalised, being a copy of P.\n     */\n    for( j = 0; j + 1 \u003c T_size; j++ )\n        TT[j] = T + j + 1;\n\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV + 6 * j - 2 );\n\n    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, j ) );\n\ncleanup:\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n    {\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_pre_dbl )\n            rs_ctx-\u003ersm-\u003ei = j;\n    }\n#endif\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1641,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"439548":{"score":0.85818213,"function_name":"ecp_select_comb","code":"static int ecp_select_comb( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                            const mbedtls_ecp_point T[], unsigned char T_size,\n                            unsigned char i )\n{\n    int ret;\n    unsigned char ii, j;\n\n    /* Ignore the \"sign\" bit and scale down */\n    ii =  ( i \u0026 0x7Fu ) \u003e\u003e 1;\n\n    /* Read the whole table to thwart cache-based timing attacks */\n    for( j = 0; j \u003c T_size; j++ )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026R-\u003eX, \u0026T[j].X, j == ii ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026R-\u003eY, \u0026T[j].Y, j == ii ) );\n    }\n\n    /* Safely invert result if i is \"negative\" */\n    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, i \u003e\u003e 7 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1778,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"439799":{"score":0.7416588,"function_name":"ecp_mul_comb_core","code":"static int ecp_mul_comb_core( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                              const mbedtls_ecp_point T[], unsigned char T_size,\n                              const unsigned char x[], size_t d,\n                              int (*f_rng)(void *, unsigned char *, size_t),\n                              void *p_rng,\n                              mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    mbedtls_ecp_point Txi;\n    size_t i;\n\n    mbedtls_ecp_point_init( \u0026Txi );\n\n#if !defined(MBEDTLS_ECP_RESTARTABLE)\n    (void) rs_ctx;\n#endif\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        rs_ctx-\u003ersm-\u003estate != ecp_rsm_comb_core )\n    {\n        rs_ctx-\u003ersm-\u003ei = 0;\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_comb_core;\n    }\n\n    /* new 'if' instead of nested for the sake of the 'else' branch */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003ei != 0 )\n    {\n        /* restore current index (R already pointing to rs_ctx-\u003ersm-\u003eR) */\n        i = rs_ctx-\u003ersm-\u003ei;\n    }\n    else\n#endif\n    {\n        /* Start with a non-zero point and randomize its coordinates */\n        i = d;\n        MBEDTLS_MPI_CHK( ecp_select_comb( grp, R, T, T_size, x[i] ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eZ, 1 ) );\n        if( f_rng != 0 )\n            MBEDTLS_MPI_CHK( ecp_randomize_jac( grp, R, f_rng, p_rng ) );\n    }\n\n    while( i != 0 )\n    {\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_DBL + MBEDTLS_ECP_OPS_ADD );\n        --i;\n\n        MBEDTLS_MPI_CHK( ecp_double_jac( grp, R, R ) );\n        MBEDTLS_MPI_CHK( ecp_select_comb( grp, \u0026Txi, T, T_size, x[i] ) );\n        MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, R, \u0026Txi ) );\n    }\n\ncleanup:\n\n    mbedtls_ecp_point_free( \u0026Txi );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026\n        ret == MBEDTLS_ERR_ECP_IN_PROGRESS )\n    {\n        rs_ctx-\u003ersm-\u003ei = i;\n        /* no need to save R, already pointing to rs_ctx-\u003ersm-\u003eR */\n    }\n#endif\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1808,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"440207":{"score":0.8307191,"function_name":"ecp_comb_recode_scalar","code":"static int ecp_comb_recode_scalar( const mbedtls_ecp_group *grp,\n                                   const mbedtls_mpi *m,\n                                   unsigned char k[COMB_MAX_D + 1],\n                                   size_t d,\n                                   unsigned char w,\n                                   unsigned char *parity_trick )\n{\n    int ret;\n    mbedtls_mpi M, mm;\n\n    mbedtls_mpi_init( \u0026M );\n    mbedtls_mpi_init( \u0026mm );\n\n    /* N is always odd (see above), just make extra sure */\n    if( mbedtls_mpi_get_bit( \u0026grp-\u003eN, 0 ) != 1 )\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n\n    /* do we need the parity trick? */\n    *parity_trick = ( mbedtls_mpi_get_bit( m, 0 ) == 0 );\n\n    /* execute parity fix in constant time */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026M, m ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026mm, \u0026grp-\u003eN, m ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( \u0026M, \u0026mm, *parity_trick ) );\n\n    /* actual scalar recoding */\n    ecp_comb_recode_core( k, d, w, \u0026M );\n\ncleanup:\n    mbedtls_mpi_free( \u0026mm );\n    mbedtls_mpi_free( \u0026M );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1888,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"440547":{"score":0.77681434,"function_name":"ecp_mul_comb_after_precomp","code":"static int ecp_mul_comb_after_precomp( const mbedtls_ecp_group *grp,\n                                mbedtls_ecp_point *R,\n                                const mbedtls_mpi *m,\n                                const mbedtls_ecp_point *T,\n                                unsigned char T_size,\n                                unsigned char w,\n                                size_t d,\n                                int (*f_rng)(void *, unsigned char *, size_t),\n                                void *p_rng,\n                                mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    unsigned char parity_trick;\n    unsigned char k[COMB_MAX_D + 1];\n    mbedtls_ecp_point *RR = R;\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n    {\n        RR = \u0026rs_ctx-\u003ersm-\u003eR;\n\n        if( rs_ctx-\u003ersm-\u003estate == ecp_rsm_final_norm )\n            goto final_norm;\n    }\n#endif\n\n    MBEDTLS_MPI_CHK( ecp_comb_recode_scalar( grp, m, k, d, w,\n                                            \u0026parity_trick ) );\n    MBEDTLS_MPI_CHK( ecp_mul_comb_core( grp, RR, T, T_size, k, d,\n                                        f_rng, p_rng, rs_ctx ) );\n    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, RR, parity_trick ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        rs_ctx-\u003ersm-\u003estate = ecp_rsm_final_norm;\n\nfinal_norm:\n#endif\n    MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_INV );\n    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, RR ) );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, RR ) );\n#endif\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1930,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"440940":{"score":0.95783144,"function_name":"ecp_pick_window_size","code":"static unsigned char ecp_pick_window_size( const mbedtls_ecp_group *grp,\n                                           unsigned char p_eq_g )\n{\n    unsigned char w;\n\n    /*\n     * Minimize the number of multiplications, that is minimize\n     * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )\n     * (see costs of the various parts, with 1S = 1M)\n     */\n    w = grp-\u003enbits \u003e= 384 ? 5 : 4;\n\n    /*\n     * If P == G, pre-compute a bit more, since this may be re-used later.\n     * Just adding one avoids upping the cost of the first mul too much,\n     * and the memory cost too.\n     */\n    if( p_eq_g )\n        w++;\n\n    /*\n     * Make sure w is within bounds.\n     * (The last test is useful only for very small curves in the test suite.)\n     */\n    if( w \u003e MBEDTLS_ECP_WINDOW_SIZE )\n        w = MBEDTLS_ECP_WINDOW_SIZE;\n    if( w \u003e= grp-\u003enbits )\n        w = 2;\n\n    return( w );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":1983,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"441040":{"score":0.7641247,"function_name":"ecp_mul_comb","code":"static int ecp_mul_comb( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                         const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n                         int (*f_rng)(void *, unsigned char *, size_t),\n                         void *p_rng,\n                         mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n    unsigned char w, p_eq_g, i;\n    size_t d;\n    unsigned char T_size, T_ok;\n    mbedtls_ecp_point *T;\n\n    ECP_RS_ENTER( rsm );\n\n    /* Is P the base point ? */\n#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1\n    p_eq_g = ( mbedtls_mpi_cmp_mpi( \u0026P-\u003eY, \u0026grp-\u003eG.Y ) == 0 \u0026\u0026\n               mbedtls_mpi_cmp_mpi( \u0026P-\u003eX, \u0026grp-\u003eG.X ) == 0 );\n#else\n    p_eq_g = 0;\n#endif\n\n    /* Pick window size and deduce related sizes */\n    w = ecp_pick_window_size( grp, p_eq_g );\n    T_size = 1U \u003c\u003c ( w - 1 );\n    d = ( grp-\u003enbits + w - 1 ) / w;\n\n    /* Pre-computed table: do we have it already for the base point? */\n    if( p_eq_g \u0026\u0026 grp-\u003eT != NULL )\n    {\n        /* second pointer to the same table, will be deleted on exit */\n        T = grp-\u003eT;\n        T_ok = 1;\n    }\n    else\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* Pre-computed table: do we have one in progress? complete? */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 rs_ctx-\u003ersm-\u003eT != NULL )\n    {\n        /* transfer ownership of T from rsm to local function */\n        T = rs_ctx-\u003ersm-\u003eT;\n        rs_ctx-\u003ersm-\u003eT = NULL;\n        rs_ctx-\u003ersm-\u003eT_size = 0;\n\n        /* This effectively jumps to the call to mul_comb_after_precomp() */\n        T_ok = rs_ctx-\u003ersm-\u003estate \u003e= ecp_rsm_comb_core;\n    }\n    else\n#endif\n    /* Allocate table if we didn't have any */\n    {\n        T = mbedtls_calloc( T_size, sizeof( mbedtls_ecp_point ) );\n        if( T == NULL )\n        {\n            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;\n            goto cleanup;\n        }\n\n        for( i = 0; i \u003c T_size; i++ )\n            mbedtls_ecp_point_init( \u0026T[i] );\n\n        T_ok = 0;\n    }\n\n    /* Compute table (or finish computing it) if not done already */\n    if( !T_ok )\n    {\n        MBEDTLS_MPI_CHK( ecp_precompute_comb( grp, T, P, w, d, rs_ctx ) );\n\n        if( p_eq_g )\n        {\n            /* almost transfer ownership of T to the group, but keep a copy of\n             * the pointer to use for calling the next function more easily */\n            grp-\u003eT = T;\n            grp-\u003eT_size = T_size;\n        }\n    }\n\n    /* Actual comb multiplication using precomputed points */\n    MBEDTLS_MPI_CHK( ecp_mul_comb_after_precomp( grp, R, m,\n                                                 T, T_size, w, d,\n                                                 f_rng, p_rng, rs_ctx ) );\n\ncleanup:\n\n    /* does T belong to the group? */\n    if( T == grp-\u003eT )\n        T = NULL;\n\n    /* does T belong to the restart context? */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003ersm != NULL \u0026\u0026 ret == MBEDTLS_ERR_ECP_IN_PROGRESS \u0026\u0026 T != NULL )\n    {\n        /* transfer ownership of T from local function to rsm */\n        rs_ctx-\u003ersm-\u003eT_size = T_size;\n        rs_ctx-\u003ersm-\u003eT = T;\n        T = NULL;\n    }\n#endif\n\n    /* did T belong to us? then let's destroy it! */\n    if( T != NULL )\n    {\n        for( i = 0; i \u003c T_size; i++ )\n            mbedtls_ecp_point_free( \u0026T[i] );\n        mbedtls_free( T );\n    }\n\n    /* don't free R while in progress in case R == P */\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( ret != MBEDTLS_ERR_ECP_IN_PROGRESS )\n#endif\n    /* prevent caller from using invalid value */\n    if( ret != 0 )\n        mbedtls_ecp_point_free( R );\n\n    ECP_RS_LEAVE( rsm );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2028,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"441582":{"score":0.732604,"function_name":"ecp_normalize_mxz","code":"static int ecp_normalize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P )\n{\n    int ret;\n\n#if defined(MBEDTLS_ECP_NORMALIZE_MXZ_ALT)\n    if( mbedtls_internal_ecp_grp_capable( grp ) )\n        return( mbedtls_internal_ecp_normalize_mxz( grp, P ) );\n#endif /* MBEDTLS_ECP_NORMALIZE_MXZ_ALT */\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( \u0026P-\u003eZ, \u0026P-\u003eZ, \u0026grp-\u003eP ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026P-\u003eX, \u0026P-\u003eX, \u0026P-\u003eZ ) ); MOD_MUL( P-\u003eX );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026P-\u003eZ, 1 ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2164,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"444367":{"score":0.68732226,"function_name":"ecp_mul_mxz","code":"static int ecp_mul_mxz( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n                        const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n                        int (*f_rng)(void *, unsigned char *, size_t),\n                        void *p_rng )\n{\n    int ret;\n    size_t i;\n    unsigned char b;\n    mbedtls_ecp_point RP;\n    mbedtls_mpi PX;\n\n    mbedtls_ecp_point_init( \u0026RP ); mbedtls_mpi_init( \u0026PX );\n\n    /* Save PX and read from P before writing to R, in case P == R */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( \u0026PX, \u0026P-\u003eX ) );\n    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( \u0026RP, P ) );\n\n    /* Set R to zero in modified x/z coordinates */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eX, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( \u0026R-\u003eZ, 0 ) );\n    mbedtls_mpi_free( \u0026R-\u003eY );\n\n    /* RP.X might be sligtly larger than P, so reduce it */\n    MOD_ADD( RP.X );\n\n    /* Randomize coordinates of the starting point */\n    if( f_rng != NULL )\n        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, \u0026RP, f_rng, p_rng ) );\n\n    /* Loop invariant: R = result so far, RP = R + P */\n    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */\n    while( i-- \u003e 0 )\n    {\n        b = mbedtls_mpi_get_bit( m, i );\n        /*\n         *  if (b) R = 2R + P else R = 2R,\n         * which is:\n         *  if (b) double_add( RP, R, RP, R )\n         *  else   double_add( R, RP, R, RP )\n         * but using safe conditional swaps to avoid leaks\n         */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eX, \u0026RP.X, b ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eZ, \u0026RP.Z, b ) );\n        MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, \u0026RP, R, \u0026RP, \u0026PX ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eX, \u0026RP.X, b ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( \u0026R-\u003eZ, \u0026RP.Z, b ) );\n    }\n\n    MBEDTLS_MPI_CHK( ecp_normalize_mxz( grp, R ) );\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026RP ); mbedtls_mpi_free( \u0026PX );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2290,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"445081":{"score":0.73803747,"function_name":"mbedtls_ecp_mul_restartable","code":"int mbedtls_ecp_mul_restartable( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,\n             const mbedtls_mpi *m, const mbedtls_ecp_point *P,\n             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,\n             mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    char is_grp_capable = 0;\n#endif\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( R   != NULL );\n    ECP_VALIDATE_RET( m   != NULL );\n    ECP_VALIDATE_RET( P   != NULL );\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* reset ops count for this call if top-level */\n    if( rs_ctx != NULL \u0026\u0026 rs_ctx-\u003edepth++ == 0 )\n        rs_ctx-\u003eops_done = 0;\n#endif\n\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    if( ( is_grp_capable = mbedtls_internal_ecp_grp_capable( grp ) ) )\n        MBEDTLS_MPI_CHK( mbedtls_internal_ecp_init( grp ) );\n#endif /* MBEDTLS_ECP_INTERNAL_ALT */\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    /* skip argument check when restarting */\n    if( rs_ctx == NULL || rs_ctx-\u003ersm == NULL )\n#endif\n    {\n        /* check_privkey is free */\n        MBEDTLS_ECP_BUDGET( MBEDTLS_ECP_OPS_CHK );\n\n        /* Common sanity checks */\n        MBEDTLS_MPI_CHK( mbedtls_ecp_check_privkey( grp, m ) );\n        MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, P ) );\n    }\n\n    ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n#if defined(ECP_MONTGOMERY)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n        MBEDTLS_MPI_CHK( ecp_mul_mxz( grp, R, m, P, f_rng, p_rng ) );\n#endif\n#if defined(ECP_SHORTWEIERSTRASS)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n        MBEDTLS_MPI_CHK( ecp_mul_comb( grp, R, m, P, f_rng, p_rng, rs_ctx ) );\n#endif\n\ncleanup:\n\n#if defined(MBEDTLS_ECP_INTERNAL_ALT)\n    if( is_grp_capable )\n        mbedtls_internal_ecp_free( grp );\n#endif /* MBEDTLS_ECP_INTERNAL_ALT */\n\n#if defined(MBEDTLS_ECP_RESTARTABLE)\n    if( rs_ctx != NULL )\n        rs_ctx-\u003edepth--;\n#endif\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2351,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"445348":{"score":0.82337236,"function_name":"ecp_check_pubkey_sw","code":"static int ecp_check_pubkey_sw( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )\n{\n    int ret;\n    mbedtls_mpi YY, RHS;\n\n    /* pt coordinates must be normalized for our checks */\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eX, 0 ) \u003c 0 ||\n        mbedtls_mpi_cmp_int( \u0026pt-\u003eY, 0 ) \u003c 0 ||\n        mbedtls_mpi_cmp_mpi( \u0026pt-\u003eX, \u0026grp-\u003eP ) \u003e= 0 ||\n        mbedtls_mpi_cmp_mpi( \u0026pt-\u003eY, \u0026grp-\u003eP ) \u003e= 0 )\n        return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n    mbedtls_mpi_init( \u0026YY ); mbedtls_mpi_init( \u0026RHS );\n\n    /*\n     * YY = Y^2\n     * RHS = X (X^2 + A) + B = X^3 + A X + B\n     */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026YY,  \u0026pt-\u003eY,   \u0026pt-\u003eY  ) );  MOD_MUL( YY  );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026RHS, \u0026pt-\u003eX,   \u0026pt-\u003eX  ) );  MOD_MUL( RHS );\n\n    /* Special case for A = -3 */\n    if( grp-\u003eA.p == NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026RHS, \u0026RHS, 3       ) );  MOD_SUB( RHS );\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026RHS, \u0026RHS, \u0026grp-\u003eA ) );  MOD_ADD( RHS );\n    }\n\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026RHS, \u0026RHS,     \u0026pt-\u003eX  ) );  MOD_MUL( RHS );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( \u0026RHS, \u0026RHS,     \u0026grp-\u003eB ) );  MOD_ADD( RHS );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026YY, \u0026RHS ) != 0 )\n        ret = MBEDTLS_ERR_ECP_INVALID_KEY;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026YY ); mbedtls_mpi_free( \u0026RHS );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2433,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"446183":{"score":0.81254697,"function_name":"mbedtls_ecp_mul_shortcuts","code":"static int mbedtls_ecp_mul_shortcuts( mbedtls_ecp_group *grp,\n                                      mbedtls_ecp_point *R,\n                                      const mbedtls_mpi *m,\n                                      const mbedtls_ecp_point *P,\n                                      mbedtls_ecp_restart_ctx *rs_ctx )\n{\n    int ret;\n\n    if( mbedtls_mpi_cmp_int( m, 1 ) == 0 )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );\n    }\n    else if( mbedtls_mpi_cmp_int( m, -1 ) == 0 )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );\n        if( mbedtls_mpi_cmp_int( \u0026R-\u003eY, 0 ) != 0 )\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026R-\u003eY, \u0026grp-\u003eP, \u0026R-\u003eY ) );\n    }\n    else\n    {\n        MBEDTLS_MPI_CHK( mbedtls_ecp_mul_restartable( grp, R, m, P,\n                                                      NULL, NULL, rs_ctx ) );\n    }\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2482,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"446818":{"score":0.8137383,"function_name":"mbedtls_ecp_check_pubkey","code":"int mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp,\n                              const mbedtls_ecp_point *pt )\n{\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( pt  != NULL );\n\n    /* Must use affine coordinates */\n    if( mbedtls_mpi_cmp_int( \u0026pt-\u003eZ, 1 ) != 0 )\n        return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n#if defined(ECP_MONTGOMERY)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n        return( ecp_check_pubkey_mx( grp, pt ) );\n#endif\n#if defined(ECP_SHORTWEIERSTRASS)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n        return( ecp_check_pubkey_sw( grp, pt ) );\n#endif\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2643,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"446954":{"score":0.84902,"function_name":"mbedtls_ecp_check_privkey","code":"int mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp,\n                               const mbedtls_mpi *d )\n{\n    ECP_VALIDATE_RET( grp != NULL );\n    ECP_VALIDATE_RET( d   != NULL );\n\n#if defined(ECP_MONTGOMERY)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        /* see RFC 7748 sec. 5 para. 5 */\n        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||\n            mbedtls_mpi_get_bit( d, 1 ) != 0 ||\n            mbedtls_mpi_bitlen( d ) - 1 != grp-\u003enbits ) /* mbedtls_mpi_bitlen is one-based! */\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n        /* see [Curve25519] page 5 */\n        if( grp-\u003enbits == 254 \u0026\u0026 mbedtls_mpi_get_bit( d, 2 ) != 0 )\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n\n        return( 0 );\n    }\n#endif /* ECP_MONTGOMERY */\n#if defined(ECP_SHORTWEIERSTRASS)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /* see SEC1 3.2 */\n        if( mbedtls_mpi_cmp_int( d, 1 ) \u003c 0 ||\n            mbedtls_mpi_cmp_mpi( d, \u0026grp-\u003eN ) \u003e= 0 )\n            return( MBEDTLS_ERR_ECP_INVALID_KEY );\n        else\n            return( 0 );\n    }\n#endif /* ECP_SHORTWEIERSTRASS */\n\n    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2667,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"447200":{"score":0.8482746,"function_name":"mbedtls_ecp_gen_privkey","code":"int mbedtls_ecp_gen_privkey( const mbedtls_ecp_group *grp,\n                     mbedtls_mpi *d,\n                     int (*f_rng)(void *, unsigned char *, size_t),\n                     void *p_rng )\n{\n    int ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n    size_t n_size;\n\n    ECP_VALIDATE_RET( grp   != NULL );\n    ECP_VALIDATE_RET( d     != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    n_size = ( grp-\u003enbits + 7 ) / 8;\n\n#if defined(ECP_MONTGOMERY)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_MONTGOMERY )\n    {\n        /* [M225] page 5 */\n        size_t b;\n\n        do {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );\n        } while( mbedtls_mpi_bitlen( d ) == 0);\n\n        /* Make sure the most significant bit is nbits */\n        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */\n        if( b \u003e grp-\u003enbits )\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, b - grp-\u003enbits ) );\n        else\n            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp-\u003enbits, 1 ) );\n\n        /* Make sure the last two bits are unset for Curve448, three bits for\n           Curve25519 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 0, 0 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 1, 0 ) );\n        if( grp-\u003enbits == 254 )\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 2, 0 ) );\n        }\n    }\n#endif /* ECP_MONTGOMERY */\n\n#if defined(ECP_SHORTWEIERSTRASS)\n    if( mbedtls_ecp_get_type( grp ) == MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS )\n    {\n        /* SEC1 3.2.1: Generate d such that 1 \u003c= n \u003c N */\n        int count = 0;\n\n        /*\n         * Match the procedure given in RFC 6979 (deterministic ECDSA):\n         * - use the same byte ordering;\n         * - keep the leftmost nbits bits of the generated octet string;\n         * - try until result is in the desired range.\n         * This also avoids any biais, which is especially important for ECDSA.\n         */\n        do\n        {\n            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp-\u003enbits ) );\n\n            /*\n             * Each try has at worst a probability 1/2 of failing (the msb has\n             * a probability 1/2 of being 0, and then the result will be \u003c N),\n             * so after 30 tries failure probability is a most 2**(-30).\n             *\n             * For most curves, 1 try is enough with overwhelming probability,\n             * since N starts with a lot of 1s in binary, but some curves\n             * such as secp224k1 are actually very close to the worst case.\n             */\n            if( ++count \u003e 30 )\n                return( MBEDTLS_ERR_ECP_RANDOM_FAILED );\n        }\n        while( mbedtls_mpi_cmp_int( d, 1 ) \u003c 0 ||\n               mbedtls_mpi_cmp_mpi( d, \u0026grp-\u003eN ) \u003e= 0 );\n    }\n#endif /* ECP_SHORTWEIERSTRASS */\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2707,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"447731":{"score":0.8032483,"function_name":"mbedtls_ecp_gen_keypair_base","code":"int mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,\n                     const mbedtls_ecp_point *G,\n                     mbedtls_mpi *d, mbedtls_ecp_point *Q,\n                     int (*f_rng)(void *, unsigned char *, size_t),\n                     void *p_rng )\n{\n    int ret;\n    ECP_VALIDATE_RET( grp   != NULL );\n    ECP_VALIDATE_RET( d     != NULL );\n    ECP_VALIDATE_RET( G     != NULL );\n    ECP_VALIDATE_RET( Q     != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    MBEDTLS_MPI_CHK( mbedtls_ecp_gen_privkey( grp, d, f_rng, p_rng ) );\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );\n\ncleanup:\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2791,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"447871":{"score":0.75649714,"function_name":"mbedtls_ecp_gen_key","code":"int mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret;\n    ECP_VALIDATE_RET( key   != NULL );\n    ECP_VALIDATE_RET( f_rng != NULL );\n\n    if( ( ret = mbedtls_ecp_group_load( \u0026key-\u003egrp, grp_id ) ) != 0 )\n        return( ret );\n\n    return( mbedtls_ecp_gen_keypair( \u0026key-\u003egrp, \u0026key-\u003ed, \u0026key-\u003eQ, f_rng, p_rng ) );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2830,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"447965":{"score":0.8486922,"function_name":"mbedtls_ecp_check_pub_priv","code":"int mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )\n{\n    int ret;\n    mbedtls_ecp_point Q;\n    mbedtls_ecp_group grp;\n    ECP_VALIDATE_RET( pub != NULL );\n    ECP_VALIDATE_RET( prv != NULL );\n\n    if( pub-\u003egrp.id == MBEDTLS_ECP_DP_NONE ||\n        pub-\u003egrp.id != prv-\u003egrp.id ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.X, \u0026prv-\u003eQ.X ) ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.Y, \u0026prv-\u003eQ.Y ) ||\n        mbedtls_mpi_cmp_mpi( \u0026pub-\u003eQ.Z, \u0026prv-\u003eQ.Z ) )\n    {\n        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );\n    }\n\n    mbedtls_ecp_point_init( \u0026Q );\n    mbedtls_ecp_group_init( \u0026grp );\n\n    /* mbedtls_ecp_mul() needs a non-const group... */\n    mbedtls_ecp_group_copy( \u0026grp, \u0026prv-\u003egrp );\n\n    /* Also checks d is valid */\n    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( \u0026grp, \u0026Q, \u0026prv-\u003ed, \u0026prv-\u003egrp.G, NULL, NULL ) );\n\n    if( mbedtls_mpi_cmp_mpi( \u0026Q.X, \u0026prv-\u003eQ.X ) ||\n        mbedtls_mpi_cmp_mpi( \u0026Q.Y, \u0026prv-\u003eQ.Y ) ||\n        mbedtls_mpi_cmp_mpi( \u0026Q.Z, \u0026prv-\u003eQ.Z ) )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\ncleanup:\n    mbedtls_ecp_point_free( \u0026Q );\n    mbedtls_ecp_group_free( \u0026grp );\n\n    return( ret );\n}","filepath":"features/mbedtls/mbed-crypto/src/ecp.c","line_number":2915,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-5.13.0-rc1"},"448590":{"score":0.93845713,"function_name":"ecp_group_load","code":"static int ecp_group_load( ecp_group *grp,\n                           const t_uint *p,  size_t plen,\n                           const t_uint *a,  size_t alen,\n                           const t_uint *b,  size_t blen,\n                           const t_uint *gx, size_t gxlen,\n                           const t_uint *gy, size_t gylen,\n                           const t_uint *n,  size_t nlen)\n{\n    ecp_mpi_load( \u0026grp-\u003eP, p, plen );\n    if( a != NULL )\n        ecp_mpi_load( \u0026grp-\u003eA, a, alen );\n    ecp_mpi_load( \u0026grp-\u003eB, b, blen );\n    ecp_mpi_load( \u0026grp-\u003eN, n, nlen );\n\n    ecp_mpi_load( \u0026grp-\u003eG.X, gx, gxlen );\n    ecp_mpi_load( \u0026grp-\u003eG.Y, gy, gylen );\n    ecp_mpi_set1( \u0026grp-\u003eG.Z );\n\n    grp-\u003epbits = mpi_msb( \u0026grp-\u003eP );\n    grp-\u003enbits = mpi_msb( \u0026grp-\u003eN );\n\n    grp-\u003eh = 1;\n\n    return( 0 );\n}","filepath":"library/ecp_curves.c","line_number":607,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.8"},"448827":{"score":0.8128561,"function_name":"ecp_use_curve25519","code":"static int ecp_use_curve25519( ecp_group *grp )\n{\n    int ret;\n\n    /* Actually ( A + 2 ) / 4 */\n    MPI_CHK( mpi_read_string( \u0026grp-\u003eA, 16, \"01DB42\" ) );\n\n    /* P = 2^255 - 19 */\n    MPI_CHK( mpi_lset( \u0026grp-\u003eP, 1 ) );\n    MPI_CHK( mpi_shift_l( \u0026grp-\u003eP, 255 ) );\n    MPI_CHK( mpi_sub_int( \u0026grp-\u003eP, \u0026grp-\u003eP, 19 ) );\n    grp-\u003epbits = mpi_msb( \u0026grp-\u003eP );\n\n    /* Y intentionaly not set, since we use x/z coordinates.\n     * This is used as a marker to identify Montgomery curves! */\n    MPI_CHK( mpi_lset( \u0026grp-\u003eG.X, 9 ) );\n    MPI_CHK( mpi_lset( \u0026grp-\u003eG.Z, 1 ) );\n    mpi_free( \u0026grp-\u003eG.Y );\n\n    /* Actually, the required msb for private keys */\n    grp-\u003enbits = 254;\n\ncleanup:\n    if( ret != 0 )\n        ecp_group_free( grp );\n\n    return( ret );\n}","filepath":"library/ecp_curves.c","line_number":690,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.8"},"449232":{"score":0.67650485,"function_name":"ecp_use_known_dp","code":"int ecp_use_known_dp( ecp_group *grp, ecp_group_id id )\n{\n    ecp_group_free( grp );\n\n    grp-\u003eid = id;\n\n    switch( id )\n    {\n#if defined(POLARSSL_ECP_DP_SECP192R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP192R1:\n            NIST_MODP( p192 );\n            return( LOAD_GROUP( secp192r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP192R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP224R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP224R1:\n            NIST_MODP( p224 );\n            return( LOAD_GROUP( secp224r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP224R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP256R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP256R1:\n            NIST_MODP( p256 );\n            return( LOAD_GROUP( secp256r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP256R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP384R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP384R1:\n            NIST_MODP( p384 );\n            return( LOAD_GROUP( secp384r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP384R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP521R1_ENABLED)\n        case POLARSSL_ECP_DP_SECP521R1:\n            NIST_MODP( p521 );\n            return( LOAD_GROUP( secp521r1 ) );\n#endif /* POLARSSL_ECP_DP_SECP521R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP192K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP192K1:\n            grp-\u003emodp = ecp_mod_p192k1;\n            return( LOAD_GROUP_A( secp192k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP192K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP224K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP224K1:\n            grp-\u003emodp = ecp_mod_p224k1;\n            return( LOAD_GROUP_A( secp224k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP224K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_SECP256K1_ENABLED)\n        case POLARSSL_ECP_DP_SECP256K1:\n            grp-\u003emodp = ecp_mod_p256k1;\n            return( LOAD_GROUP_A( secp256k1 ) );\n#endif /* POLARSSL_ECP_DP_SECP256K1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP256R1_ENABLED)\n        case POLARSSL_ECP_DP_BP256R1:\n            return( LOAD_GROUP_A( brainpoolP256r1 ) );\n#endif /* POLARSSL_ECP_DP_BP256R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP384R1_ENABLED)\n        case POLARSSL_ECP_DP_BP384R1:\n            return( LOAD_GROUP_A( brainpoolP384r1 ) );\n#endif /* POLARSSL_ECP_DP_BP384R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_BP512R1_ENABLED)\n        case POLARSSL_ECP_DP_BP512R1:\n            return( LOAD_GROUP_A( brainpoolP512r1 ) );\n#endif /* POLARSSL_ECP_DP_BP512R1_ENABLED */\n\n#if defined(POLARSSL_ECP_DP_M255_ENABLED)\n        case POLARSSL_ECP_DP_M255:\n            grp-\u003emodp = ecp_mod_p255;\n            return( ecp_use_curve25519( grp ) );\n#endif /* POLARSSL_ECP_DP_M255_ENABLED */\n\n        default:\n            ecp_group_free( grp );\n            return( POLARSSL_ERR_ECP_FEATURE_UNAVAILABLE );\n    }\n}","filepath":"library/ecp_curves.c","line_number":723,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.8"},"449404":{"score":0.8665344,"function_name":"ecp_mod_p255","code":"static int ecp_mod_p255( mpi *N )\n{\n    int ret;\n    size_t i;\n    mpi M;\n    t_uint Mp[P255_WIDTH + 2];\n\n    if( N-\u003en \u003c P255_WIDTH )\n        return( 0 );\n\n    /* M = A1 */\n    M.s = 1;\n    M.n = N-\u003en - ( P255_WIDTH - 1 );\n    if( M.n \u003e P255_WIDTH + 1 )\n        M.n = P255_WIDTH + 1;\n    M.p = Mp;\n    memset( Mp, 0, sizeof Mp );\n    memcpy( Mp, N-\u003ep + P255_WIDTH - 1, M.n * sizeof( t_uint ) );\n    MPI_CHK( mpi_shift_r( \u0026M, 255 % ( 8 * sizeof( t_uint ) ) ) );\n    M.n++; /* Make room for multiplication by 19 */\n\n    /* N = A0 */\n    MPI_CHK( mpi_set_bit( N, 255, 0 ) );\n    for( i = P255_WIDTH; i \u003c N-\u003en; i++ )\n        N-\u003ep[i] = 0;\n\n    /* N = A0 + 19 * A1 */\n    MPI_CHK( mpi_mul_int( \u0026M, \u0026M, 19 ) );\n    MPI_CHK( mpi_add_abs( N, N, \u0026M ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/ecp_curves.c","line_number":1218,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"polarssl-1.3.8"},"449784":{"score":0.8217473,"function_name":"mbedtls_md_info_from_string","code":"const mbedtls_md_info_t *mbedtls_md_info_from_string( const char *md_name )\n{\n    if( NULL == md_name )\n        return( NULL );\n\n    /* Get the appropriate digest information */\n#if defined(MBEDTLS_MD2_C)\n    if( !strcmp( \"MD2\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD2 );\n#endif\n#if defined(MBEDTLS_MD4_C)\n    if( !strcmp( \"MD4\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD4 );\n#endif\n#if defined(MBEDTLS_MD5_C)\n    if( !strcmp( \"MD5\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_MD5 );\n#endif\n#if defined(MBEDTLS_RIPEMD160_C)\n    if( !strcmp( \"RIPEMD160\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_RIPEMD160 );\n#endif\n#if defined(MBEDTLS_SHA1_C)\n    if( !strcmp( \"SHA1\", md_name ) || !strcmp( \"SHA\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA1 );\n#endif\n#if defined(MBEDTLS_SHA256_C)\n    if( !strcmp( \"SHA224\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA224 );\n    if( !strcmp( \"SHA256\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA256 );\n#endif\n#if defined(MBEDTLS_SHA512_C)\n    if( !strcmp( \"SHA384\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA384 );\n    if( !strcmp( \"SHA512\", md_name ) )\n        return mbedtls_md_info_from_type( MBEDTLS_MD_SHA512 );\n#endif\n    return( NULL );\n}","filepath":"library/md.c","line_number":95,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"450184":{"score":0.82199734,"function_name":"mbedtls_md_free","code":"void mbedtls_md_free( mbedtls_md_context_t *ctx )\n{\n    if( ctx == NULL || ctx-\u003emd_info == NULL )\n        return;\n\n    if( ctx-\u003emd_ctx != NULL )\n        ctx-\u003emd_info-\u003ectx_free_func( ctx-\u003emd_ctx );\n\n    if( ctx-\u003ehmac_ctx != NULL )\n    {\n        mbedtls_platform_zeroize( ctx-\u003ehmac_ctx,\n                                  2 * ctx-\u003emd_info-\u003eblock_size );\n        mbedtls_free( ctx-\u003ehmac_ctx );\n    }\n\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );\n}","filepath":"library/md.c","line_number":182,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"450333":{"score":0.9069716,"function_name":"mbedtls_md_clone","code":"int mbedtls_md_clone( mbedtls_md_context_t *dst,\n                      const mbedtls_md_context_t *src )\n{\n    if( dst == NULL || dst-\u003emd_info == NULL ||\n        src == NULL || src-\u003emd_info == NULL ||\n        dst-\u003emd_info != src-\u003emd_info )\n    {\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n    }\n\n    dst-\u003emd_info-\u003eclone_func( dst-\u003emd_ctx, src-\u003emd_ctx );\n\n    return( 0 );\n}","filepath":"library/md.c","line_number":200,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"450474":{"score":0.89676,"function_name":"mbedtls_md_setup","code":"int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )\n{\n    if( md_info == NULL || ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003emd_ctx = md_info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_MD_ALLOC_FAILED );\n\n    if( hmac != 0 )\n    {\n        ctx-\u003ehmac_ctx = mbedtls_calloc( 2, md_info-\u003eblock_size );\n        if( ctx-\u003ehmac_ctx == NULL )\n        {\n            md_info-\u003ectx_free_func( ctx-\u003emd_ctx );\n            return( MBEDTLS_ERR_MD_ALLOC_FAILED );\n        }\n    }\n\n    ctx-\u003emd_info = md_info;\n\n    return( 0 );\n}","filepath":"library/md.c","line_number":222,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"450886":{"score":0.8471345,"function_name":"mbedtls_md_hmac_starts","code":"int mbedtls_md_hmac_starts( mbedtls_md_context_t *ctx, const unsigned char *key, size_t keylen )\n{\n    int ret;\n    unsigned char sum[MBEDTLS_MD_MAX_SIZE];\n    unsigned char *ipad, *opad;\n    size_t i;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    if( keylen \u003e (size_t) ctx-\u003emd_info-\u003eblock_size )\n    {\n        if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n            goto cleanup;\n        if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, key, keylen ) ) != 0 )\n            goto cleanup;\n        if( ( ret = ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, sum ) ) != 0 )\n            goto cleanup;\n\n        keylen = ctx-\u003emd_info-\u003esize;\n        key = sum;\n    }\n\n    ipad = (unsigned char *) ctx-\u003ehmac_ctx;\n    opad = (unsigned char *) ctx-\u003ehmac_ctx + ctx-\u003emd_info-\u003eblock_size;\n\n    memset( ipad, 0x36, ctx-\u003emd_info-\u003eblock_size );\n    memset( opad, 0x5C, ctx-\u003emd_info-\u003eblock_size );\n\n    for( i = 0; i \u003c keylen; i++ )\n    {\n        ipad[i] = (unsigned char)( ipad[i] ^ key[i] );\n        opad[i] = (unsigned char)( opad[i] ^ key[i] );\n    }\n\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        goto cleanup;\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, ipad,\n                                           ctx-\u003emd_info-\u003eblock_size ) ) != 0 )\n        goto cleanup;\n\ncleanup:\n    mbedtls_platform_zeroize( sum, sizeof( sum ) );\n\n    return( ret );\n}","filepath":"library/md.c","line_number":319,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"451504":{"score":0.83015454,"function_name":"mbedtls_md_hmac_finish","code":"int mbedtls_md_hmac_finish( mbedtls_md_context_t *ctx, unsigned char *output )\n{\n    int ret;\n    unsigned char tmp[MBEDTLS_MD_MAX_SIZE];\n    unsigned char *opad;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    opad = (unsigned char *) ctx-\u003ehmac_ctx + ctx-\u003emd_info-\u003eblock_size;\n\n    if( ( ret = ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, tmp ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, opad,\n                                           ctx-\u003emd_info-\u003eblock_size ) ) != 0 )\n        return( ret );\n    if( ( ret = ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, tmp,\n                                           ctx-\u003emd_info-\u003esize ) ) != 0 )\n        return( ret );\n    return( ctx-\u003emd_info-\u003efinish_func( ctx-\u003emd_ctx, output ) );\n}","filepath":"library/md.c","line_number":374,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"451829":{"score":0.90826344,"function_name":"mbedtls_md_hmac_reset","code":"int mbedtls_md_hmac_reset( mbedtls_md_context_t *ctx )\n{\n    int ret;\n    unsigned char *ipad;\n\n    if( ctx == NULL || ctx-\u003emd_info == NULL || ctx-\u003ehmac_ctx == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    ipad = (unsigned char *) ctx-\u003ehmac_ctx;\n\n    if( ( ret = ctx-\u003emd_info-\u003estarts_func( ctx-\u003emd_ctx ) ) != 0 )\n        return( ret );\n    return( ctx-\u003emd_info-\u003eupdate_func( ctx-\u003emd_ctx, ipad,\n                                       ctx-\u003emd_info-\u003eblock_size ) );\n}","filepath":"library/md.c","line_number":398,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"451962":{"score":0.85053384,"function_name":"mbedtls_md_hmac","code":"int mbedtls_md_hmac( const mbedtls_md_info_t *md_info,\n                     const unsigned char *key, size_t keylen,\n                     const unsigned char *input, size_t ilen,\n                     unsigned char *output )\n{\n    mbedtls_md_context_t ctx;\n    int ret;\n\n    if( md_info == NULL )\n        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );\n\n    mbedtls_md_init( \u0026ctx );\n\n    if( ( ret = mbedtls_md_setup( \u0026ctx, md_info, 1 ) ) != 0 )\n        goto cleanup;\n\n    if( ( ret = mbedtls_md_hmac_starts( \u0026ctx, key, keylen ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_md_hmac_update( \u0026ctx, input, ilen ) ) != 0 )\n        goto cleanup;\n    if( ( ret = mbedtls_md_hmac_finish( \u0026ctx, output ) ) != 0 )\n        goto cleanup;\n\ncleanup:\n    mbedtls_md_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"library/md.c","line_number":414,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.10.0"},"457628":{"score":0.87201786,"function_name":"mbedtls_pk_free","code":"void mbedtls_pk_free( mbedtls_pk_context *ctx )\n{\n    if( ctx == NULL )\n        return;\n\n    if ( ctx-\u003epk_info != NULL )\n        ctx-\u003epk_info-\u003ectx_free_func( ctx-\u003epk_ctx );\n\n    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_pk_context ) );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":72,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"457708":{"score":0.77443576,"function_name":"mbedtls_pk_info_from_type","code":"const mbedtls_pk_info_t * mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type )\n{\n    switch( pk_type ) {\n#if defined(MBEDTLS_RSA_C)\n        case MBEDTLS_PK_RSA:\n            return( \u0026mbedtls_rsa_info );\n#endif\n#if defined(MBEDTLS_ECP_C)\n        case MBEDTLS_PK_ECKEY:\n            return( \u0026mbedtls_eckey_info );\n        case MBEDTLS_PK_ECKEY_DH:\n            return( \u0026mbedtls_eckeydh_info );\n#endif\n#if defined(MBEDTLS_ECDSA_C)\n        case MBEDTLS_PK_ECDSA:\n            return( \u0026mbedtls_ecdsa_info );\n#endif\n        /* MBEDTLS_PK_RSA_ALT omitted on purpose */\n        default:\n            return( NULL );\n    }\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":115,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"457770":{"score":0.8999712,"function_name":"mbedtls_pk_setup","code":"int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    if( info == NULL || ctx-\u003epk_info != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003epk_ctx = info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n    ctx-\u003epk_info = info;\n\n    return( 0 );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":141,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"457856":{"score":0.86218244,"function_name":"mbedtls_pk_setup_rsa_alt","code":"int mbedtls_pk_setup_rsa_alt( mbedtls_pk_context *ctx, void * key,\n                         mbedtls_pk_rsa_alt_decrypt_func decrypt_func,\n                         mbedtls_pk_rsa_alt_sign_func sign_func,\n                         mbedtls_pk_rsa_alt_key_len_func key_len_func )\n{\n    mbedtls_rsa_alt_context *rsa_alt;\n    const mbedtls_pk_info_t *info = \u0026mbedtls_rsa_alt_info;\n\n    PK_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003epk_info != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ( ctx-\u003epk_ctx = info-\u003ectx_alloc_func() ) == NULL )\n        return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n    ctx-\u003epk_info = info;\n\n    rsa_alt = (mbedtls_rsa_alt_context *) ctx-\u003epk_ctx;\n\n    rsa_alt-\u003ekey = key;\n    rsa_alt-\u003edecrypt_func = decrypt_func;\n    rsa_alt-\u003esign_func = sign_func;\n    rsa_alt-\u003ekey_len_func = key_len_func;\n\n    return( 0 );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":194,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458048":{"score":0.84290457,"function_name":"pk_hashlen_helper","code":"static inline int pk_hashlen_helper( mbedtls_md_type_t md_alg, size_t *hash_len )\n{\n    const mbedtls_md_info_t *md_info;\n\n    if( *hash_len != 0 )\n        return( 0 );\n\n    if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )\n        return( -1 );\n\n    *hash_len = mbedtls_md_get_size( md_info );\n    return( 0 );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":239,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458307":{"score":0.80578136,"function_name":"mbedtls_pk_verify_ext","code":"int mbedtls_pk_verify_ext( mbedtls_pk_type_t type, const void *options,\n                   mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   const unsigned char *sig, size_t sig_len )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( ( md_alg == MBEDTLS_MD_NONE \u0026\u0026 hash_len == 0 ) ||\n                     hash != NULL );\n    PK_VALIDATE_RET( sig != NULL );\n\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ! mbedtls_pk_can_do( ctx, type ) )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    if( type == MBEDTLS_PK_RSASSA_PSS )\n    {\n#if defined(MBEDTLS_RSA_C) \u0026\u0026 defined(MBEDTLS_PKCS1_V21)\n        int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n        const mbedtls_pk_rsassa_pss_options *pss_opts;\n\n#if SIZE_MAX \u003e UINT_MAX\n        if( md_alg == MBEDTLS_MD_NONE \u0026\u0026 UINT_MAX \u003c hash_len )\n            return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n#endif /* SIZE_MAX \u003e UINT_MAX */\n\n        if( options == NULL )\n            return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n        pss_opts = (const mbedtls_pk_rsassa_pss_options *) options;\n\n        if( sig_len \u003c mbedtls_pk_get_len( ctx ) )\n            return( MBEDTLS_ERR_RSA_VERIFY_FAILED );\n\n        ret = mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_pk_rsa( *ctx ),\n                NULL, NULL, MBEDTLS_RSA_PUBLIC,\n                md_alg, (unsigned int) hash_len, hash,\n                pss_opts-\u003emgf1_hash_id,\n                pss_opts-\u003eexpected_salt_len,\n                sig );\n        if( ret != 0 )\n            return( ret );\n\n        if( sig_len \u003e mbedtls_pk_get_len( ctx ) )\n            return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );\n\n        return( 0 );\n#else\n        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );\n#endif /* MBEDTLS_RSA_C \u0026\u0026 MBEDTLS_PKCS1_V21 */\n    }\n\n    /* General case: no options */\n    if( options != NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    return( mbedtls_pk_verify( ctx, md_alg, hash, hash_len, sig, sig_len ) );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":339,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458424":{"score":0.8571805,"function_name":"mbedtls_pk_verify_restartable","code":"int mbedtls_pk_verify_restartable( mbedtls_pk_context *ctx,\n               mbedtls_md_type_t md_alg,\n               const unsigned char *hash, size_t hash_len,\n               const unsigned char *sig, size_t sig_len,\n               mbedtls_pk_restart_ctx *rs_ctx )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( ( md_alg == MBEDTLS_MD_NONE \u0026\u0026 hash_len == 0 ) ||\n                     hash != NULL );\n    PK_VALIDATE_RET( sig != NULL );\n\n    if( ctx-\u003epk_info == NULL ||\n        pk_hashlen_helper( md_alg, \u0026hash_len ) != 0 )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_ECDSA_C) \u0026\u0026 defined(MBEDTLS_ECP_RESTARTABLE)\n    /* optimization: use non-restartable version if restart disabled */\n    if( rs_ctx != NULL \u0026\u0026\n        mbedtls_ecp_restart_is_enabled() \u0026\u0026\n        ctx-\u003epk_info-\u003everify_rs_func != NULL )\n    {\n        int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n\n        if( ( ret = pk_restart_setup( rs_ctx, ctx-\u003epk_info ) ) != 0 )\n            return( ret );\n\n        ret = ctx-\u003epk_info-\u003everify_rs_func( ctx-\u003epk_ctx,\n                   md_alg, hash, hash_len, sig, sig_len, rs_ctx-\u003ers_ctx );\n\n        if( ret != MBEDTLS_ERR_ECP_IN_PROGRESS )\n            mbedtls_pk_restart_free( rs_ctx );\n\n        return( ret );\n    }\n#else /* MBEDTLS_ECDSA_C \u0026\u0026 MBEDTLS_ECP_RESTARTABLE */\n    (void) rs_ctx;\n#endif /* MBEDTLS_ECDSA_C \u0026\u0026 MBEDTLS_ECP_RESTARTABLE */\n\n    if( ctx-\u003epk_info-\u003everify_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003everify_func( ctx-\u003epk_ctx, md_alg, hash, hash_len,\n                                       sig, sig_len ) );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":280,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458690":{"score":0.9032019,"function_name":"mbedtls_pk_encrypt","code":"int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,\n                const unsigned char *input, size_t ilen,\n                unsigned char *output, size_t *olen, size_t osize,\n                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    PK_VALIDATE_RET( input != NULL || ilen == 0 );\n    PK_VALIDATE_RET( output != NULL || osize == 0 );\n    PK_VALIDATE_RET( olen != NULL );\n\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003eencrypt_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    return( ctx-\u003epk_info-\u003eencrypt_func( ctx-\u003epk_ctx, input, ilen,\n                output, olen, osize, f_rng, p_rng ) );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":486,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458784":{"score":0.9052711,"function_name":"mbedtls_pk_check_pair","code":"int mbedtls_pk_check_pair( const mbedtls_pk_context *pub, const mbedtls_pk_context *prv )\n{\n    PK_VALIDATE_RET( pub != NULL );\n    PK_VALIDATE_RET( prv != NULL );\n\n    if( pub-\u003epk_info == NULL ||\n        prv-\u003epk_info == NULL )\n    {\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n    }\n\n    if( prv-\u003epk_info-\u003echeck_pair_func == NULL )\n        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );\n\n    if( prv-\u003epk_info-\u003etype == MBEDTLS_PK_RSA_ALT )\n    {\n        if( pub-\u003epk_info-\u003etype != MBEDTLS_PK_RSA )\n            return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n    }\n    else\n    {\n        if( pub-\u003epk_info != prv-\u003epk_info )\n            return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n    }\n\n    return( prv-\u003epk_info-\u003echeck_pair_func( pub-\u003epk_ctx, prv-\u003epk_ctx ) );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":509,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"458984":{"score":0.91664547,"function_name":"mbedtls_pk_debug","code":"int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items )\n{\n    PK_VALIDATE_RET( ctx != NULL );\n    if( ctx-\u003epk_info == NULL )\n        return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );\n\n    if( ctx-\u003epk_info-\u003edebug_func == NULL )\n        return( MBEDTLS_ERR_PK_TYPE_MISMATCH );\n\n    ctx-\u003epk_info-\u003edebug_func( ctx-\u003epk_ctx, items );\n    return( 0 );\n}","filepath":"connectivity/mbedtls/source/pk.c","line_number":553,"entry_url":"https://github.com/ARMmbed/mbed-os.git","slot_name":"mbed-os-6.2.1-rc1"},"459244":{"score":0.87569714,"function_name":"rsa_verify_wrap","code":"static int rsa_verify_wrap( void *ctx, md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   const unsigned char *sig, size_t sig_len )\n{\n    int ret;\n\n    if( sig_len \u003c ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_RSA_VERIFY_FAILED );\n\n    if( ( ret = rsa_pkcs1_verify( (rsa_context *) ctx, NULL, NULL,\n                                  RSA_PUBLIC, md_alg,\n                                  (unsigned int) hash_len, hash, sig ) ) != 0 )\n        return( ret );\n\n    if( sig_len \u003e ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_PK_SIG_LEN_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/pk_wrap.c","line_number":69,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459368":{"score":0.8132944,"function_name":"rsa_sign_wrap","code":"static int rsa_sign_wrap( void *ctx, md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   unsigned char *sig, size_t *sig_len,\n                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    *sig_len = ((rsa_context *) ctx)-\u003elen;\n\n    return( rsa_pkcs1_sign( (rsa_context *) ctx, f_rng, p_rng, RSA_PRIVATE,\n                md_alg, (unsigned int) hash_len, hash, sig ) );\n}","filepath":"library/pk_wrap.c","line_number":89,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459449":{"score":0.84128714,"function_name":"rsa_decrypt_wrap","code":"static int rsa_decrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    if( ilen != ((rsa_context *) ctx)-\u003elen )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    return( rsa_pkcs1_decrypt( (rsa_context *) ctx, f_rng, p_rng,\n                RSA_PRIVATE, olen, input, output, osize ) );\n}","filepath":"library/pk_wrap.c","line_number":100,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459535":{"score":0.88266575,"function_name":"rsa_encrypt_wrap","code":"static int rsa_encrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    *olen = ((rsa_context *) ctx)-\u003elen;\n\n    if( *olen \u003e osize )\n        return( POLARSSL_ERR_RSA_OUTPUT_TOO_LARGE );\n\n    return( rsa_pkcs1_encrypt( (rsa_context *) ctx,\n                f_rng, p_rng, RSA_PUBLIC, ilen, input, output ) );\n}","filepath":"library/pk_wrap.c","line_number":112,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"459797":{"score":0.91298676,"function_name":"rsa_debug","code":"static void rsa_debug( const void *ctx, pk_debug_item *items )\n{\n    items-\u003etype = POLARSSL_PK_DEBUG_MPI;\n    items-\u003ename = \"rsa.N\";\n    items-\u003evalue = \u0026( ((rsa_context *) ctx)-\u003eN );\n\n    items++;\n\n    items-\u003etype = POLARSSL_PK_DEBUG_MPI;\n    items-\u003ename = \"rsa.E\";\n    items-\u003evalue = \u0026( ((rsa_context *) ctx)-\u003eE );\n}","filepath":"library/pk_wrap.c","line_number":148,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460273":{"score":0.9412341,"function_name":"rsa_alt_sign_wrap","code":"static int rsa_alt_sign_wrap( void *ctx, md_type_t md_alg,\n                   const unsigned char *hash, size_t hash_len,\n                   unsigned char *sig, size_t *sig_len,\n                   int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    rsa_alt_context *rsa_alt = (rsa_alt_context *) ctx;\n\n    *sig_len = rsa_alt-\u003ekey_len_func( rsa_alt-\u003ekey );\n\n    return( rsa_alt-\u003esign_func( rsa_alt-\u003ekey, f_rng, p_rng, RSA_PRIVATE,\n                md_alg, (unsigned int) hash_len, hash, sig ) );\n}","filepath":"library/pk_wrap.c","line_number":406,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460361":{"score":0.8751509,"function_name":"rsa_alt_decrypt_wrap","code":"static int rsa_alt_decrypt_wrap( void *ctx,\n                    const unsigned char *input, size_t ilen,\n                    unsigned char *output, size_t *olen, size_t osize,\n                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    rsa_alt_context *rsa_alt = (rsa_alt_context *) ctx;\n\n    ((void) f_rng);\n    ((void) p_rng);\n\n    if( ilen != rsa_alt-\u003ekey_len_func( rsa_alt-\u003ekey ) )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    return( rsa_alt-\u003edecrypt_func( rsa_alt-\u003ekey,\n                RSA_PRIVATE, olen, input, output, osize ) );\n}","filepath":"library/pk_wrap.c","line_number":419,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"460451":{"score":0.91562533,"function_name":"rsa_alt_check_pair","code":"static int rsa_alt_check_pair( const void *pub, const void *prv )\n{\n    unsigned char sig[POLARSSL_MPI_MAX_SIZE];\n    unsigned char hash[32];\n    size_t sig_len = 0;\n    int ret;\n\n    if( rsa_alt_get_size( prv ) != rsa_get_size( pub ) )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    memset( hash, 0x2a, sizeof( hash ) );\n\n    if( ( ret = rsa_alt_sign_wrap( (void *) prv, POLARSSL_MD_NONE,\n                                   hash, sizeof( hash ),\n                                   sig, \u0026sig_len, NULL, NULL ) ) != 0 )\n    {\n        return( ret );\n    }\n\n    if( rsa_verify_wrap( (void *) pub, POLARSSL_MD_NONE,\n                         hash, sizeof( hash ), sig, sig_len ) != 0 )\n    {\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    return( 0 );\n}","filepath":"library/pk_wrap.c","line_number":437,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.10"},"461070":{"score":0.8163569,"function_name":"pk_use_ecparams","code":"static int pk_use_ecparams( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )\n{\n    int ret;\n    mbedtls_ecp_group_id grp_id;\n\n    if( params-\u003etag == MBEDTLS_ASN1_OID )\n    {\n        if( mbedtls_oid_get_ec_grp( params, \u0026grp_id ) != 0 )\n            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );\n    }\n    else\n    {\n#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)\n        if( ( ret = pk_group_id_from_specified( params, \u0026grp_id ) ) != 0 )\n            return( ret );\n#else\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n#endif\n    }\n\n    /*\n     * grp may already be initilialized; if so, make sure IDs match\n     */\n    if( grp-\u003eid != MBEDTLS_ECP_DP_NONE \u0026\u0026 grp-\u003eid != grp_id )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n\n    if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )\n        return( ret );\n\n    return( 0 );\n}","filepath":"library/pkparse.c","line_number":461,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"461244":{"score":0.8696296,"function_name":"pk_get_ecpubkey","code":"static int pk_get_ecpubkey( unsigned char **p, const unsigned char *end,\n                            mbedtls_ecp_keypair *key )\n{\n    int ret;\n\n    if( ( ret = mbedtls_ecp_point_read_binary( \u0026key-\u003egrp, \u0026key-\u003eQ,\n                    (const unsigned char *) *p, end - *p ) ) == 0 )\n    {\n        ret = mbedtls_ecp_check_pubkey( \u0026key-\u003egrp, \u0026key-\u003eQ );\n    }\n\n    /*\n     * We know mbedtls_ecp_point_read_binary consumed all bytes or failed\n     */\n    *p = (unsigned char *) end;\n\n    return( ret );\n}","filepath":"library/pkparse.c","line_number":500,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"461361":{"score":0.84149307,"function_name":"pk_get_rsapubkey","code":"static int pk_get_rsapubkey( unsigned char **p,\n                             const unsigned char *end,\n                             mbedtls_rsa_context *rsa )\n{\n    int ret;\n    size_t len;\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    /* Import N */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len, MBEDTLS_ASN1_INTEGER ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( ( ret = mbedtls_rsa_import_raw( rsa, *p, len, NULL, 0, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n\n    *p += len;\n\n    /* Import E */\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len, MBEDTLS_ASN1_INTEGER ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        NULL, 0, *p, len ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n\n    *p += len;\n\n    if( mbedtls_rsa_complete( rsa ) != 0 ||\n        mbedtls_rsa_check_pubkey( rsa ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );\n    }\n\n    if( *p != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/pkparse.c","line_number":527,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"461791":{"score":0.8856485,"function_name":"pk_get_pk_alg","code":"static int pk_get_pk_alg( unsigned char **p,\n                          const unsigned char *end,\n                          mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params )\n{\n    int ret;\n    mbedtls_asn1_buf alg_oid;\n\n    memset( params, 0, sizeof(mbedtls_asn1_buf) );\n\n    if( ( ret = mbedtls_asn1_get_alg( p, end, \u0026alg_oid, params ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_ALG + ret );\n\n    if( mbedtls_oid_get_pk_alg( \u0026alg_oid, pk_alg ) != 0 )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    /*\n     * No parameters with RSA (only for EC)\n     */\n    if( *pk_alg == MBEDTLS_PK_RSA \u0026\u0026\n            ( ( params-\u003etag != MBEDTLS_ASN1_NULL \u0026\u0026 params-\u003etag != 0 ) ||\n                params-\u003elen != 0 ) )\n    {\n        return( MBEDTLS_ERR_PK_INVALID_ALG );\n    }\n\n    return( 0 );\n}","filepath":"library/pkparse.c","line_number":582,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"462004":{"score":0.8538196,"function_name":"mbedtls_pk_parse_subpubkey","code":"int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,\n                        mbedtls_pk_context *pk )\n{\n    int ret;\n    size_t len;\n    mbedtls_asn1_buf alg_params;\n    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;\n    const mbedtls_pk_info_t *pk_info;\n\n    PK_VALIDATE_RET( p != NULL );\n    PK_VALIDATE_RET( *p != NULL );\n    PK_VALIDATE_RET( end != NULL );\n    PK_VALIDATE_RET( pk != NULL );\n\n    if( ( ret = mbedtls_asn1_get_tag( p, end, \u0026len,\n                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = *p + len;\n\n    if( ( ret = pk_get_pk_alg( p, end, \u0026pk_alg, \u0026alg_params ) ) != 0 )\n        return( ret );\n\n    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, \u0026len ) ) != 0 )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );\n\n    if( *p + len != end )\n        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +\n                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )\n        return( ret );\n\n#if defined(MBEDTLS_RSA_C)\n    if( pk_alg == MBEDTLS_PK_RSA )\n    {\n        ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );\n    } else\n#endif /* MBEDTLS_RSA_C */\n#if defined(MBEDTLS_ECP_C)\n    if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )\n    {\n        ret = pk_use_ecparams( \u0026alg_params, \u0026mbedtls_pk_ec( *pk )-\u003egrp );\n        if( ret == 0 )\n            ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );\n    } else\n#endif /* MBEDTLS_ECP_C */\n        ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;\n\n    if( ret == 0 \u0026\u0026 *p != end )\n        ret = MBEDTLS_ERR_PK_INVALID_PUBKEY\n              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;\n\n    if( ret != 0 )\n        mbedtls_pk_free( pk );\n\n    return( ret );\n}","filepath":"library/pkparse.c","line_number":615,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"462515":{"score":0.81219715,"function_name":"pk_parse_key_pkcs1_der","code":"static int pk_parse_key_pkcs1_der( mbedtls_rsa_context *rsa,\n                                   const unsigned char *key,\n                                   size_t keylen )\n{\n    int ret, version;\n    size_t len;\n    unsigned char *p, *end;\n\n    mbedtls_mpi T;\n    mbedtls_mpi_init( \u0026T );\n\n    p = (unsigned char *) key;\n    end = p + keylen;\n\n    /*\n     * This function parses the RSAPrivateKey (PKCS#1)\n     *\n     *  RSAPrivateKey ::= SEQUENCE {\n     *      version           Version,\n     *      modulus           INTEGER,  -- n\n     *      publicExponent    INTEGER,  -- e\n     *      privateExponent   INTEGER,  -- d\n     *      prime1            INTEGER,  -- p\n     *      prime2            INTEGER,  -- q\n     *      exponent1         INTEGER,  -- d mod (p-1)\n     *      exponent2         INTEGER,  -- d mod (q-1)\n     *      coefficient       INTEGER,  -- (inverse of q) mod p\n     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL\n     *  }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( \u0026p, end, \u0026version ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    if( version != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );\n    }\n\n    /* Import N */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, p, len, NULL, 0, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import E */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        NULL, 0, p, len ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import D */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,\n                                        p, len, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import P */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, p, len, NULL, 0,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Import Q */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||\n        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, p, len,\n                                        NULL, 0, NULL, 0 ) ) != 0 )\n        goto cleanup;\n    p += len;\n\n    /* Complete the RSA private key */\n    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 )\n        goto cleanup;\n\n    /* Check optional parameters */\n    if( ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 ||\n        ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 ||\n        ( ret = mbedtls_asn1_get_mpi( \u0026p, end, \u0026T ) ) != 0 )\n        goto cleanup;\n\n    if( p != end )\n    {\n        ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +\n              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ;\n    }\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026T );\n\n    if( ret != 0 )\n    {\n        /* Wrap error code if it's coming from a lower level */\n        if( ( ret \u0026 0xff80 ) == 0 )\n            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret;\n        else\n            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;\n\n        mbedtls_rsa_free( rsa );\n    }\n\n    return( ret );\n}","filepath":"library/pkparse.c","line_number":683,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"463408":{"score":0.81123537,"function_name":"pk_parse_key_sec1_der","code":"static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,\n                                  const unsigned char *key,\n                                  size_t keylen )\n{\n    int ret;\n    int version, pubkey_done;\n    size_t len;\n    mbedtls_asn1_buf params;\n    unsigned char *p = (unsigned char *) key;\n    unsigned char *end = p + keylen;\n    unsigned char *end2;\n\n    /*\n     * RFC 5915, or SEC1 Appendix C.4\n     *\n     * ECPrivateKey ::= SEQUENCE {\n     *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),\n     *      privateKey     OCTET STRING,\n     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,\n     *      publicKey  [1] BIT STRING OPTIONAL\n     *    }\n     */\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    end = p + len;\n\n    if( ( ret = mbedtls_asn1_get_int( \u0026p, end, \u0026version ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( version != 1 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );\n\n    if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n    if( ( ret = mbedtls_mpi_read_binary( \u0026eck-\u003ed, p, len ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    p += len;\n\n    pubkey_done = 0;\n    if( p != end )\n    {\n        /*\n         * Is 'parameters' present?\n         */\n        if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )\n        {\n            if( ( ret = pk_get_ecparams( \u0026p, p + len, \u0026params) ) != 0 ||\n                ( ret = pk_use_ecparams( \u0026params, \u0026eck-\u003egrp )  ) != 0 )\n            {\n                mbedtls_ecp_keypair_free( eck );\n                return( ret );\n            }\n        }\n        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            mbedtls_ecp_keypair_free( eck );\n            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n        }\n    }\n\n    if( p != end )\n    {\n        /*\n         * Is 'publickey' present? If not, or if we can't read it (eg because it\n         * is compressed), create it from the private key.\n         */\n        if( ( ret = mbedtls_asn1_get_tag( \u0026p, end, \u0026len,\n                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )\n        {\n            end2 = p + len;\n\n            if( ( ret = mbedtls_asn1_get_bitstring_null( \u0026p, end2, \u0026len ) ) != 0 )\n                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n\n            if( p + len != end2 )\n                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +\n                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );\n\n            if( ( ret = pk_get_ecpubkey( \u0026p, end2, eck ) ) == 0 )\n                pubkey_done = 1;\n            else\n            {\n                /*\n                 * The only acceptable failure mode of pk_get_ecpubkey() above\n                 * is if the point format is not recognized.\n                 */\n                if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )\n                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n            }\n        }\n        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )\n        {\n            mbedtls_ecp_keypair_free( eck );\n            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n        }\n    }\n\n    if( ! pubkey_done \u0026\u0026\n        ( ret = mbedtls_ecp_mul( \u0026eck-\u003egrp, \u0026eck-\u003eQ, \u0026eck-\u003ed, \u0026eck-\u003egrp.G,\n                                                      NULL, NULL ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );\n    }\n\n    if( ( ret = mbedtls_ecp_check_privkey( \u0026eck-\u003egrp, \u0026eck-\u003ed ) ) != 0 )\n    {\n        mbedtls_ecp_keypair_free( eck );\n        return( ret );\n    }\n\n    return( 0 );\n}","filepath":"library/pkparse.c","line_number":810,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"464855":{"score":0.75399953,"function_name":"mbedtls_pk_parse_key","code":"int mbedtls_pk_parse_key( mbedtls_pk_context *pk,\n                  const unsigned char *key, size_t keylen,\n                  const unsigned char *pwd, size_t pwdlen )\n{\n    int ret;\n    const mbedtls_pk_info_t *pk_info;\n#if defined(MBEDTLS_PEM_PARSE_C)\n    size_t len;\n    mbedtls_pem_context pem;\n#endif\n\n    PK_VALIDATE_RET( pk != NULL );\n    if( keylen == 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n    PK_VALIDATE_RET( key != NULL );\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n   mbedtls_pem_init( \u0026pem );\n\n#if defined(MBEDTLS_RSA_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN RSA PRIVATE KEY-----\",\n                               \"-----END RSA PRIVATE KEY-----\",\n                               key, pwd, pwdlen, \u0026len );\n\n    if( ret == 0 )\n    {\n        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );\n        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||\n            ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ),\n                                            pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )\n        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )\n        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_ECP_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN EC PRIVATE KEY-----\",\n                               \"-----END EC PRIVATE KEY-----\",\n                               key, pwd, pwdlen, \u0026len );\n    if( ret == 0 )\n    {\n        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );\n\n        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||\n            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),\n                                           pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )\n        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );\n    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )\n        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_ECP_C */\n\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN PRIVATE KEY-----\",\n                               \"-----END PRIVATE KEY-----\",\n                               key, NULL, 0, \u0026len );\n    if( ret == 0 )\n    {\n        if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk,\n                                                pem.buf, pem.buflen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n\n#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN ENCRYPTED PRIVATE KEY-----\",\n                               \"-----END ENCRYPTED PRIVATE KEY-----\",\n                               key, NULL, 0, \u0026len );\n    if( ret == 0 )\n    {\n        if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,\n                                                      pem.buf, pem.buflen,\n                                                      pwd, pwdlen ) ) != 0 )\n        {\n            mbedtls_pk_free( pk );\n        }\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n        return( ret );\n#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */\n#else\n    ((void) pwd);\n    ((void) pwdlen);\n#endif /* MBEDTLS_PEM_PARSE_C */\n\n    /*\n     * At this point we only know it's not a PEM formatted key. Could be any\n     * of the known DER encoded private key formats\n     *\n     * We try the different DER format parsers to see if one passes without\n     * error\n     */\n#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)\n    {\n        unsigned char *key_copy;\n\n        if( ( key_copy = mbedtls_calloc( 1, keylen ) ) == NULL )\n            return( MBEDTLS_ERR_PK_ALLOC_FAILED );\n\n        memcpy( key_copy, key, keylen );\n\n        ret = pk_parse_key_pkcs8_encrypted_der( pk, key_copy, keylen,\n                                                pwd, pwdlen );\n\n        mbedtls_platform_zeroize( key_copy, keylen );\n        mbedtls_free( key_copy );\n    }\n\n    if( ret == 0 )\n        return( 0 );\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n\n    if( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */\n\n    if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen ) ) == 0 )\n        return( 0 );\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n\n#if defined(MBEDTLS_RSA_C)\n\n    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );\n    if( mbedtls_pk_setup( pk, pk_info ) == 0 \u0026\u0026\n        pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), key, keylen ) == 0 )\n    {\n        return( 0 );\n    }\n\n    mbedtls_pk_free( pk );\n    mbedtls_pk_init( pk );\n#endif /* MBEDTLS_RSA_C */\n\n#if defined(MBEDTLS_ECP_C)\n    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );\n    if( mbedtls_pk_setup( pk, pk_info ) == 0 \u0026\u0026\n        pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),\n                               key, keylen ) == 0 )\n    {\n        return( 0 );\n    }\n    mbedtls_pk_free( pk );\n#endif /* MBEDTLS_ECP_C */\n\n    /* If MBEDTLS_RSA_C is defined but MBEDTLS_ECP_C isn't,\n     * it is ok to leave the PK context initialized but not\n     * freed: It is the caller's responsibility to call pk_init()\n     * before calling this function, and to call pk_free()\n     * when it fails. If MBEDTLS_ECP_C is defined but MBEDTLS_RSA_C\n     * isn't, this leads to mbedtls_pk_free() being called\n     * twice, once here and once by the caller, but this is\n     * also ok and in line with the mbedtls_pk_free() calls\n     * on failed PEM parsing attempts. */\n\n    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n}","filepath":"library/pkparse.c","line_number":1163,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"465928":{"score":0.84936666,"function_name":"mbedtls_pk_parse_public_key","code":"int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,\n                         const unsigned char *key, size_t keylen )\n{\n    int ret;\n    unsigned char *p;\n#if defined(MBEDTLS_RSA_C)\n    const mbedtls_pk_info_t *pk_info;\n#endif\n#if defined(MBEDTLS_PEM_PARSE_C)\n    size_t len;\n    mbedtls_pem_context pem;\n#endif\n\n    PK_VALIDATE_RET( ctx != NULL );\n    if( keylen == 0 )\n        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );\n    PK_VALIDATE_RET( key != NULL || keylen == 0 );\n\n#if defined(MBEDTLS_PEM_PARSE_C)\n    mbedtls_pem_init( \u0026pem );\n#if defined(MBEDTLS_RSA_C)\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                               \"-----BEGIN RSA PUBLIC KEY-----\",\n                               \"-----END RSA PUBLIC KEY-----\",\n                               key, NULL, 0, \u0026len );\n\n    if( ret == 0 )\n    {\n        p = pem.buf;\n        if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )\n            return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n        if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )\n            return( ret );\n\n        if ( ( ret = pk_get_rsapubkey( \u0026p, p + pem.buflen, mbedtls_pk_rsa( *ctx ) ) ) != 0 )\n            mbedtls_pk_free( ctx );\n\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n    {\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n#endif /* MBEDTLS_RSA_C */\n\n    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */\n    if( key[keylen - 1] != '\\0' )\n        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;\n    else\n        ret = mbedtls_pem_read_buffer( \u0026pem,\n                \"-----BEGIN PUBLIC KEY-----\",\n                \"-----END PUBLIC KEY-----\",\n                key, NULL, 0, \u0026len );\n\n    if( ret == 0 )\n    {\n        /*\n         * Was PEM encoded\n         */\n        p = pem.buf;\n\n        ret = mbedtls_pk_parse_subpubkey( \u0026p,  p + pem.buflen, ctx );\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )\n    {\n        mbedtls_pem_free( \u0026pem );\n        return( ret );\n    }\n    mbedtls_pem_free( \u0026pem );\n#endif /* MBEDTLS_PEM_PARSE_C */\n\n#if defined(MBEDTLS_RSA_C)\n    if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )\n        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );\n\n    if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )\n        return( ret );\n\n    p = (unsigned char *)key;\n    ret = pk_get_rsapubkey( \u0026p, p + keylen, mbedtls_pk_rsa( *ctx ) );\n    if( ret == 0 )\n    {\n        return( ret );\n    }\n    mbedtls_pk_free( ctx );\n    if( ret != ( MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )\n    {\n        return( ret );\n    }\n#endif /* MBEDTLS_RSA_C */\n    p = (unsigned char *) key;\n\n    ret = mbedtls_pk_parse_subpubkey( \u0026p, p + keylen, ctx );\n\n    return( ret );\n}","filepath":"library/pkparse.c","line_number":1376,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.16.0"},"466765":{"score":0.79978204,"function_name":"mbedtls_rsa_import","code":"int mbedtls_rsa_import( mbedtls_rsa_context *ctx,\n                        const mbedtls_mpi *N,\n                        const mbedtls_mpi *P, const mbedtls_mpi *Q,\n                        const mbedtls_mpi *D, const mbedtls_mpi *E )\n{\n    int ret;\n    RSA_VALIDATE_RET( ctx != NULL );\n\n    if( ( N != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eN, N ) ) != 0 ) ||\n        ( P != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eP, P ) ) != 0 ) ||\n        ( Q != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eQ, Q ) ) != 0 ) ||\n        ( D != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eD, D ) ) != 0 ) ||\n        ( E != NULL \u0026\u0026 ( ret = mbedtls_mpi_copy( \u0026ctx-\u003eE, E ) ) != 0 ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n    }\n\n    if( N != NULL )\n        ctx-\u003elen = mbedtls_mpi_size( \u0026ctx-\u003eN );\n\n    return( 0 );\n}","filepath":"components/mbedtls/platform/yoc/rsa_alt.c","line_number":572,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"rel_3.3.0"},"467019":{"score":0.76832557,"function_name":"mbedtls_rsa_import_raw","code":"int mbedtls_rsa_import_raw( mbedtls_rsa_context *ctx,\n                            unsigned char const *N, size_t N_len,\n                            unsigned char const *P, size_t P_len,\n                            unsigned char const *Q, size_t Q_len,\n                            unsigned char const *D, size_t D_len,\n                            unsigned char const *E, size_t E_len )\n{\n    int ret = 0;\n\n    if( N != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eN, N, N_len ) );\n        ctx-\u003elen = mbedtls_mpi_size( \u0026ctx-\u003eN );\n    }\n\n    if( P != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eP, P, P_len ) );\n\n    if( Q != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eQ, Q, Q_len ) );\n\n    if( D != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eD, D, D_len ) );\n\n    if( E != NULL )\n        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( \u0026ctx-\u003eE, E, E_len ) );\n\ncleanup:\n\n    if( ret != 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );\n\n    return( 0 );\n}","filepath":"components/mbedtls/platform/yoc/rsa_alt.c","line_number":595,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"rel_3.3.0"},"467308":{"score":0.74902284,"function_name":"rsa_check_context","code":"static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,\n                              int blinding_needed )\n{\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* blinding_needed is only used for NO_CRT to decide whether\n     * P,Q need to be present or not. */\n    ((void) blinding_needed);\n#endif\n\n    if( ctx-\u003elen != mbedtls_mpi_size( \u0026ctx-\u003eN ) ||\n        ctx-\u003elen \u003e MBEDTLS_MPI_MAX_SIZE )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n    /*\n     * 1. Modular exponentiation needs positive, odd moduli.\n     */\n\n    /* Modular exponentiation wrt. N is always used for\n     * RSA public key operations. */\n    if( mbedtls_mpi_cmp_int( \u0026ctx-\u003eN, 0 ) \u003c= 0 ||\n        mbedtls_mpi_get_bit( \u0026ctx-\u003eN, 0 ) == 0  )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    /* Modular exponentiation for P and Q is only\n     * used for private key operations and if CRT\n     * is used. */\n    if( is_priv \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_get_bit( \u0026ctx-\u003eP, 0 ) == 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) \u003c= 0 ||\n          mbedtls_mpi_get_bit( \u0026ctx-\u003eQ, 0 ) == 0  ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif /* !MBEDTLS_RSA_NO_CRT */\n\n    /*\n     * 2. Exponents must be positive\n     */\n\n    /* Always need E for public key operations */\n    if( mbedtls_mpi_cmp_int( \u0026ctx-\u003eE, 0 ) \u003c= 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n\n#if defined(MBEDTLS_RSA_NO_CRT)\n    /* For private key operations, use D or DP \u0026 DQ\n     * as (unblinded) exponents. */\n    if( is_priv \u0026\u0026 mbedtls_mpi_cmp_int( \u0026ctx-\u003eD, 0 ) \u003c= 0 )\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n#else\n    if( is_priv \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eDP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eDQ, 0 ) \u003c= 0  ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif /* MBEDTLS_RSA_NO_CRT */\n\n    /* Blinding shouldn't make exponents negative either,\n     * so check that P, Q \u003e= 1 if that hasn't yet been\n     * done as part of 1. */\n#if defined(MBEDTLS_RSA_NO_CRT)\n    if( is_priv \u0026\u0026 blinding_needed \u0026\u0026\n        ( mbedtls_mpi_cmp_int( \u0026ctx-\u003eP, 0 ) \u003c= 0 ||\n          mbedtls_mpi_cmp_int( \u0026ctx-\u003eQ, 0 ) \u003c= 0 ) )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif\n\n    /* It wouldn't lead to an error if it wasn't satisfied,\n     * but check for QP \u003e= 1 nonetheless. */\n#if !defined(MBEDTLS_RSA_NO_CRT)\n    if( is_priv \u0026\u0026\n        mbedtls_mpi_cmp_int( \u0026ctx-\u003eQP, 0 ) \u003c= 0 )\n    {\n        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );\n    }\n#endif\n\n    return( 0 );\n}","filepath":"components/mbedtls/platform/yoc/rsa_alt.c","line_number":90,"entry_url":"https://github.com/alibaba/AliOS-Things.git","slot_name":"rel_3.3.0"},"469528":{"score":0.82879615,"function_name":"rsa_init","code":"void rsa_init( rsa_context *ctx,\n               int padding,\n               int hash_id )\n{\n    memset( ctx, 0, sizeof( rsa_context ) );\n\n    rsa_set_padding( ctx, padding, hash_id );\n\n#if defined(POLARSSL_THREADING_C)\n    polarssl_mutex_init( \u0026ctx-\u003emutex );\n#endif\n}","filepath":"library/rsa.c","line_number":62,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"469655":{"score":0.7499804,"function_name":"rsa_check_pubkey","code":"int rsa_check_pubkey( const rsa_context *ctx )\n{\n    if( !ctx-\u003eN.p || !ctx-\u003eE.p )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    if( ( ctx-\u003eN.p[0] \u0026 1 ) == 0 ||\n        ( ctx-\u003eE.p[0] \u0026 1 ) == 0 )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    if( mpi_msb( \u0026ctx-\u003eN ) \u003c 128 ||\n        mpi_msb( \u0026ctx-\u003eN ) \u003e POLARSSL_MPI_MAX_BITS )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    if( mpi_msb( \u0026ctx-\u003eE ) \u003c 2 ||\n        mpi_cmp_mpi( \u0026ctx-\u003eE, \u0026ctx-\u003eN ) \u003e= 0 )\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":164,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"470042":{"score":0.898448,"function_name":"rsa_check_pub_priv","code":"int rsa_check_pub_priv( const rsa_context *pub, const rsa_context *prv )\n{\n    if( rsa_check_pubkey( pub ) != 0 ||\n        rsa_check_privkey( prv ) != 0 )\n    {\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    if( mpi_cmp_mpi( \u0026pub-\u003eN, \u0026prv-\u003eN ) != 0 ||\n        mpi_cmp_mpi( \u0026pub-\u003eE, \u0026prv-\u003eE ) != 0 )\n    {\n        return( POLARSSL_ERR_RSA_KEY_CHECK_FAILED );\n    }\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":249,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"470178":{"score":0.8032826,"function_name":"rsa_public","code":"int rsa_public( rsa_context *ctx,\n                const unsigned char *input,\n                unsigned char *output )\n{\n    int ret;\n    size_t olen;\n    mpi T;\n\n    mpi_init( \u0026T );\n\n#if defined(POLARSSL_THREADING_C)\n    if( ( ret = polarssl_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n            return( ret );\n#endif\n\n    MPI_CHK( mpi_read_binary( \u0026T, input, ctx-\u003elen ) );\n\n    if( mpi_cmp_mpi( \u0026T, \u0026ctx-\u003eN ) \u003e= 0 )\n    {\n        ret = POLARSSL_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    olen = ctx-\u003elen;\n    MPI_CHK( mpi_exp_mod( \u0026T, \u0026T, \u0026ctx-\u003eE, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n    MPI_CHK( mpi_write_binary( \u0026T, output, olen ) );\n\ncleanup:\n#if defined(POLARSSL_THREADING_C)\n    if( polarssl_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( POLARSSL_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    mpi_free( \u0026T );\n\n    if( ret != 0 )\n        return( POLARSSL_ERR_RSA_PUBLIC_FAILED + ret );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":269,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"470491":{"score":0.86855406,"function_name":"rsa_prepare_blinding","code":"static int rsa_prepare_blinding( rsa_context *ctx,\n                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )\n{\n    int ret, count = 0;\n\n    if( ctx-\u003eVf.p != NULL )\n    {\n        /* We already have blinding values, just update them by squaring */\n        MPI_CHK( mpi_mul_mpi( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eVi ) );\n        MPI_CHK( mpi_mod_mpi( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eN ) );\n        MPI_CHK( mpi_mul_mpi( \u0026ctx-\u003eVf, \u0026ctx-\u003eVf, \u0026ctx-\u003eVf ) );\n        MPI_CHK( mpi_mod_mpi( \u0026ctx-\u003eVf, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n\n        goto cleanup;\n    }\n\n    /* Unblinding value: Vf = random number, invertible mod N */\n    do {\n        if( count++ \u003e 10 )\n            return( POLARSSL_ERR_RSA_RNG_FAILED );\n\n        MPI_CHK( mpi_fill_random( \u0026ctx-\u003eVf, ctx-\u003elen - 1, f_rng, p_rng ) );\n        MPI_CHK( mpi_gcd( \u0026ctx-\u003eVi, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n    } while( mpi_cmp_int( \u0026ctx-\u003eVi, 1 ) != 0 );\n\n    /* Blinding value: Vi =  Vf^(-e) mod N */\n    MPI_CHK( mpi_inv_mod( \u0026ctx-\u003eVi, \u0026ctx-\u003eVf, \u0026ctx-\u003eN ) );\n    MPI_CHK( mpi_exp_mod( \u0026ctx-\u003eVi, \u0026ctx-\u003eVi, \u0026ctx-\u003eE, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n\ncleanup:\n    return( ret );\n}","filepath":"library/rsa.c","line_number":316,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"471023":{"score":0.70040244,"function_name":"rsa_private","code":"int rsa_private( rsa_context *ctx,\n                 int (*f_rng)(void *, unsigned char *, size_t),\n                 void *p_rng,\n                 const unsigned char *input,\n                 unsigned char *output )\n{\n    int ret;\n    size_t olen;\n    mpi T, T1, T2;\n\n    mpi_init( \u0026T ); mpi_init( \u0026T1 ); mpi_init( \u0026T2 );\n\n#if defined(POLARSSL_THREADING_C)\n    if( ( ret = polarssl_mutex_lock( \u0026ctx-\u003emutex ) ) != 0 )\n        return( ret );\n#endif\n\n    MPI_CHK( mpi_read_binary( \u0026T, input, ctx-\u003elen ) );\n    if( mpi_cmp_mpi( \u0026T, \u0026ctx-\u003eN ) \u003e= 0 )\n    {\n        ret = POLARSSL_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    if( f_rng != NULL )\n    {\n        /*\n         * Blinding\n         * T = T * Vi mod N\n         */\n        MPI_CHK( rsa_prepare_blinding( ctx, f_rng, p_rng ) );\n        MPI_CHK( mpi_mul_mpi( \u0026T, \u0026T, \u0026ctx-\u003eVi ) );\n        MPI_CHK( mpi_mod_mpi( \u0026T, \u0026T, \u0026ctx-\u003eN ) );\n    }\n\n#if defined(POLARSSL_RSA_NO_CRT)\n    MPI_CHK( mpi_exp_mod( \u0026T, \u0026T, \u0026ctx-\u003eD, \u0026ctx-\u003eN, \u0026ctx-\u003eRN ) );\n#else\n    /*\n     * faster decryption using the CRT\n     *\n     * T1 = input ^ dP mod P\n     * T2 = input ^ dQ mod Q\n     */\n    MPI_CHK( mpi_exp_mod( \u0026T1, \u0026T, \u0026ctx-\u003eDP, \u0026ctx-\u003eP, \u0026ctx-\u003eRP ) );\n    MPI_CHK( mpi_exp_mod( \u0026T2, \u0026T, \u0026ctx-\u003eDQ, \u0026ctx-\u003eQ, \u0026ctx-\u003eRQ ) );\n\n    /*\n     * T = (T1 - T2) * (Q^-1 mod P) mod P\n     */\n    MPI_CHK( mpi_sub_mpi( \u0026T, \u0026T1, \u0026T2 ) );\n    MPI_CHK( mpi_mul_mpi( \u0026T1, \u0026T, \u0026ctx-\u003eQP ) );\n    MPI_CHK( mpi_mod_mpi( \u0026T, \u0026T1, \u0026ctx-\u003eP ) );\n\n    /*\n     * T = T2 + T * Q\n     */\n    MPI_CHK( mpi_mul_mpi( \u0026T1, \u0026T, \u0026ctx-\u003eQ ) );\n    MPI_CHK( mpi_add_mpi( \u0026T, \u0026T2, \u0026T1 ) );\n#endif /* POLARSSL_RSA_NO_CRT */\n\n    if( f_rng != NULL )\n    {\n        /*\n         * Unblind\n         * T = T * Vf mod N\n         */\n        MPI_CHK( mpi_mul_mpi( \u0026T, \u0026T, \u0026ctx-\u003eVf ) );\n        MPI_CHK( mpi_mod_mpi( \u0026T, \u0026T, \u0026ctx-\u003eN ) );\n    }\n\n    olen = ctx-\u003elen;\n    MPI_CHK( mpi_write_binary( \u0026T, output, olen ) );\n\ncleanup:\n#if defined(POLARSSL_THREADING_C)\n    if( polarssl_mutex_unlock( \u0026ctx-\u003emutex ) != 0 )\n        return( POLARSSL_ERR_THREADING_MUTEX_ERROR );\n#endif\n\n    mpi_free( \u0026T ); mpi_free( \u0026T1 ); mpi_free( \u0026T2 );\n\n    if( ret != 0 )\n        return( POLARSSL_ERR_RSA_PRIVATE_FAILED + ret );\n\n    return( 0 );\n}","filepath":"library/rsa.c","line_number":352,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"472974":{"score":0.9166212,"function_name":"rsa_rsaes_pkcs1_v15_encrypt","code":"int rsa_rsaes_pkcs1_v15_encrypt( rsa_context *ctx,\n                                 int (*f_rng)(void *, unsigned char *, size_t),\n                                 void *p_rng,\n                                 int mode, size_t ilen,\n                                 const unsigned char *input,\n                                 unsigned char *output )\n{\n    size_t nb_pad, olen;\n    int ret;\n    unsigned char *p = output;\n\n    if( mode == RSA_PRIVATE \u0026\u0026 ctx-\u003epadding != RSA_PKCS_V15 )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    if( f_rng == NULL )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    olen = ctx-\u003elen;\n\n    if( olen \u003c ilen + 11 )\n        return( POLARSSL_ERR_RSA_BAD_INPUT_DATA );\n\n    nb_pad = olen - 3 - ilen;\n\n    *p++ = 0;\n    if( mode == RSA_PUBLIC )\n    {\n        *p++ = RSA_CRYPT;\n\n        while( nb_pad-- \u003e 0 )\n        {\n            int rng_dl = 100;\n\n            do {\n                ret = f_rng( p_rng, p, 1 );\n            } while( *p == 0 \u0026\u0026 --rng_dl \u0026\u0026 ret == 0 );\n\n            // Check if RNG failed to generate data\n            //\n            if( rng_dl == 0 || ret != 0 )\n                return( POLARSSL_ERR_RSA_RNG_FAILED + ret );\n\n            p++;\n        }\n    }\n    else\n    {\n        *p++ = RSA_SIGN;\n\n        while( nb_pad-- \u003e 0 )\n            *p++ = 0xFF;\n    }\n\n    *p++ = 0;\n    memcpy( p, input, ilen );\n\n    return( ( mode == RSA_PUBLIC )\n            ? rsa_public(  ctx, output, output )\n            : rsa_private( ctx, f_rng, p_rng, output, output ) );\n}","filepath":"library/rsa.c","line_number":569,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"476548":{"score":0.9233254,"function_name":"rsa_copy","code":"int rsa_copy( rsa_context *dst, const rsa_context *src )\n{\n    int ret;\n\n    dst-\u003ever = src-\u003ever;\n    dst-\u003elen = src-\u003elen;\n\n    MPI_CHK( mpi_copy( \u0026dst-\u003eN, \u0026src-\u003eN ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eE, \u0026src-\u003eE ) );\n\n    MPI_CHK( mpi_copy( \u0026dst-\u003eD, \u0026src-\u003eD ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eP, \u0026src-\u003eP ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eQ, \u0026src-\u003eQ ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eDP, \u0026src-\u003eDP ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eDQ, \u0026src-\u003eDQ ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eQP, \u0026src-\u003eQP ) );\n\n    MPI_CHK( mpi_copy( \u0026dst-\u003eRN, \u0026src-\u003eRN ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eRP, \u0026src-\u003eRP ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eRQ, \u0026src-\u003eRQ ) );\n\n    MPI_CHK( mpi_copy( \u0026dst-\u003eVi, \u0026src-\u003eVi ) );\n    MPI_CHK( mpi_copy( \u0026dst-\u003eVf, \u0026src-\u003eVf ) );\n\n    dst-\u003epadding = src-\u003epadding;\n    dst-\u003ehash_id = src-\u003ehash_id;\n\ncleanup:\n    if( ret != 0 )\n        rsa_free( dst );\n\n    return( ret );\n}","filepath":"library/rsa.c","line_number":1443,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"477190":{"score":0.7348558,"function_name":"rsa_free","code":"void rsa_free( rsa_context *ctx )\n{\n    mpi_free( \u0026ctx-\u003eVi ); mpi_free( \u0026ctx-\u003eVf );\n    mpi_free( \u0026ctx-\u003eRQ ); mpi_free( \u0026ctx-\u003eRP ); mpi_free( \u0026ctx-\u003eRN );\n    mpi_free( \u0026ctx-\u003eQP ); mpi_free( \u0026ctx-\u003eDQ ); mpi_free( \u0026ctx-\u003eDP );\n    mpi_free( \u0026ctx-\u003eQ  ); mpi_free( \u0026ctx-\u003eP  ); mpi_free( \u0026ctx-\u003eD );\n    mpi_free( \u0026ctx-\u003eE  ); mpi_free( \u0026ctx-\u003eN  );\n\n#if defined(POLARSSL_THREADING_C)\n    polarssl_mutex_free( \u0026ctx-\u003emutex );\n#endif\n}","filepath":"library/rsa.c","line_number":1480,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.13"},"477468":{"score":0.8247398,"function_name":"mbedtls_rsa_deduce_primes","code":"int mbedtls_rsa_deduce_primes( mbedtls_mpi const *N,\n                     mbedtls_mpi const *E, mbedtls_mpi const *D,\n                     mbedtls_mpi *P, mbedtls_mpi *Q )\n{\n    int ret = 0;\n\n    uint16_t attempt;  /* Number of current attempt  */\n    uint16_t iter;     /* Number of squares computed in the current attempt */\n\n    uint16_t order;    /* Order of 2 in DE - 1 */\n\n    mbedtls_mpi T;  /* Holds largest odd divisor of DE - 1     */\n    mbedtls_mpi K;  /* Temporary holding the current candidate */\n\n    const unsigned char primes[] = { 2,\n           3,    5,    7,   11,   13,   17,   19,   23,\n          29,   31,   37,   41,   43,   47,   53,   59,\n          61,   67,   71,   73,   79,   83,   89,   97,\n         101,  103,  107,  109,  113,  127,  131,  137,\n         139,  149,  151,  157,  163,  167,  173,  179,\n         181,  191,  193,  197,  199,  211,  223,  227,\n         229,  233,  239,  241,  251\n    };\n\n    const size_t num_primes = sizeof( primes ) / sizeof( *primes );\n\n    if( P == NULL || Q == NULL || P-\u003ep != NULL || Q-\u003ep != NULL )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    if( mbedtls_mpi_cmp_int( N, 0 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( D, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_mpi( D, N ) \u003e= 0 ||\n        mbedtls_mpi_cmp_int( E, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_mpi( E, N ) \u003e= 0 )\n    {\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n    }\n\n    /*\n     * Initializations and temporary changes\n     */\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026T );\n\n    /* T := DE - 1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026T, D,  E ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026T, \u0026T, 1 ) );\n\n    if( ( order = (uint16_t) mbedtls_mpi_lsb( \u0026T ) ) == 0 )\n    {\n        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n\n    /* After this operation, T holds the largest odd divisor of DE - 1. */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( \u0026T, order ) );\n\n    /*\n     * Actual work\n     */\n\n    /* Skip trying 2 if N == 1 mod 8 */\n    attempt = 0;\n    if( N-\u003ep[0] % 8 == 1 )\n        attempt = 1;\n\n    for( ; attempt \u003c num_primes; ++attempt )\n    {\n        mbedtls_mpi_lset( \u0026K, primes[attempt] );\n\n        /* Check if gcd(K,N) = 1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, \u0026K, N ) );\n        if( mbedtls_mpi_cmp_int( P, 1 ) != 0 )\n            continue;\n\n        /* Go through K^T + 1, K^(2T) + 1, K^(4T) + 1, ...\n         * and check whether they have nontrivial GCD with N. */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( \u0026K, \u0026K, \u0026T, N,\n                             Q /* temporarily use Q for storing Montgomery\n                                * multiplication helper values */ ) );\n\n        for( iter = 1; iter \u003c= order; ++iter )\n        {\n            /* If we reach 1 prematurely, there's no point\n             * in continuing to square K */\n            if( mbedtls_mpi_cmp_int( \u0026K, 1 ) == 0 )\n                break;\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( \u0026K, \u0026K, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( P, \u0026K, N ) );\n\n            if( mbedtls_mpi_cmp_int( P, 1 ) ==  1 \u0026\u0026\n                mbedtls_mpi_cmp_mpi( P, N ) == -1 )\n            {\n                /*\n                 * Have found a nontrivial divisor P of N.\n                 * Set Q := N / P.\n                 */\n\n                MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( Q, NULL, N, P ) );\n                goto cleanup;\n            }\n\n            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, \u0026K, \u0026K ) );\n            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, N ) );\n        }\n\n        /*\n         * If we get here, then either we prematurely aborted the loop because\n         * we reached 1, or K holds primes[attempt]^(DE - 1) mod N, which must\n         * be 1 if D,E,N were consistent.\n         * Check if that's the case and abort if not, to avoid very long,\n         * yet eventually failing, computations if N,D,E were not sane.\n         */\n        if( mbedtls_mpi_cmp_int( \u0026K, 1 ) != 0 )\n        {\n            break;\n        }\n    }\n\n    ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026T );\n    return( ret );\n}","filepath":"library/rsa_internal.c","line_number":95,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"478740":{"score":0.85237104,"function_name":"mbedtls_rsa_deduce_private_exponent","code":"int mbedtls_rsa_deduce_private_exponent( mbedtls_mpi const *P,\n                                         mbedtls_mpi const *Q,\n                                         mbedtls_mpi const *E,\n                                         mbedtls_mpi *D )\n{\n    int ret = 0;\n    mbedtls_mpi K, L;\n\n    if( D == NULL || mbedtls_mpi_cmp_int( D, 0 ) != 0 )\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n\n    if( mbedtls_mpi_cmp_int( P, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( Q, 1 ) \u003c= 0 ||\n        mbedtls_mpi_cmp_int( E, 0 ) == 0 )\n    {\n        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );\n    }\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /* Temporarily put K := P-1 and L := Q-1 */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1 ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, Q, 1 ) );\n\n    /* Temporarily put D := gcd(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( D, \u0026K, \u0026L ) );\n\n    /* K := LCM(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, \u0026K, \u0026L ) );\n    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( \u0026K, NULL, \u0026K, D ) );\n\n    /* Compute modular inverse of E in LCM(P-1, Q-1) */\n    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( D, E, \u0026K ) );\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    return( ret );\n}","filepath":"library/rsa_internal.c","line_number":230,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"479189":{"score":0.8449062,"function_name":"mbedtls_rsa_validate_crt","code":"int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,\n                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,\n                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )\n{\n    int ret = 0;\n\n    mbedtls_mpi K, L;\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /* Check that DP - D == 0 mod P - 1 */\n    if( DP != NULL )\n    {\n        if( P == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026L, DP, D ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026L, \u0026L, \u0026K ) );\n\n        if( mbedtls_mpi_cmp_int( \u0026L, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /* Check that DQ - D == 0 mod Q - 1 */\n    if( DQ != NULL )\n    {\n        if( Q == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, Q, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( \u0026L, DQ, D ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026L, \u0026L, \u0026K ) );\n\n        if( mbedtls_mpi_cmp_int( \u0026L, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /* Check that QP * Q - 1 == 0 mod P */\n    if( QP != NULL )\n    {\n        if( P == NULL || Q == NULL )\n        {\n            ret = MBEDTLS_ERR_RSA_BAD_INPUT_DATA;\n            goto cleanup;\n        }\n\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, QP, Q ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, P ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n\n    /* Wrap MPI error codes by RSA check failure error code */\n    if( ret != 0 \u0026\u0026\n        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED \u0026\u0026\n        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )\n    {\n        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n    }\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    return( ret );\n}","filepath":"library/rsa_internal.c","line_number":276,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"479888":{"score":0.86879504,"function_name":"mbedtls_rsa_validate_params","code":"int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,\n                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,\n                                 const mbedtls_mpi *E,\n                                 int (*f_rng)(void *, unsigned char *, size_t),\n                                 void *p_rng )\n{\n    int ret = 0;\n    mbedtls_mpi K, L;\n\n    mbedtls_mpi_init( \u0026K );\n    mbedtls_mpi_init( \u0026L );\n\n    /*\n     * Step 1: If PRNG provided, check that P and Q are prime\n     */\n\n#if defined(MBEDTLS_GENPRIME)\n    /*\n     * When generating keys, the strongest security we support aims for an error\n     * rate of at most 2^-100 and we are aiming for the same certainty here as\n     * well.\n     */\n    if( f_rng != NULL \u0026\u0026 P != NULL \u0026\u0026\n        ( ret = mbedtls_mpi_is_prime_ext( P, 50, f_rng, p_rng ) ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n        goto cleanup;\n    }\n\n    if( f_rng != NULL \u0026\u0026 Q != NULL \u0026\u0026\n        ( ret = mbedtls_mpi_is_prime_ext( Q, 50, f_rng, p_rng ) ) != 0 )\n    {\n        ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n        goto cleanup;\n    }\n#else\n    ((void) f_rng);\n    ((void) p_rng);\n#endif /* MBEDTLS_GENPRIME */\n\n    /*\n     * Step 2: Check that 1 \u003c N = P * Q\n     */\n\n    if( P != NULL \u0026\u0026 Q != NULL \u0026\u0026 N != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, P, Q ) );\n        if( mbedtls_mpi_cmp_int( N, 1 )  \u003c= 0 ||\n            mbedtls_mpi_cmp_mpi( \u0026K, N ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /*\n     * Step 3: Check and 1 \u003c D, E \u003c N if present.\n     */\n\n    if( N != NULL \u0026\u0026 D != NULL \u0026\u0026 E != NULL )\n    {\n        if ( mbedtls_mpi_cmp_int( D, 1 ) \u003c= 0 ||\n             mbedtls_mpi_cmp_int( E, 1 ) \u003c= 0 ||\n             mbedtls_mpi_cmp_mpi( D, N ) \u003e= 0 ||\n             mbedtls_mpi_cmp_mpi( E, N ) \u003e= 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\n    /*\n     * Step 4: Check that D, E are inverse modulo P-1 and Q-1\n     */\n\n    if( P != NULL \u0026\u0026 Q != NULL \u0026\u0026 D != NULL \u0026\u0026 E != NULL )\n    {\n        if( mbedtls_mpi_cmp_int( P, 1 ) \u003c= 0 ||\n            mbedtls_mpi_cmp_int( Q, 1 ) \u003c= 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n\n        /* Compute DE-1 mod P-1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, D, E ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, P, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, \u0026L ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n\n        /* Compute DE-1 mod Q-1 */\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( \u0026K, D, E ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, \u0026K, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026L, Q, 1 ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( \u0026K, \u0026K, \u0026L ) );\n        if( mbedtls_mpi_cmp_int( \u0026K, 0 ) != 0 )\n        {\n            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n            goto cleanup;\n        }\n    }\n\ncleanup:\n\n    mbedtls_mpi_free( \u0026K );\n    mbedtls_mpi_free( \u0026L );\n\n    /* Wrap MPI error codes by RSA check failure error code */\n    if( ret != 0 \u0026\u0026 ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )\n    {\n        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;\n    }\n\n    return( ret );\n}","filepath":"library/rsa_internal.c","line_number":364,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"480736":{"score":0.74595284,"function_name":"mbedtls_rsa_deduce_crt","code":"int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,\n                            const mbedtls_mpi *D, mbedtls_mpi *DP,\n                            mbedtls_mpi *DQ, mbedtls_mpi *QP )\n{\n    int ret = 0;\n    mbedtls_mpi K;\n    mbedtls_mpi_init( \u0026K );\n\n    /* DP = D mod P-1 */\n    if( DP != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, P, 1  ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, \u0026K ) );\n    }\n\n    /* DQ = D mod Q-1 */\n    if( DQ != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( \u0026K, Q, 1  ) );\n        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, \u0026K ) );\n    }\n\n    /* QP = Q^{-1} mod P */\n    if( QP != NULL )\n    {\n        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );\n    }\n\ncleanup:\n    mbedtls_mpi_free( \u0026K );\n\n    return( ret );\n}","filepath":"library/rsa_internal.c","line_number":485,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"v2.16.7"},"481180":{"score":0.91667324,"function_name":"mbedtls_sha1_starts_ret","code":"int mbedtls_sha1_starts_ret( mbedtls_sha1_context *ctx )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    ctx-\u003estate[0] = 0x67452301;\n    ctx-\u003estate[1] = 0xEFCDAB89;\n    ctx-\u003estate[2] = 0x98BADCFE;\n    ctx-\u003estate[3] = 0x10325476;\n    ctx-\u003estate[4] = 0xC3D2E1F0;\n\n    return( 0 );\n}","filepath":"external/mbedtls/sha1.c","line_number":118,"entry_url":"https://github.com/Samsung/TizenRT.git","slot_name":"3.0_GBM"},"487706":{"score":0.8886706,"function_name":"mbedtls_sha1_update_ret","code":"int mbedtls_sha1_update_ret( mbedtls_sha1_context *ctx,\n                             const unsigned char *input,\n                             size_t ilen )\n{\n    int ret;\n    size_t fill;\n    uint32_t left;\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = ctx-\u003etotal[0] \u0026 0x3F;\n    fill = 64 - left;\n\n    ctx-\u003etotal[0] += (uint32_t) ilen;\n    ctx-\u003etotal[0] \u0026= 0xFFFFFFFF;\n\n    if( ctx-\u003etotal[0] \u003c (uint32_t) ilen )\n        ctx-\u003etotal[1]++;\n\n    if( left \u0026\u0026 ilen \u003e= fill )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, fill );\n\n        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen \u003e= 64 )\n    {\n        if( ( ret = mbedtls_internal_sha1_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen \u003e 0 )\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, ilen );\n\n    return( 0 );\n}","filepath":"external/mbedtls/sha1.c","line_number":311,"entry_url":"https://github.com/Samsung/TizenRT.git","slot_name":"3.0_GBM"},"488044":{"score":0.8720926,"function_name":"mbedtls_sha1_finish_ret","code":"int mbedtls_sha1_finish_ret( mbedtls_sha1_context *ctx,\n                             unsigned char output[20] )\n{\n    int ret;\n    uint32_t used;\n    uint32_t high, low;\n\n    /*\n     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length\n     */\n    used = ctx-\u003etotal[0] \u0026 0x3F;\n\n    ctx-\u003ebuffer[used++] = 0x80;\n\n    if( used \u003c= 56 )\n    {\n        /* Enough room for padding + length in current block */\n        memset( ctx-\u003ebuffer + used, 0, 56 - used );\n    }\n    else\n    {\n        /* We'll need an extra block */\n        memset( ctx-\u003ebuffer + used, 0, 64 - used );\n\n        if( ( ret = mbedtls_internal_sha1_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        memset( ctx-\u003ebuffer, 0, 56 );\n    }\n\n    /*\n     * Add message length\n     */\n    high = ( ctx-\u003etotal[0] \u003e\u003e 29 )\n         | ( ctx-\u003etotal[1] \u003c\u003c  3 );\n    low  = ( ctx-\u003etotal[0] \u003c\u003c  3 );\n\n    PUT_UINT32_BE( high, ctx-\u003ebuffer, 56 );\n    PUT_UINT32_BE( low,  ctx-\u003ebuffer, 60 );\n\n    if( ( ret = mbedtls_internal_sha1_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n        return( ret );\n\n    /*\n     * Output final state\n     */\n    PUT_UINT32_BE( ctx-\u003estate[0], output,  0 );\n    PUT_UINT32_BE( ctx-\u003estate[1], output,  4 );\n    PUT_UINT32_BE( ctx-\u003estate[2], output,  8 );\n    PUT_UINT32_BE( ctx-\u003estate[3], output, 12 );\n    PUT_UINT32_BE( ctx-\u003estate[4], output, 16 );\n\n    return( 0 );\n}","filepath":"external/mbedtls/sha1.c","line_number":370,"entry_url":"https://github.com/Samsung/TizenRT.git","slot_name":"3.0_GBM"},"488803":{"score":0.8022437,"function_name":"mbedtls_sha1_ret","code":"int mbedtls_sha1_ret( const unsigned char *input,\n                      size_t ilen,\n                      unsigned char output[20] )\n{\n    int ret;\n    mbedtls_sha1_context ctx;\n\n    mbedtls_sha1_init( \u0026ctx );\n\n    if( ( ret = mbedtls_sha1_starts_ret( \u0026ctx ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_update_ret( \u0026ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha1_finish_ret( \u0026ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha1_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"external/mbedtls/sha1.c","line_number":438,"entry_url":"https://github.com/Samsung/TizenRT.git","slot_name":"3.0_GBM"},"489156":{"score":0.8991927,"function_name":"mbedtls_sha256_starts_ret","code":"int mbedtls_sha256_starts_ret( mbedtls_sha256_context *ctx, int is224 )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n\n    if( is224 == 0 )\n    {\n        /* SHA-256 */\n        ctx-\u003estate[0] = 0x6A09E667;\n        ctx-\u003estate[1] = 0xBB67AE85;\n        ctx-\u003estate[2] = 0x3C6EF372;\n        ctx-\u003estate[3] = 0xA54FF53A;\n        ctx-\u003estate[4] = 0x510E527F;\n        ctx-\u003estate[5] = 0x9B05688C;\n        ctx-\u003estate[6] = 0x1F83D9AB;\n        ctx-\u003estate[7] = 0x5BE0CD19;\n    }\n    else\n    {\n        /* SHA-224 */\n        ctx-\u003estate[0] = 0xC1059ED8;\n        ctx-\u003estate[1] = 0x367CD507;\n        ctx-\u003estate[2] = 0x3070DD17;\n        ctx-\u003estate[3] = 0xF70E5939;\n        ctx-\u003estate[4] = 0xFFC00B31;\n        ctx-\u003estate[5] = 0x68581511;\n        ctx-\u003estate[6] = 0x64F98FA7;\n        ctx-\u003estate[7] = 0xBEFA4FA4;\n    }\n\n    ctx-\u003eis224 = is224;\n\n    return( 0 );\n}","filepath":"library/sha256.c","line_number":128,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.18"},"489402":{"score":0.75178665,"function_name":"mbedtls_internal_sha256_process","code":"int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx,\n                                const unsigned char data[64] )\n{\n    struct\n    {\n        uint32_t temp1, temp2, W[64];\n        uint32_t A[8];\n    } local;\n\n    unsigned int i;\n\n    for( i = 0; i \u003c 8; i++ )\n        local.A[i] = ctx-\u003estate[i];\n\n#if defined(MBEDTLS_SHA256_SMALLER)\n    for( i = 0; i \u003c 64; i++ )\n    {\n        if( i \u003c 16 )\n            GET_UINT32_BE( local.W[i], data, 4 * i );\n        else\n            R( i );\n\n        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],\n           local.A[5], local.A[6], local.A[7], local.W[i], K[i] );\n\n        local.temp1 = local.A[7]; local.A[7] = local.A[6];\n        local.A[6] = local.A[5]; local.A[5] = local.A[4];\n        local.A[4] = local.A[3]; local.A[3] = local.A[2];\n        local.A[2] = local.A[1]; local.A[1] = local.A[0];\n        local.A[0] = local.temp1;\n    }\n#else /* MBEDTLS_SHA256_SMALLER */\n    for( i = 0; i \u003c 16; i++ )\n        GET_UINT32_BE( local.W[i], data, 4 * i );\n\n    for( i = 0; i \u003c 16; i += 8 )\n    {\n        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],\n           local.A[5], local.A[6], local.A[7], local.W[i+0], K[i+0] );\n        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],\n           local.A[4], local.A[5], local.A[6], local.W[i+1], K[i+1] );\n        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],\n           local.A[3], local.A[4], local.A[5], local.W[i+2], K[i+2] );\n        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],\n           local.A[2], local.A[3], local.A[4], local.W[i+3], K[i+3] );\n        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],\n           local.A[1], local.A[2], local.A[3], local.W[i+4], K[i+4] );\n        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],\n           local.A[0], local.A[1], local.A[2], local.W[i+5], K[i+5] );\n        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],\n           local.A[7], local.A[0], local.A[1], local.W[i+6], K[i+6] );\n        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],\n           local.A[6], local.A[7], local.A[0], local.W[i+7], K[i+7] );\n    }\n\n    for( i = 16; i \u003c 64; i += 8 )\n    {\n        P( local.A[0], local.A[1], local.A[2], local.A[3], local.A[4],\n           local.A[5], local.A[6], local.A[7], R(i+0), K[i+0] );\n        P( local.A[7], local.A[0], local.A[1], local.A[2], local.A[3],\n           local.A[4], local.A[5], local.A[6], R(i+1), K[i+1] );\n        P( local.A[6], local.A[7], local.A[0], local.A[1], local.A[2],\n           local.A[3], local.A[4], local.A[5], R(i+2), K[i+2] );\n        P( local.A[5], local.A[6], local.A[7], local.A[0], local.A[1],\n           local.A[2], local.A[3], local.A[4], R(i+3), K[i+3] );\n        P( local.A[4], local.A[5], local.A[6], local.A[7], local.A[0],\n           local.A[1], local.A[2], local.A[3], R(i+4), K[i+4] );\n        P( local.A[3], local.A[4], local.A[5], local.A[6], local.A[7],\n           local.A[0], local.A[1], local.A[2], R(i+5), K[i+5] );\n        P( local.A[2], local.A[3], local.A[4], local.A[5], local.A[6],\n           local.A[7], local.A[0], local.A[1], R(i+6), K[i+6] );\n        P( local.A[1], local.A[2], local.A[3], local.A[4], local.A[5],\n           local.A[6], local.A[7], local.A[0], R(i+7), K[i+7] );\n    }\n#endif /* MBEDTLS_SHA256_SMALLER */\n\n    for( i = 0; i \u003c 8; i++ )\n        ctx-\u003estate[i] += local.A[i];\n\n    /* Zeroise buffers and variables to clear sensitive data from memory. */\n    mbedtls_zeroize( \u0026local, sizeof( local ) );\n\n    return( 0 );\n}","filepath":"library/sha256.c","line_number":217,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.18"},"495101":{"score":0.88497186,"function_name":"mbedtls_sha256_update_ret","code":"int mbedtls_sha256_update_ret( mbedtls_sha256_context *ctx,\n                               const unsigned char *input,\n                               size_t ilen )\n{\n    int ret;\n    size_t fill;\n    uint32_t left;\n\n    if( ilen == 0 )\n        return( 0 );\n\n    left = ctx-\u003etotal[0] \u0026 0x3F;\n    fill = 64 - left;\n\n    ctx-\u003etotal[0] += (uint32_t) ilen;\n    ctx-\u003etotal[0] \u0026= 0xFFFFFFFF;\n\n    if( ctx-\u003etotal[0] \u003c (uint32_t) ilen )\n        ctx-\u003etotal[1]++;\n\n    if( left \u0026\u0026 ilen \u003e= fill )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, fill );\n\n        if( ( ret = mbedtls_internal_sha256_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        input += fill;\n        ilen  -= fill;\n        left = 0;\n    }\n\n    while( ilen \u003e= 64 )\n    {\n        if( ( ret = mbedtls_internal_sha256_process( ctx, input ) ) != 0 )\n            return( ret );\n\n        input += 64;\n        ilen  -= 64;\n    }\n\n    if( ilen \u003e 0 )\n        memcpy( (void *) (ctx-\u003ebuffer + left), input, ilen );\n\n    return( 0 );\n}","filepath":"library/sha256.c","line_number":314,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.18"},"495439":{"score":0.85838985,"function_name":"mbedtls_sha256_finish_ret","code":"int mbedtls_sha256_finish_ret( mbedtls_sha256_context *ctx,\n                               unsigned char output[32] )\n{\n    int ret;\n    uint32_t used;\n    uint32_t high, low;\n\n    /*\n     * Add padding: 0x80 then 0x00 until 8 bytes remain for the length\n     */\n    used = ctx-\u003etotal[0] \u0026 0x3F;\n\n    ctx-\u003ebuffer[used++] = 0x80;\n\n    if( used \u003c= 56 )\n    {\n        /* Enough room for padding + length in current block */\n        memset( ctx-\u003ebuffer + used, 0, 56 - used );\n    }\n    else\n    {\n        /* We'll need an extra block */\n        memset( ctx-\u003ebuffer + used, 0, 64 - used );\n\n        if( ( ret = mbedtls_internal_sha256_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n            return( ret );\n\n        memset( ctx-\u003ebuffer, 0, 56 );\n    }\n\n    /*\n     * Add message length\n     */\n    high = ( ctx-\u003etotal[0] \u003e\u003e 29 )\n         | ( ctx-\u003etotal[1] \u003c\u003c  3 );\n    low  = ( ctx-\u003etotal[0] \u003c\u003c  3 );\n\n    PUT_UINT32_BE( high, ctx-\u003ebuffer, 56 );\n    PUT_UINT32_BE( low,  ctx-\u003ebuffer, 60 );\n\n    if( ( ret = mbedtls_internal_sha256_process( ctx, ctx-\u003ebuffer ) ) != 0 )\n        return( ret );\n\n    /*\n     * Output final state\n     */\n    PUT_UINT32_BE( ctx-\u003estate[0], output,  0 );\n    PUT_UINT32_BE( ctx-\u003estate[1], output,  4 );\n    PUT_UINT32_BE( ctx-\u003estate[2], output,  8 );\n    PUT_UINT32_BE( ctx-\u003estate[3], output, 12 );\n    PUT_UINT32_BE( ctx-\u003estate[4], output, 16 );\n    PUT_UINT32_BE( ctx-\u003estate[5], output, 20 );\n    PUT_UINT32_BE( ctx-\u003estate[6], output, 24 );\n\n    if( ctx-\u003eis224 == 0 )\n        PUT_UINT32_BE( ctx-\u003estate[7], output, 28 );\n\n    return( 0 );\n}","filepath":"library/sha256.c","line_number":373,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.18"},"496421":{"score":0.7455777,"function_name":"mbedtls_sha256_ret","code":"int mbedtls_sha256_ret( const unsigned char *input,\n                        size_t ilen,\n                        unsigned char output[32],\n                        int is224 )\n{\n    int ret;\n    mbedtls_sha256_context ctx;\n\n    mbedtls_sha256_init( \u0026ctx );\n\n    if( ( ret = mbedtls_sha256_starts_ret( \u0026ctx, is224 ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha256_update_ret( \u0026ctx, input, ilen ) ) != 0 )\n        goto exit;\n\n    if( ( ret = mbedtls_sha256_finish_ret( \u0026ctx, output ) ) != 0 )\n        goto exit;\n\nexit:\n    mbedtls_sha256_free( \u0026ctx );\n\n    return( ret );\n}","filepath":"library/sha256.c","line_number":446,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-2.7.18"},"496654":{"score":0.9003141,"function_name":"ssl_list_ciphersuites","code":"const int *ssl_list_ciphersuites( void )\n{\n    /*\n     * On initial call filter out all ciphersuites not supported by current\n     * build based on presence in the ciphersuite_definitions.\n     */\n    if( supported_init == 0 )\n    {\n        const int *p;\n        int *q;\n\n        for( p = ciphersuite_preference, q = supported_ciphersuites;\n             *p != 0 \u0026\u0026 q \u003c supported_ciphersuites + MAX_CIPHERSUITES - 1;\n             p++ )\n        {\n#if defined(POLARSSL_REMOVE_ARC4_CIPHERSUITES)\n            const ssl_ciphersuite_t *cs_info;\n            if( ( cs_info = ssl_ciphersuite_from_id( *p ) ) != NULL \u0026\u0026\n                cs_info-\u003ecipher != POLARSSL_CIPHER_ARC4_128 )\n#else\n            if( ssl_ciphersuite_from_id( *p ) != NULL )\n#endif\n                *(q++) = *p;\n        }\n        *q = 0;\n\n        supported_init = 1;\n    }\n\n    return( supported_ciphersuites );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1693,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496793":{"score":0.8838594,"function_name":"ssl_ciphersuite_from_string","code":"const ssl_ciphersuite_t *ssl_ciphersuite_from_string(\n                                                const char *ciphersuite_name )\n{\n    const ssl_ciphersuite_t *cur = ciphersuite_definitions;\n\n    if( NULL == ciphersuite_name )\n        return( NULL );\n\n    while( cur-\u003eid != 0 )\n    {\n        if( 0 == strcasecmp( cur-\u003ename, ciphersuite_name ) )\n            return( cur );\n\n        cur++;\n    }\n\n    return( NULL );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1726,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496886":{"score":0.78386277,"function_name":"ssl_ciphersuite_from_id","code":"const ssl_ciphersuite_t *ssl_ciphersuite_from_id( int ciphersuite )\n{\n    const ssl_ciphersuite_t *cur = ciphersuite_definitions;\n\n    while( cur-\u003eid != 0 )\n    {\n        if( cur-\u003eid == ciphersuite )\n            return( cur );\n\n        cur++;\n    }\n\n    return( NULL );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1745,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"496948":{"score":0.891251,"function_name":"ssl_get_ciphersuite_name","code":"const char *ssl_get_ciphersuite_name( const int ciphersuite_id )\n{\n    const ssl_ciphersuite_t *cur;\n\n    cur = ssl_ciphersuite_from_id( ciphersuite_id );\n\n    if( cur == NULL )\n        return( \"unknown\" );\n\n    return( cur-\u003ename );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1760,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497005":{"score":0.6609197,"function_name":"ssl_get_ciphersuite_id","code":"int ssl_get_ciphersuite_id( const char *ciphersuite_name )\n{\n    const ssl_ciphersuite_t *cur;\n\n    cur = ssl_ciphersuite_from_string( ciphersuite_name );\n\n    if( cur == NULL )\n        return( 0 );\n\n    return( cur-\u003eid );\n}","filepath":"library/ssl_ciphersuites.c","line_number":1772,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497058":{"score":0.8268961,"function_name":"ssl_get_ciphersuite_sig_pk_alg","code":"pk_type_t ssl_get_ciphersuite_sig_pk_alg( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_RSA:\n        case POLARSSL_KEY_EXCHANGE_DHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_RSA_PSK:\n            return( POLARSSL_PK_RSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDHE_ECDSA:\n            return( POLARSSL_PK_ECDSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDH_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDH_ECDSA:\n            return( POLARSSL_PK_ECKEY );\n\n        default:\n            return( POLARSSL_PK_NONE );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1785,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497124":{"score":0.81026065,"function_name":"ssl_get_ciphersuite_sig_alg","code":"pk_type_t ssl_get_ciphersuite_sig_alg( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_RSA:\n        case POLARSSL_KEY_EXCHANGE_DHE_RSA:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_RSA:\n            return( POLARSSL_PK_RSA );\n\n        case POLARSSL_KEY_EXCHANGE_ECDHE_ECDSA:\n            return( POLARSSL_PK_ECDSA );\n\n        default:\n            return( POLARSSL_PK_NONE );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1807,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497232":{"score":0.8474088,"function_name":"ssl_ciphersuite_uses_psk","code":"int ssl_ciphersuite_uses_psk( const ssl_ciphersuite_t *info )\n{\n    switch( info-\u003ekey_exchange )\n    {\n        case POLARSSL_KEY_EXCHANGE_PSK:\n        case POLARSSL_KEY_EXCHANGE_RSA_PSK:\n        case POLARSSL_KEY_EXCHANGE_DHE_PSK:\n        case POLARSSL_KEY_EXCHANGE_ECDHE_PSK:\n            return( 1 );\n\n        default:\n            return( 0 );\n    }\n}","filepath":"library/ssl_ciphersuites.c","line_number":1845,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.20"},"497484":{"score":0.7573174,"function_name":"ssl_write_session_ticket_ext","code":"static void ssl_write_session_ticket_ext( ssl_context *ssl,\n                                          unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n    size_t tlen = ssl-\u003esession_negotiate-\u003eticket_len;\n\n    *olen = 0;\n\n    if( ssl-\u003esession_tickets == SSL_SESSION_TICKETS_DISABLED )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding session ticket extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 4 + tlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SESSION_TICKET      ) \u0026 0xFF );\n\n    *p++ = (unsigned char)( ( tlen \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( tlen      ) \u0026 0xFF );\n\n    *olen = 4;\n\n    if( ssl-\u003esession_negotiate-\u003eticket == NULL ||\n        ssl-\u003esession_negotiate-\u003eticket_len == 0 )\n    {\n        return;\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"sending session ticket of length %d\", tlen ) );\n\n    memcpy( p, ssl-\u003esession_negotiate-\u003eticket, tlen );\n\n    *olen += tlen;\n}","filepath":"library/ssl_cli.c","line_number":534,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"498181":{"score":0.66259027,"function_name":"ssl_write_alpn_ext","code":"static void ssl_write_alpn_ext( ssl_context *ssl,\n                                unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n    size_t alpnlen = 0;\n    const char **cur;\n\n    *olen = 0;\n\n    if( ssl-\u003ealpn_list == NULL )\n        return;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding alpn extension\" ) );\n\n    for( cur = ssl-\u003ealpn_list; *cur != NULL; cur++ )\n        alpnlen += (unsigned char)( strlen( *cur ) \u0026 0xFF ) + 1;\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 6 + alpnlen )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_ALPN \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_ALPN      ) \u0026 0xFF );\n\n    /*\n     * opaque ProtocolName\u003c1..2^8-1\u003e;\n     *\n     * struct {\n     *     ProtocolName protocol_name_list\u003c2..2^16-1\u003e\n     * } ProtocolNameList;\n     */\n\n    /* Skip writing extension and list length for now */\n    p += 4;\n\n    for( cur = ssl-\u003ealpn_list; *cur != NULL; cur++ )\n    {\n        *p = (unsigned char)( strlen( *cur ) \u0026 0xFF );\n        memcpy( p + 1, *cur, *p );\n        p += 1 + *p;\n    }\n\n    *olen = p - buf;\n\n    /* List length = olen - 2 (ext_type) - 2 (ext_len) - 2 (list_len) */\n    buf[4] = (unsigned char)( ( ( *olen - 6 ) \u003e\u003e 8 ) \u0026 0xFF );\n    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) \u0026 0xFF );\n\n    /* Extension length = olen - 2 (ext_type) - 2 (ext_len) */\n    buf[2] = (unsigned char)( ( ( *olen - 4 ) \u003e\u003e 8 ) \u0026 0xFF );\n    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) \u0026 0xFF );\n}","filepath":"library/ssl_cli.c","line_number":577,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"498587":{"score":0.6759732,"function_name":"ssl_write_supported_point_formats_ext","code":"static void ssl_write_supported_point_formats_ext( ssl_context *ssl,\n                                                   unsigned char *buf,\n                                                   size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding supported_point_formats extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 6 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_SUPPORTED_POINT_FORMATS \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_SUPPORTED_POINT_FORMATS      ) \u0026 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 2;\n\n    *p++ = 1;\n    *p++ = POLARSSL_ECP_PF_UNCOMPRESSED;\n\n    *olen = 6;\n}","filepath":"library/ssl_cli.c","line_number":372,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"498744":{"score":0.69807076,"function_name":"ssl_write_extended_ms_ext","code":"static void ssl_write_extended_ms_ext( ssl_context *ssl,\n                                       unsigned char *buf, size_t *olen )\n{\n    unsigned char *p = buf;\n    const unsigned char *end = ssl-\u003eout_msg + SSL_MAX_CONTENT_LEN;\n\n    *olen = 0;\n\n    if( ssl-\u003eextended_ms == SSL_EXTENDED_MS_DISABLED ||\n        ssl-\u003emax_minor_ver == SSL_MINOR_VERSION_0 )\n    {\n        return;\n    }\n\n    SSL_DEBUG_MSG( 3, ( \"client hello, adding extended_master_secret \"\n                        \"extension\" ) );\n\n    if( end \u003c p || (size_t)( end - p ) \u003c 4 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small\" ) );\n        return;\n    }\n\n    *p++ = (unsigned char)( ( TLS_EXT_EXTENDED_MASTER_SECRET \u003e\u003e 8 ) \u0026 0xFF );\n    *p++ = (unsigned char)( ( TLS_EXT_EXTENDED_MASTER_SECRET      ) \u0026 0xFF );\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}","filepath":"library/ssl_cli.c","line_number":500,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"500264":{"score":0.5907979,"function_name":"ssl_parse_truncated_hmac_ext","code":"static int ssl_parse_truncated_hmac_ext( ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl-\u003etrunc_hmac == SSL_TRUNC_HMAC_DISABLED ||\n        len != 0 )\n    {\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl-\u003esession_negotiate-\u003etrunc_hmac = SSL_TRUNC_HMAC_ENABLED;\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":985,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"500347":{"score":0.7698943,"function_name":"ssl_parse_encrypt_then_mac_ext","code":"static int ssl_parse_encrypt_then_mac_ext( ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n    if( ssl-\u003eencrypt_then_mac == SSL_ETM_DISABLED ||\n        ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 ||\n        len != 0 )\n    {\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    ((void) buf);\n\n    ssl-\u003esession_negotiate-\u003eencrypt_then_mac = SSL_ETM_ENABLED;\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":1004,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"500449":{"score":0.6759175,"function_name":"ssl_parse_supported_point_formats_ext","code":"static int ssl_parse_supported_point_formats_ext( ssl_context *ssl,\n                                                  const unsigned char *buf,\n                                                  size_t len )\n{\n    size_t list_size;\n    const unsigned char *p;\n\n    list_size = buf[0];\n    if( list_size + 1 != len )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad server hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n    }\n\n    p = buf + 1;\n    while( list_size \u003e 0 )\n    {\n        if( p[0] == POLARSSL_ECP_PF_UNCOMPRESSED ||\n            p[0] == POLARSSL_ECP_PF_COMPRESSED )\n        {\n            ssl-\u003ehandshake-\u003eecdh_ctx.point_format = p[0];\n            SSL_DEBUG_MSG( 4, ( \"point format selected: %d\", p[0] ) );\n            return( 0 );\n        }\n\n        list_size--;\n        p++;\n    }\n\n    SSL_DEBUG_MSG( 1, ( \"no point format in common\" ) );\n    return( POLARSSL_ERR_SSL_BAD_HS_SERVER_HELLO );\n}","filepath":"library/ssl_cli.c","line_number":1063,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"502402":{"score":0.6613143,"function_name":"ssl_write_encrypted_pms","code":"static int ssl_write_encrypted_pms( ssl_context *ssl,\n                                    size_t offset, size_t *olen,\n                                    size_t pms_offset )\n{\n    int ret;\n    size_t len_bytes = ssl-\u003eminor_ver == SSL_MINOR_VERSION_0 ? 0 : 2;\n    unsigned char *p = ssl-\u003ehandshake-\u003epremaster + pms_offset;\n\n    if( offset + len_bytes \u003e SSL_MAX_CONTENT_LEN )\n    {\n        SSL_DEBUG_MSG( 1, ( \"buffer too small for encrypted pms\" ) );\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    }\n\n    /*\n     * Generate (part of) the pre-master as\n     *  struct {\n     *      ProtocolVersion client_version;\n     *      opaque random[46];\n     *  } PreMasterSecret;\n     */\n    p[0] = (unsigned char) ssl-\u003emax_major_ver;\n    p[1] = (unsigned char) ssl-\u003emax_minor_ver;\n\n    if( ( ret = ssl-\u003ef_rng( ssl-\u003ep_rng, p + 2, 46 ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"f_rng\", ret );\n        return( ret );\n    }\n\n    ssl-\u003ehandshake-\u003epmslen = 48;\n\n    if( ssl-\u003esession_negotiate-\u003epeer_cert == NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"certificate required\" ) );\n        return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n    }\n\n    /*\n     * Now write it out, encrypted\n     */\n    if( ! pk_can_do( \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk,\n                POLARSSL_PK_RSA ) )\n    {\n        SSL_DEBUG_MSG( 1, ( \"certificate key type mismatch\" ) );\n        return( POLARSSL_ERR_SSL_PK_TYPE_MISMATCH );\n    }\n\n    if( ( ret = pk_encrypt( \u0026ssl-\u003esession_negotiate-\u003epeer_cert-\u003epk,\n                            p, ssl-\u003ehandshake-\u003epmslen,\n                            ssl-\u003eout_msg + offset + len_bytes, olen,\n                            SSL_MAX_CONTENT_LEN - offset - len_bytes,\n                            ssl-\u003ef_rng, ssl-\u003ep_rng ) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"rsa_pkcs1_encrypt\", ret );\n        return( ret );\n    }\n\n#if defined(POLARSSL_SSL_PROTO_TLS1) || defined(POLARSSL_SSL_PROTO_TLS1_1) || \\\n    defined(POLARSSL_SSL_PROTO_TLS1_2)\n    if( len_bytes == 2 )\n    {\n        ssl-\u003eout_msg[offset+0] = (unsigned char)( *olen \u003e\u003e 8 );\n        ssl-\u003eout_msg[offset+1] = (unsigned char)( *olen      );\n        *olen += 2;\n    }\n#endif\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":1704,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"503176":{"score":0.57069063,"function_name":"ssl_parse_certificate_request","code":"static int ssl_parse_certificate_request( ssl_context *ssl )\n{\n    int ret;\n    unsigned char *buf, *p;\n    size_t n = 0, m = 0;\n    size_t cert_type_len = 0, dn_len = 0;\n    const ssl_ciphersuite_t *ciphersuite_info = ssl-\u003etransform_negotiate-\u003eciphersuite_info;\n\n    SSL_DEBUG_MSG( 2, ( \"=\u003e parse certificate request\" ) );\n\n    if( ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_RSA_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_DHE_PSK ||\n        ciphersuite_info-\u003ekey_exchange == POLARSSL_KEY_EXCHANGE_ECDHE_PSK )\n    {\n        SSL_DEBUG_MSG( 2, ( \"\u003c= skip parse certificate request\" ) );\n        ssl-\u003estate++;\n        return( 0 );\n    }\n\n    /*\n     *     0  .   0   handshake type\n     *     1  .   3   handshake length\n     *     4  .   4   cert type count\n     *     5  .. m-1  cert types\n     *     m  .. m+1  sig alg length (TLS 1.2 only)\n     *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)\n     *     n  .. n+1  length of all DNs\n     *    n+2 .. n+3  length of DN 1\n     *    n+4 .. ...  Distinguished Name #1\n     *    ... .. ...  length of DN 2, etc.\n     */\n    if( ssl-\u003erecord_read == 0 )\n    {\n        if( ( ret = ssl_read_record( ssl ) ) != 0 )\n        {\n            SSL_DEBUG_RET( 1, \"ssl_read_record\", ret );\n            return( ret );\n        }\n\n        if( ssl-\u003ein_msgtype != SSL_MSG_HANDSHAKE )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n            return( POLARSSL_ERR_SSL_UNEXPECTED_MESSAGE );\n        }\n\n        ssl-\u003erecord_read = 1;\n    }\n\n    ssl-\u003eclient_auth = 0;\n    ssl-\u003estate++;\n\n    if( ssl-\u003ein_msg[0] == SSL_HS_CERTIFICATE_REQUEST )\n        ssl-\u003eclient_auth++;\n\n    SSL_DEBUG_MSG( 3, ( \"got %s certificate request\",\n                        ssl-\u003eclient_auth ? \"a\" : \"no\" ) );\n\n    if( ssl-\u003eclient_auth == 0 )\n        goto exit;\n\n    ssl-\u003erecord_read = 0;\n\n    // TODO: handshake_failure alert for an anonymous server to request\n    // client authentication\n\n    buf = ssl-\u003ein_msg;\n\n    // Retrieve cert types\n    //\n    cert_type_len = buf[4];\n    n = cert_type_len;\n\n    if( ssl-\u003ein_hslen \u003c 6 + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\n    p = buf + 5;\n    while( cert_type_len \u003e 0 )\n    {\n#if defined(POLARSSL_RSA_C)\n        if( *p == SSL_CERT_TYPE_RSA_SIGN \u0026\u0026\n            pk_can_do( ssl_own_key( ssl ), POLARSSL_PK_RSA ) )\n        {\n            ssl-\u003ehandshake-\u003ecert_type = SSL_CERT_TYPE_RSA_SIGN;\n            break;\n        }\n        else\n#endif\n#if defined(POLARSSL_ECDSA_C)\n        if( *p == SSL_CERT_TYPE_ECDSA_SIGN \u0026\u0026\n            pk_can_do( ssl_own_key( ssl ), POLARSSL_PK_ECDSA ) )\n        {\n            ssl-\u003ehandshake-\u003ecert_type = SSL_CERT_TYPE_ECDSA_SIGN;\n            break;\n        }\n        else\n#endif\n        {\n            ; /* Unsupported cert type, ignore */\n        }\n\n        cert_type_len--;\n        p++;\n    }\n\n#if defined(POLARSSL_SSL_PROTO_TLS1_2)\n    if( ssl-\u003eminor_ver == SSL_MINOR_VERSION_3 )\n    {\n        /* Ignored, see comments about hash in write_certificate_verify */\n        // TODO: should check the signature part against our pk_key though\n        size_t sig_alg_len = ( ( buf[5 + n] \u003c\u003c  8 )\n                             | ( buf[6 + n]       ) );\n\n        p = buf + 7 + n;\n        m += 2;\n        n += sig_alg_len;\n\n        if( ssl-\u003ein_hslen \u003c 6 + n )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n        }\n    }\n#endif /* POLARSSL_SSL_PROTO_TLS1_2 */\n\n    /* Ignore certificate_authorities, we only have one cert anyway */\n    // TODO: should not send cert if no CA matches\n    dn_len = ( ( buf[5 + m + n] \u003c\u003c  8 )\n             | ( buf[6 + m + n]       ) );\n\n    n += dn_len;\n    if( ssl-\u003ein_hslen != 7 + m + n )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad certificate request message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE_REQUEST );\n    }\n\nexit:\n    SSL_DEBUG_MSG( 2, ( \"\u003c= parse certificate request\" ) );\n\n    return( 0 );\n}","filepath":"library/ssl_cli.c","line_number":2224,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"505002":{"score":0.7330592,"function_name":"ssl_handshake_client_step","code":"int ssl_handshake_client_step( ssl_context *ssl )\n{\n    int ret = 0;\n\n    if( ssl-\u003estate == SSL_HANDSHAKE_OVER )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n\n    SSL_DEBUG_MSG( 2, ( \"client state: %d\", ssl-\u003estate ) );\n\n    if( ( ret = ssl_flush_output( ssl ) ) != 0 )\n        return( ret );\n\n    switch( ssl-\u003estate )\n    {\n        case SSL_HELLO_REQUEST:\n            ssl-\u003estate = SSL_CLIENT_HELLO;\n            break;\n\n       /*\n        *  ==\u003e   ClientHello\n        */\n       case SSL_CLIENT_HELLO:\n           ret = ssl_write_client_hello( ssl );\n           break;\n\n       /*\n        *  \u003c==   ServerHello\n        *        Certificate\n        *      ( ServerKeyExchange  )\n        *      ( CertificateRequest )\n        *        ServerHelloDone\n        */\n       case SSL_SERVER_HELLO:\n           ret = ssl_parse_server_hello( ssl );\n           break;\n\n       case SSL_SERVER_CERTIFICATE:\n           ret = ssl_parse_certificate( ssl );\n           break;\n\n       case SSL_SERVER_KEY_EXCHANGE:\n           ret = ssl_parse_server_key_exchange( ssl );\n           break;\n\n       case SSL_CERTIFICATE_REQUEST:\n           ret = ssl_parse_certificate_request( ssl );\n           break;\n\n       case SSL_SERVER_HELLO_DONE:\n           ret = ssl_parse_server_hello_done( ssl );\n           break;\n\n       /*\n        *  ==\u003e ( Certificate/Alert  )\n        *        ClientKeyExchange\n        *      ( CertificateVerify  )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n       case SSL_CLIENT_CERTIFICATE:\n           ret = ssl_write_certificate( ssl );\n           break;\n\n       case SSL_CLIENT_KEY_EXCHANGE:\n           ret = ssl_write_client_key_exchange( ssl );\n           break;\n\n       case SSL_CERTIFICATE_VERIFY:\n           ret = ssl_write_certificate_verify( ssl );\n           break;\n\n       case SSL_CLIENT_CHANGE_CIPHER_SPEC:\n           ret = ssl_write_change_cipher_spec( ssl );\n           break;\n\n       case SSL_CLIENT_FINISHED:\n           ret = ssl_write_finished( ssl );\n           break;\n\n       /*\n        *  \u003c==   ( NewSessionTicket )\n        *        ChangeCipherSpec\n        *        Finished\n        */\n       case SSL_SERVER_CHANGE_CIPHER_SPEC:\n#if defined(POLARSSL_SSL_SESSION_TICKETS)\n           if( ssl-\u003ehandshake-\u003enew_session_ticket != 0 )\n               ret = ssl_parse_new_session_ticket( ssl );\n           else\n#endif\n               ret = ssl_parse_change_cipher_spec( ssl );\n           break;\n\n       case SSL_SERVER_FINISHED:\n           ret = ssl_parse_finished( ssl );\n           break;\n\n       case SSL_FLUSH_BUFFERS:\n           SSL_DEBUG_MSG( 2, ( \"handshake: done\" ) );\n           ssl-\u003estate = SSL_HANDSHAKE_WRAPUP;\n           break;\n\n       case SSL_HANDSHAKE_WRAPUP:\n           ssl_handshake_wrapup( ssl );\n           break;\n\n       default:\n           SSL_DEBUG_MSG( 1, ( \"invalid state %d\", ssl-\u003estate ) );\n           return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n   }\n\n    return( ret );\n}","filepath":"library/ssl_cli.c","line_number":2920,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.16"},"505447":{"score":0.90567267,"function_name":"x509_get_serial","code":"int x509_get_serial( unsigned char **p, const unsigned char *end,\n                     x509_buf *serial )\n{\n    int ret;\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_X509_INVALID_SERIAL +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != ( ASN1_CONTEXT_SPECIFIC | ASN1_PRIMITIVE | 2 ) \u0026\u0026\n        **p !=   ASN1_INTEGER )\n        return( POLARSSL_ERR_X509_INVALID_SERIAL +\n                POLARSSL_ERR_ASN1_UNEXPECTED_TAG );\n\n    serial-\u003etag = *(*p)++;\n\n    if( ( ret = asn1_get_len( p, end, \u0026serial-\u003elen ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_SERIAL + ret );\n\n    serial-\u003ep = *p;\n    *p += serial-\u003elen;\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":84,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"505630":{"score":0.6628112,"function_name":"x509_get_alg_null","code":"int x509_get_alg_null( unsigned char **p, const unsigned char *end,\n                       x509_buf *alg )\n{\n    int ret;\n\n    if( ( ret = asn1_get_alg_null( p, end, alg ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_ALG + ret );\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":115,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"505766":{"score":0.89642864,"function_name":"x509_get_attr_type_value","code":"static int x509_get_attr_type_value( unsigned char **p,\n                                     const unsigned char *end,\n                                     x509_name *cur )\n{\n    int ret;\n    size_t len;\n    x509_buf *oid;\n    x509_buf *val;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_X509_INVALID_NAME +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    oid = \u0026cur-\u003eoid;\n    oid-\u003etag = **p;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026oid-\u003elen, ASN1_OID ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n\n    oid-\u003ep = *p;\n    *p += oid-\u003elen;\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_X509_INVALID_NAME +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    if( **p != ASN1_BMP_STRING \u0026\u0026 **p != ASN1_UTF8_STRING      \u0026\u0026\n        **p != ASN1_T61_STRING \u0026\u0026 **p != ASN1_PRINTABLE_STRING \u0026\u0026\n        **p != ASN1_IA5_STRING \u0026\u0026 **p != ASN1_UNIVERSAL_STRING \u0026\u0026\n        **p != ASN1_BIT_STRING )\n        return( POLARSSL_ERR_X509_INVALID_NAME +\n                POLARSSL_ERR_ASN1_UNEXPECTED_TAG );\n\n    val = \u0026cur-\u003eval;\n    val-\u003etag = *(*p)++;\n\n    if( ( ret = asn1_get_len( p, end, \u0026val-\u003elen ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n\n    val-\u003ep = *p;\n    *p += val-\u003elen;\n\n    cur-\u003enext = NULL;\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":352,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"506236":{"score":0.86859834,"function_name":"x509_get_name","code":"int x509_get_name( unsigned char **p, const unsigned char *end,\n                   x509_name *cur )\n{\n    int ret;\n    size_t set_len;\n    const unsigned char *end_set;\n\n    /* don't use recursion, we'd risk stack overflow if not optimized */\n    while( 1 )\n    {\n        /*\n         * parse SET\n         */\n        if( ( ret = asn1_get_tag( p, end, \u0026set_len,\n                ASN1_CONSTRUCTED | ASN1_SET ) ) != 0 )\n            return( POLARSSL_ERR_X509_INVALID_NAME + ret );\n\n        end_set  = *p + set_len;\n\n        while( 1 )\n        {\n            if( ( ret = x509_get_attr_type_value( p, end_set, cur ) ) != 0 )\n                return( ret );\n\n            if( *p == end_set )\n                break;\n\n            /* Mark this item as being not the only one in a set */\n            cur-\u003enext_merged = 1;\n\n            cur-\u003enext = polarssl_malloc( sizeof( x509_name ) );\n\n            if( cur-\u003enext == NULL )\n                return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n            memset( cur-\u003enext, 0, sizeof( x509_name ) );\n\n            cur = cur-\u003enext;\n        }\n\n        /*\n         * continue until end of SEQUENCE is reached\n         */\n        if( *p == end )\n            return( 0 );\n\n        cur-\u003enext = polarssl_malloc( sizeof( x509_name ) );\n\n        if( cur-\u003enext == NULL )\n            return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n        memset( cur-\u003enext, 0, sizeof( x509_name ) );\n\n        cur = cur-\u003enext;\n    }\n}","filepath":"library/x509.c","line_number":426,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"506537":{"score":0.9114243,"function_name":"x509_parse_int","code":"static int x509_parse_int( unsigned char **p, size_t n, int *res )\n{\n    *res = 0;\n\n    for( ; n \u003e 0; --n )\n    {\n        if( ( **p \u003c '0') || ( **p \u003e '9' ) )\n            return( POLARSSL_ERR_X509_INVALID_DATE );\n\n        *res *= 10;\n        *res += ( *(*p)++ - '0' );\n    }\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":483,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"506664":{"score":0.9153983,"function_name":"x509_date_is_valid","code":"static int x509_date_is_valid(const x509_time *t)\n{\n    int ret = POLARSSL_ERR_X509_INVALID_DATE;\n    int month_len;\n\n    CHECK_RANGE( 0, 9999, t-\u003eyear );\n    CHECK_RANGE( 0, 23,   t-\u003ehour );\n    CHECK_RANGE( 0, 59,   t-\u003emin  );\n    CHECK_RANGE( 0, 59,   t-\u003esec  );\n\n    switch( t-\u003emon )\n    {\n        case 1: case 3: case 5: case 7: case 8: case 10: case 12:\n            month_len = 31;\n            break;\n        case 4: case 6: case 9: case 11:\n            month_len = 30;\n            break;\n        case 2:\n            if( ( !( t-\u003eyear % 4 ) \u0026\u0026 t-\u003eyear % 100 ) ||\n                !( t-\u003eyear % 400 ) )\n                month_len = 29;\n            else\n                month_len = 28;\n            break;\n        default:\n            return( ret );\n    }\n    CHECK_RANGE( 1, month_len, t-\u003eday );\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":499,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"506996":{"score":0.89465404,"function_name":"x509_parse_time","code":"static int x509_parse_time( unsigned char **p, size_t len, size_t yearlen,\n                            x509_time *tm )\n{\n    int ret;\n\n    /*\n     * minimum length is 10 or 12 depending on yearlen\n     */\n    if ( len \u003c yearlen + 8 )\n        return POLARSSL_ERR_X509_INVALID_DATE;\n    len -= yearlen + 8;\n\n    /*\n     * parse year, month, day, hour, minute\n     */\n    CHECK( x509_parse_int( p, yearlen, \u0026tm-\u003eyear ) );\n    if ( 2 == yearlen )\n    {\n        if ( tm-\u003eyear \u003c 50 )\n            tm-\u003eyear += 100;\n\n        tm-\u003eyear += 1900;\n    }\n\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003emon ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003eday ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003ehour ) );\n    CHECK( x509_parse_int( p, 2, \u0026tm-\u003emin ) );\n\n    /*\n     * parse seconds if present\n     */\n    if ( len \u003e= 2 \u0026\u0026 **p \u003e= '0' \u0026\u0026 **p \u003c= '9' )\n    {\n        CHECK( x509_parse_int( p, 2, \u0026tm-\u003esec ) );\n        len -= 2;\n    }\n    else\n    {\n#if defined(POLARSSL_X509_ALLOW_RELAXED_DATE)\n        /*\n         * if relaxed mode, allow seconds to be absent\n         */\n        tm-\u003esec = 0;\n#else\n        return POLARSSL_ERR_X509_INVALID_DATE;\n#endif\n    }\n\n    /*\n     * parse trailing 'Z' if present\n     */\n    if ( 1 == len \u0026\u0026 'Z' == **p )\n    {\n        (*p)++;\n        return 0;\n    }\n#if defined(POLARSSL_X509_ALLOW_RELAXED_DATE)\n    /*\n     * if relaxed mode, allow timezone to be present\n     */\n    else if ( 5 == len \u0026\u0026 ( '+' == **p || '-' == **p ) )\n    {\n        int tz; /* throwaway timezone */\n\n        (*p)++;\n        CHECK( x509_parse_int( p, 4, \u0026tz ) );\n\n        return 0;\n    }\n#endif\n    /*\n     * okay if no trailing 'Z' or timezone specified\n     */\n    else if ( 0 == len )\n        return 0;\n    else\n        return POLARSSL_ERR_X509_INVALID_DATE;\n}","filepath":"library/x509.c","line_number":535,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"507406":{"score":0.70199376,"function_name":"x509_get_time","code":"int x509_get_time( unsigned char **p, const unsigned char *end,\n                   x509_time *tm )\n{\n    int ret;\n    size_t len;\n    unsigned char tag;\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_X509_INVALID_DATE +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    tag = **p;\n\n    if( tag == ASN1_UTC_TIME )\n    {\n        (*p)++;\n        ret = asn1_get_len( p, end, \u0026len );\n        if( ret != 0 )\n            return( POLARSSL_ERR_X509_INVALID_DATE + ret );\n\n        CHECK( x509_parse_time( p, len, 2, tm ) );\n\n        CHECK( x509_date_is_valid( tm ) );\n\n        return( 0 );\n    }\n    else if( tag == ASN1_GENERALIZED_TIME )\n    {\n        (*p)++;\n        ret = asn1_get_len( p, end, \u0026len );\n        if( ret != 0 )\n            return( POLARSSL_ERR_X509_INVALID_DATE + ret );\n\n        CHECK( x509_parse_time( p, len, 4, tm ) );\n\n        CHECK( x509_date_is_valid( tm ) );\n\n        return( 0 );\n    }\n    else\n        return( POLARSSL_ERR_X509_INVALID_DATE +\n                POLARSSL_ERR_ASN1_UNEXPECTED_TAG );\n}","filepath":"library/x509.c","line_number":620,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"507622":{"score":0.8574969,"function_name":"x509_get_sig","code":"int x509_get_sig( unsigned char **p, const unsigned char *end, x509_buf *sig )\n{\n    int ret;\n    size_t len;\n    int tag_type;\n\n    if( ( end - *p ) \u003c 1 )\n        return( POLARSSL_ERR_X509_INVALID_SIGNATURE +\n                POLARSSL_ERR_ASN1_OUT_OF_DATA );\n\n    tag_type = **p;\n\n    if( ( ret = asn1_get_bitstring_null( p, end, \u0026len ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_SIGNATURE + ret );\n\n    sig-\u003etag = tag_type;\n    sig-\u003elen = len;\n    sig-\u003ep = *p;\n\n    *p += len;\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":664,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"507818":{"score":0.774006,"function_name":"x509_get_sig_alg","code":"int x509_get_sig_alg( const x509_buf *sig_oid, const x509_buf *sig_params,\n                      md_type_t *md_alg, pk_type_t *pk_alg,\n                      void **sig_opts )\n{\n    int ret;\n\n    if( *sig_opts != NULL )\n        return( POLARSSL_ERR_X509_BAD_INPUT_DATA );\n\n    if( ( ret = oid_get_sig_alg( sig_oid, md_alg, pk_alg ) ) != 0 )\n        return( POLARSSL_ERR_X509_UNKNOWN_SIG_ALG + ret );\n\n#if defined(POLARSSL_X509_RSASSA_PSS_SUPPORT)\n    if( *pk_alg == POLARSSL_PK_RSASSA_PSS )\n    {\n        pk_rsassa_pss_options *pss_opts;\n\n        pss_opts = polarssl_malloc( sizeof( pk_rsassa_pss_options ) );\n        if( pss_opts == NULL )\n            return( POLARSSL_ERR_X509_MALLOC_FAILED );\n\n        ret = x509_get_rsassa_pss_params( sig_params,\n                                          md_alg,\n                                          \u0026pss_opts-\u003emgf1_hash_id,\n                                          \u0026pss_opts-\u003eexpected_salt_len );\n        if( ret != 0 )\n        {\n            polarssl_free( pss_opts );\n            return( ret );\n        }\n\n        *sig_opts = (void *) pss_opts;\n    }\n    else\n#endif /* POLARSSL_X509_RSASSA_PSS_SUPPORT */\n    {\n        /* Make sure parameters are absent or NULL */\n        if( ( sig_params-\u003etag != ASN1_NULL \u0026\u0026 sig_params-\u003etag != 0 ) ||\n              sig_params-\u003elen != 0 )\n        return( POLARSSL_ERR_X509_INVALID_ALG );\n    }\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":691,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"507938":{"score":0.9133114,"function_name":"x509_get_ext","code":"int x509_get_ext( unsigned char **p, const unsigned char *end,\n                  x509_buf *ext, int tag )\n{\n    int ret;\n    size_t len;\n\n    if( *p == end )\n        return( 0 );\n\n    ext-\u003etag = **p;\n\n    if( ( ret = asn1_get_tag( p, end, \u0026ext-\u003elen,\n            ASN1_CONTEXT_SPECIFIC | ASN1_CONSTRUCTED | tag ) ) != 0 )\n        return( ret );\n\n    ext-\u003ep = *p;\n    end = *p + ext-\u003elen;\n\n    /*\n     * Extensions  ::=  SEQUENCE SIZE (1..MAX) OF Extension\n     *\n     * Extension  ::=  SEQUENCE  {\n     *      extnID      OBJECT IDENTIFIER,\n     *      critical    BOOLEAN DEFAULT FALSE,\n     *      extnValue   OCTET STRING  }\n     */\n    if( ( ret = asn1_get_tag( p, end, \u0026len,\n            ASN1_CONSTRUCTED | ASN1_SEQUENCE ) ) != 0 )\n        return( POLARSSL_ERR_X509_INVALID_EXTENSIONS + ret );\n\n    if( end != *p + len )\n        return( POLARSSL_ERR_X509_INVALID_EXTENSIONS +\n                POLARSSL_ERR_ASN1_LENGTH_MISMATCH );\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":740,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"508179":{"score":0.83900285,"function_name":"x509_dn_gets","code":"int x509_dn_gets( char *buf, size_t size, const x509_name *dn )\n{\n    int ret;\n    size_t i, n;\n    unsigned char c, merge = 0;\n    const x509_name *name;\n    const char *short_name = NULL;\n    char s[X509_MAX_DN_NAME_SIZE], *p;\n\n    memset( s, 0, sizeof( s ) );\n\n    name = dn;\n    p = buf;\n    n = size;\n\n    while( name != NULL )\n    {\n        if( !name-\u003eoid.p )\n        {\n            name = name-\u003enext;\n            continue;\n        }\n\n        if( name != dn )\n        {\n            ret = polarssl_snprintf( p, n, merge ? \" + \" : \", \" );\n            SAFE_SNPRINTF();\n        }\n\n        ret = oid_get_attr_short_name( \u0026name-\u003eoid, \u0026short_name );\n\n        if( ret == 0 )\n            ret = polarssl_snprintf( p, n, \"%s=\", short_name );\n        else\n            ret = polarssl_snprintf( p, n, \"\\?\\?=\" );\n        SAFE_SNPRINTF();\n\n        for( i = 0; i \u003c name-\u003eval.len; i++ )\n        {\n            if( i \u003e= sizeof( s ) - 1 )\n                break;\n\n            c = name-\u003eval.p[i];\n            if( c \u003c 32 || c == 127 || ( c \u003e 128 \u0026\u0026 c \u003c 160 ) )\n                 s[i] = '?';\n            else s[i] = c;\n        }\n        s[i] = '\\0';\n        ret = polarssl_snprintf( p, n, \"%s\", s );\n        SAFE_SNPRINTF();\n\n        merge = name-\u003enext_merged;\n        name = name-\u003enext;\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"library/x509.c","line_number":833,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"508990":{"score":0.83747125,"function_name":"x509_serial_gets","code":"int x509_serial_gets( char *buf, size_t size, const x509_buf *serial )\n{\n    int ret;\n    size_t i, n, nr;\n    char *p;\n\n    p = buf;\n    n = size;\n\n    nr = ( serial-\u003elen \u003c= 32 )\n        ? serial-\u003elen  : 28;\n\n    for( i = 0; i \u003c nr; i++ )\n    {\n        if( i == 0 \u0026\u0026 nr \u003e 1 \u0026\u0026 serial-\u003ep[i] == 0x0 )\n            continue;\n\n        ret = polarssl_snprintf( p, n, \"%02X%s\",\n                serial-\u003ep[i], ( i \u003c nr - 1 ) ? \":\" : \"\" );\n        SAFE_SNPRINTF();\n    }\n\n    if( nr != serial-\u003elen )\n    {\n        ret = polarssl_snprintf( p, n, \"....\" );\n        SAFE_SNPRINTF();\n    }\n\n    return( (int) ( size - n ) );\n}","filepath":"library/x509.c","line_number":895,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"509505":{"score":0.78930914,"function_name":"x509_key_size_helper","code":"int x509_key_size_helper( char *buf, size_t size, const char *name )\n{\n    char *p = buf;\n    size_t n = size;\n    int ret;\n\n    if( strlen( name ) + sizeof( \" key size\" ) \u003e size )\n        return( POLARSSL_ERR_DEBUG_BUF_TOO_SMALL );\n\n    ret = polarssl_snprintf( p, n, \"%s key size\", name );\n    SAFE_SNPRINTF();\n\n    return( 0 );\n}","filepath":"library/x509.c","line_number":974,"entry_url":"https://github.com/ARMmbed/mbedtls.git","slot_name":"mbedtls-1.3.22-rc1"},"509646":{"score":0.87240195,"function_name":"_iot_dump_create_dump_state","code":"static struct iot_dump_state* _iot_dump_create_dump_state(struct iot_context *iot_ctx)\n{\n    struct iot_dump_state* dump_state;\n    struct timeval time;\n\n    IOT_INFO(\"log version : %x\", IOT_DUMP_LOG_VERSION);\n\n    dump_state = iot_os_malloc(sizeof(struct iot_dump_state));\n    if (!dump_state) {\n        IOT_ERROR(\"failed to malloc for evt_data\");\n        return NULL;\n    }\n    memset(dump_state, 0, sizeof(struct iot_dump_state));\n\n    dump_state-\u003estdk_version_code = STDK_VERSION_CODE;\n    dump_state-\u003eclock_time = clock();\n    COPY_STR_TO_BYTE(dump_state-\u003eos_name, iot_os_get_os_name(), sizeof(dump_state-\u003eos_name));\n    COPY_STR_TO_BYTE(dump_state-\u003eos_version, iot_os_get_os_version_string(), sizeof(dump_state-\u003eos_version));\n    COPY_STR_TO_BYTE(dump_state-\u003ebsp_name, iot_bsp_get_bsp_name(), sizeof(dump_state-\u003ebsp_name));\n    COPY_STR_TO_BYTE(dump_state-\u003ebsp_version, iot_bsp_get_bsp_version_string(), sizeof(dump_state-\u003ebsp_version));\n\n    gettimeofday(\u0026time, NULL);\n    dump_state-\u003elog_time = time.tv_sec;\n\n    if (iot_ctx) {\n        dump_state-\u003esequence_number = iot_ctx-\u003eevent_sequence_num;\n\n        COPY_STR_TO_BYTE(dump_state-\u003edevice_id, iot_ctx-\u003eiot_reg_data.deviceId,\n                sizeof(dump_state-\u003edevice_id));\n\n        if (iot_ctx-\u003edevconf.dip) {\n            memcpy(dump_state-\u003edip_id, iot_ctx-\u003edevconf.dip-\u003edip_id.id,\n                    sizeof(dump_state-\u003edip_id));\n\n            dump_state-\u003edip_version =\n                    ((iot_ctx-\u003edevconf.dip-\u003edip_major_version \u0026 0xffff) \u003c\u003c 16)\n                            | (iot_ctx-\u003edevconf.dip-\u003edip_minor_version \u0026 0xffff);\n        }\n        if (iot_ctx-\u003edevice_info.firmware_version) {\n            COPY_STR_TO_BYTE(dump_state-\u003efirmware_version, iot_ctx-\u003edevice_info.firmware_version,\n                    sizeof(dump_state-\u003efirmware_version));\n        }\n        if (iot_ctx-\u003edevice_info.model_number) {\n            COPY_STR_TO_BYTE(dump_state-\u003emodel_number, iot_ctx-\u003edevice_info.model_number,\n                    sizeof(dump_state-\u003emodel_number));\n        }\n        if (iot_ctx-\u003edevice_info.manufacturer_name) {\n            COPY_STR_TO_BYTE(dump_state-\u003emanufacturer_name, iot_ctx-\u003edevice_info.manufacturer_name,\n                    sizeof(dump_state-\u003emanufacturer_name));\n        }\n\n        dump_state-\u003emqtt_connection_success_count = iot_ctx-\u003emqtt_connection_success_count;\n        dump_state-\u003emqtt_connection_try_count = iot_ctx-\u003emqtt_connection_try_count;\n    }\n    return dump_state;\n}","filepath":"src/iot_dump_log.c","line_number":36,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"510715":{"score":0.88091457,"function_name":"_iot_dump_create_header","code":"static struct iot_dump_header* _iot_dump_create_header()\n{\n    struct iot_dump_header* header;\n    header = iot_os_malloc(sizeof(struct iot_dump_header));\n    if (!header) {\n        IOT_ERROR(\"failed to malloc for header_line of dump\");\n        return NULL;\n    }\n    memset(header, 0, sizeof(struct iot_dump_header));\n\n    header-\u003emagic_number = IOT_DUMP_MAGIC_NUMBER;\n    header-\u003elog_version = IOT_DUMP_LOG_VERSION;\n    header-\u003edump_state_size = sizeof(struct iot_dump_state);\n\n    return header;\n}","filepath":"src/iot_dump_log.c","line_number":93,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"510853":{"score":0.90250814,"function_name":"_iot_dump_copy_memory","code":"static iot_error_t _iot_dump_copy_memory(void *dest, int dest_size, const void *src, int src_size,\n        void *buf, int buf_size, int *remain_number, int *written_len, int need_base64)\n{\n    size_t pre_out_len = 0;\n    size_t main_out_len = 0;\n    size_t pre_copy_len = 0;\n    size_t main_copy_len = 0;\n    iot_error_t iot_err = IOT_ERROR_NONE;\n\n    if ((!written_len) || (!dest) || (!src) || (dest_size \u003c= 0) || (src_size \u003c= 0) || (buf_size \u003c 3))\n        return IOT_ERROR_BAD_REQ;\n\n    *written_len = 0;\n\n    if (src_size \u003e dest_size)\n        src_size = dest_size;\n\n    if (!need_base64) {\n        memcpy(dest, src, src_size);\n        *written_len = src_size;\n        return IOT_ERROR_NONE;\n    }\n    //Step1: old 'remain' bytes and new (3-'remain') bytes are combined to 3bytes, and converted to base64\n    if (*remain_number \u003e 0) {\n        pre_copy_len = 3 - *remain_number;\n        memcpy(buf + *remain_number, src, pre_copy_len);\n        iot_err = iot_security_base64_encode(buf, 3, dest, dest_size, \u0026pre_out_len);\n        if (iot_err \u003c 0) {\n            return iot_err;\n        }\n        memset(buf, 0, 3);\n        *written_len = pre_out_len;\n    }\n    //Step2: convert multiples of 3 bytes\n    *remain_number = (src_size - pre_copy_len) % 3;\n    main_copy_len = GET_LARGEST_MULTIPLE(src_size - pre_copy_len, 3);\n    if (main_copy_len \u003e 0) {\n        iot_err = iot_security_base64_encode(src + pre_copy_len, main_copy_len, dest + pre_out_len,\n                                             dest_size - pre_out_len, \u0026main_out_len);\n        if (iot_err \u003c 0) {\n            return iot_err;\n        }\n    }\n    //Step3: save unconverted remain bytes to buf\n    memcpy(buf, src + pre_copy_len + main_copy_len, *remain_number);\n    *written_len = pre_out_len + main_out_len;\n    return iot_err;\n}","filepath":"src/iot_dump_log.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"511394":{"score":0.8833176,"function_name":"st_create_log_dump","code":"int st_create_log_dump(IOT_CTX *iot_ctx, char **log_dump_output, size_t max_log_dump_size, size_t *allocated_size, int log_mode)\n{\n    struct iot_dump_header* header;\n    struct iot_dump_state* dump_state;\n    struct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n    char temp_buf[IOT_DUMP_BUFFER_SIZE] = \"\";\n    char *all_log_dump;\n    int remain_number = 0;\n    int written_len = 0;\n\n    size_t max_msg_size = 0;\n    size_t min_log_size = 0;\n    size_t output_log_size = 0;\n    size_t stored_log_size = 0;\n    size_t curr_size = 0;\n\n    int need_base64 = log_mode \u0026 IOT_DUMP_MODE_NEED_BASE64;\n    int need_dump_state = log_mode \u0026 IOT_DUMP_MODE_NEED_DUMP_STATE;\n\n    size_t iot_dump_state_size = sizeof(struct iot_dump_state);\n\n    iot_error_t iot_err = IOT_ERROR_NONE;\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    size_t msg_size;\n    iot_log_file_handle_t *logfile;\n#endif\n\n    if (!need_dump_state) {\n        iot_dump_state_size = 0;\n    }\n\n    if (need_base64) {\n        min_log_size = IOT_SECURITY_B64_ENCODE_LEN(sizeof(struct iot_dump_header) + iot_dump_state_size);\n    } else {\n        min_log_size = sizeof(struct iot_dump_header) + iot_dump_state_size;\n    }\n    if (max_log_dump_size \u003c min_log_size) {\n        IOT_ERROR(\"input log size is smaller than minimum log size\");\n        return IOT_ERROR_BAD_REQ;\n    }\n\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE_RAM_ONLY)\n    logfile = iot_log_file_open(\u0026stored_log_size, RAM_ONLY);\n#elif defined(CONFIG_STDK_IOT_CORE_LOG_FILE_FLASH_WITH_RAM)\n    logfile = iot_log_file_open(\u0026stored_log_size, FLASH_WITH_RAM);\n#else\n#error \"Need to choice STDK_IOT_CORE_LOG_FILE_TYPE first\"\n#endif\n    if (!logfile) {\n        IOT_ERROR(\"fail to open log file\");\n        return IOT_ERROR_BAD_REQ;\n    }\n#endif\n\n    if (need_base64) {\n        max_msg_size = (max_log_dump_size - 1) / 4 * 3 - sizeof(struct iot_dump_header) - iot_dump_state_size;\n    } else {\n        max_msg_size = max_log_dump_size - sizeof(struct iot_dump_header) - iot_dump_state_size;\n    }\n    if (max_msg_size \u003e stored_log_size)\n        max_msg_size = stored_log_size;\n    max_msg_size = GET_LARGEST_MULTIPLE(max_msg_size, IOT_DUMP_LOG_MSG_LINE_LENGTH);\n\n    if (need_base64) {\n        output_log_size = IOT_SECURITY_B64_ENCODE_LEN(max_msg_size + sizeof(struct iot_dump_header) + iot_dump_state_size);\n    } else {\n        output_log_size = max_msg_size + sizeof(struct iot_dump_header) + iot_dump_state_size;\n    }\n\n    all_log_dump = iot_os_malloc(output_log_size);\n    if (!all_log_dump) {\n        IOT_ERROR(\"failed to malloc for all_log_dump\");\n        iot_err = IOT_ERROR_MEM_ALLOC;\n        goto end;\n    }\n    memset(all_log_dump, 0, output_log_size);\n\n    header = _iot_dump_create_header();\n    if (!need_dump_state) {\n        header-\u003edump_state_size = 0;\n    }\n    iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                header, sizeof(struct iot_dump_header), temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n    iot_os_free(header);\n    if (iot_err \u003c 0) {\n        IOT_ERROR(\"failed to get header for all_log_dump : ret %d\", iot_err);\n        goto end;\n    }\n    curr_size += written_len;\n\n    if (need_dump_state) {\n        dump_state = _iot_dump_create_dump_state(ctx);\n        iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                    dump_state, sizeof(struct iot_dump_state), temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n        iot_os_free(dump_state);\n        if (iot_err \u003c 0) {\n            IOT_ERROR(\"failed to get dump_state for all_log_dump : ret %d\", iot_err);\n            goto end;\n        }\n        curr_size += written_len;\n    }\n\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    if (logfile) {\n        iot_log_file_seek(logfile, 0 - max_msg_size, logfile-\u003etail_addr);\n\n        while (max_msg_size) {\n            msg_size = sizeof(temp_buf) - remain_number;\n            if (msg_size \u003e max_msg_size)\n                msg_size = max_msg_size;\n\n            iot_log_file_read(logfile, temp_buf + remain_number, msg_size, \u0026msg_size);\n\n            max_msg_size -= msg_size;\n            msg_size += remain_number;\n            remain_number = 0;\n\n            iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                    temp_buf, msg_size, temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n            if (iot_err \u003c 0) {\n                IOT_ERROR(\"failed to get log msg for all_log_dump : ret %d\", iot_err);\n                goto end;\n            }\n            curr_size += written_len;\n        }\n        iot_log_file_close(logfile);\n    }\n#endif\n\n    if (remain_number) {\n        memset(temp_buf + remain_number, 0, 3 - remain_number);\n        iot_err = _iot_dump_copy_memory(all_log_dump + curr_size, output_log_size - curr_size,\n                temp_buf, 3 - remain_number, temp_buf, sizeof(temp_buf), \u0026remain_number, \u0026written_len, need_base64);\n        if (iot_err \u003c 0) {\n            IOT_ERROR(\"failed to get remain character for all_log_dump : ret %d\", iot_err);\n            goto end;\n        }\n        curr_size += written_len;\n    }\n\n    if (allocated_size)\n        *allocated_size = output_log_size;\n    *log_dump_output = all_log_dump;\n    return iot_err;\n\nend:\n#ifdef CONFIG_STDK_IOT_CORE_LOG_FILE\n    if (logfile) {\n        iot_log_file_close(logfile);\n    }\n#endif\n    if (all_log_dump)\n        iot_os_free(all_log_dump);\n    if (allocated_size)\n        *allocated_size = 0;\n    *log_dump_output = NULL;\n    return iot_err;\n}","filepath":"src/iot_dump_log.c","line_number":159,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.5"},"514140":{"score":0.910717,"function_name":"is_http_conn_handle_initialized","code":"bool is_http_conn_handle_initialized(HTTP_CONN_H *handle)\n{\n\tif ((handle == NULL) || (handle-\u003eaccept_sock == CONN_HANDLE_UNINITIALIZED) ||\n\t\t\t(handle-\u003elisten_sock == CONN_HANDLE_UNINITIALIZED)) {\n\t\treturn false;\n\t}\n\treturn true;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":23,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514194":{"score":0.9130585,"function_name":"http_cleanup_all_connection","code":"void http_cleanup_all_connection(HTTP_CONN_H *handle)\n{\n\tif (handle == NULL) {\n\t\treturn;\n\t}\n\n\tif (handle-\u003elisten_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close listen socket\");\n\t\tclose(handle-\u003elisten_sock);\n\t\thandle-\u003elisten_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n\n\t// if http deinit before ST app reset tcp connection, we need close it here\n\tif (handle-\u003eaccept_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close accept socket\");\n\t\tclose(handle-\u003eaccept_sock);\n\t\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":32,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514377":{"score":0.90870774,"function_name":"http_cleanup_accepted_connection","code":"void http_cleanup_accepted_connection(HTTP_CONN_H *handle)\n{\n\tif (handle == NULL) {\n\t\treturn;\n\t}\n\tif (handle-\u003eaccept_sock != CONN_HANDLE_UNINITIALIZED) {\n\t\tIOT_INFO(\"close accept socket\");\n\t\tclose(handle-\u003eaccept_sock);\n\t\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":52,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514484":{"score":0.93936867,"function_name":"http_packet_send","code":"ssize_t http_packet_send(HTTP_CONN_H *handle, char *tx_buffer, size_t tx_buffer_len)\n{\n\tint len;\n\n\tif (handle == NULL || is_http_conn_handle_initialized(handle) == false) {\n\t\treturn -1;\n\t}\n\tif (tx_buffer == NULL) {\n\t\treturn -1;\n\t}\n\n\tlen = send(handle-\u003eaccept_sock, tx_buffer, tx_buffer_len, 0);\n\treturn len;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":64,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514580":{"score":0.9204925,"function_name":"http_packet_read","code":"iot_error_t http_packet_read(HTTP_CONN_H *handle, char *rx_buffer, size_t rx_buffer_size, size_t *received_len,\n\t\t\t\t\t\t\t size_t *http_header_len)\n{\n\tssize_t len;\n\tsize_t existing_len;\n\tint header_position = -1;\n\tint i;\n\n\tif (handle == NULL || rx_buffer == NULL || received_len == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\texisting_len = *received_len;\n\t// ensure complete http request header before es_msg_parser\n\tdo {\n\t\tlen = recv(handle-\u003eaccept_sock, rx_buffer + existing_len, rx_buffer_size - existing_len - 1, 0);\n\t\tif (len \u003c 0) {\n\t\t\tif (!is_es_http_deinit_processing()) {\n\t\t\t\tIOT_ERROR(\"recv failed: errno %d\", errno);\n\t\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_RECV_FAIL, errno);\n\t\t\t}\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_RECV_FAIL;\n\t\t}\n\t\telse if (len == 0) {\n\t\t\tIOT_WARN(\"peer connection closed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_WARN, IOT_DUMP_EASYSETUP_SOCKET_CON_CLOSE, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED;\n\t\t}\n\t\telse {\n\t\t\texisting_len += len;\n\t\t}\n\n\t\t// \\r\\n\\r\\n  header end\n\t\tfor (i = 0; i \u003c existing_len; i++) {\n\t\t\tif (i \u003c existing_len - 3) {\n\t\t\t\tif ((rx_buffer[i] == '\\r') \u0026\u0026 (rx_buffer[i + 1] == '\\n') \u0026\u0026 (rx_buffer[i + 2] == '\\r')\n\t\t\t\t\t\u0026\u0026 (rx_buffer[i + 3] == '\\n')) {\n\t\t\t\t\theader_position = i + 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (header_position \u003c 0);\n\n\t*received_len = existing_len;\n\t*http_header_len = header_position;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":79,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"514960":{"score":0.91226536,"function_name":"http_packet_read_remaining","code":"iot_error_t http_packet_read_remaining(HTTP_CONN_H *handle, char *rx_buffer, size_t rx_buffer_size, size_t offset,\n\t\t\t\t\t\t\t\t\t   size_t expected_len)\n{\n\tssize_t len;\n\tsize_t total_recv_len = offset;\n\n\tif (handle == NULL || rx_buffer == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tdo {\n\t\tlen = recv(handle-\u003eaccept_sock, rx_buffer + offset, rx_buffer_size - offset - 1, 0);\n\t\tif (len \u003c 0) {\n\t\t\tIOT_ERROR(\"recv failed: errno %d\", errno);\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_RECV_FAIL, errno);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_RECV_FAIL;\n\t\t}\n\t\telse if (len == 0) {\n\t\t\tIOT_ERROR(\"peer connection closed\");\n\t\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_CON_CLOSE, 0);\n\t\t\treturn IOT_ERROR_EASYSETUP_HTTP_PEER_CONN_CLOSED;\n\t\t}\n\t\telse {\n\t\t\ttotal_recv_len += len;\n\t\t}\n\t} while (total_recv_len \u003c expected_len);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":128,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"515185":{"score":0.89384353,"function_name":"http_try_configure_connection","code":"void http_try_configure_connection(HTTP_CONN_H *handle)\n{\n\tint ret;\n\n\tif (handle == NULL || is_http_conn_handle_initialized(handle) == false) {\n\t\treturn;\n\t}\n\t// set tcp keepalive related opts\n\t// if ST app WiFi disconnect coincidentally during easysetup,\n\t// we need short time tcp keepalive here.\n\tint keep_alive = 1;\n\tret = setsockopt(handle-\u003eaccept_sock, SOL_SOCKET, SO_KEEPALIVE, \u0026keep_alive, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-alive failed %d\", errno);\n\t}\n\n\tint idle = 10;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPIDLE, \u0026idle, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-idle failed %d\", errno);\n\t}\n\n\tint interval = 5;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPINTVL, \u0026interval, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-interval failed %d\", errno);\n\t}\n\n\tint maxpkt = 3;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_KEEPCNT, \u0026maxpkt, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set keep-count failed %d\", errno);\n\t}\n\n\t// HTTP response as tcp payload is sent once, and mostly less than MTU.\n\t// There is no need for tcp packet coalesced.\n\t// To enhance throughput, disable TCP Nagle's algorithm here.\n\tint no_delay = 1;\n\tret = setsockopt(handle-\u003eaccept_sock, IPPROTO_TCP, TCP_NODELAY, \u0026no_delay, sizeof(int));\n\tif (ret \u003c 0) {\n\t\tIOT_INFO(\"socket set no-delay failed %d\", errno);\n\t}\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":157,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"515732":{"score":0.87654173,"function_name":"http_initialize_connection","code":"iot_error_t http_initialize_connection(HTTP_CONN_H *handle)\n{\n\tint addr_family, ip_protocol, ret;\n\tint opt = 1;\n\tstruct sockaddr_in destAddr;\n\tdestAddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tdestAddr.sin_family = AF_INET;\n\tdestAddr.sin_port = htons(HTTP_PORT);\n\taddr_family = AF_INET;\n\tip_protocol = IPPROTO_IP;\n\tint listen_sock;\n\n\tif (handle == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\thandle-\u003elisten_sock = CONN_HANDLE_UNINITIALIZED;\n\thandle-\u003eaccept_sock = CONN_HANDLE_UNINITIALIZED;\n\n\tlisten_sock = socket(addr_family, SOCK_STREAM, ip_protocol);\n\tif (listen_sock \u003c 0) {\n\t\tIOT_ERROR(\"Unable to create socket: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_CREATE_FAIL, errno);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\tret = setsockopt(listen_sock, SOL_SOCKET, SO_REUSEADDR, \u0026opt, sizeof(opt));\n\tif (ret != 0) {\n\t\tIOT_INFO(\"reuse socket isn't supported\");\n\t}\n\n\tret = bind(listen_sock, (struct sockaddr *)\u0026destAddr, sizeof(destAddr));\n\tif (ret != 0) {\n\t\tIOT_ERROR(\"Socket unable to bind: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_BIND_FAIL, errno);\n\t\tclose(listen_sock);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\tret = listen(listen_sock, 1);\n\tif (ret != 0) {\n\t\tIOT_ERROR(\"Error occurred during listen: errno %d\", errno);\n\t\tIOT_ES_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_EASYSETUP_SOCKET_LISTEN_FAIL, errno);\n\t\tclose(listen_sock);\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\n\thandle-\u003elisten_sock = listen_sock;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":201,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"516247":{"score":0.9442389,"function_name":"http_accept_connection","code":"iot_error_t http_accept_connection(HTTP_CONN_H *handle)\n{\n\tstruct sockaddr_in source_addr;\n\tuint addr_len;\n\tint sock;\n\n\tif (handle == NULL) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\taddr_len = sizeof(source_addr);\n\n\tsock = accept(handle-\u003elisten_sock, (struct sockaddr *)\u0026source_addr, \u0026addr_len);\n\tif (sock \u003c 0) {\n\t\treturn IOT_ERROR_CONNECT_FAIL;\n\t}\n\thandle-\u003eaccept_sock = sock;\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/port/http/socket/iot_easysetup_http_socket.c","line_number":253,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"516383":{"score":0.69860625,"function_name":"_iot_security_be_bsp_fs_storage_id2target","code":"STATIC_FUNCTION\niot_security_storage_target_t _iot_security_be_bsp_fs_storage_id2target(iot_security_storage_id_t storage_id)\n{\n\tif (storage_id == IOT_NVD_UNKNOWN) {\n\t\treturn IOT_SECURITY_STORAGE_TARGET_UNKNOWN;\n\t}\n\n\tif (storage_id \u003c IOT_NVD_FACTORY) {\n\t\treturn IOT_SECURITY_STORAGE_TARGET_NV;\n\t}\n\n\tif (storage_id \u003c IOT_NVD_MAX) {\n#if defined(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION)\n\t\treturn IOT_SECURITY_STORAGE_TARGET_FACTORY;\n#else\n\t\treturn IOT_SECURITY_STORAGE_TARGET_DI;\n#endif\n\t}\n\n\treturn IOT_SECURITY_STORAGE_TARGET_UNKNOWN;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":34,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"516442":{"score":0.8757286,"function_name":"_iot_security_be_bsp_fs_storage_id2filename","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_storage_id2filename(iot_security_storage_id_t storage_id, char *filename, size_t filename_len)\n{\n\tconst char *storage_file;\n\tconst char *extra_path = (const char *)IOT_SECURITY_STORAGE_EXTRA_PATH;\n\tint c = 0;\n\n\tif (!filename || (filename_len == 0)) {\n\t\tIOT_ERROR(\"filename is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tstorage_file = iot_bsp_nv_get_data_path(storage_id);\n\tif (!storage_file) {\n\t\tIOT_ERROR(\"not found file for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(STORAGE_INVALID_ID, storage_id);\n\t}\n\n\tif (extra_path) {\n\t\tc = snprintf(filename, filename_len, \"%s/\", extra_path);\n\t}\n\n\tif (filename_len \u003c strlen(storage_file) + c) {\n\t\tIOT_ERROR(\"length is not enough (%d \u003c (%d + %d)\", (int)filename_len, strlen(storage_file), c);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_BUFFER, filename_len);\n\t}\n\n\tsnprintf(filename + c, filename_len - c, \"%s\", storage_file);\n\n\tIOT_DEBUG(\"storage file = '%s'\", filename);\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"516777":{"score":0.8217008,"function_name":"_iot_security_be_bsp_fs_load_from_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_load_from_nv(iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_error_t err;\n\tiot_bsp_fs_handle_t handle;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\tchar *fs_buf;\n\tsize_t fs_buf_len;\n\tunsigned char *realloc_buf;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tif (storage_id \u003e= IOT_NVD_FACTORY) {\n#if defined(CONFIG_STDK_IOT_CORE_SUPPORT_STNV_PARTITION)\n\t\terr = iot_bsp_fs_open_from_stnv(filename, \u0026handle);\n\t\tif (err) {\n\t\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open_from_stnv(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, err);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open_from_stnv(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t\t\t}\n\t\t}\n#else\n\t\tIOT_ERROR(\"not defined factory partition\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, 0);\n#endif\n\t} else {\n\t\terr = iot_bsp_fs_open(filename, FS_READONLY, \u0026handle);\n\t\tif (err) {\n\t\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, err);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t\t\t}\n\t\t}\n\t}\n\n\tfs_buf_len = IOT_SECURITY_STORAGE_BUF_MAX_LEN;\n\tfs_buf = (char *)iot_os_malloc(fs_buf_len);\n\tif (!fs_buf) {\n\t\tIOT_ERROR(\"failed to malloc for fs buf\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\terr = iot_bsp_fs_read(handle, fs_buf, \u0026fs_buf_len);\n\tif (err) {\n\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\terr = IOT_ERROR_SECURITY_FS_NOT_FOUND;\n\t\t} else {\n\t\t\tIOT_ERROR(\"iot_bsp_fs_read = %d\", err);\n\t\t\terr = IOT_ERROR_SECURITY_FS_READ;\n\t\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, err, __LINE__, 0);\n\t\t}\n\n\t\tiot_os_free(fs_buf);\n\t\t(void)iot_bsp_fs_close(handle);\n\n\t\treturn err;\n\t}\n\n\trealloc_buf = (unsigned char *)iot_os_realloc(fs_buf, fs_buf_len + 1);\n\tif (realloc_buf) {\n\t\trealloc_buf[fs_buf_len] = '\\0';\n\t\toutput_buf-\u003ep = realloc_buf;\n\t\toutput_buf-\u003elen = fs_buf_len;\n\t} else {\n\t\tIOT_ERROR(\"failed to realloc for buf\");\n\t\tiot_os_free(fs_buf);\n\t\t(void)iot_bsp_fs_close(handle);\n\t\tIOT_ERROR_DUMP_AND_RETURN(MEM_ALLOC, 0);\n\t}\n\n\terr = iot_bsp_fs_close(handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_close = %d\", err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_CLOSE, err);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"517744":{"score":0.859826,"function_name":"_iot_security_be_bsp_fs_load","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_load(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id, iot_security_buffer_t *output_buf)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tif (!be_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tif (!output_buf) {\n\t\tIOT_ERROR(\"output buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tmemset(output_buf, 0, sizeof(iot_security_buffer_t));\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\treturn _iot_security_be_bsp_fs_load_from_nv(storage_id, output_buf);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tif (!be_context-\u003eexternal_device_info_cb) {\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(BE_EXTERNAL_NULL, 0);\n\t\t}\n\t\treturn be_context-\u003eexternal_device_info_cb(storage_id, output_buf);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, 0);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":182,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"517998":{"score":0.77620614,"function_name":"_iot_security_be_bsp_fs_store_to_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_store_to_nv(iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_error_t err;\n\tiot_bsp_fs_handle_t handle;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_bsp_fs_open(filename, FS_READWRITE, \u0026handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_open(%s) = %d\", filename, err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_OPEN, err);\n\t}\n\n\terr = iot_bsp_fs_write(handle, (const char *)input_buf-\u003ep, (unsigned int)input_buf-\u003elen);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_write = %d\", err);\n\t\t(void)iot_bsp_fs_close(handle);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_WRITE, err);\n\t}\n\n\terr = iot_bsp_fs_close(handle);\n\tif (err) {\n\t\tIOT_ERROR(\"iot_bsp_fs_close = %d\", err);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_CLOSE, err);\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":217,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518491":{"score":0.8339387,"function_name":"_iot_security_be_bsp_fs_store","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_store(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id, iot_security_buffer_t *input_buf)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tif (!input_buf || !input_buf-\u003ep || (input_buf-\u003elen == 0)) {\n\t\tIOT_ERROR(\"input buffer is invalid\");\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_ARGS, 0);\n\t}\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\t\treturn _iot_security_be_bsp_fs_store_to_nv(storage_id, input_buf);\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\tIOT_ERROR(\"cannot update factory nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tIOT_ERROR(\"cannot update device info nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, storage_id);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":251,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518790":{"score":0.8163898,"function_name":"_iot_security_be_bsp_fs_remove_from_nv","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_remove_from_nv(iot_security_storage_id_t storage_id)\n{\n\tiot_error_t err;\n\tchar filename[IOT_SECURITY_STORAGE_FILENAME_MAX_LEN];\n\n\terr = _iot_security_be_bsp_fs_storage_id2filename(storage_id, filename, sizeof(filename));\n\tif (err) {\n\t\treturn err;\n\t}\n\n\terr = iot_bsp_fs_remove(filename);\n\tif (err) {\n\t\tif (err == IOT_ERROR_FS_NO_FILE) {\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_NOT_FOUND, 0);\n\t\t} else {\n\t\t\tIOT_ERROR(\"iot_bsp_fs_remove = %d\", err);\n\t\t\tIOT_ERROR_DUMP_AND_RETURN(FS_REMOVE, err);\n\t\t}\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":280,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"518966":{"score":0.8581254,"function_name":"_iot_security_be_bsp_fs_remove","code":"STATIC_FUNCTION\niot_error_t _iot_security_be_bsp_fs_remove(iot_security_be_context_t *be_context, iot_security_storage_id_t storage_id)\n{\n\tiot_security_storage_target_t storage_target;\n\n\tIOT_DEBUG(\"id = %d\", storage_id);\n\n\tstorage_target = _iot_security_be_bsp_fs_storage_id2target(storage_id);\n\n\tswitch (storage_target) {\n\tcase IOT_SECURITY_STORAGE_TARGET_NV:\n\t\treturn _iot_security_be_bsp_fs_remove_from_nv(storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_FACTORY:\n\t\tIOT_ERROR(\"cannot remove factory nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tcase IOT_SECURITY_STORAGE_TARGET_DI:\n\t\tIOT_ERROR(\"cannot remove device info nv for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_INVALID_TARGET, storage_id);\n\tdefault:\n\t\tIOT_ERROR(\"cannot found target for id = %d\", storage_id);\n\t\tIOT_ERROR_DUMP_AND_RETURN(FS_UNKNOWN_TARGET, storage_id);\n\t}\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":304,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"519185":{"score":0.74618876,"function_name":"iot_security_be_bsp_init","code":"iot_error_t iot_security_be_bsp_init(iot_security_be_context_t *be_context)\n{\n\tif (!be_context) {\n\t\tIOT_ERROR_DUMP_AND_RETURN(BE_CONTEXT_NULL, 0);\n\t}\n\n\tbe_context-\u003ebsp_fn = \u0026iot_security_be_software_bsp_funcs;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/security/backend/software/iot_security_be_bsp.c","line_number":334,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.4.6"},"519345":{"score":0.8219595,"function_name":"chacha_keysetup","code":"static void\nchacha_keysetup(chacha_ctx *ctx, const uint8_t *k)\n{\n    ctx-\u003einput[0]  = U32C(0x61707865);\n    ctx-\u003einput[1]  = U32C(0x3320646e);\n    ctx-\u003einput[2]  = U32C(0x79622d32);\n    ctx-\u003einput[3]  = U32C(0x6b206574);\n    ctx-\u003einput[4]  = LOAD32_LE(k + 0);\n    ctx-\u003einput[5]  = LOAD32_LE(k + 4);\n    ctx-\u003einput[6]  = LOAD32_LE(k + 8);\n    ctx-\u003einput[7]  = LOAD32_LE(k + 12);\n    ctx-\u003einput[8]  = LOAD32_LE(k + 16);\n    ctx-\u003einput[9]  = LOAD32_LE(k + 20);\n    ctx-\u003einput[10] = LOAD32_LE(k + 24);\n    ctx-\u003einput[11] = LOAD32_LE(k + 28);\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":45,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"519607":{"score":0.7780817,"function_name":"chacha_ivsetup","code":"static void\nchacha_ivsetup(chacha_ctx *ctx, const uint8_t *iv, const uint8_t *counter)\n{\n    ctx-\u003einput[12] = counter == NULL ? 0 : LOAD32_LE(counter + 0);\n    ctx-\u003einput[13] = counter == NULL ? 0 : LOAD32_LE(counter + 4);\n    ctx-\u003einput[14] = LOAD32_LE(iv + 0);\n    ctx-\u003einput[15] = LOAD32_LE(iv + 4);\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":62,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"519876":{"score":0.84815437,"function_name":"chacha20_encrypt_bytes","code":"static void\nchacha20_encrypt_bytes(chacha_ctx *ctx, const uint8_t *m, uint8_t *c,\n                       unsigned long long bytes)\n{\n    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14,\n        x15;\n    uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14,\n        j15;\n    uint8_t     *ctarget = NULL;\n    uint8_t      tmp[64];\n    unsigned int i;\n\n    if (!bytes) {\n        return; /* LCOV_EXCL_LINE */\n    }\n    j0  = ctx-\u003einput[0];\n    j1  = ctx-\u003einput[1];\n    j2  = ctx-\u003einput[2];\n    j3  = ctx-\u003einput[3];\n    j4  = ctx-\u003einput[4];\n    j5  = ctx-\u003einput[5];\n    j6  = ctx-\u003einput[6];\n    j7  = ctx-\u003einput[7];\n    j8  = ctx-\u003einput[8];\n    j9  = ctx-\u003einput[9];\n    j10 = ctx-\u003einput[10];\n    j11 = ctx-\u003einput[11];\n    j12 = ctx-\u003einput[12];\n    j13 = ctx-\u003einput[13];\n    j14 = ctx-\u003einput[14];\n    j15 = ctx-\u003einput[15];\n\n    for (;;) {\n        if (bytes \u003c 64) {\n            memset(tmp, 0, 64);\n            for (i = 0; i \u003c bytes; ++i) {\n                tmp[i] = m[i];\n            }\n            m       = tmp;\n            ctarget = c;\n            c       = tmp;\n        }\n        x0  = j0;\n        x1  = j1;\n        x2  = j2;\n        x3  = j3;\n        x4  = j4;\n        x5  = j5;\n        x6  = j6;\n        x7  = j7;\n        x8  = j8;\n        x9  = j9;\n        x10 = j10;\n        x11 = j11;\n        x12 = j12;\n        x13 = j13;\n        x14 = j14;\n        x15 = j15;\n        for (i = 20; i \u003e 0; i -= 2) {\n            QUARTERROUND(x0, x4, x8, x12)\n            QUARTERROUND(x1, x5, x9, x13)\n            QUARTERROUND(x2, x6, x10, x14)\n            QUARTERROUND(x3, x7, x11, x15)\n            QUARTERROUND(x0, x5, x10, x15)\n            QUARTERROUND(x1, x6, x11, x12)\n            QUARTERROUND(x2, x7, x8, x13)\n            QUARTERROUND(x3, x4, x9, x14)\n        }\n        x0  = PLUS(x0, j0);\n        x1  = PLUS(x1, j1);\n        x2  = PLUS(x2, j2);\n        x3  = PLUS(x3, j3);\n        x4  = PLUS(x4, j4);\n        x5  = PLUS(x5, j5);\n        x6  = PLUS(x6, j6);\n        x7  = PLUS(x7, j7);\n        x8  = PLUS(x8, j8);\n        x9  = PLUS(x9, j9);\n        x10 = PLUS(x10, j10);\n        x11 = PLUS(x11, j11);\n        x12 = PLUS(x12, j12);\n        x13 = PLUS(x13, j13);\n        x14 = PLUS(x14, j14);\n        x15 = PLUS(x15, j15);\n\n        x0  = XOR(x0, LOAD32_LE(m + 0));\n        x1  = XOR(x1, LOAD32_LE(m + 4));\n        x2  = XOR(x2, LOAD32_LE(m + 8));\n        x3  = XOR(x3, LOAD32_LE(m + 12));\n        x4  = XOR(x4, LOAD32_LE(m + 16));\n        x5  = XOR(x5, LOAD32_LE(m + 20));\n        x6  = XOR(x6, LOAD32_LE(m + 24));\n        x7  = XOR(x7, LOAD32_LE(m + 28));\n        x8  = XOR(x8, LOAD32_LE(m + 32));\n        x9  = XOR(x9, LOAD32_LE(m + 36));\n        x10 = XOR(x10, LOAD32_LE(m + 40));\n        x11 = XOR(x11, LOAD32_LE(m + 44));\n        x12 = XOR(x12, LOAD32_LE(m + 48));\n        x13 = XOR(x13, LOAD32_LE(m + 52));\n        x14 = XOR(x14, LOAD32_LE(m + 56));\n        x15 = XOR(x15, LOAD32_LE(m + 60));\n\n        j12 = PLUSONE(j12);\n        /* LCOV_EXCL_START */\n        if (!j12) {\n            j13 = PLUSONE(j13);\n        }\n        /* LCOV_EXCL_STOP */\n\n        STORE32_LE(c + 0, x0);\n        STORE32_LE(c + 4, x1);\n        STORE32_LE(c + 8, x2);\n        STORE32_LE(c + 12, x3);\n        STORE32_LE(c + 16, x4);\n        STORE32_LE(c + 20, x5);\n        STORE32_LE(c + 24, x6);\n        STORE32_LE(c + 28, x7);\n        STORE32_LE(c + 32, x8);\n        STORE32_LE(c + 36, x9);\n        STORE32_LE(c + 40, x10);\n        STORE32_LE(c + 44, x11);\n        STORE32_LE(c + 48, x12);\n        STORE32_LE(c + 52, x13);\n        STORE32_LE(c + 56, x14);\n        STORE32_LE(c + 60, x15);\n\n        if (bytes \u003c= 64) {\n            if (bytes \u003c 64) {\n                for (i = 0; i \u003c (unsigned int) bytes; ++i) {\n                    ctarget[i] = c[i]; /* ctarget cannot be NULL */\n                }\n            }\n            ctx-\u003einput[12] = j12;\n            ctx-\u003einput[13] = j13;\n\n            return;\n        }\n        bytes -= 64;\n        c += 64;\n        m += 64;\n    }\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":80,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"523204":{"score":0.78812754,"function_name":"stream_ref","code":"static int\nstream_ref(unsigned char *c, unsigned long long clen, const unsigned char *n,\n           const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n\n    if (!clen) {\n        return 0;\n    }\n    COMPILER_ASSERT(crypto_stream_chacha20_KEYBYTES == 256 / 8);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ivsetup(\u0026ctx, n, NULL);\n    memset(c, 0, clen);\n    chacha20_encrypt_bytes(\u0026ctx, c, c, clen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":223,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"523640":{"score":0.79266393,"function_name":"stream_ref_xor_ic","code":"static int\nstream_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                  unsigned long long mlen, const unsigned char *n, uint64_t ic,\n                  const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n    uint8_t           ic_bytes[8];\n    uint32_t          ic_high;\n    uint32_t          ic_low;\n\n    if (!mlen) {\n        return 0;\n    }\n    ic_high = U32V(ic \u003e\u003e 32);\n    ic_low  = U32V(ic);\n    STORE32_LE(\u0026ic_bytes[0], ic_low);\n    STORE32_LE(\u0026ic_bytes[4], ic_high);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ivsetup(\u0026ctx, n, ic_bytes);\n    chacha20_encrypt_bytes(\u0026ctx, m, c, mlen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":261,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"523970":{"score":0.82894826,"function_name":"stream_ietf_ext_ref_xor_ic","code":"static int\nstream_ietf_ext_ref_xor_ic(unsigned char *c, const unsigned char *m,\n                           unsigned long long mlen, const unsigned char *n,\n                           uint32_t ic, const unsigned char *k)\n{\n    struct chacha_ctx ctx;\n    uint8_t           ic_bytes[4];\n\n    if (!mlen) {\n        return 0;\n    }\n    STORE32_LE(ic_bytes, ic);\n    chacha_keysetup(\u0026ctx, k);\n    chacha_ietf_ivsetup(\u0026ctx, n, ic_bytes);\n    chacha20_encrypt_bytes(\u0026ctx, m, c, mlen);\n    sodium_memzero(\u0026ctx, sizeof ctx);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_stream/chacha20/ref/chacha20_ref.c","line_number":286,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"524191":{"score":0.8239882,"function_name":"sodium_init","code":"int\nsodium_init(void)\n{\n    if (sodium_crit_enter() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    if (initialized != 0) {\n        if (sodium_crit_leave() != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n        return 1;\n    }\n    _sodium_runtime_get_cpu_features();\n    randombytes_stir();\n    _sodium_alloc_init();\n    _crypto_pwhash_argon2_pick_best_implementation();\n    _crypto_generichash_blake2b_pick_best_implementation();\n    _crypto_onetimeauth_poly1305_pick_best_implementation();\n    _crypto_scalarmult_curve25519_pick_best_implementation();\n    _crypto_stream_chacha20_pick_best_implementation();\n    _crypto_stream_salsa20_pick_best_implementation();\n    initialized = 1;\n    if (sodium_crit_leave() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/sodium/core.c","line_number":27,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"524380":{"score":0.846207,"function_name":"sodium_misuse","code":"void\nsodium_misuse(void)\n{\n    void (*handler)(void);\n\n    (void) sodium_crit_leave();\n    if (sodium_crit_enter() == 0) {\n        handler = _misuse_handler;\n        if (handler != NULL) {\n            handler();\n        }\n    }\n/* LCOV_EXCL_START */\n    abort();\n}","filepath":"src/libsodium/sodium/core.c","line_number":186,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"524437":{"score":0.9192514,"function_name":"sodium_set_misuse_handler","code":"int\nsodium_set_misuse_handler(void (*handler)(void))\n{\n    if (sodium_crit_enter() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    _misuse_handler = handler;\n    if (sodium_crit_leave() != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/sodium/core.c","line_number":203,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"524612":{"score":0.87075233,"function_name":"fe_add","code":"void\nfe_add(fe h, const fe f, const fe g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t h0 = f0 + g0;\n    int32_t h1 = f1 + g1;\n    int32_t h2 = f2 + g2;\n    int32_t h3 = f3 + g3;\n    int32_t h4 = f4 + g4;\n    int32_t h5 = f5 + g5;\n    int32_t h6 = f6 + g6;\n    int32_t h7 = f7 + g7;\n    int32_t h8 = f8 + g8;\n    int32_t h9 = f9 + g9;\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":67,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"524942":{"score":0.85157704,"function_name":"fe_sub","code":"void\nfe_sub(fe h, const fe f, const fe g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t h0 = f0 - g0;\n    int32_t h1 = f1 - g1;\n    int32_t h2 = f2 - g2;\n    int32_t h3 = f3 - g3;\n    int32_t h4 = f4 - g4;\n    int32_t h5 = f5 - g5;\n    int32_t h6 = f6 - g6;\n    int32_t h7 = f7 - g7;\n    int32_t h8 = f8 - g8;\n    int32_t h9 = f9 - g9;\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1287,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"525292":{"score":0.8963329,"function_name":"fe_neg","code":"static void\nfe_neg(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t h0 = -f0;\n    int32_t h1 = -f1;\n    int32_t h2 = -f2;\n    int32_t h3 = -f3;\n    int32_t h4 = -f4;\n    int32_t h5 = -f5;\n    int32_t h6 = -f6;\n    int32_t h7 = -f7;\n    int32_t h8 = -f8;\n    int32_t h9 = -f9;\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":762,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"526690":{"score":0.8265402,"function_name":"fe_copy","code":"void\nfe_copy(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    h[0] = f0;\n    h[1] = f1;\n    h[2] = f2;\n    h[3] = f3;\n    h[4] = f4;\n    h[5] = f5;\n    h[6] = f6;\n    h[7] = f7;\n    h[8] = f8;\n    h[9] = f9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":185,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"527077":{"score":0.85792327,"function_name":"fe_mul","code":"void\nfe_mul(fe h, const fe f, const fe g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */\n    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n    int32_t g3_19 = 19 * g3;\n    int32_t g4_19 = 19 * g4;\n    int32_t g5_19 = 19 * g5;\n    int32_t g6_19 = 19 * g6;\n    int32_t g7_19 = 19 * g7;\n    int32_t g8_19 = 19 * g8;\n    int32_t g9_19 = 19 * g9;\n    int32_t f1_2  = 2 * f1;\n    int32_t f3_2  = 2 * f3;\n    int32_t f5_2  = 2 * f5;\n    int32_t f7_2  = 2 * f7;\n    int32_t f9_2  = 2 * f9;\n\n    int64_t f0g0    = f0 * (int64_t) g0;\n    int64_t f0g1    = f0 * (int64_t) g1;\n    int64_t f0g2    = f0 * (int64_t) g2;\n    int64_t f0g3    = f0 * (int64_t) g3;\n    int64_t f0g4    = f0 * (int64_t) g4;\n    int64_t f0g5    = f0 * (int64_t) g5;\n    int64_t f0g6    = f0 * (int64_t) g6;\n    int64_t f0g7    = f0 * (int64_t) g7;\n    int64_t f0g8    = f0 * (int64_t) g8;\n    int64_t f0g9    = f0 * (int64_t) g9;\n    int64_t f1g0    = f1 * (int64_t) g0;\n    int64_t f1g1_2  = f1_2 * (int64_t) g1;\n    int64_t f1g2    = f1 * (int64_t) g2;\n    int64_t f1g3_2  = f1_2 * (int64_t) g3;\n    int64_t f1g4    = f1 * (int64_t) g4;\n    int64_t f1g5_2  = f1_2 * (int64_t) g5;\n    int64_t f1g6    = f1 * (int64_t) g6;\n    int64_t f1g7_2  = f1_2 * (int64_t) g7;\n    int64_t f1g8    = f1 * (int64_t) g8;\n    int64_t f1g9_38 = f1_2 * (int64_t) g9_19;\n    int64_t f2g0    = f2 * (int64_t) g0;\n    int64_t f2g1    = f2 * (int64_t) g1;\n    int64_t f2g2    = f2 * (int64_t) g2;\n    int64_t f2g3    = f2 * (int64_t) g3;\n    int64_t f2g4    = f2 * (int64_t) g4;\n    int64_t f2g5    = f2 * (int64_t) g5;\n    int64_t f2g6    = f2 * (int64_t) g6;\n    int64_t f2g7    = f2 * (int64_t) g7;\n    int64_t f2g8_19 = f2 * (int64_t) g8_19;\n    int64_t f2g9_19 = f2 * (int64_t) g9_19;\n    int64_t f3g0    = f3 * (int64_t) g0;\n    int64_t f3g1_2  = f3_2 * (int64_t) g1;\n    int64_t f3g2    = f3 * (int64_t) g2;\n    int64_t f3g3_2  = f3_2 * (int64_t) g3;\n    int64_t f3g4    = f3 * (int64_t) g4;\n    int64_t f3g5_2  = f3_2 * (int64_t) g5;\n    int64_t f3g6    = f3 * (int64_t) g6;\n    int64_t f3g7_38 = f3_2 * (int64_t) g7_19;\n    int64_t f3g8_19 = f3 * (int64_t) g8_19;\n    int64_t f3g9_38 = f3_2 * (int64_t) g9_19;\n    int64_t f4g0    = f4 * (int64_t) g0;\n    int64_t f4g1    = f4 * (int64_t) g1;\n    int64_t f4g2    = f4 * (int64_t) g2;\n    int64_t f4g3    = f4 * (int64_t) g3;\n    int64_t f4g4    = f4 * (int64_t) g4;\n    int64_t f4g5    = f4 * (int64_t) g5;\n    int64_t f4g6_19 = f4 * (int64_t) g6_19;\n    int64_t f4g7_19 = f4 * (int64_t) g7_19;\n    int64_t f4g8_19 = f4 * (int64_t) g8_19;\n    int64_t f4g9_19 = f4 * (int64_t) g9_19;\n    int64_t f5g0    = f5 * (int64_t) g0;\n    int64_t f5g1_2  = f5_2 * (int64_t) g1;\n    int64_t f5g2    = f5 * (int64_t) g2;\n    int64_t f5g3_2  = f5_2 * (int64_t) g3;\n    int64_t f5g4    = f5 * (int64_t) g4;\n    int64_t f5g5_38 = f5_2 * (int64_t) g5_19;\n    int64_t f5g6_19 = f5 * (int64_t) g6_19;\n    int64_t f5g7_38 = f5_2 * (int64_t) g7_19;\n    int64_t f5g8_19 = f5 * (int64_t) g8_19;\n    int64_t f5g9_38 = f5_2 * (int64_t) g9_19;\n    int64_t f6g0    = f6 * (int64_t) g0;\n    int64_t f6g1    = f6 * (int64_t) g1;\n    int64_t f6g2    = f6 * (int64_t) g2;\n    int64_t f6g3    = f6 * (int64_t) g3;\n    int64_t f6g4_19 = f6 * (int64_t) g4_19;\n    int64_t f6g5_19 = f6 * (int64_t) g5_19;\n    int64_t f6g6_19 = f6 * (int64_t) g6_19;\n    int64_t f6g7_19 = f6 * (int64_t) g7_19;\n    int64_t f6g8_19 = f6 * (int64_t) g8_19;\n    int64_t f6g9_19 = f6 * (int64_t) g9_19;\n    int64_t f7g0    = f7 * (int64_t) g0;\n    int64_t f7g1_2  = f7_2 * (int64_t) g1;\n    int64_t f7g2    = f7 * (int64_t) g2;\n    int64_t f7g3_38 = f7_2 * (int64_t) g3_19;\n    int64_t f7g4_19 = f7 * (int64_t) g4_19;\n    int64_t f7g5_38 = f7_2 * (int64_t) g5_19;\n    int64_t f7g6_19 = f7 * (int64_t) g6_19;\n    int64_t f7g7_38 = f7_2 * (int64_t) g7_19;\n    int64_t f7g8_19 = f7 * (int64_t) g8_19;\n    int64_t f7g9_38 = f7_2 * (int64_t) g9_19;\n    int64_t f8g0    = f8 * (int64_t) g0;\n    int64_t f8g1    = f8 * (int64_t) g1;\n    int64_t f8g2_19 = f8 * (int64_t) g2_19;\n    int64_t f8g3_19 = f8 * (int64_t) g3_19;\n    int64_t f8g4_19 = f8 * (int64_t) g4_19;\n    int64_t f8g5_19 = f8 * (int64_t) g5_19;\n    int64_t f8g6_19 = f8 * (int64_t) g6_19;\n    int64_t f8g7_19 = f8 * (int64_t) g7_19;\n    int64_t f8g8_19 = f8 * (int64_t) g8_19;\n    int64_t f8g9_19 = f8 * (int64_t) g9_19;\n    int64_t f9g0    = f9 * (int64_t) g0;\n    int64_t f9g1_38 = f9_2 * (int64_t) g1_19;\n    int64_t f9g2_19 = f9 * (int64_t) g2_19;\n    int64_t f9g3_38 = f9_2 * (int64_t) g3_19;\n    int64_t f9g4_19 = f9 * (int64_t) g4_19;\n    int64_t f9g5_38 = f9_2 * (int64_t) g5_19;\n    int64_t f9g6_19 = f9 * (int64_t) g6_19;\n    int64_t f9g7_38 = f9_2 * (int64_t) g7_19;\n    int64_t f9g8_19 = f9 * (int64_t) g8_19;\n    int64_t f9g9_38 = f9_2 * (int64_t) g9_19;\n\n    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 +\n                 f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;\n    int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 +\n                 f7g4_19 + f8g3_19 + f9g2_19;\n    int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 +\n                 f7g5_38 + f8g4_19 + f9g3_38;\n    int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 +\n                 f7g6_19 + f8g5_19 + f9g4_19;\n    int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 +\n                 f7g7_38 + f8g6_19 + f9g5_38;\n    int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 +\n                 f8g7_19 + f9g6_19;\n    int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 +\n                 f7g9_38 + f8g8_19 + f9g7_38;\n    int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 +\n                 f8g9_19 + f9g8_19;\n    int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 +\n                 f8g0 + f9g9_38;\n    int64_t h9 =\n        f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    /*\n     |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n     i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n     |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n     i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9\n     */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25 */\n    /* |h4| \u003c= 2^25 */\n    /* |h1| \u003c= 1.71*2^59 */\n    /* |h5| \u003c= 1.71*2^59 */\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h1| \u003c= 2^24; from now on fits into int32 */\n    /* |h5| \u003c= 2^24; from now on fits into int32 */\n    /* |h2| \u003c= 1.41*2^60 */\n    /* |h6| \u003c= 1.41*2^60 */\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h3| \u003c= 1.71*2^59 */\n    /* |h7| \u003c= 1.71*2^59 */\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h4| \u003c= 1.72*2^34 */\n    /* |h8| \u003c= 1.41*2^60 */\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h5| \u003c= 1.01*2^24 */\n    /* |h9| \u003c= 1.71*2^59 */\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h0| \u003c= 1.1*2^39 */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h1| \u003c= 1.01*2^24 */\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":493,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"543031":{"score":0.8613372,"function_name":"fe_sq2","code":"static void\nfe_sq2(fe h, const fe f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t f0_2  = 2 * f0;\n    int32_t f1_2  = 2 * f1;\n    int32_t f2_2  = 2 * f2;\n    int32_t f3_2  = 2 * f3;\n    int32_t f4_2  = 2 * f4;\n    int32_t f5_2  = 2 * f5;\n    int32_t f6_2  = 2 * f6;\n    int32_t f7_2  = 2 * f7;\n    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */\n    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */\n    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */\n    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */\n    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */\n\n    int64_t f0f0    = f0 * (int64_t) f0;\n    int64_t f0f1_2  = f0_2 * (int64_t) f1;\n    int64_t f0f2_2  = f0_2 * (int64_t) f2;\n    int64_t f0f3_2  = f0_2 * (int64_t) f3;\n    int64_t f0f4_2  = f0_2 * (int64_t) f4;\n    int64_t f0f5_2  = f0_2 * (int64_t) f5;\n    int64_t f0f6_2  = f0_2 * (int64_t) f6;\n    int64_t f0f7_2  = f0_2 * (int64_t) f7;\n    int64_t f0f8_2  = f0_2 * (int64_t) f8;\n    int64_t f0f9_2  = f0_2 * (int64_t) f9;\n    int64_t f1f1_2  = f1_2 * (int64_t) f1;\n    int64_t f1f2_2  = f1_2 * (int64_t) f2;\n    int64_t f1f3_4  = f1_2 * (int64_t) f3_2;\n    int64_t f1f4_2  = f1_2 * (int64_t) f4;\n    int64_t f1f5_4  = f1_2 * (int64_t) f5_2;\n    int64_t f1f6_2  = f1_2 * (int64_t) f6;\n    int64_t f1f7_4  = f1_2 * (int64_t) f7_2;\n    int64_t f1f8_2  = f1_2 * (int64_t) f8;\n    int64_t f1f9_76 = f1_2 * (int64_t) f9_38;\n    int64_t f2f2    = f2 * (int64_t) f2;\n    int64_t f2f3_2  = f2_2 * (int64_t) f3;\n    int64_t f2f4_2  = f2_2 * (int64_t) f4;\n    int64_t f2f5_2  = f2_2 * (int64_t) f5;\n    int64_t f2f6_2  = f2_2 * (int64_t) f6;\n    int64_t f2f7_2  = f2_2 * (int64_t) f7;\n    int64_t f2f8_38 = f2_2 * (int64_t) f8_19;\n    int64_t f2f9_38 = f2 * (int64_t) f9_38;\n    int64_t f3f3_2  = f3_2 * (int64_t) f3;\n    int64_t f3f4_2  = f3_2 * (int64_t) f4;\n    int64_t f3f5_4  = f3_2 * (int64_t) f5_2;\n    int64_t f3f6_2  = f3_2 * (int64_t) f6;\n    int64_t f3f7_76 = f3_2 * (int64_t) f7_38;\n    int64_t f3f8_38 = f3_2 * (int64_t) f8_19;\n    int64_t f3f9_76 = f3_2 * (int64_t) f9_38;\n    int64_t f4f4    = f4 * (int64_t) f4;\n    int64_t f4f5_2  = f4_2 * (int64_t) f5;\n    int64_t f4f6_38 = f4_2 * (int64_t) f6_19;\n    int64_t f4f7_38 = f4 * (int64_t) f7_38;\n    int64_t f4f8_38 = f4_2 * (int64_t) f8_19;\n    int64_t f4f9_38 = f4 * (int64_t) f9_38;\n    int64_t f5f5_38 = f5 * (int64_t) f5_38;\n    int64_t f5f6_38 = f5_2 * (int64_t) f6_19;\n    int64_t f5f7_76 = f5_2 * (int64_t) f7_38;\n    int64_t f5f8_38 = f5_2 * (int64_t) f8_19;\n    int64_t f5f9_76 = f5_2 * (int64_t) f9_38;\n    int64_t f6f6_19 = f6 * (int64_t) f6_19;\n    int64_t f6f7_38 = f6 * (int64_t) f7_38;\n    int64_t f6f8_38 = f6_2 * (int64_t) f8_19;\n    int64_t f6f9_38 = f6 * (int64_t) f9_38;\n    int64_t f7f7_38 = f7 * (int64_t) f7_38;\n    int64_t f7f8_38 = f7_2 * (int64_t) f8_19;\n    int64_t f7f9_76 = f7_2 * (int64_t) f9_38;\n    int64_t f8f8_19 = f8 * (int64_t) f8_19;\n    int64_t f8f9_38 = f8 * (int64_t) f9_38;\n    int64_t f9f9_38 = f9 * (int64_t) f9_38;\n\n    int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;\n    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;\n    int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;\n    int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;\n    int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;\n    int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;\n    int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;\n    int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;\n    int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;\n    int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    h0 += h0;\n    h1 += h1;\n    h2 += h2;\n    h3 += h3;\n    h4 += h4;\n    h5 += h5;\n    h6 += h6;\n    h7 += h7;\n    h8 += h8;\n    h9 += h9;\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":990,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"551377":{"score":0.84591657,"function_name":"fe_frombytes","code":"void\nfe_frombytes(fe h, const unsigned char *s)\n{\n    int64_t h0 = load_4(s);\n    int64_t h1 = load_3(s + 4) \u003c\u003c 6;\n    int64_t h2 = load_3(s + 7) \u003c\u003c 5;\n    int64_t h3 = load_3(s + 10) \u003c\u003c 3;\n    int64_t h4 = load_3(s + 13) \u003c\u003c 2;\n    int64_t h5 = load_4(s + 16);\n    int64_t h6 = load_3(s + 20) \u003c\u003c 7;\n    int64_t h7 = load_3(s + 23) \u003c\u003c 5;\n    int64_t h8 = load_3(s + 26) \u003c\u003c 4;\n    int64_t h9 = (load_3(s + 29) \u0026 8388607) \u003c\u003c 2;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":215,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"554283":{"score":0.82275826,"function_name":"chi25519","code":"static void\nchi25519(fe25519 out, const fe25519 z)\n{\n    fe25519 t0, t1, t2, t3;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_mul(t1, t0, z);\n    fe25519_sq(t0, t1);\n    fe25519_sq(t2, t0);\n    fe25519_sq(t2, t2);\n    fe25519_mul(t2, t2, t0);\n    fe25519_mul(t1, t2, z);\n    fe25519_sq(t2, t1);\n\n    for (i = 1; i \u003c 5; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 10; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i \u003c 20; i++) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    fe25519_sq(t2, t2);\n    for (i = 1; i \u003c 10; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 50; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t2, t2, t1);\n    fe25519_sq(t3, t2);\n    for (i = 1; i \u003c 100; i++) {\n        fe25519_sq(t3, t3);\n    }\n    fe25519_mul(t2, t3, t2);\n    fe25519_sq(t2, t2);\n    for (i = 1; i \u003c 50; i++) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 4; i++) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(out, t1, t0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2472,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"555244":{"score":0.7926742,"function_name":"fe25519_pow22523","code":"static void\nfe25519_pow22523(fe25519 out, const fe25519 z)\n{\n    fe25519 t0;\n    fe25519 t1;\n    fe25519 t2;\n    int     i;\n\n    fe25519_sq(t0, z);\n    fe25519_sq(t1, t0);\n    fe25519_sq(t1, t1);\n    fe25519_mul(t1, z, t1);\n    fe25519_mul(t0, t0, t1);\n    fe25519_sq(t0, t0);\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 5; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 10; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 20; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 10; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t1, t0);\n    for (i = 1; i \u003c 50; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t1, t1, t0);\n    fe25519_sq(t2, t1);\n    for (i = 1; i \u003c 100; ++i) {\n        fe25519_sq(t2, t2);\n    }\n    fe25519_mul(t1, t2, t1);\n    fe25519_sq(t1, t1);\n    for (i = 1; i \u003c 50; ++i) {\n        fe25519_sq(t1, t1);\n    }\n    fe25519_mul(t0, t1, t0);\n    fe25519_sq(t0, t0);\n    fe25519_sq(t0, t0);\n    fe25519_mul(out, t0, z);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":111,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"556161":{"score":0.7429187,"function_name":"fe25519_cneg","code":"static inline void\nfe25519_cneg(fe25519 h, const fe25519 f, unsigned int b)\n{\n    fe25519 negf;\n\n    fe25519_neg(negf, f);\n    fe25519_copy(h, f);\n    fe25519_cmov(h, negf, b);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":166,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"556318":{"score":0.8091829,"function_name":"ge_sub","code":"static void\nge_sub(ge_p1p1 *r, const ge_p3 *p, const ge_cached *q)\n{\n    fe t0;\n\n    fe_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe_mul(r-\u003eZ, r-\u003eX, q-\u003eYminusX);\n    fe_mul(r-\u003eY, r-\u003eY, q-\u003eYplusX);\n    fe_mul(r-\u003eT, q-\u003eT2d, p-\u003eT);\n    fe_mul(r-\u003eX, p-\u003eZ, q-\u003eZ);\n    fe_add(t0, r-\u003eX, r-\u003eX);\n    fe_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe_sub(r-\u003eZ, t0, r-\u003eT);\n    fe_add(r-\u003eT, t0, r-\u003eT);\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1689,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"556693":{"score":0.8249733,"function_name":"slide_vartime","code":"static void\nslide_vartime(signed char *r, const unsigned char *a)\n{\n    int i;\n    int b;\n    int k;\n    int ribs;\n    int cmp;\n\n    for (i = 0; i \u003c 256; ++i) {\n        r[i] = 1 \u0026 (a[i \u003e\u003e 3] \u003e\u003e (i \u0026 7));\n    }\n    for (i = 0; i \u003c 256; ++i) {\n        if (! r[i]) {\n            continue;\n        }\n        for (b = 1; b \u003c= 6 \u0026\u0026 i + b \u003c 256; ++b) {\n            if (! r[i + b]) {\n                continue;\n            }\n            ribs = r[i + b] \u003c\u003c b;\n            cmp = r[i] + ribs;\n            if (cmp \u003c= 15) {\n                r[i] = cmp;\n                r[i + b] = 0;\n            } else {\n                cmp = r[i] - ribs;\n                if (cmp \u003c -15) {\n                    break;\n                }\n                r[i] = cmp;\n                for (k = i + b; k \u003c 256; ++k) {\n                    if (! r[k]) {\n                        r[k] = 1;\n                        break;\n                    }\n                    r[k] = 0;\n                }\n            }\n        }\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":204,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"557104":{"score":0.8444481,"function_name":"ge25519_frombytes","code":"int\nge25519_frombytes(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 u;\n    fe25519 v;\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check;\n    fe25519 negx;\n    fe25519 x_sqrtm1;\n    int     has_m_root, has_p_root;\n\n    fe25519_frombytes(h-\u003eY, s);\n    fe25519_1(h-\u003eZ);\n    fe25519_sq(u, h-\u003eY);\n    fe25519_mul(v, u, d);\n    fe25519_sub(u, u, h-\u003eZ); /* u = y^2-1 */\n    fe25519_add(v, v, h-\u003eZ); /* v = dy^2+1 */\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, v);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^7 */\n\n    fe25519_pow22523(h-\u003eX, h-\u003eX); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(h-\u003eX, h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, h-\u003eX);\n    fe25519_mul(vxx, vxx, v);\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n    has_m_root = fe25519_iszero(m_root_check);\n    has_p_root = fe25519_iszero(p_root_check);\n    fe25519_mul(x_sqrtm1, h-\u003eX, sqrtm1); /* x*sqrt(-1) */\n    fe25519_cmov(h-\u003eX, x_sqrtm1, 1 - has_m_root);\n\n    fe25519_neg(negx, h-\u003eX);\n    fe25519_cmov(h-\u003eX, negx, fe25519_isnegative(h-\u003eX) ^ (s[31] \u003e\u003e 7));\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return (has_m_root | has_p_root) - 1;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":247,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"557960":{"score":0.8452774,"function_name":"ge25519_frombytes_negate_vartime","code":"int\nge25519_frombytes_negate_vartime(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 u;\n    fe25519 v;\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check;\n\n    fe25519_frombytes(h-\u003eY, s);\n    fe25519_1(h-\u003eZ);\n    fe25519_sq(u, h-\u003eY);\n    fe25519_mul(v, u, d);\n    fe25519_sub(u, u, h-\u003eZ); /* u = y^2-1 */\n    fe25519_add(v, v, h-\u003eZ); /* v = dy^2+1 */\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, v);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^7 */\n\n    fe25519_pow22523(h-\u003eX, h-\u003eX); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(h-\u003eX, h-\u003eX, v3);\n    fe25519_mul(h-\u003eX, h-\u003eX, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, h-\u003eX);\n    fe25519_mul(vxx, vxx, v);\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    if (fe25519_iszero(m_root_check) == 0) {\n        fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n        if (fe25519_iszero(p_root_check) == 0) {\n            return -1;\n        }\n        fe25519_mul(h-\u003eX, h-\u003eX, sqrtm1);\n    }\n\n    if (fe25519_isnegative(h-\u003eX) == (s[31] \u003e\u003e 7)) {\n        fe25519_neg(h-\u003eX, h-\u003eX);\n    }\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":292,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"558747":{"score":0.81356484,"function_name":"ge_madd","code":"static void\nge_madd(ge_p1p1 *r, const ge_p3 *p, const ge_precomp *q)\n{\n    fe t0;\n\n    fe_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe_mul(r-\u003eZ, r-\u003eX, q-\u003eyplusx);\n    fe_mul(r-\u003eY, r-\u003eY, q-\u003eyminusx);\n    fe_mul(r-\u003eT, q-\u003exy2d, p-\u003eT);\n    fe_add(t0, p-\u003eZ, p-\u003eZ);\n    fe_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe_add(r-\u003eZ, t0, r-\u003eT);\n    fe_sub(r-\u003eT, t0, r-\u003eT);\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1460,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"559099":{"score":0.8259178,"function_name":"ge25519_msub","code":"static void\nge25519_msub(ge25519_p1p1 *r, const ge25519_p3 *p, const ge25519_precomp *q)\n{\n    fe25519 t0;\n\n    fe25519_add(r-\u003eX, p-\u003eY, p-\u003eX);\n    fe25519_sub(r-\u003eY, p-\u003eY, p-\u003eX);\n    fe25519_mul(r-\u003eZ, r-\u003eX, q-\u003eyminusx);\n    fe25519_mul(r-\u003eY, r-\u003eY, q-\u003eyplusx);\n    fe25519_mul(r-\u003eT, q-\u003exy2d, p-\u003eT);\n    fe25519_add(t0, p-\u003eZ, p-\u003eZ);\n    fe25519_sub(r-\u003eX, r-\u003eZ, r-\u003eY);\n    fe25519_add(r-\u003eY, r-\u003eZ, r-\u003eY);\n    fe25519_sub(r-\u003eZ, t0, r-\u003eT);\n    fe25519_add(r-\u003eT, t0, r-\u003eT);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":362,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"559557":{"score":0.78234255,"function_name":"ge25519_p1p1_to_p3","code":"void\nge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1 *p)\n{\n    fe25519_mul(r-\u003eX, p-\u003eX, p-\u003eT);\n    fe25519_mul(r-\u003eY, p-\u003eY, p-\u003eZ);\n    fe25519_mul(r-\u003eZ, p-\u003eZ, p-\u003eT);\n    fe25519_mul(r-\u003eT, p-\u003eX, p-\u003eY);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":395,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"559762":{"score":0.82927185,"function_name":"ge25519_p2_dbl","code":"static void\nge25519_p2_dbl(ge25519_p1p1 *r, const ge25519_p2 *p)\n{\n    fe25519 t0;\n\n    fe25519_sq(r-\u003eX, p-\u003eX);\n    fe25519_sq(r-\u003eZ, p-\u003eY);\n    fe25519_sq2(r-\u003eT, p-\u003eZ);\n    fe25519_add(r-\u003eY, p-\u003eX, p-\u003eY);\n    fe25519_sq(t0, r-\u003eY);\n    fe25519_add(r-\u003eY, r-\u003eZ, r-\u003eX);\n    fe25519_sub(r-\u003eZ, r-\u003eZ, r-\u003eX);\n    fe25519_sub(r-\u003eX, t0, r-\u003eY);\n    fe25519_sub(r-\u003eT, r-\u003eT, r-\u003eZ);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":416,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560045":{"score":0.842602,"function_name":"ge25519_p3_0","code":"static void\nge25519_p3_0(ge25519_p3 *h)\n{\n    fe25519_0(h-\u003eX);\n    fe25519_1(h-\u003eY);\n    fe25519_1(h-\u003eZ);\n    fe25519_0(h-\u003eT);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":432,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560133":{"score":0.89677566,"function_name":"ge25519_cached_0","code":"static void\nge25519_cached_0(ge25519_cached *h)\n{\n    fe25519_1(h-\u003eYplusX);\n    fe25519_1(h-\u003eYminusX);\n    fe25519_1(h-\u003eZ);\n    fe25519_0(h-\u003eT2d);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":441,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560221":{"score":0.83392394,"function_name":"ge25519_p3_to_cached","code":"void\nge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p)\n{\n    fe25519_add(r-\u003eYplusX, p-\u003eY, p-\u003eX);\n    fe25519_sub(r-\u003eYminusX, p-\u003eY, p-\u003eX);\n    fe25519_copy(r-\u003eZ, p-\u003eZ);\n    fe25519_mul(r-\u003eT2d, p-\u003eT, d2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":454,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560348":{"score":0.7832994,"function_name":"ge25519_p3_to_precomp","code":"static void\nge25519_p3_to_precomp(ge25519_precomp *pi, const ge25519_p3 *p)\n{\n    fe25519 recip;\n    fe25519 x;\n    fe25519 y;\n    fe25519 xy;\n\n    fe25519_invert(recip, p-\u003eZ);\n    fe25519_mul(x, p-\u003eX, recip);\n    fe25519_mul(y, p-\u003eY, recip);\n    fe25519_add(pi-\u003eyplusx, y, x);\n    fe25519_sub(pi-\u003eyminusx, y, x);\n    fe25519_mul(xy, x, y);\n    fe25519_mul(pi-\u003exy2d, xy, d2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":463,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"560708":{"score":0.87477034,"function_name":"ge_tobytes","code":"void\nge_tobytes(unsigned char *s, const ge_p2 *h)\n{\n    fe recip;\n    fe x;\n    fe y;\n\n    fe_invert(recip, h-\u003eZ);\n    fe_mul(x, h-\u003eX, recip);\n    fe_mul(y, h-\u003eY, recip);\n    fe_tobytes(s, y);\n    s[31] ^= fe_isnegative(x) \u003c\u003c 7;\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1707,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"561358":{"score":0.9041426,"function_name":"ge25519_cmov_cached","code":"static void\nge25519_cmov_cached(ge25519_cached *t, const ge25519_cached *u, unsigned char b)\n{\n    fe25519_cmov(t-\u003eYplusX, u-\u003eYplusX, b);\n    fe25519_cmov(t-\u003eYminusX, u-\u003eYminusX, b);\n    fe25519_cmov(t-\u003eZ, u-\u003eZ, b);\n    fe25519_cmov(t-\u003eT2d, u-\u003eT2d, b);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":559,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"562279":{"score":0.82312256,"function_name":"ge25519_cmov8_cached","code":"static void\nge25519_cmov8_cached(ge25519_cached *t, const ge25519_cached cached[8], const signed char b)\n{\n    ge25519_cached      minust;\n    const unsigned char bnegative = negative(b);\n    const unsigned char babs      = b - (((-bnegative) \u0026 b) * ((signed char) 1 \u003c\u003c 1));\n\n    ge25519_cached_0(t);\n    ge25519_cmov_cached(t, \u0026cached[0], equal(babs, 1));\n    ge25519_cmov_cached(t, \u0026cached[1], equal(babs, 2));\n    ge25519_cmov_cached(t, \u0026cached[2], equal(babs, 3));\n    ge25519_cmov_cached(t, \u0026cached[3], equal(babs, 4));\n    ge25519_cmov_cached(t, \u0026cached[4], equal(babs, 5));\n    ge25519_cmov_cached(t, \u0026cached[5], equal(babs, 6));\n    ge25519_cmov_cached(t, \u0026cached[6], equal(babs, 7));\n    ge25519_cmov_cached(t, \u0026cached[7], equal(babs, 8));\n    fe25519_copy(minust.YplusX, t-\u003eYminusX);\n    fe25519_copy(minust.YminusX, t-\u003eYplusX);\n    fe25519_copy(minust.Z, t-\u003eZ);\n    fe25519_neg(minust.T2d, t-\u003eT2d);\n    ge25519_cmov_cached(t, \u0026minust, bnegative);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":603,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"563648":{"score":0.80349815,"function_name":"ge25519_double_scalarmult_vartime","code":"void\nge25519_double_scalarmult_vartime(ge25519_p2 *r, const unsigned char *a,\n                                  const ge25519_p3 *A, const unsigned char *b)\n{\n    static const ge25519_precomp Bi[8] = {\n#ifdef HAVE_TI_MODE\n# include \"fe_51/base2.h\"\n#else\n# include \"fe_25_5/base2.h\"\n#endif\n    };\n    signed char    aslide[256];\n    signed char    bslide[256];\n    ge25519_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */\n    ge25519_p1p1   t;\n    ge25519_p3     u;\n    ge25519_p3     A2;\n    int            i;\n\n    slide_vartime(aslide, a);\n    slide_vartime(bslide, b);\n\n    ge25519_p3_to_cached(\u0026Ai[0], A);\n\n    ge25519_p3_dbl(\u0026t, A);\n    ge25519_p1p1_to_p3(\u0026A2, \u0026t);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[0]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[1], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[1]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[2], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[2]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[3], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[3]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[4], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[4]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[5], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[5]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[6], \u0026u);\n\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[6]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[7], \u0026u);\n\n    ge25519_p2_0(r);\n\n    for (i = 255; i \u003e= 0; --i) {\n        if (aslide[i] || bslide[i]) {\n            break;\n        }\n    }\n\n    for (; i \u003e= 0; --i) {\n        ge25519_p2_dbl(\u0026t, r);\n\n        if (aslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_add(\u0026t, \u0026u, \u0026Ai[aslide[i] / 2]);\n        } else if (aslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_sub(\u0026t, \u0026u, \u0026Ai[(-aslide[i]) / 2]);\n        }\n\n        if (bslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_madd(\u0026t, \u0026u, \u0026Bi[bslide[i] / 2]);\n        } else if (bslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_msub(\u0026t, \u0026u, \u0026Bi[(-bslide[i]) / 2]);\n        }\n\n        ge25519_p1p1_to_p2(r, \u0026t);\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":671,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"565130":{"score":0.8788631,"function_name":"ge25519_scalarmult","code":"void\nge25519_scalarmult(ge25519_p3 *h, const unsigned char *a, const ge25519_p3 *p)\n{\n    signed char     e[64];\n    signed char     carry;\n    ge25519_p1p1    r;\n    ge25519_p2      s;\n    ge25519_p1p1    t2, t3, t4, t5, t6, t7, t8;\n    ge25519_p3      p2, p3, p4, p5, p6, p7, p8;\n    ge25519_cached  pi[8];\n    ge25519_cached  t;\n    int             i;\n\n    ge25519_p3_to_cached(\u0026pi[1 - 1], p);   /* p */\n\n    ge25519_p3_dbl(\u0026t2, p);\n    ge25519_p1p1_to_p3(\u0026p2, \u0026t2);\n    ge25519_p3_to_cached(\u0026pi[2 - 1], \u0026p2); /* 2p = 2*p */\n\n    ge25519_add(\u0026t3, p, \u0026pi[2 - 1]);\n    ge25519_p1p1_to_p3(\u0026p3, \u0026t3);\n    ge25519_p3_to_cached(\u0026pi[3 - 1], \u0026p3); /* 3p = 2p+p */\n\n    ge25519_p3_dbl(\u0026t4, \u0026p2);\n    ge25519_p1p1_to_p3(\u0026p4, \u0026t4);\n    ge25519_p3_to_cached(\u0026pi[4 - 1], \u0026p4); /* 4p = 2*2p */\n\n    ge25519_add(\u0026t5, p, \u0026pi[4 - 1]);\n    ge25519_p1p1_to_p3(\u0026p5, \u0026t5);\n    ge25519_p3_to_cached(\u0026pi[5 - 1], \u0026p5); /* 5p = 4p+p */\n\n    ge25519_p3_dbl(\u0026t6, \u0026p3);\n    ge25519_p1p1_to_p3(\u0026p6, \u0026t6);\n    ge25519_p3_to_cached(\u0026pi[6 - 1], \u0026p6); /* 6p = 2*3p */\n\n    ge25519_add(\u0026t7, p, \u0026pi[6 - 1]);\n    ge25519_p1p1_to_p3(\u0026p7, \u0026t7);\n    ge25519_p3_to_cached(\u0026pi[7 - 1], \u0026p7); /* 7p = 6p+p */\n\n    ge25519_p3_dbl(\u0026t8, \u0026p4);\n    ge25519_p1p1_to_p3(\u0026p8, \u0026t8);\n    ge25519_p3_to_cached(\u0026pi[8 - 1], \u0026p8); /* 8p = 2*4p */\n\n    for (i = 0; i \u003c 32; ++i) {\n        e[2 * i + 0] = (a[i] \u003e\u003e 0) \u0026 15;\n        e[2 * i + 1] = (a[i] \u003e\u003e 4) \u0026 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i \u003c 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry \u003e\u003e= 4;\n        e[i] -= carry * ((signed char) 1 \u003c\u003c 4);\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge25519_p3_0(h);\n\n    for (i = 63; i != 0; i--) {\n        ge25519_cmov8_cached(\u0026t, pi, e[i]);\n        ge25519_add(\u0026r, h, \u0026t);\n\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n        ge25519_p1p1_to_p2(\u0026s, \u0026r);\n        ge25519_p2_dbl(\u0026r, \u0026s);\n\n        ge25519_p1p1_to_p3(h, \u0026r);  /* *16 */\n    }\n    ge25519_cmov8_cached(\u0026t, pi, e[i]);\n    ge25519_add(\u0026r, h, \u0026t);\n\n    ge25519_p1p1_to_p3(h, \u0026r);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":767,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"566539":{"score":0.9191635,"function_name":"ge_scalarmult_base","code":"void\nge_scalarmult_base(ge_p3 *h, const unsigned char *a)\n{\n    signed char e[64];\n    signed char carry;\n    ge_p1p1     r;\n    ge_p2       s;\n    ge_precomp  t;\n    int         i;\n\n    for (i = 0; i \u003c 32; ++i) {\n        e[2 * i + 0] = (a[i] \u003e\u003e 0) \u0026 15;\n        e[2 * i + 1] = (a[i] \u003e\u003e 4) \u0026 15;\n    }\n    /* each e[i] is between 0 and 15 */\n    /* e[63] is between 0 and 7 */\n\n    carry = 0;\n    for (i = 0; i \u003c 63; ++i) {\n        e[i] += carry;\n        carry = e[i] + 8;\n        carry \u003e\u003e= 4;\n        e[i] -= carry * ((signed char) 1 \u003c\u003c 4);\n    }\n    e[63] += carry;\n    /* each e[i] is between -8 and 8 */\n\n    ge_p3_0(h);\n    for (i = 1; i \u003c 64; i += 2) {\n        ge_select(\u0026t, i / 2, e[i]);\n        ge_madd(\u0026r, h, \u0026t);\n        ge_p1p1_to_p3(h, \u0026r);\n    }\n\n    ge_p3_dbl(\u0026r, h);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p2(\u0026s, \u0026r);\n    ge_p2_dbl(\u0026r, \u0026s);\n    ge_p1p1_to_p3(h, \u0026r);\n\n    for (i = 0; i \u003c 64; i += 2) {\n        ge_select(\u0026t, i / 2, e[i]);\n        ge_madd(\u0026r, h, \u0026t);\n        ge_p1p1_to_p3(h, \u0026r);\n    }\n}","filepath":"src/libsodium/crypto_core/curve25519/ref10/curve25519_ref10.c","line_number":1872,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"567363":{"score":0.842297,"function_name":"ge25519_mul_l","code":"static void\nge25519_mul_l(ge25519_p3 *r, const ge25519_p3 *A)\n{\n    static const signed char aslide[253] = {\n        13, 0, 0, 0, 0, -1, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, -13, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, -13, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0, 11, 0, 0, 0, 0, -13, 0, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 3, 0, 0, 0, 0, -11, 0, 0, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n    };\n    ge25519_cached Ai[8];\n    ge25519_p1p1   t;\n    ge25519_p3     u;\n    ge25519_p3     A2;\n    int            i;\n\n    ge25519_p3_to_cached(\u0026Ai[0], A);\n    ge25519_p3_dbl(\u0026t, A);\n    ge25519_p1p1_to_p3(\u0026A2, \u0026t);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[0]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[1], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[1]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[2], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[2]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[3], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[3]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[4], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[4]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[5], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[5]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[6], \u0026u);\n    ge25519_add(\u0026t, \u0026A2, \u0026Ai[6]);\n    ge25519_p1p1_to_p3(\u0026u, \u0026t);\n    ge25519_p3_to_cached(\u0026Ai[7], \u0026u);\n\n    ge25519_p3_0(r);\n\n    for (i = 252; i \u003e= 0; --i) {\n        ge25519_p3_dbl(\u0026t, r);\n\n        if (aslide[i] \u003e 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_add(\u0026t, \u0026u, \u0026Ai[aslide[i] / 2]);\n        } else if (aslide[i] \u003c 0) {\n            ge25519_p1p1_to_p3(\u0026u, \u0026t);\n            ge25519_sub(\u0026t, \u0026u, \u0026Ai[(-aslide[i]) / 2]);\n        }\n\n        ge25519_p1p1_to_p3(r, \u0026t);\n    }\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":912,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"568489":{"score":0.6856227,"function_name":"ge25519_is_on_curve","code":"int\nge25519_is_on_curve(const ge25519_p3 *p)\n{\n    fe25519 x2;\n    fe25519 y2;\n    fe25519 z2;\n    fe25519 z4;\n    fe25519 t0;\n    fe25519 t1;\n\n    fe25519_sq(x2, p-\u003eX);\n    fe25519_sq(y2, p-\u003eY);\n    fe25519_sq(z2, p-\u003eZ);\n    fe25519_sub(t0, y2, x2);\n    fe25519_mul(t0, t0, z2);\n\n    fe25519_mul(t1, x2, y2);\n    fe25519_mul(t1, t1, d);\n    fe25519_sq(z4, z2);\n    fe25519_add(t1, t1, z4);\n    fe25519_sub(t0, t0, t1);\n\n    return fe25519_iszero(t0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":966,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"568920":{"score":0.8961187,"function_name":"ge25519_is_canonical","code":"int\nge25519_is_canonical(const unsigned char *s)\n{\n    unsigned char c;\n    unsigned char d;\n    unsigned int  i;\n\n    c = (s[31] \u0026 0x7f) ^ 0x7f;\n    for (i = 30; i \u003e 0; i--) {\n        c |= s[i] ^ 0xff;\n    }\n    c = (((unsigned int) c) - 1U) \u003e\u003e 8;\n    d = (0xed - 1U - (unsigned int) s[0]) \u003e\u003e 8;\n\n    return 1 - (c \u0026 d \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1001,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"569048":{"score":0.84934473,"function_name":"ge25519_has_small_order","code":"int\nge25519_has_small_order(const unsigned char s[32])\n{\n    CRYPTO_ALIGN(16)\n    static const unsigned char blacklist[][32] = {\n        /* 0 (order 4) */\n        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 1 (order 1) */\n        { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 2707385501144840649318225287225658788936804267575313519463743609750303402022\n           (order 8) */\n        { 0x26, 0xe8, 0x95, 0x8f, 0xc2, 0xb2, 0x27, 0xb0, 0x45, 0xc3, 0xf4,\n          0x89, 0xf2, 0xef, 0x98, 0xf0, 0xd5, 0xdf, 0xac, 0x05, 0xd3, 0xc6,\n          0x33, 0x39, 0xb1, 0x38, 0x02, 0x88, 0x6d, 0x53, 0xfc, 0x05 },\n        /* 55188659117513257062467267217118295137698188065244968500265048394206261417927\n           (order 8) */\n        { 0xc7, 0x17, 0x6a, 0x70, 0x3d, 0x4d, 0xd8, 0x4f, 0xba, 0x3c, 0x0b,\n          0x76, 0x0d, 0x10, 0x67, 0x0f, 0x2a, 0x20, 0x53, 0xfa, 0x2c, 0x39,\n          0xcc, 0xc6, 0x4e, 0xc7, 0xfd, 0x77, 0x92, 0xac, 0x03, 0x7a },\n        /* p-1 (order 2) */\n        { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p (=0, order 4) */\n        { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p+1 (=1, order 1) */\n        { 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }\n    };\n    unsigned char c[7] = { 0 };\n    unsigned int  k;\n    size_t        i, j;\n\n    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);\n    for (j = 0; j \u003c 31; j++) {\n        for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n            c[i] |= s[j] ^ blacklist[i][j];\n        }\n    }\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        c[i] |= (s[j] \u0026 0x7f) ^ blacklist[i][j];\n    }\n    k = 0;\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        k |= (c[i] - 1);\n    }\n    return (int) ((k \u003e\u003e 8) \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1018,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"569366":{"score":0.7991732,"function_name":"sc25519_mul","code":"void\nsc25519_mul(unsigned char s[32], const unsigned char a[32], const unsigned char b[32])\n{\n    int64_t a0  = 2097151 \u0026 load_3(a);\n    int64_t a1  = 2097151 \u0026 (load_4(a + 2) \u003e\u003e 5);\n    int64_t a2  = 2097151 \u0026 (load_3(a + 5) \u003e\u003e 2);\n    int64_t a3  = 2097151 \u0026 (load_4(a + 7) \u003e\u003e 7);\n    int64_t a4  = 2097151 \u0026 (load_4(a + 10) \u003e\u003e 4);\n    int64_t a5  = 2097151 \u0026 (load_3(a + 13) \u003e\u003e 1);\n    int64_t a6  = 2097151 \u0026 (load_4(a + 15) \u003e\u003e 6);\n    int64_t a7  = 2097151 \u0026 (load_3(a + 18) \u003e\u003e 3);\n    int64_t a8  = 2097151 \u0026 load_3(a + 21);\n    int64_t a9  = 2097151 \u0026 (load_4(a + 23) \u003e\u003e 5);\n    int64_t a10 = 2097151 \u0026 (load_3(a + 26) \u003e\u003e 2);\n    int64_t a11 = (load_4(a + 28) \u003e\u003e 7);\n\n    int64_t b0  = 2097151 \u0026 load_3(b);\n    int64_t b1  = 2097151 \u0026 (load_4(b + 2) \u003e\u003e 5);\n    int64_t b2  = 2097151 \u0026 (load_3(b + 5) \u003e\u003e 2);\n    int64_t b3  = 2097151 \u0026 (load_4(b + 7) \u003e\u003e 7);\n    int64_t b4  = 2097151 \u0026 (load_4(b + 10) \u003e\u003e 4);\n    int64_t b5  = 2097151 \u0026 (load_3(b + 13) \u003e\u003e 1);\n    int64_t b6  = 2097151 \u0026 (load_4(b + 15) \u003e\u003e 6);\n    int64_t b7  = 2097151 \u0026 (load_3(b + 18) \u003e\u003e 3);\n    int64_t b8  = 2097151 \u0026 load_3(b + 21);\n    int64_t b9  = 2097151 \u0026 (load_4(b + 23) \u003e\u003e 5);\n    int64_t b10 = 2097151 \u0026 (load_3(b + 26) \u003e\u003e 2);\n    int64_t b11 = (load_4(b + 28) \u003e\u003e 7);\n\n    int64_t s0;\n    int64_t s1;\n    int64_t s2;\n    int64_t s3;\n    int64_t s4;\n    int64_t s5;\n    int64_t s6;\n    int64_t s7;\n    int64_t s8;\n    int64_t s9;\n    int64_t s10;\n    int64_t s11;\n    int64_t s12;\n    int64_t s13;\n    int64_t s14;\n    int64_t s15;\n    int64_t s16;\n    int64_t s17;\n    int64_t s18;\n    int64_t s19;\n    int64_t s20;\n    int64_t s21;\n    int64_t s22;\n    int64_t s23;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n    int64_t carry10;\n    int64_t carry11;\n    int64_t carry12;\n    int64_t carry13;\n    int64_t carry14;\n    int64_t carry15;\n    int64_t carry16;\n    int64_t carry17;\n    int64_t carry18;\n    int64_t carry19;\n    int64_t carry20;\n    int64_t carry21;\n    int64_t carry22;\n\n    s0 = a0 * b0;\n    s1 = a0 * b1 + a1 * b0;\n    s2 = a0 * b2 + a1 * b1 + a2 * b0;\n    s3 = a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;\n    s4 = a0 * b4 + a1 * b3 + a2 * b2 + a3 * b1 + a4 * b0;\n    s5 = a0 * b5 + a1 * b4 + a2 * b3 + a3 * b2 + a4 * b1 + a5 * b0;\n    s6 = a0 * b6 + a1 * b5 + a2 * b4 + a3 * b3 + a4 * b2 + a5 * b1 + a6 * b0;\n    s7 = a0 * b7 + a1 * b6 + a2 * b5 + a3 * b4 + a4 * b3 + a5 * b2 +\n         a6 * b1 + a7 * b0;\n    s8 = a0 * b8 + a1 * b7 + a2 * b6 + a3 * b5 + a4 * b4 + a5 * b3 +\n         a6 * b2 + a7 * b1 + a8 * b0;\n    s9 = a0 * b9 + a1 * b8 + a2 * b7 + a3 * b6 + a4 * b5 + a5 * b4 +\n         a6 * b3 + a7 * b2 + a8 * b1 + a9 * b0;\n    s10 = a0 * b10 + a1 * b9 + a2 * b8 + a3 * b7 + a4 * b6 + a5 * b5 +\n          a6 * b4 + a7 * b3 + a8 * b2 + a9 * b1 + a10 * b0;\n    s11 = a0 * b11 + a1 * b10 + a2 * b9 + a3 * b8 + a4 * b7 + a5 * b6 +\n          a6 * b5 + a7 * b4 + a8 * b3 + a9 * b2 + a10 * b1 + a11 * b0;\n    s12 = a1 * b11 + a2 * b10 + a3 * b9 + a4 * b8 + a5 * b7 + a6 * b6 +\n          a7 * b5 + a8 * b4 + a9 * b3 + a10 * b2 + a11 * b1;\n    s13 = a2 * b11 + a3 * b10 + a4 * b9 + a5 * b8 + a6 * b7 + a7 * b6 +\n          a8 * b5 + a9 * b4 + a10 * b3 + a11 * b2;\n    s14 = a3 * b11 + a4 * b10 + a5 * b9 + a6 * b8 + a7 * b7 + a8 * b6 +\n          a9 * b5 + a10 * b4 + a11 * b3;\n    s15 = a4 * b11 + a5 * b10 + a6 * b9 + a7 * b8 + a8 * b7 + a9 * b6 +\n          a10 * b5 + a11 * b4;\n    s16 =\n        a5 * b11 + a6 * b10 + a7 * b9 + a8 * b8 + a9 * b7 + a10 * b6 + a11 * b5;\n    s17 = a6 * b11 + a7 * b10 + a8 * b9 + a9 * b8 + a10 * b7 + a11 * b6;\n    s18 = a7 * b11 + a8 * b10 + a9 * b9 + a10 * b8 + a11 * b7;\n    s19 = a8 * b11 + a9 * b10 + a10 * b9 + a11 * b8;\n    s20 = a9 * b11 + a10 * b10 + a11 * b9;\n    s21 = a10 * b11 + a11 * b10;\n    s22 = a11 * b11;\n    s23 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n    carry18 = (s18 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s19 += carry18;\n    s18 -= carry18 * ((uint64_t) 1L \u003c\u003c 21);\n    carry20 = (s20 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s21 += carry20;\n    s20 -= carry20 * ((uint64_t) 1L \u003c\u003c 21);\n    carry22 = (s22 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s23 += carry22;\n    s22 -= carry22 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n    carry17 = (s17 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s18 += carry17;\n    s17 -= carry17 * ((uint64_t) 1L \u003c\u003c 21);\n    carry19 = (s19 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s20 += carry19;\n    s19 -= carry19 * ((uint64_t) 1L \u003c\u003c 21);\n    carry21 = (s21 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s22 += carry21;\n    s21 -= carry21 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s11 += s23 * 666643;\n    s12 += s23 * 470296;\n    s13 += s23 * 654183;\n    s14 -= s23 * 997805;\n    s15 += s23 * 136657;\n    s16 -= s23 * 683901;\n\n    s10 += s22 * 666643;\n    s11 += s22 * 470296;\n    s12 += s22 * 654183;\n    s13 -= s22 * 997805;\n    s14 += s22 * 136657;\n    s15 -= s22 * 683901;\n\n    s9 += s21 * 666643;\n    s10 += s21 * 470296;\n    s11 += s21 * 654183;\n    s12 -= s21 * 997805;\n    s13 += s21 * 136657;\n    s14 -= s21 * 683901;\n\n    s8 += s20 * 666643;\n    s9 += s20 * 470296;\n    s10 += s20 * 654183;\n    s11 -= s20 * 997805;\n    s12 += s20 * 136657;\n    s13 -= s20 * 683901;\n\n    s7 += s19 * 666643;\n    s8 += s19 * 470296;\n    s9 += s19 * 654183;\n    s10 -= s19 * 997805;\n    s11 += s19 * 136657;\n    s12 -= s19 * 683901;\n\n    s6 += s18 * 666643;\n    s7 += s18 * 470296;\n    s8 += s18 * 654183;\n    s9 -= s18 * 997805;\n    s10 += s18 * 136657;\n    s11 -= s18 * 683901;\n\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry12 = (s12 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s13 += carry12;\n    s12 -= carry12 * ((uint64_t) 1L \u003c\u003c 21);\n    carry14 = (s14 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s15 += carry14;\n    s14 -= carry14 * ((uint64_t) 1L \u003c\u003c 21);\n    carry16 = (s16 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s17 += carry16;\n    s16 -= carry16 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n    carry13 = (s13 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s14 += carry13;\n    s13 -= carry13 * ((uint64_t) 1L \u003c\u003c 21);\n    carry15 = (s15 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s16 += carry15;\n    s15 -= carry15 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s5 += s17 * 666643;\n    s6 += s17 * 470296;\n    s7 += s17 * 654183;\n    s8 -= s17 * 997805;\n    s9 += s17 * 136657;\n    s10 -= s17 * 683901;\n\n    s4 += s16 * 666643;\n    s5 += s16 * 470296;\n    s6 += s16 * 654183;\n    s7 -= s16 * 997805;\n    s8 += s16 * 136657;\n    s9 -= s16 * 683901;\n\n    s3 += s15 * 666643;\n    s4 += s15 * 470296;\n    s5 += s15 * 654183;\n    s6 -= s15 * 997805;\n    s7 += s15 * 136657;\n    s8 -= s15 * 683901;\n\n    s2 += s14 * 666643;\n    s3 += s14 * 470296;\n    s4 += s14 * 654183;\n    s5 -= s14 * 997805;\n    s6 += s14 * 136657;\n    s7 -= s14 * 683901;\n\n    s1 += s13 * 666643;\n    s2 += s13 * 470296;\n    s3 += s13 * 654183;\n    s4 -= s13 * 997805;\n    s5 += s13 * 136657;\n    s6 -= s13 * 683901;\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = (s0 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = (s2 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = (s4 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = (s6 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = (s8 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = (s10 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    carry1 = (s1 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = (s3 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = (s5 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = (s7 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = (s9 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = (s11 + (int64_t) (1L \u003c\u003c 20)) \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n    s12 = 0;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n    carry11 = s11 \u003e\u003e 21;\n    s12 += carry11;\n    s11 -= carry11 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s0 += s12 * 666643;\n    s1 += s12 * 470296;\n    s2 += s12 * 654183;\n    s3 -= s12 * 997805;\n    s4 += s12 * 136657;\n    s5 -= s12 * 683901;\n\n    carry0 = s0 \u003e\u003e 21;\n    s1 += carry0;\n    s0 -= carry0 * ((uint64_t) 1L \u003c\u003c 21);\n    carry1 = s1 \u003e\u003e 21;\n    s2 += carry1;\n    s1 -= carry1 * ((uint64_t) 1L \u003c\u003c 21);\n    carry2 = s2 \u003e\u003e 21;\n    s3 += carry2;\n    s2 -= carry2 * ((uint64_t) 1L \u003c\u003c 21);\n    carry3 = s3 \u003e\u003e 21;\n    s4 += carry3;\n    s3 -= carry3 * ((uint64_t) 1L \u003c\u003c 21);\n    carry4 = s4 \u003e\u003e 21;\n    s5 += carry4;\n    s4 -= carry4 * ((uint64_t) 1L \u003c\u003c 21);\n    carry5 = s5 \u003e\u003e 21;\n    s6 += carry5;\n    s5 -= carry5 * ((uint64_t) 1L \u003c\u003c 21);\n    carry6 = s6 \u003e\u003e 21;\n    s7 += carry6;\n    s6 -= carry6 * ((uint64_t) 1L \u003c\u003c 21);\n    carry7 = s7 \u003e\u003e 21;\n    s8 += carry7;\n    s7 -= carry7 * ((uint64_t) 1L \u003c\u003c 21);\n    carry8 = s8 \u003e\u003e 21;\n    s9 += carry8;\n    s8 -= carry8 * ((uint64_t) 1L \u003c\u003c 21);\n    carry9 = s9 \u003e\u003e 21;\n    s10 += carry9;\n    s9 -= carry9 * ((uint64_t) 1L \u003c\u003c 21);\n    carry10 = s10 \u003e\u003e 21;\n    s11 += carry10;\n    s10 -= carry10 * ((uint64_t) 1L \u003c\u003c 21);\n\n    s[0]  = s0 \u003e\u003e 0;\n    s[1]  = s0 \u003e\u003e 8;\n    s[2]  = (s0 \u003e\u003e 16) | (s1 * ((uint64_t) 1 \u003c\u003c 5));\n    s[3]  = s1 \u003e\u003e 3;\n    s[4]  = s1 \u003e\u003e 11;\n    s[5]  = (s1 \u003e\u003e 19) | (s2 * ((uint64_t) 1 \u003c\u003c 2));\n    s[6]  = s2 \u003e\u003e 6;\n    s[7]  = (s2 \u003e\u003e 14) | (s3 * ((uint64_t) 1 \u003c\u003c 7));\n    s[8]  = s3 \u003e\u003e 1;\n    s[9]  = s3 \u003e\u003e 9;\n    s[10] = (s3 \u003e\u003e 17) | (s4 * ((uint64_t) 1 \u003c\u003c 4));\n    s[11] = s4 \u003e\u003e 4;\n    s[12] = s4 \u003e\u003e 12;\n    s[13] = (s4 \u003e\u003e 20) | (s5 * ((uint64_t) 1 \u003c\u003c 1));\n    s[14] = s5 \u003e\u003e 7;\n    s[15] = (s5 \u003e\u003e 15) | (s6 * ((uint64_t) 1 \u003c\u003c 6));\n    s[16] = s6 \u003e\u003e 2;\n    s[17] = s6 \u003e\u003e 10;\n    s[18] = (s6 \u003e\u003e 18) | (s7 * ((uint64_t) 1 \u003c\u003c 3));\n    s[19] = s7 \u003e\u003e 5;\n    s[20] = s7 \u003e\u003e 13;\n    s[21] = s8 \u003e\u003e 0;\n    s[22] = s8 \u003e\u003e 8;\n    s[23] = (s8 \u003e\u003e 16) | (s9 * ((uint64_t) 1 \u003c\u003c 5));\n    s[24] = s9 \u003e\u003e 3;\n    s[25] = s9 \u003e\u003e 11;\n    s[26] = (s9 \u003e\u003e 19) | (s10 * ((uint64_t) 1 \u003c\u003c 2));\n    s[27] = s10 \u003e\u003e 6;\n    s[28] = (s10 \u003e\u003e 14) | (s11 * ((uint64_t) 1 \u003c\u003c 7));\n    s[29] = s11 \u003e\u003e 1;\n    s[30] = s11 \u003e\u003e 9;\n    s[31] = s11 \u003e\u003e 17;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":1084,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"614887":{"score":0.92131394,"function_name":"sc25519_sqmul","code":"static inline void\nsc25519_sqmul(unsigned char s[32], const int n, const unsigned char a[32])\n{\n    int i;\n\n    for (i = 0; i \u003c n; i++) {\n        sc25519_sq(s, s);\n    }\n    sc25519_mul(s, s, a);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2060,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"614961":{"score":0.81969327,"function_name":"sc25519_invert","code":"void\nsc25519_invert(unsigned char recip[32], const unsigned char s[32])\n{\n    unsigned char _10[32], _100[32], _11[32], _101[32], _111[32],\n        _1001[32], _1011[32], _1111[32];\n\n    sc25519_sq(_10, s);\n    sc25519_sq(_100, _10);\n    sc25519_mul(_11, _10, s);\n    sc25519_mul(_101, _10, _11);\n    sc25519_mul(_111, _10, _101);\n    sc25519_mul(_1001, _10, _111);\n    sc25519_mul(_1011, _10, _1001);\n    sc25519_mul(_1111, _100, _1011);\n    sc25519_mul(recip, _1111, s);\n\n    sc25519_sqmul(recip, 123 + 3, _101);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 4, _1001);\n    sc25519_sqmul(recip, 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 3, _101);\n    sc25519_sqmul(recip, 3 + 3, _101);\n    sc25519_sqmul(recip, 3, _111);\n    sc25519_sqmul(recip, 1 + 4, _1111);\n    sc25519_sqmul(recip, 2 + 3, _111);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1011);\n    sc25519_sqmul(recip, 2 + 4, _1011);\n    sc25519_sqmul(recip, 6 + 4, _1001);\n    sc25519_sqmul(recip, 2 + 2, _11);\n    sc25519_sqmul(recip, 3 + 2, _11);\n    sc25519_sqmul(recip, 3 + 2, _11);\n    sc25519_sqmul(recip, 1 + 4, _1001);\n    sc25519_sqmul(recip, 1 + 3, _111);\n    sc25519_sqmul(recip, 2 + 4, _1111);\n    sc25519_sqmul(recip, 1 + 4, _1011);\n    sc25519_sqmul(recip, 3, _101);\n    sc25519_sqmul(recip, 2 + 4, _1111);\n    sc25519_sqmul(recip, 3, _101);\n    sc25519_sqmul(recip, 1 + 2, _11);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2071,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"627680":{"score":0.893859,"function_name":"sc25519_is_canonical","code":"int\nsc25519_is_canonical(const unsigned char s[32])\n{\n    /* 2^252+27742317777372353535851937790883648493 */\n    static const unsigned char L[32] = {\n        0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7,\n        0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10\n    };\n    unsigned char c = 0;\n    unsigned char n = 1;\n    unsigned int  i = 32;\n\n    do {\n        i--;\n        c |= ((s[i] - L[i]) \u003e\u003e 8) \u0026 n;\n        n \u0026= ((s[i] ^ L[i]) - 1) \u003e\u003e 8;\n    } while (i != 0);\n\n    return (c != 0);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2450,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"628788":{"score":0.85095906,"function_name":"ge25519_elligator2","code":"static void\nge25519_elligator2(unsigned char s[32], const fe25519 r, const unsigned char x_sign)\n{\n    fe25519      e;\n    fe25519      negx;\n    fe25519      rr2;\n    fe25519      x, x2, x3;\n    ge25519_p3   p3;\n    ge25519_p1p1 p1;\n    ge25519_p2   p2;\n    unsigned int e_is_minus_1;\n\n    fe25519_sq2(rr2, r);\n    rr2[0]++;\n    fe25519_invert(rr2, rr2);\n    fe25519_mul(x, curve25519_A, rr2);\n    fe25519_neg(x, x);\n\n    fe25519_sq(x2, x);\n    fe25519_mul(x3, x, x2);\n    fe25519_add(e, x3, x);\n    fe25519_mul(x2, x2, curve25519_A);\n    fe25519_add(e, x2, e);\n\n    chi25519(e, e);\n\n    fe25519_tobytes(s, e);\n    e_is_minus_1 = s[1] \u0026 1;\n    fe25519_neg(negx, x);\n    fe25519_cmov(x, negx, e_is_minus_1);\n    fe25519_0(x2);\n    fe25519_cmov(x2, curve25519_A, e_is_minus_1);\n    fe25519_sub(x, x, x2);\n\n    /* yed = (x-1)/(x+1) */\n    {\n        fe25519 one;\n        fe25519 x_plus_one;\n        fe25519 x_plus_one_inv;\n        fe25519 x_minus_one;\n        fe25519 yed;\n\n        fe25519_1(one);\n        fe25519_add(x_plus_one, x, one);\n        fe25519_sub(x_minus_one, x, one);\n        fe25519_invert(x_plus_one_inv, x_plus_one);\n        fe25519_mul(yed, x_minus_one, x_plus_one_inv);\n        fe25519_tobytes(s, yed);\n    }\n\n    /* recover x */\n    s[31] |= x_sign;\n    if (ge25519_frombytes(\u0026p3, s) != 0) {\n        abort(); /* LCOV_EXCL_LINE */\n    }\n\n    /* multiply by the cofactor */\n    ge25519_p3_dbl(\u0026p1, \u0026p3);\n    ge25519_p1p1_to_p2(\u0026p2, \u0026p1);\n    ge25519_p2_dbl(\u0026p1, \u0026p2);\n    ge25519_p1p1_to_p2(\u0026p2, \u0026p1);\n    ge25519_p2_dbl(\u0026p1, \u0026p2);\n    ge25519_p1p1_to_p3(\u0026p3, \u0026p1);\n\n    ge25519_p3_tobytes(s, \u0026p3);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2528,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"629752":{"score":0.8018938,"function_name":"ge25519_from_uniform","code":"void\nge25519_from_uniform(unsigned char s[32], const unsigned char r[32])\n{\n    fe25519       r_fe;\n    unsigned char x_sign;\n\n    memcpy(s, r, 32);\n    x_sign = s[31] \u0026 0x80;\n    s[31] \u0026= 0x7f;\n    fe25519_frombytes(r_fe, s);\n    ge25519_elligator2(s, r_fe, x_sign);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2595,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"629913":{"score":0.9058892,"function_name":"ge25519_from_hash","code":"void\nge25519_from_hash(unsigned char s[32], const unsigned char h[64])\n{\n    unsigned char fl[32];\n    unsigned char gl[32];\n    fe25519       fe_f;\n    fe25519       fe_g;\n    size_t        i;\n    unsigned char x_sign;\n\n    x_sign = h[0] \u0026 0x80;\n    for (i = 0; i \u003c 32; i++) {\n        fl[i] = h[63 - i];\n        gl[i] = h[31 - i];\n    }\n    fl[31] \u0026= 0x7f;\n    gl[31] \u0026= 0x7f;\n    fe25519_frombytes(fe_f, fl);\n    fe25519_frombytes(fe_g, gl);\n    fe_f[0] += (h[32] \u003e\u003e 7) * 19;\n    for (i = 0; i \u003c sizeof (fe25519) / sizeof fe_f[0]; i++) {\n        fe_f[i] += 38 * fe_g[i];\n    }\n    fe25519_reduce(fe_f, fe_f);\n    ge25519_elligator2(s, fe_f, x_sign);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2608,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"630322":{"score":0.8564824,"function_name":"ristretto255_sqrt_ratio_m1","code":"static int\nristretto255_sqrt_ratio_m1(fe25519 x, const fe25519 u, const fe25519 v)\n{\n    fe25519 v3;\n    fe25519 vxx;\n    fe25519 m_root_check, p_root_check, f_root_check;\n    fe25519 x_sqrtm1;\n    int     has_m_root, has_p_root, has_f_root;\n\n    fe25519_sq(v3, v);\n    fe25519_mul(v3, v3, v); /* v3 = v^3 */\n    fe25519_sq(x, v3);\n    fe25519_mul(x, x, v);\n    fe25519_mul(x, x, u); /* x = uv^7 */\n\n    fe25519_pow22523(x, x); /* x = (uv^7)^((q-5)/8) */\n    fe25519_mul(x, x, v3);\n    fe25519_mul(x, x, u); /* x = uv^3(uv^7)^((q-5)/8) */\n\n    fe25519_sq(vxx, x);\n    fe25519_mul(vxx, vxx, v); /* vx^2 */\n    fe25519_sub(m_root_check, vxx, u); /* vx^2-u */\n    fe25519_add(p_root_check, vxx, u); /* vx^2+u */\n    fe25519_mul(f_root_check, u, sqrtm1); /* u*sqrt(-1) */\n    fe25519_add(f_root_check, vxx, f_root_check); /* vx^2+u*sqrt(-1) */\n    has_m_root = fe25519_iszero(m_root_check);\n    has_p_root = fe25519_iszero(p_root_check);\n    has_f_root = fe25519_iszero(f_root_check);\n    fe25519_mul(x_sqrtm1, x, sqrtm1); /* x*sqrt(-1) */\n\n    fe25519_cmov(x, x_sqrtm1, has_p_root | has_f_root);\n    fe25519_abs(x, x);\n\n    return has_m_root | has_p_root;\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2637,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"630953":{"score":0.9051226,"function_name":"ristretto255_is_canonical","code":"static int\nristretto255_is_canonical(const unsigned char *s)\n{\n    unsigned char c;\n    unsigned char d;\n    unsigned int  i;\n\n    c = (s[31] \u0026 0x7f) ^ 0x7f;\n    for (i = 30; i \u003e 0; i--) {\n        c |= s[i] ^ 0xff;\n    }\n    c = (((unsigned int) c) - 1U) \u003e\u003e 8;\n    d = (0xed - 1U - (unsigned int) s[0]) \u003e\u003e 8;\n\n    return 1 - (((c \u0026 d) | s[0]) \u0026 1);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2673,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"631091":{"score":0.88256794,"function_name":"ristretto255_frombytes","code":"int\nristretto255_frombytes(ge25519_p3 *h, const unsigned char *s)\n{\n    fe25519 inv_sqrt;\n    fe25519 one;\n    fe25519 s_;\n    fe25519 ss;\n    fe25519 u1, u2;\n    fe25519 u1u1, u2u2;\n    fe25519 v;\n    fe25519 v_u2u2;\n    int     was_square;\n\n    if (ristretto255_is_canonical(s) == 0) {\n        return -1;\n    }\n    fe25519_frombytes(s_, s);\n    fe25519_sq(ss, s_);                /* ss = s^2 */\n\n    fe25519_1(u1);\n    fe25519_sub(u1, u1, ss);           /* u1 = 1-ss */\n    fe25519_sq(u1u1, u1);              /* u1u1 = u1^2 */\n\n    fe25519_1(u2);\n    fe25519_add(u2, u2, ss);           /* u2 = 1+ss */\n    fe25519_sq(u2u2, u2);              /* u2u2 = u2^2 */\n\n    fe25519_mul(v, d, u1u1);           /* v = d*u1^2 */\n    fe25519_neg(v, v);                 /* v = -d*u1^2 */\n    fe25519_sub(v, v, u2u2);           /* v = -(d*u1^2)-u2^2 */\n\n    fe25519_mul(v_u2u2, v, u2u2);      /* v_u2u2 = v*u2^2 */\n\n    fe25519_1(one);\n    was_square = ristretto255_sqrt_ratio_m1(inv_sqrt, one, v_u2u2);\n    fe25519_mul(h-\u003eX, inv_sqrt, u2);\n    fe25519_mul(h-\u003eY, inv_sqrt, h-\u003eX);\n    fe25519_mul(h-\u003eY, h-\u003eY, v);\n\n    fe25519_mul(h-\u003eX, h-\u003eX, s_);\n    fe25519_add(h-\u003eX, h-\u003eX, h-\u003eX);\n    fe25519_abs(h-\u003eX, h-\u003eX);\n    fe25519_mul(h-\u003eY, u1, h-\u003eY);\n    fe25519_1(h-\u003eZ);\n    fe25519_mul(h-\u003eT, h-\u003eX, h-\u003eY);\n\n    return - ((1 - was_square) |\n              fe25519_isnegative(h-\u003eT) | fe25519_iszero(h-\u003eY));\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2690,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"631886":{"score":0.8718745,"function_name":"ristretto255_p3_tobytes","code":"void\nristretto255_p3_tobytes(unsigned char *s, const ge25519_p3 *h)\n{\n    fe25519 den1, den2;\n    fe25519 den_inv;\n    fe25519 eden;\n    fe25519 inv_sqrt;\n    fe25519 ix, iy;\n    fe25519 one;\n    fe25519 s_;\n    fe25519 t_z_inv;\n    fe25519 u1, u2;\n    fe25519 u1_u2u2;\n    fe25519 x_, y_;\n    fe25519 x_z_inv;\n    fe25519 z_inv;\n    fe25519 zmy;\n    int     rotate;\n\n    fe25519_add(u1, h-\u003eZ, h-\u003eY);       /* u1 = Z+Y */\n    fe25519_sub(zmy, h-\u003eZ, h-\u003eY);      /* zmy = Z-Y */\n    fe25519_mul(u1, u1, zmy);          /* u1 = (Z+Y)*(Z-Y) */\n    fe25519_mul(u2, h-\u003eX, h-\u003eY);       /* u2 = X*Y */\n\n    fe25519_sq(u1_u2u2, u2);           /* u1_u2u2 = u2^2 */\n    fe25519_mul(u1_u2u2, u1, u1_u2u2); /* u1_u2u2 = u1*u2^2 */\n\n    fe25519_1(one);\n    (void) ristretto255_sqrt_ratio_m1(inv_sqrt, one, u1_u2u2);\n    fe25519_mul(den1, inv_sqrt, u1);   /* den1 = inv_sqrt*u1 */\n    fe25519_mul(den2, inv_sqrt, u2);   /* den2 = inv_sqrt*u2 */\n    fe25519_mul(z_inv, den1, den2);    /* z_inv = den1*den2 */\n    fe25519_mul(z_inv, z_inv, h-\u003eT);   /* z_inv = den1*den2*T */\n\n    fe25519_mul(ix, h-\u003eX, sqrtm1);     /* ix = X*sqrt(-1) */\n    fe25519_mul(iy, h-\u003eY, sqrtm1);     /* iy = Y*sqrt(-1) */\n    fe25519_mul(eden, den1, invsqrtamd); /* eden = den1*sqrt(a-d) */\n\n    fe25519_mul(t_z_inv, h-\u003eT, z_inv); /* t_z_inv = T*z_inv */\n    rotate = fe25519_isnegative(t_z_inv);\n\n    fe25519_copy(x_, h-\u003eX);\n    fe25519_copy(y_, h-\u003eY);\n    fe25519_copy(den_inv, den2);\n\n    fe25519_cmov(x_, iy, rotate);\n    fe25519_cmov(y_, ix, rotate);\n    fe25519_cmov(den_inv, eden, rotate);\n\n    fe25519_mul(x_z_inv, x_, z_inv);\n    fe25519_cneg(y_, y_, fe25519_isnegative(x_z_inv));\n\n    fe25519_sub(s_, h-\u003eZ, y_);\n    fe25519_mul(s_, den_inv, s_);\n    fe25519_abs(s_, s_);\n    fe25519_tobytes(s, s_);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2740,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"632834":{"score":0.82178515,"function_name":"ristretto255_elligator","code":"static void\nristretto255_elligator(ge25519_p3 *p, const fe25519 t)\n{\n    fe25519 c;\n    fe25519 n;\n    fe25519 one;\n    fe25519 r;\n    fe25519 rpd;\n    fe25519 s, s_prime;\n    fe25519 ss;\n    fe25519 u, v;\n    fe25519 w0, w1, w2, w3;\n    int     wasnt_square;\n\n    fe25519_1(one);\n    fe25519_sq(r, t);                  /* r = t^2 */\n    fe25519_mul(r, sqrtm1, r);         /* r = sqrt(-1)*t^2 */\n    fe25519_add(u, r, one);            /* u = r+1 */\n    fe25519_mul(u, u, onemsqd);        /* u = (r+1)*(1-d^2) */\n    fe25519_1(c);\n    fe25519_neg(c, c);                 /* c = -1 */\n    fe25519_add(rpd, r, d);            /* rpd = r*d */\n    fe25519_mul(v, r, d);              /* v = r*d */\n    fe25519_sub(v, c, v);              /* v = c-r*d */\n    fe25519_mul(v, v, rpd);            /* v = (c-r*d)*(r+d) */\n\n    wasnt_square = 1 - ristretto255_sqrt_ratio_m1(s, u, v);\n    fe25519_mul(s_prime, s, t);\n    fe25519_abs(s_prime, s_prime);\n    fe25519_neg(s_prime, s_prime);     /* s_prime = -|s*t| */\n    fe25519_cmov(s, s_prime, wasnt_square);\n    fe25519_cmov(c, r, wasnt_square);\n\n    fe25519_sub(n, r, one);            /* n = r-1 */\n    fe25519_mul(n, n, c);              /* n = c*(r-1) */\n    fe25519_mul(n, n, sqdmone);        /* n = c*(r-1)*(d-1)^2 */\n    fe25519_sub(n, n, v);              /* n =  c*(r-1)*(d-1)^2-v */\n\n    fe25519_add(w0, s, s);             /* w0 = 2s */\n    fe25519_mul(w0, w0, v);            /* w0 = 2s*v */\n    fe25519_mul(w1, n, sqrtadm1);      /* w1 = n*sqrt(ad-1) */\n    fe25519_sq(ss, s);                 /* ss = s^2 */\n    fe25519_sub(w2, one, ss);          /* w2 = 1-s^2 */\n    fe25519_add(w3, one, ss);          /* w3 = 1+s^2 */\n\n    fe25519_mul(p-\u003eX, w0, w3);\n    fe25519_mul(p-\u003eY, w2, w1);\n    fe25519_mul(p-\u003eZ, w1, w3);\n    fe25519_mul(p-\u003eT, w0, w2);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2798,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"633840":{"score":0.79511726,"function_name":"ristretto255_from_hash","code":"void\nristretto255_from_hash(unsigned char s[32], const unsigned char h[64])\n{\n    fe25519        r0, r1;\n    ge25519_cached p1_cached;\n    ge25519_p1p1   p_p1p1;\n    ge25519_p3     p0, p1;\n    ge25519_p3     p;\n\n    fe25519_frombytes(r0, h);\n    fe25519_frombytes(r1, h + 32);\n    ristretto255_elligator(\u0026p0, r0);\n    ristretto255_elligator(\u0026p1, r1);\n    ge25519_p3_to_cached(\u0026p1_cached, \u0026p1);\n    ge25519_add(\u0026p_p1p1, \u0026p0, \u0026p1_cached);\n    ge25519_p1p1_to_p3(\u0026p, \u0026p_p1p1);\n    ristretto255_p3_tobytes(s, \u0026p);\n}","filepath":"src/libsodium/crypto_core/ed25519/ref10/ed25519_ref10.c","line_number":2849,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.18-RELEASE"},"634110":{"score":0.823341,"function_name":"crypto_generichash_blake2b_salt_personal","code":"int\ncrypto_generichash_blake2b_salt_personal(unsigned char *out, size_t outlen,\n                                         const unsigned char *in, unsigned long long inlen,\n                                         const unsigned char *key, size_t keylen,\n                                         const unsigned char *salt,\n                                         const unsigned char *personal)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES || inlen \u003e UINT64_MAX) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n\n    return blake2b_salt_personal((uint8_t *) out, in, key,\n                                 (uint8_t) outlen, (uint64_t) inlen, (uint8_t) keylen,\n                                 salt, personal);\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/generichash_blake2b.c","line_number":25,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.7.1"},"634474":{"score":0.89059114,"function_name":"crypto_generichash_blake2b_init","code":"int\ncrypto_generichash_blake2b_init(crypto_generichash_blake2b_state *state,\n                                const unsigned char *key,\n                                const size_t keylen, const size_t outlen)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n    if (key == NULL || keylen \u003c= 0U) {\n        if (blake2b_init(state, (uint8_t) outlen) != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n    } else if (blake2b_init_key(state, (uint8_t) outlen, key,\n                                (uint8_t) keylen) != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/generichash_blake2b.c","line_number":44,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.7.1"},"634694":{"score":0.8931307,"function_name":"crypto_generichash_blake2b_init_salt_personal","code":"int\ncrypto_generichash_blake2b_init_salt_personal(crypto_generichash_blake2b_state *state,\n                                              const unsigned char *key,\n                                              const size_t keylen, const size_t outlen,\n                                              const unsigned char *salt,\n                                              const unsigned char *personal)\n{\n    if (outlen \u003c= 0U || outlen \u003e BLAKE2B_OUTBYTES ||\n        keylen \u003e BLAKE2B_KEYBYTES) {\n        return -1;\n    }\n    assert(outlen \u003c= UINT8_MAX);\n    assert(keylen \u003c= UINT8_MAX);\n    if (key == NULL || keylen \u003c= 0U) {\n        if (blake2b_init_salt_personal(state, (uint8_t) outlen,\n                                       salt, personal) != 0) {\n            return -1; /* LCOV_EXCL_LINE */\n        }\n    } else if (blake2b_init_key_salt_personal(state,\n                                              (uint8_t) outlen, key,\n                                              (uint8_t) keylen,\n                                              salt, personal) != 0) {\n        return -1; /* LCOV_EXCL_LINE */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/generichash_blake2b.c","line_number":66,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.7.1"},"634982":{"score":0.7944976,"function_name":"crypto_generichash_blake2b_final","code":"int\ncrypto_generichash_blake2b_final(crypto_generichash_blake2b_state *state,\n                                 unsigned char *out,\n                                 const size_t outlen)\n{\n    assert(outlen \u003c= UINT8_MAX);\n    return blake2b_final(state, (uint8_t *) out, (uint8_t) outlen);\n}","filepath":"src/libsodium/crypto_generichash/blake2/ref/generichash_blake2b.c","line_number":101,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"0.7.1"},"635818":{"score":0.7449516,"function_name":"be32enc_vect","code":"static void\nbe32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n    size_t i;\n\n    for (i = 0; i \u003c len / 4; i++) {\n        STORE32_BE(dst + i * 4, src[i]);\n    }\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":40,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"635914":{"score":0.78939295,"function_name":"be32dec_vect","code":"static void\nbe32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n    size_t i;\n\n    for (i = 0; i \u003c len / 4; i++) {\n        dst[i] = LOAD32_BE(src + i * 4);\n    }\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":50,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"636009":{"score":0.8773805,"function_name":"SHA256_Transform","code":"static void\nSHA256_Transform(uint32_t state[8], const uint8_t block[64], uint32_t W[64],\n                 uint32_t S[8])\n{\n    int i;\n\n    be32dec_vect(W, block, 64);\n    memcpy(S, state, 32);\n    for (i = 0; i \u003c 64; i += 16) {\n        RNDr(S, W, 0, i);\n        RNDr(S, W, 1, i);\n        RNDr(S, W, 2, i);\n        RNDr(S, W, 3, i);\n        RNDr(S, W, 4, i);\n        RNDr(S, W, 5, i);\n        RNDr(S, W, 6, i);\n        RNDr(S, W, 7, i);\n        RNDr(S, W, 8, i);\n        RNDr(S, W, 9, i);\n        RNDr(S, W, 10, i);\n        RNDr(S, W, 11, i);\n        RNDr(S, W, 12, i);\n        RNDr(S, W, 13, i);\n        RNDr(S, W, 14, i);\n        RNDr(S, W, 15, i);\n        if (i == 48) {\n            break;\n        }\n        MSCH(W, 0, i);\n        MSCH(W, 1, i);\n        MSCH(W, 2, i);\n        MSCH(W, 3, i);\n        MSCH(W, 4, i);\n        MSCH(W, 5, i);\n        MSCH(W, 6, i);\n        MSCH(W, 7, i);\n        MSCH(W, 8, i);\n        MSCH(W, 9, i);\n        MSCH(W, 10, i);\n        MSCH(W, 11, i);\n        MSCH(W, 12, i);\n        MSCH(W, 13, i);\n        MSCH(W, 14, i);\n        MSCH(W, 15, i);\n    }\n    for (i = 0; i \u003c 8; i++) {\n        state[i] += S[i];\n    }\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":97,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"656611":{"score":0.92258334,"function_name":"SHA256_Pad","code":"static void\nSHA256_Pad(crypto_hash_sha256_state *state, uint32_t tmp32[64 + 8])\n{\n    unsigned int r;\n    unsigned int i;\n\n    r = (unsigned int) ((state-\u003ecount \u003e\u003e 3) \u0026 0x3f);\n    if (r \u003c 56) {\n        for (i = 0; i \u003c 56 - r; i++) {\n            state-\u003ebuf[r + i] = PAD[i];\n        }\n    } else {\n        for (i = 0; i \u003c 64 - r; i++) {\n            state-\u003ebuf[r + i] = PAD[i];\n        }\n        SHA256_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp32[0], \u0026tmp32[64]);\n        memset(\u0026state-\u003ebuf[0], 0, 56);\n    }\n    STORE64_BE(\u0026state-\u003ebuf[56], state-\u003ecount);\n    SHA256_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp32[0], \u0026tmp32[64]);\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":153,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"656901":{"score":0.7523878,"function_name":"crypto_hash_sha256_init","code":"int\ncrypto_hash_sha256_init(crypto_hash_sha256_state *state)\n{\n    static const uint32_t sha256_initial_state[8] = { 0x6a09e667, 0xbb67ae85,\n                                                      0x3c6ef372, 0xa54ff53a,\n                                                      0x510e527f, 0x9b05688c,\n                                                      0x1f83d9ab, 0x5be0cd19 };\n\n    state-\u003ecount = (uint64_t) 0U;\n    memcpy(state-\u003estate, sha256_initial_state, sizeof sha256_initial_state);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":175,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"656990":{"score":0.69831824,"function_name":"crypto_hash_sha256_update","code":"int\ncrypto_hash_sha256_update(crypto_hash_sha256_state *state,\n                          const unsigned char *in, unsigned long long inlen)\n{\n    uint32_t           tmp32[64 + 8];\n    unsigned long long i;\n    unsigned long long r;\n\n    if (inlen \u003c= 0U) {\n        return 0;\n    }\n    r = (unsigned long long) ((state-\u003ecount \u003e\u003e 3) \u0026 0x3f);\n\n    state-\u003ecount += ((uint64_t) inlen) \u003c\u003c 3;\n    if (inlen \u003c 64 - r) {\n        for (i = 0; i \u003c inlen; i++) {\n            state-\u003ebuf[r + i] = in[i];\n        }\n        return 0;\n    }\n    for (i = 0; i \u003c 64 - r; i++) {\n        state-\u003ebuf[r + i] = in[i];\n    }\n    SHA256_Transform(state-\u003estate, state-\u003ebuf, \u0026tmp32[0], \u0026tmp32[64]);\n    in += 64 - r;\n    inlen -= 64 - r;\n\n    while (inlen \u003e= 64) {\n        SHA256_Transform(state-\u003estate, in, \u0026tmp32[0], \u0026tmp32[64]);\n        in += 64;\n        inlen -= 64;\n    }\n    inlen \u0026= 63;\n    for (i = 0; i \u003c inlen; i++) {\n        state-\u003ebuf[i] = in[i];\n    }\n    sodium_memzero((void *) tmp32, sizeof tmp32);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":189,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"658080":{"score":0.7232821,"function_name":"crypto_hash_sha256_final","code":"int\ncrypto_hash_sha256_final(crypto_hash_sha256_state *state, unsigned char *out)\n{\n    uint32_t tmp32[64 + 8];\n\n    SHA256_Pad(state, tmp32);\n    be32enc_vect(out, state-\u003estate, 32);\n    sodium_memzero((void *) tmp32, sizeof tmp32);\n    sodium_memzero((void *) state, sizeof *state);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":230,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"658252":{"score":0.7933816,"function_name":"crypto_hash_sha256","code":"int\ncrypto_hash_sha256(unsigned char *out, const unsigned char *in,\n                   unsigned long long inlen)\n{\n    crypto_hash_sha256_state state;\n\n    crypto_hash_sha256_init(\u0026state);\n    crypto_hash_sha256_update(\u0026state, in, inlen);\n    crypto_hash_sha256_final(\u0026state, out);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_hash/sha256/cp/hash_sha256_cp.c","line_number":243,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"658898":{"score":0.8480146,"function_name":"poly1305_init","code":"static void\npoly1305_init(poly1305_context *ctx, const unsigned char key[32]) {\n        poly1305_state_internal_t *st = (poly1305_state_internal_t *)(void *)ctx;\n\n        /* r \u0026= 0xffffffc0ffffffc0ffffffc0fffffff */\n        st-\u003er[0] = (U8TO32(\u0026key[ 0])     ) \u0026 0x3ffffff;\n        st-\u003er[1] = (U8TO32(\u0026key[ 3]) \u003e\u003e 2) \u0026 0x3ffff03;\n        st-\u003er[2] = (U8TO32(\u0026key[ 6]) \u003e\u003e 4) \u0026 0x3ffc0ff;\n        st-\u003er[3] = (U8TO32(\u0026key[ 9]) \u003e\u003e 6) \u0026 0x3f03fff;\n        st-\u003er[4] = (U8TO32(\u0026key[12]) \u003e\u003e 8) \u0026 0x00fffff;\n\n        /* h = 0 */\n        st-\u003eh[0] = 0;\n        st-\u003eh[1] = 0;\n        st-\u003eh[2] = 0;\n        st-\u003eh[3] = 0;\n        st-\u003eh[4] = 0;\n\n        /* save pad for later */\n        st-\u003epad[0] = U8TO32(\u0026key[16]);\n        st-\u003epad[1] = U8TO32(\u0026key[20]);\n        st-\u003epad[2] = U8TO32(\u0026key[24]);\n        st-\u003epad[3] = U8TO32(\u0026key[28]);\n\n        st-\u003eleftover = 0;\n        st-\u003efinal = 0;\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":44,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.6"},"659257":{"score":0.75500786,"function_name":"poly1305_blocks","code":"static void\npoly1305_blocks(poly1305_state_internal_t *st, const unsigned char *m, unsigned long long bytes) {\n        const unsigned long hibit = (st-\u003efinal) ? 0 : (1 \u003c\u003c 24); /* 1 \u003c\u003c 128 */\n        unsigned long r0,r1,r2,r3,r4;\n        unsigned long s1,s2,s3,s4;\n        unsigned long h0,h1,h2,h3,h4;\n        unsigned long long d0,d1,d2,d3,d4;\n        unsigned long c;\n\n        r0 = st-\u003er[0];\n        r1 = st-\u003er[1];\n        r2 = st-\u003er[2];\n        r3 = st-\u003er[3];\n        r4 = st-\u003er[4];\n\n        s1 = r1 * 5;\n        s2 = r2 * 5;\n        s3 = r3 * 5;\n        s4 = r4 * 5;\n\n        h0 = st-\u003eh[0];\n        h1 = st-\u003eh[1];\n        h2 = st-\u003eh[2];\n        h3 = st-\u003eh[3];\n        h4 = st-\u003eh[4];\n\n        while (bytes \u003e= poly1305_block_size) {\n                /* h += m[i] */\n                h0 += (U8TO32(m+ 0)     ) \u0026 0x3ffffff;\n                h1 += (U8TO32(m+ 3) \u003e\u003e 2) \u0026 0x3ffffff;\n                h2 += (U8TO32(m+ 6) \u003e\u003e 4) \u0026 0x3ffffff;\n                h3 += (U8TO32(m+ 9) \u003e\u003e 6) \u0026 0x3ffffff;\n                h4 += (U8TO32(m+12) \u003e\u003e 8) | hibit;\n\n                /* h *= r */\n                d0 = ((unsigned long long)h0 * r0) + ((unsigned long long)h1 * s4) + ((unsigned long long)h2 * s3) + ((unsigned long long)h3 * s2) + ((unsigned long long)h4 * s1);\n                d1 = ((unsigned long long)h0 * r1) + ((unsigned long long)h1 * r0) + ((unsigned long long)h2 * s4) + ((unsigned long long)h3 * s3) + ((unsigned long long)h4 * s2);\n                d2 = ((unsigned long long)h0 * r2) + ((unsigned long long)h1 * r1) + ((unsigned long long)h2 * r0) + ((unsigned long long)h3 * s4) + ((unsigned long long)h4 * s3);\n                d3 = ((unsigned long long)h0 * r3) + ((unsigned long long)h1 * r2) + ((unsigned long long)h2 * r1) + ((unsigned long long)h3 * r0) + ((unsigned long long)h4 * s4);\n                d4 = ((unsigned long long)h0 * r4) + ((unsigned long long)h1 * r3) + ((unsigned long long)h2 * r2) + ((unsigned long long)h3 * r1) + ((unsigned long long)h4 * r0);\n\n                /* (partial) h %= p */\n                              c = (unsigned long)(d0 \u003e\u003e 26); h0 = (unsigned long)d0 \u0026 0x3ffffff;\n                d1 += c;      c = (unsigned long)(d1 \u003e\u003e 26); h1 = (unsigned long)d1 \u0026 0x3ffffff;\n                d2 += c;      c = (unsigned long)(d2 \u003e\u003e 26); h2 = (unsigned long)d2 \u0026 0x3ffffff;\n                d3 += c;      c = (unsigned long)(d3 \u003e\u003e 26); h3 = (unsigned long)d3 \u0026 0x3ffffff;\n                d4 += c;      c = (unsigned long)(d4 \u003e\u003e 26); h4 = (unsigned long)d4 \u0026 0x3ffffff;\n                h0 += c * 5;  c =                (h0 \u003e\u003e 26); h0 =                h0 \u0026 0x3ffffff;\n                h1 += c;\n\n                m += poly1305_block_size;\n                bytes -= poly1305_block_size;\n        }\n\n        st-\u003eh[0] = h0;\n        st-\u003eh[1] = h1;\n        st-\u003eh[2] = h2;\n        st-\u003eh[3] = h3;\n        st-\u003eh[4] = h4;\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":72,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.6"},"661413":{"score":0.84405893,"function_name":"poly1305_finish","code":"static POLY1305_NOINLINE void\npoly1305_finish(poly1305_context *ctx, unsigned char mac[16]) {\n        poly1305_state_internal_t *st = (poly1305_state_internal_t *)(void *)ctx;\n        unsigned long h0,h1,h2,h3,h4,c;\n        unsigned long g0,g1,g2,g3,g4;\n        unsigned long long f;\n        unsigned long mask;\n\n        /* process the remaining block */\n        if (st-\u003eleftover) {\n                unsigned long long i = st-\u003eleftover;\n                st-\u003ebuffer[i++] = 1;\n                for (; i \u003c poly1305_block_size; i++)\n                        st-\u003ebuffer[i] = 0;\n                st-\u003efinal = 1;\n                poly1305_blocks(st, st-\u003ebuffer, poly1305_block_size);\n        }\n\n        /* fully carry h */\n        h0 = st-\u003eh[0];\n        h1 = st-\u003eh[1];\n        h2 = st-\u003eh[2];\n        h3 = st-\u003eh[3];\n        h4 = st-\u003eh[4];\n\n                     c = h1 \u003e\u003e 26; h1 = h1 \u0026 0x3ffffff;\n        h2 +=     c; c = h2 \u003e\u003e 26; h2 = h2 \u0026 0x3ffffff;\n        h3 +=     c; c = h3 \u003e\u003e 26; h3 = h3 \u0026 0x3ffffff;\n        h4 +=     c; c = h4 \u003e\u003e 26; h4 = h4 \u0026 0x3ffffff;\n        h0 += c * 5; c = h0 \u003e\u003e 26; h0 = h0 \u0026 0x3ffffff;\n        h1 +=     c;\n\n        /* compute h + -p */\n        g0 = h0 + 5; c = g0 \u003e\u003e 26; g0 \u0026= 0x3ffffff;\n        g1 = h1 + c; c = g1 \u003e\u003e 26; g1 \u0026= 0x3ffffff;\n        g2 = h2 + c; c = g2 \u003e\u003e 26; g2 \u0026= 0x3ffffff;\n        g3 = h3 + c; c = g3 \u003e\u003e 26; g3 \u0026= 0x3ffffff;\n        g4 = h4 + c - (1 \u003c\u003c 26);\n\n        /* select h if h \u003c p, or h + -p if h \u003e= p */\n        mask = (g4 \u003e\u003e ((sizeof(unsigned long) * 8) - 1)) - 1;\n        g0 \u0026= mask;\n        g1 \u0026= mask;\n        g2 \u0026= mask;\n        g3 \u0026= mask;\n        g4 \u0026= mask;\n        mask = ~mask;\n        h0 = (h0 \u0026 mask) | g0;\n        h1 = (h1 \u0026 mask) | g1;\n        h2 = (h2 \u0026 mask) | g2;\n        h3 = (h3 \u0026 mask) | g3;\n        h4 = (h4 \u0026 mask) | g4;\n\n        /* h = h % (2^128) */\n        h0 = ((h0      ) | (h1 \u003c\u003c 26)) \u0026 0xffffffff;\n        h1 = ((h1 \u003e\u003e  6) | (h2 \u003c\u003c 20)) \u0026 0xffffffff;\n        h2 = ((h2 \u003e\u003e 12) | (h3 \u003c\u003c 14)) \u0026 0xffffffff;\n        h3 = ((h3 \u003e\u003e 18) | (h4 \u003c\u003c  8)) \u0026 0xffffffff;\n\n        /* mac = (h + pad) % (2^128) */\n        f = (unsigned long long)h0 + st-\u003epad[0]            ; h0 = (unsigned long)f;\n        f = (unsigned long long)h1 + st-\u003epad[1] + (f \u003e\u003e 32); h1 = (unsigned long)f;\n        f = (unsigned long long)h2 + st-\u003epad[2] + (f \u003e\u003e 32); h2 = (unsigned long)f;\n        f = (unsigned long long)h3 + st-\u003epad[3] + (f \u003e\u003e 32); h3 = (unsigned long)f;\n\n        U32TO8(mac +  0, h0);\n        U32TO8(mac +  4, h1);\n        U32TO8(mac +  8, h2);\n        U32TO8(mac + 12, h3);\n\n        /* zero out the state */\n        sodium_memzero((void *)st, sizeof *st);\n}","filepath":"src/libsodium/crypto_onetimeauth/poly1305/donna/poly1305_donna32.h","line_number":133,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.6"},"664971":{"score":0.9180872,"function_name":"fe25519_sub","code":"static void\nfe25519_sub(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    int32_t h0 = f[0] - g[0];\n    int32_t h1 = f[1] - g[1];\n    int32_t h2 = f[2] - g[2];\n    int32_t h3 = f[3] - g[3];\n    int32_t h4 = f[4] - g[4];\n    int32_t h5 = f[5] - g[5];\n    int32_t h6 = f[6] - g[6];\n    int32_t h7 = f[7] - g[7];\n    int32_t h8 = f[8] - g[8];\n    int32_t h9 = f[9] - g[9];\n\n    h[0] = h0;\n    h[1] = h1;\n    h[2] = h2;\n    h[3] = h3;\n    h[4] = h4;\n    h[5] = h5;\n    h[6] = h6;\n    h[7] = h7;\n    h[8] = h8;\n    h[9] = h9;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_25_5.h","line_number":78,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"666466":{"score":0.87719876,"function_name":"fe25519_copy","code":"static inline void\nfe25519_copy(fe25519 h, const fe25519 f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    h[0] = f0;\n    h[1] = f1;\n    h[2] = f2;\n    h[3] = f3;\n    h[4] = f4;\n    h[5] = f5;\n    h[6] = f6;\n    h[7] = f7;\n    h[8] = f8;\n    h[9] = f9;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_25_5.h","line_number":273,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"666681":{"score":0.89251876,"function_name":"fe25519_mul","code":"static void\nfe25519_mul(fe25519 h, const fe25519 f, const fe25519 g)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t g0 = g[0];\n    int32_t g1 = g[1];\n    int32_t g2 = g[2];\n    int32_t g3 = g[3];\n    int32_t g4 = g[4];\n    int32_t g5 = g[5];\n    int32_t g6 = g[6];\n    int32_t g7 = g[7];\n    int32_t g8 = g[8];\n    int32_t g9 = g[9];\n\n    int32_t g1_19 = 19 * g1; /* 1.959375*2^29 */\n    int32_t g2_19 = 19 * g2; /* 1.959375*2^30; still ok */\n    int32_t g3_19 = 19 * g3;\n    int32_t g4_19 = 19 * g4;\n    int32_t g5_19 = 19 * g5;\n    int32_t g6_19 = 19 * g6;\n    int32_t g7_19 = 19 * g7;\n    int32_t g8_19 = 19 * g8;\n    int32_t g9_19 = 19 * g9;\n    int32_t f1_2  = 2 * f1;\n    int32_t f3_2  = 2 * f3;\n    int32_t f5_2  = 2 * f5;\n    int32_t f7_2  = 2 * f7;\n    int32_t f9_2  = 2 * f9;\n\n    int64_t f0g0    = f0 * (int64_t) g0;\n    int64_t f0g1    = f0 * (int64_t) g1;\n    int64_t f0g2    = f0 * (int64_t) g2;\n    int64_t f0g3    = f0 * (int64_t) g3;\n    int64_t f0g4    = f0 * (int64_t) g4;\n    int64_t f0g5    = f0 * (int64_t) g5;\n    int64_t f0g6    = f0 * (int64_t) g6;\n    int64_t f0g7    = f0 * (int64_t) g7;\n    int64_t f0g8    = f0 * (int64_t) g8;\n    int64_t f0g9    = f0 * (int64_t) g9;\n    int64_t f1g0    = f1 * (int64_t) g0;\n    int64_t f1g1_2  = f1_2 * (int64_t) g1;\n    int64_t f1g2    = f1 * (int64_t) g2;\n    int64_t f1g3_2  = f1_2 * (int64_t) g3;\n    int64_t f1g4    = f1 * (int64_t) g4;\n    int64_t f1g5_2  = f1_2 * (int64_t) g5;\n    int64_t f1g6    = f1 * (int64_t) g6;\n    int64_t f1g7_2  = f1_2 * (int64_t) g7;\n    int64_t f1g8    = f1 * (int64_t) g8;\n    int64_t f1g9_38 = f1_2 * (int64_t) g9_19;\n    int64_t f2g0    = f2 * (int64_t) g0;\n    int64_t f2g1    = f2 * (int64_t) g1;\n    int64_t f2g2    = f2 * (int64_t) g2;\n    int64_t f2g3    = f2 * (int64_t) g3;\n    int64_t f2g4    = f2 * (int64_t) g4;\n    int64_t f2g5    = f2 * (int64_t) g5;\n    int64_t f2g6    = f2 * (int64_t) g6;\n    int64_t f2g7    = f2 * (int64_t) g7;\n    int64_t f2g8_19 = f2 * (int64_t) g8_19;\n    int64_t f2g9_19 = f2 * (int64_t) g9_19;\n    int64_t f3g0    = f3 * (int64_t) g0;\n    int64_t f3g1_2  = f3_2 * (int64_t) g1;\n    int64_t f3g2    = f3 * (int64_t) g2;\n    int64_t f3g3_2  = f3_2 * (int64_t) g3;\n    int64_t f3g4    = f3 * (int64_t) g4;\n    int64_t f3g5_2  = f3_2 * (int64_t) g5;\n    int64_t f3g6    = f3 * (int64_t) g6;\n    int64_t f3g7_38 = f3_2 * (int64_t) g7_19;\n    int64_t f3g8_19 = f3 * (int64_t) g8_19;\n    int64_t f3g9_38 = f3_2 * (int64_t) g9_19;\n    int64_t f4g0    = f4 * (int64_t) g0;\n    int64_t f4g1    = f4 * (int64_t) g1;\n    int64_t f4g2    = f4 * (int64_t) g2;\n    int64_t f4g3    = f4 * (int64_t) g3;\n    int64_t f4g4    = f4 * (int64_t) g4;\n    int64_t f4g5    = f4 * (int64_t) g5;\n    int64_t f4g6_19 = f4 * (int64_t) g6_19;\n    int64_t f4g7_19 = f4 * (int64_t) g7_19;\n    int64_t f4g8_19 = f4 * (int64_t) g8_19;\n    int64_t f4g9_19 = f4 * (int64_t) g9_19;\n    int64_t f5g0    = f5 * (int64_t) g0;\n    int64_t f5g1_2  = f5_2 * (int64_t) g1;\n    int64_t f5g2    = f5 * (int64_t) g2;\n    int64_t f5g3_2  = f5_2 * (int64_t) g3;\n    int64_t f5g4    = f5 * (int64_t) g4;\n    int64_t f5g5_38 = f5_2 * (int64_t) g5_19;\n    int64_t f5g6_19 = f5 * (int64_t) g6_19;\n    int64_t f5g7_38 = f5_2 * (int64_t) g7_19;\n    int64_t f5g8_19 = f5 * (int64_t) g8_19;\n    int64_t f5g9_38 = f5_2 * (int64_t) g9_19;\n    int64_t f6g0    = f6 * (int64_t) g0;\n    int64_t f6g1    = f6 * (int64_t) g1;\n    int64_t f6g2    = f6 * (int64_t) g2;\n    int64_t f6g3    = f6 * (int64_t) g3;\n    int64_t f6g4_19 = f6 * (int64_t) g4_19;\n    int64_t f6g5_19 = f6 * (int64_t) g5_19;\n    int64_t f6g6_19 = f6 * (int64_t) g6_19;\n    int64_t f6g7_19 = f6 * (int64_t) g7_19;\n    int64_t f6g8_19 = f6 * (int64_t) g8_19;\n    int64_t f6g9_19 = f6 * (int64_t) g9_19;\n    int64_t f7g0    = f7 * (int64_t) g0;\n    int64_t f7g1_2  = f7_2 * (int64_t) g1;\n    int64_t f7g2    = f7 * (int64_t) g2;\n    int64_t f7g3_38 = f7_2 * (int64_t) g3_19;\n    int64_t f7g4_19 = f7 * (int64_t) g4_19;\n    int64_t f7g5_38 = f7_2 * (int64_t) g5_19;\n    int64_t f7g6_19 = f7 * (int64_t) g6_19;\n    int64_t f7g7_38 = f7_2 * (int64_t) g7_19;\n    int64_t f7g8_19 = f7 * (int64_t) g8_19;\n    int64_t f7g9_38 = f7_2 * (int64_t) g9_19;\n    int64_t f8g0    = f8 * (int64_t) g0;\n    int64_t f8g1    = f8 * (int64_t) g1;\n    int64_t f8g2_19 = f8 * (int64_t) g2_19;\n    int64_t f8g3_19 = f8 * (int64_t) g3_19;\n    int64_t f8g4_19 = f8 * (int64_t) g4_19;\n    int64_t f8g5_19 = f8 * (int64_t) g5_19;\n    int64_t f8g6_19 = f8 * (int64_t) g6_19;\n    int64_t f8g7_19 = f8 * (int64_t) g7_19;\n    int64_t f8g8_19 = f8 * (int64_t) g8_19;\n    int64_t f8g9_19 = f8 * (int64_t) g9_19;\n    int64_t f9g0    = f9 * (int64_t) g0;\n    int64_t f9g1_38 = f9_2 * (int64_t) g1_19;\n    int64_t f9g2_19 = f9 * (int64_t) g2_19;\n    int64_t f9g3_38 = f9_2 * (int64_t) g3_19;\n    int64_t f9g4_19 = f9 * (int64_t) g4_19;\n    int64_t f9g5_38 = f9_2 * (int64_t) g5_19;\n    int64_t f9g6_19 = f9 * (int64_t) g6_19;\n    int64_t f9g7_38 = f9_2 * (int64_t) g7_19;\n    int64_t f9g8_19 = f9 * (int64_t) g8_19;\n    int64_t f9g9_38 = f9_2 * (int64_t) g9_19;\n\n    int64_t h0 = f0g0 + f1g9_38 + f2g8_19 + f3g7_38 + f4g6_19 + f5g5_38 +\n                 f6g4_19 + f7g3_38 + f8g2_19 + f9g1_38;\n    int64_t h1 = f0g1 + f1g0 + f2g9_19 + f3g8_19 + f4g7_19 + f5g6_19 + f6g5_19 +\n                 f7g4_19 + f8g3_19 + f9g2_19;\n    int64_t h2 = f0g2 + f1g1_2 + f2g0 + f3g9_38 + f4g8_19 + f5g7_38 + f6g6_19 +\n                 f7g5_38 + f8g4_19 + f9g3_38;\n    int64_t h3 = f0g3 + f1g2 + f2g1 + f3g0 + f4g9_19 + f5g8_19 + f6g7_19 +\n                 f7g6_19 + f8g5_19 + f9g4_19;\n    int64_t h4 = f0g4 + f1g3_2 + f2g2 + f3g1_2 + f4g0 + f5g9_38 + f6g8_19 +\n                 f7g7_38 + f8g6_19 + f9g5_38;\n    int64_t h5 = f0g5 + f1g4 + f2g3 + f3g2 + f4g1 + f5g0 + f6g9_19 + f7g8_19 +\n                 f8g7_19 + f9g6_19;\n    int64_t h6 = f0g6 + f1g5_2 + f2g4 + f3g3_2 + f4g2 + f5g1_2 + f6g0 +\n                 f7g9_38 + f8g8_19 + f9g7_38;\n    int64_t h7 = f0g7 + f1g6 + f2g5 + f3g4 + f4g3 + f5g2 + f6g1 + f7g0 +\n                 f8g9_19 + f9g8_19;\n    int64_t h8 = f0g8 + f1g7_2 + f2g6 + f3g5_2 + f4g4 + f5g3_2 + f6g2 + f7g1_2 +\n                 f8g0 + f9g9_38;\n    int64_t h9 =\n        f0g9 + f1g8 + f2g7 + f3g6 + f4g5 + f5g4 + f6g3 + f7g2 + f8g1 + f9g0;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    /*\n     |h0| \u003c= (1.65*1.65*2^52*(1+19+19+19+19)+1.65*1.65*2^50*(38+38+38+38+38))\n     i.e. |h0| \u003c= 1.4*2^60; narrower ranges for h2, h4, h6, h8\n     |h1| \u003c= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))\n     i.e. |h1| \u003c= 1.7*2^59; narrower ranges for h3, h5, h7, h9\n     */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25 */\n    /* |h4| \u003c= 2^25 */\n    /* |h1| \u003c= 1.71*2^59 */\n    /* |h5| \u003c= 1.71*2^59 */\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h1| \u003c= 2^24; from now on fits into int32 */\n    /* |h5| \u003c= 2^24; from now on fits into int32 */\n    /* |h2| \u003c= 1.41*2^60 */\n    /* |h6| \u003c= 1.41*2^60 */\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h2| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h6| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h3| \u003c= 1.71*2^59 */\n    /* |h7| \u003c= 1.71*2^59 */\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h3| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h7| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h4| \u003c= 1.72*2^34 */\n    /* |h8| \u003c= 1.41*2^60 */\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h4| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h8| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h5| \u003c= 1.01*2^24 */\n    /* |h9| \u003c= 1.71*2^59 */\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n    /* |h9| \u003c= 2^24; from now on fits into int32 unchanged */\n    /* |h0| \u003c= 1.1*2^39 */\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    /* |h0| \u003c= 2^25; from now on fits into int32 unchanged */\n    /* |h1| \u003c= 1.01*2^24 */\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_25_5.h","line_number":367,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"682635":{"score":0.88017523,"function_name":"fe25519_sq","code":"static void\nfe25519_sq(fe25519 h, const fe25519 f)\n{\n    int32_t f0 = f[0];\n    int32_t f1 = f[1];\n    int32_t f2 = f[2];\n    int32_t f3 = f[3];\n    int32_t f4 = f[4];\n    int32_t f5 = f[5];\n    int32_t f6 = f[6];\n    int32_t f7 = f[7];\n    int32_t f8 = f[8];\n    int32_t f9 = f[9];\n\n    int32_t f0_2  = 2 * f0;\n    int32_t f1_2  = 2 * f1;\n    int32_t f2_2  = 2 * f2;\n    int32_t f3_2  = 2 * f3;\n    int32_t f4_2  = 2 * f4;\n    int32_t f5_2  = 2 * f5;\n    int32_t f6_2  = 2 * f6;\n    int32_t f7_2  = 2 * f7;\n    int32_t f5_38 = 38 * f5; /* 1.959375*2^30 */\n    int32_t f6_19 = 19 * f6; /* 1.959375*2^30 */\n    int32_t f7_38 = 38 * f7; /* 1.959375*2^30 */\n    int32_t f8_19 = 19 * f8; /* 1.959375*2^30 */\n    int32_t f9_38 = 38 * f9; /* 1.959375*2^30 */\n\n    int64_t f0f0    = f0 * (int64_t) f0;\n    int64_t f0f1_2  = f0_2 * (int64_t) f1;\n    int64_t f0f2_2  = f0_2 * (int64_t) f2;\n    int64_t f0f3_2  = f0_2 * (int64_t) f3;\n    int64_t f0f4_2  = f0_2 * (int64_t) f4;\n    int64_t f0f5_2  = f0_2 * (int64_t) f5;\n    int64_t f0f6_2  = f0_2 * (int64_t) f6;\n    int64_t f0f7_2  = f0_2 * (int64_t) f7;\n    int64_t f0f8_2  = f0_2 * (int64_t) f8;\n    int64_t f0f9_2  = f0_2 * (int64_t) f9;\n    int64_t f1f1_2  = f1_2 * (int64_t) f1;\n    int64_t f1f2_2  = f1_2 * (int64_t) f2;\n    int64_t f1f3_4  = f1_2 * (int64_t) f3_2;\n    int64_t f1f4_2  = f1_2 * (int64_t) f4;\n    int64_t f1f5_4  = f1_2 * (int64_t) f5_2;\n    int64_t f1f6_2  = f1_2 * (int64_t) f6;\n    int64_t f1f7_4  = f1_2 * (int64_t) f7_2;\n    int64_t f1f8_2  = f1_2 * (int64_t) f8;\n    int64_t f1f9_76 = f1_2 * (int64_t) f9_38;\n    int64_t f2f2    = f2 * (int64_t) f2;\n    int64_t f2f3_2  = f2_2 * (int64_t) f3;\n    int64_t f2f4_2  = f2_2 * (int64_t) f4;\n    int64_t f2f5_2  = f2_2 * (int64_t) f5;\n    int64_t f2f6_2  = f2_2 * (int64_t) f6;\n    int64_t f2f7_2  = f2_2 * (int64_t) f7;\n    int64_t f2f8_38 = f2_2 * (int64_t) f8_19;\n    int64_t f2f9_38 = f2 * (int64_t) f9_38;\n    int64_t f3f3_2  = f3_2 * (int64_t) f3;\n    int64_t f3f4_2  = f3_2 * (int64_t) f4;\n    int64_t f3f5_4  = f3_2 * (int64_t) f5_2;\n    int64_t f3f6_2  = f3_2 * (int64_t) f6;\n    int64_t f3f7_76 = f3_2 * (int64_t) f7_38;\n    int64_t f3f8_38 = f3_2 * (int64_t) f8_19;\n    int64_t f3f9_76 = f3_2 * (int64_t) f9_38;\n    int64_t f4f4    = f4 * (int64_t) f4;\n    int64_t f4f5_2  = f4_2 * (int64_t) f5;\n    int64_t f4f6_38 = f4_2 * (int64_t) f6_19;\n    int64_t f4f7_38 = f4 * (int64_t) f7_38;\n    int64_t f4f8_38 = f4_2 * (int64_t) f8_19;\n    int64_t f4f9_38 = f4 * (int64_t) f9_38;\n    int64_t f5f5_38 = f5 * (int64_t) f5_38;\n    int64_t f5f6_38 = f5_2 * (int64_t) f6_19;\n    int64_t f5f7_76 = f5_2 * (int64_t) f7_38;\n    int64_t f5f8_38 = f5_2 * (int64_t) f8_19;\n    int64_t f5f9_76 = f5_2 * (int64_t) f9_38;\n    int64_t f6f6_19 = f6 * (int64_t) f6_19;\n    int64_t f6f7_38 = f6 * (int64_t) f7_38;\n    int64_t f6f8_38 = f6_2 * (int64_t) f8_19;\n    int64_t f6f9_38 = f6 * (int64_t) f9_38;\n    int64_t f7f7_38 = f7 * (int64_t) f7_38;\n    int64_t f7f8_38 = f7_2 * (int64_t) f8_19;\n    int64_t f7f9_76 = f7_2 * (int64_t) f9_38;\n    int64_t f8f8_19 = f8 * (int64_t) f8_19;\n    int64_t f8f9_38 = f8 * (int64_t) f9_38;\n    int64_t f9f9_38 = f9 * (int64_t) f9_38;\n\n    int64_t h0 = f0f0 + f1f9_76 + f2f8_38 + f3f7_76 + f4f6_38 + f5f5_38;\n    int64_t h1 = f0f1_2 + f2f9_38 + f3f8_38 + f4f7_38 + f5f6_38;\n    int64_t h2 = f0f2_2 + f1f1_2 + f3f9_76 + f4f8_38 + f5f7_76 + f6f6_19;\n    int64_t h3 = f0f3_2 + f1f2_2 + f4f9_38 + f5f8_38 + f6f7_38;\n    int64_t h4 = f0f4_2 + f1f3_4 + f2f2 + f5f9_76 + f6f8_38 + f7f7_38;\n    int64_t h5 = f0f5_2 + f1f4_2 + f2f3_2 + f6f9_38 + f7f8_38;\n    int64_t h6 = f0f6_2 + f1f5_4 + f2f4_2 + f3f3_2 + f7f9_76 + f8f8_19;\n    int64_t h7 = f0f7_2 + f1f6_2 + f2f5_2 + f3f4_2 + f8f9_38;\n    int64_t h8 = f0f8_2 + f1f7_4 + f2f6_2 + f3f5_4 + f4f4 + f9f9_38;\n    int64_t h9 = f0f9_2 + f1f8_2 + f2f7_2 + f3f6_2 + f4f5_2;\n\n    int64_t carry0;\n    int64_t carry1;\n    int64_t carry2;\n    int64_t carry3;\n    int64_t carry4;\n    int64_t carry5;\n    int64_t carry6;\n    int64_t carry7;\n    int64_t carry8;\n    int64_t carry9;\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry1 = (h1 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h2 += carry1;\n    h1 -= carry1 * ((uint64_t) 1L \u003c\u003c 25);\n    carry5 = (h5 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h6 += carry5;\n    h5 -= carry5 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry2 = (h2 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h3 += carry2;\n    h2 -= carry2 * ((uint64_t) 1L \u003c\u003c 26);\n    carry6 = (h6 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h7 += carry6;\n    h6 -= carry6 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry3 = (h3 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h4 += carry3;\n    h3 -= carry3 * ((uint64_t) 1L \u003c\u003c 25);\n    carry7 = (h7 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h8 += carry7;\n    h7 -= carry7 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry4 = (h4 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h5 += carry4;\n    h4 -= carry4 * ((uint64_t) 1L \u003c\u003c 26);\n    carry8 = (h8 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h9 += carry8;\n    h8 -= carry8 * ((uint64_t) 1L \u003c\u003c 26);\n\n    carry9 = (h9 + (int64_t)(1L \u003c\u003c 24)) \u003e\u003e 25;\n    h0 += carry9 * 19;\n    h9 -= carry9 * ((uint64_t) 1L \u003c\u003c 25);\n\n    carry0 = (h0 + (int64_t)(1L \u003c\u003c 25)) \u003e\u003e 26;\n    h1 += carry0;\n    h0 -= carry0 * ((uint64_t) 1L \u003c\u003c 26);\n\n    h[0] = (int32_t) h0;\n    h[1] = (int32_t) h1;\n    h[2] = (int32_t) h2;\n    h[3] = (int32_t) h3;\n    h[4] = (int32_t) h4;\n    h[5] = (int32_t) h5;\n    h[6] = (int32_t) h6;\n    h[7] = (int32_t) h7;\n    h[8] = (int32_t) h8;\n    h[9] = (int32_t) h9;\n}","filepath":"src/libsodium/include/sodium/private/ed25519_ref10_fe_25_5.h","line_number":637,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"690701":{"score":0.8531428,"function_name":"has_small_order","code":"static int\nhas_small_order(const unsigned char s[32])\n{\n    CRYPTO_ALIGN(16)\n    static const unsigned char blacklist[][32] = {\n        /* 0 (order 4) */\n        { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 1 (order 1) */\n        { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },\n        /* 325606250916557431795983626356110631294008115727848805560023387167927233504\n           (order 8) */\n        { 0xe0, 0xeb, 0x7a, 0x7c, 0x3b, 0x41, 0xb8, 0xae, 0x16, 0x56, 0xe3,\n          0xfa, 0xf1, 0x9f, 0xc4, 0x6a, 0xda, 0x09, 0x8d, 0xeb, 0x9c, 0x32,\n          0xb1, 0xfd, 0x86, 0x62, 0x05, 0x16, 0x5f, 0x49, 0xb8, 0x00 },\n        /* 39382357235489614581723060781553021112529911719440698176882885853963445705823\n           (order 8) */\n        { 0x5f, 0x9c, 0x95, 0xbc, 0xa3, 0x50, 0x8c, 0x24, 0xb1, 0xd0, 0xb1,\n          0x55, 0x9c, 0x83, 0xef, 0x5b, 0x04, 0x44, 0x5c, 0xc4, 0x58, 0x1c,\n          0x8e, 0x86, 0xd8, 0x22, 0x4e, 0xdd, 0xd0, 0x9f, 0x11, 0x57 },\n        /* p-1 (order 2) */\n        { 0xec, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p (=0, order 4) */\n        { 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f },\n        /* p+1 (=1, order 1) */\n        { 0xee, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f }\n    };\n    unsigned char c[7] = { 0 };\n    unsigned int  k;\n    size_t        i, j;\n\n    COMPILER_ASSERT(7 == sizeof blacklist / sizeof blacklist[0]);\n    for (j = 0; j \u003c 31; j++) {\n        for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n            c[i] |= s[j] ^ blacklist[i][j];\n        }\n    }\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        c[i] |= (s[j] \u0026 0x7f) ^ blacklist[i][j];\n    }\n    k = 0;\n    for (i = 0; i \u003c sizeof blacklist / sizeof blacklist[0]; i++) {\n        k |= (c[i] - 1);\n    }\n    return (int) ((k \u003e\u003e 8) \u0026 1);\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":16,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"691019":{"score":0.8428978,"function_name":"crypto_scalarmult_curve25519_ref10","code":"static int\ncrypto_scalarmult_curve25519_ref10(unsigned char *q,\n                                   const unsigned char *n,\n                                   const unsigned char *p)\n{\n    unsigned char *t = q;\n    unsigned int   i;\n    fe25519        x1;\n    fe25519        x2;\n    fe25519        z2;\n    fe25519        x3;\n    fe25519        z3;\n    fe25519        tmp0;\n    fe25519        tmp1;\n    int            pos;\n    unsigned int   swap;\n    unsigned int   b;\n\n    if (has_small_order(p)) {\n        return -1;\n    }\n    for (i = 0; i \u003c 32; i++) {\n        t[i] = n[i];\n    }\n    t[0] \u0026= 248;\n    t[31] \u0026= 127;\n    t[31] |= 64;\n    fe25519_frombytes(x1, p);\n    fe25519_1(x2);\n    fe25519_0(z2);\n    fe25519_copy(x3, x1);\n    fe25519_1(z3);\n\n    swap = 0;\n    for (pos = 254; pos \u003e= 0; --pos) {\n        b = t[pos / 8] \u003e\u003e (pos \u0026 7);\n        b \u0026= 1;\n        swap ^= b;\n        fe25519_cswap(x2, x3, swap);\n        fe25519_cswap(z2, z3, swap);\n        swap = b;\n        fe25519_sub(tmp0, x3, z3);\n        fe25519_sub(tmp1, x2, z2);\n        fe25519_add(x2, x2, z2);\n        fe25519_add(z2, x3, z3);\n        fe25519_mul(z3, tmp0, x2);\n        fe25519_mul(z2, z2, tmp1);\n        fe25519_sq(tmp0, tmp1);\n        fe25519_sq(tmp1, x2);\n        fe25519_add(x3, z3, z2);\n        fe25519_sub(z2, z3, z2);\n        fe25519_mul(x2, tmp1, tmp0);\n        fe25519_sub(tmp1, tmp1, tmp0);\n        fe25519_sq(z2, z2);\n        fe25519_scalar_product(z3, tmp1, 121666);\n        fe25519_sq(x3, x3);\n        fe25519_add(tmp0, tmp0, z3);\n        fe25519_mul(z3, x1, z2);\n        fe25519_mul(z2, tmp1, tmp0);\n    }\n    fe25519_cswap(x2, x3, swap);\n    fe25519_cswap(z2, z3, swap);\n\n    fe25519_invert(z2, z2);\n    fe25519_mul(x2, x2, z2);\n    fe25519_tobytes(q, x2);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":72,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"692216":{"score":0.72402376,"function_name":"edwards_to_montgomery","code":"static void\nedwards_to_montgomery(fe25519 montgomeryX, const fe25519 edwardsY, const fe25519 edwardsZ)\n{\n    fe25519 tempX;\n    fe25519 tempZ;\n\n    fe25519_add(tempX, edwardsZ, edwardsY);\n    fe25519_sub(tempZ, edwardsZ, edwardsY);\n    fe25519_invert(tempZ, tempZ);\n    fe25519_mul(montgomeryX, tempX, tempZ);\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":142,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"692363":{"score":0.83208734,"function_name":"crypto_scalarmult_curve25519_ref10_base","code":"static int\ncrypto_scalarmult_curve25519_ref10_base(unsigned char *q,\n                                        const unsigned char *n)\n{\n    unsigned char *t = q;\n    ge25519_p3     A;\n    fe25519        pk;\n    unsigned int   i;\n\n    for (i = 0; i \u003c 32; i++) {\n        t[i] = n[i];\n    }\n    t[0] \u0026= 248;\n    t[31] \u0026= 127;\n    t[31] |= 64;\n    ge25519_scalarmult_base(\u0026A, t);\n    edwards_to_montgomery(pk, A.Y, A.Z);\n    fe25519_tobytes(q, pk);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_scalarmult/curve25519/ref10/x25519_ref10.c","line_number":154,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.17"},"693218":{"score":0.873617,"function_name":"index_alpha","code":"uint32_t\nindex_alpha(const argon2_instance_t *instance,\n            const argon2_position_t *position, uint32_t pseudo_rand,\n            int same_lane)\n{\n    /*\n     * Pass 0:\n     *      This lane : all already finished segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : all already finished segments\n     * Pass 1+:\n     *      This lane : (SYNC_POINTS - 1) last segments plus already constructed\n     * blocks in this segment\n     *      Other lanes : (SYNC_POINTS - 1) last segments\n     */\n    uint32_t reference_area_size;\n    uint64_t relative_position;\n    uint32_t start_position, absolute_position;\n\n    if (position-\u003epass == 0) {\n        /* First pass */\n        if (position-\u003eslice == 0) {\n            /* First slice */\n            reference_area_size =\n                position-\u003eindex - 1; /* all but the previous */\n        } else {\n            if (same_lane) {\n                /* The same lane =\u003e add current segment */\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    position-\u003eindex - 1;\n            } else {\n                reference_area_size =\n                    position-\u003eslice * instance-\u003esegment_length +\n                    ((position-\u003eindex == 0) ? (-1) : 0);\n            }\n        }\n    } else {\n        /* Second pass */\n        if (same_lane) {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length + position-\u003eindex -\n                                  1;\n        } else {\n            reference_area_size = instance-\u003elane_length -\n                                  instance-\u003esegment_length +\n                                  ((position-\u003eindex == 0) ? (-1) : 0);\n        }\n    }\n\n    /* 1.2.4. Mapping pseudo_rand to 0..\u003creference_area_size-1\u003e and produce\n     * relative position */\n    relative_position = pseudo_rand;\n    relative_position = relative_position * relative_position \u003e\u003e 32;\n    relative_position = reference_area_size - 1 -\n                        (reference_area_size * relative_position \u003e\u003e 32);\n\n    /* 1.2.5 Computing starting position */\n    start_position = 0;\n\n    if (position-\u003epass != 0) {\n        start_position = (position-\u003eslice == ARGON2_SYNC_POINTS - 1)\n                             ? 0\n                             : (position-\u003eslice + 1) * instance-\u003esegment_length;\n    }\n\n    /* 1.2.6. Computing absolute position */\n    absolute_position = (start_position + relative_position) %\n                        instance-\u003elane_length; /* absolute position */\n    return absolute_position;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":217,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"693682":{"score":0.6341611,"function_name":"load_block","code":"static void\nload_block(block *dst, const void *input)\n{\n    unsigned i;\n    for (i = 0; i \u003c ARGON2_QWORDS_IN_BLOCK; ++i) {\n        dst-\u003ev[i] = LOAD64_LE((const uint8_t *) input + i * sizeof(dst-\u003ev[i]));\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":39,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"693849":{"score":0.8616337,"function_name":"allocate_memory","code":"static int\nallocate_memory(block_region **region, uint32_t m_cost)\n{\n    void * base;\n    block *memory;\n    size_t memory_size;\n\n    if (region == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    memory_size = sizeof(block) * m_cost;\n    if (m_cost == 0 ||\n        memory_size / m_cost !=\n            sizeof(block)) { /*1. Check for multiplication overflow*/\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    *region = (block_region *) malloc(\n        sizeof(block_region)); /*2. Try to allocate region*/\n    if (!*region) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    (*region)-\u003ebase = (*region)-\u003ememory = NULL;\n\n#if defined(MAP_ANON) \u0026\u0026 defined(HAVE_MMAP)\n    if ((base = mmap(NULL, memory_size, PROT_READ | PROT_WRITE,\n#ifdef MAP_NOCORE\n                     MAP_ANON | MAP_PRIVATE | MAP_NOCORE,\n#else\n                     MAP_ANON | MAP_PRIVATE,\n#endif\n                     -1, 0)) == MAP_FAILED) {\n        base = NULL; /* LCOV_EXCL_LINE */\n    }                /* LCOV_EXCL_LINE */\n    memcpy(\u0026memory, \u0026base, sizeof memory);\n#elif defined(HAVE_POSIX_MEMALIGN)\n    if ((errno = posix_memalign((void **) \u0026base, 64, memory_size)) != 0) {\n        base = NULL;\n    }\n    memcpy(\u0026memory, \u0026base, sizeof memory);\n#else\n    memory = NULL;\n    if (memory_size + 63 \u003c memory_size) {\n        base  = NULL;\n        errno = ENOMEM;\n    } else if ((base = malloc(memory_size + 63)) != NULL) {\n        uint8_t *aligned = ((uint8_t *) base) + 63;\n        aligned -= (uintptr_t) aligned \u0026 63;\n        memcpy(\u0026memory, \u0026aligned, sizeof memory);\n    }\n#endif\n    if (base == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR; /* LCOV_EXCL_LINE */\n    }\n    (*region)-\u003ebase   = base;\n    (*region)-\u003ememory = memory;\n    (*region)-\u003esize   = memory_size;\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":65,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694187":{"score":0.9098307,"function_name":"clear_memory","code":"static void\nclear_memory(argon2_instance_t *instance, int clear)\n{\n    /* LCOV_EXCL_START */\n    if (clear) {\n        if (instance-\u003eregion != NULL) {\n            sodium_memzero(instance-\u003eregion-\u003ememory,\n                           sizeof(block) * instance-\u003ememory_blocks);\n        }\n        if (instance-\u003epseudo_rands != NULL) {\n            sodium_memzero(instance-\u003epseudo_rands,\n                           sizeof(uint64_t) * instance-\u003esegment_length);\n        }\n    }\n    /* LCOV_EXCL_STOP */\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":133,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694300":{"score":0.74402773,"function_name":"free_memory","code":"static void\nfree_memory(block_region *region)\n{\n    if (region \u0026\u0026 region-\u003ebase) {\n#if defined(MAP_ANON) \u0026\u0026 defined(HAVE_MMAP)\n        if (munmap(region-\u003ebase, region-\u003esize)) {\n            return; /* LCOV_EXCL_LINE */\n        }\n#else\n        free(region-\u003ebase);\n#endif\n    }\n    free(region);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":155,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694370":{"score":0.8339351,"function_name":"free_instance","code":"void\nfree_instance(argon2_instance_t *instance, int flags)\n{\n    /* Clear memory */\n    clear_memory(instance, flags \u0026 ARGON2_FLAG_CLEAR_MEMORY);\n\n    /* Deallocate the memory */\n    free(instance-\u003epseudo_rands);\n    instance-\u003epseudo_rands = NULL;\n    free_memory(instance-\u003eregion);\n    instance-\u003eregion = NULL;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":170,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694469":{"score":0.8671526,"function_name":"finalize","code":"void\nfinalize(const argon2_context *context, argon2_instance_t *instance)\n{\n    if (context != NULL \u0026\u0026 instance != NULL) {\n        block    blockhash;\n        uint32_t l;\n\n        copy_block(\u0026blockhash,\n                   instance-\u003eregion-\u003ememory + instance-\u003elane_length - 1);\n\n        /* XOR the last blocks */\n        for (l = 1; l \u003c instance-\u003elanes; ++l) {\n            uint32_t last_block_in_lane =\n                l * instance-\u003elane_length + (instance-\u003elane_length - 1);\n            xor_block(\u0026blockhash,\n                      instance-\u003eregion-\u003ememory + last_block_in_lane);\n        }\n\n        /* Hash the result */\n        {\n            uint8_t blockhash_bytes[ARGON2_BLOCK_SIZE];\n            store_block(blockhash_bytes, \u0026blockhash);\n            blake2b_long(context-\u003eout, context-\u003eoutlen, blockhash_bytes,\n                         ARGON2_BLOCK_SIZE);\n            sodium_memzero(blockhash.v,\n                           ARGON2_BLOCK_SIZE); /* clear blockhash */\n            sodium_memzero(blockhash_bytes,\n                           ARGON2_BLOCK_SIZE); /* clear blockhash_bytes */\n        }\n\n        free_instance(instance, context-\u003eflags);\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":183,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"694861":{"score":0.79913616,"function_name":"fill_memory_blocks","code":"void\nfill_memory_blocks(argon2_instance_t *instance)\n{\n    uint32_t r, s;\n\n    if (instance == NULL || instance-\u003elanes == 0) {\n        return; /* LCOV_EXCL_LINE */\n    }\n\n    for (r = 0; r \u003c instance-\u003epasses; ++r) {\n        for (s = 0; s \u003c ARGON2_SYNC_POINTS; ++s) {\n            uint32_t l;\n\n            for (l = 0; l \u003c instance-\u003elanes; ++l) {\n                argon2_position_t position;\n\n                position.pass  = r;\n                position.lane  = l;\n                position.slice = (uint8_t) s;\n                position.index = 0;\n                fill_segment(instance, position);\n            }\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":289,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"695000":{"score":0.81569076,"function_name":"validate_inputs","code":"int\nvalidate_inputs(const argon2_context *context)\n{\n    /* LCOV_EXCL_START */\n    if (NULL == context) {\n        return ARGON2_INCORRECT_PARAMETER;\n    }\n\n    if (NULL == context-\u003eout) {\n        return ARGON2_OUTPUT_PTR_NULL;\n    }\n\n    /* Validate output length */\n    if (ARGON2_MIN_OUTLEN \u003e context-\u003eoutlen) {\n        return ARGON2_OUTPUT_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_OUTLEN \u003c context-\u003eoutlen) {\n        return ARGON2_OUTPUT_TOO_LONG;\n    }\n\n    /* Validate password (required param) */\n    if (NULL == context-\u003epwd) {\n        if (0 != context-\u003epwdlen) {\n            return ARGON2_PWD_PTR_MISMATCH;\n        }\n    }\n\n    if (ARGON2_MIN_PWD_LENGTH \u003e context-\u003epwdlen) {\n        return ARGON2_PWD_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_PWD_LENGTH \u003c context-\u003epwdlen) {\n        return ARGON2_PWD_TOO_LONG;\n    }\n\n    /* Validate salt (required param) */\n    if (NULL == context-\u003esalt) {\n        if (0 != context-\u003esaltlen) {\n            return ARGON2_SALT_PTR_MISMATCH;\n        }\n    }\n\n    if (ARGON2_MIN_SALT_LENGTH \u003e context-\u003esaltlen) {\n        return ARGON2_SALT_TOO_SHORT;\n    }\n\n    if (ARGON2_MAX_SALT_LENGTH \u003c context-\u003esaltlen) {\n        return ARGON2_SALT_TOO_LONG;\n    }\n\n    /* Validate secret (optional param) */\n    if (NULL == context-\u003esecret) {\n        if (0 != context-\u003esecretlen) {\n            return ARGON2_SECRET_PTR_MISMATCH;\n        }\n    } else {\n        if (ARGON2_MIN_SECRET \u003e context-\u003esecretlen) {\n            return ARGON2_SECRET_TOO_SHORT;\n        }\n\n        if (ARGON2_MAX_SECRET \u003c context-\u003esecretlen) {\n            return ARGON2_SECRET_TOO_LONG;\n        }\n    }\n\n    /* Validate associated data (optional param) */\n    if (NULL == context-\u003ead) {\n        if (0 != context-\u003eadlen) {\n            return ARGON2_AD_PTR_MISMATCH;\n        }\n    } else {\n        if (ARGON2_MIN_AD_LENGTH \u003e context-\u003eadlen) {\n            return ARGON2_AD_TOO_SHORT;\n        }\n\n        if (ARGON2_MAX_AD_LENGTH \u003c context-\u003eadlen) {\n            return ARGON2_AD_TOO_LONG;\n        }\n    }\n\n    /* Validate memory cost */\n    if (ARGON2_MIN_MEMORY \u003e context-\u003em_cost) {\n        return ARGON2_MEMORY_TOO_LITTLE;\n    }\n\n    if (ARGON2_MAX_MEMORY \u003c context-\u003em_cost) {\n        return ARGON2_MEMORY_TOO_MUCH;\n    }\n\n    if (context-\u003em_cost \u003c 8 * context-\u003elanes) {\n        return ARGON2_MEMORY_TOO_LITTLE;\n    }\n\n    /* Validate time cost */\n    if (ARGON2_MIN_TIME \u003e context-\u003et_cost) {\n        return ARGON2_TIME_TOO_SMALL;\n    }\n\n    if (ARGON2_MAX_TIME \u003c context-\u003et_cost) {\n        return ARGON2_TIME_TOO_LARGE;\n    }\n\n    /* Validate lanes */\n    if (ARGON2_MIN_LANES \u003e context-\u003elanes) {\n        return ARGON2_LANES_TOO_FEW;\n    }\n\n    if (ARGON2_MAX_LANES \u003c context-\u003elanes) {\n        return ARGON2_LANES_TOO_MANY;\n    }\n\n    /* Validate threads */\n    if (ARGON2_MIN_THREADS \u003e context-\u003ethreads) {\n        return ARGON2_THREADS_TOO_FEW;\n    }\n\n    if (ARGON2_MAX_THREADS \u003c context-\u003ethreads) {\n        return ARGON2_THREADS_TOO_MANY;\n    }\n    /* LCOV_EXCL_STOP */\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":315,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"695375":{"score":0.84922135,"function_name":"fill_first_blocks","code":"void\nfill_first_blocks(uint8_t *blockhash, const argon2_instance_t *instance)\n{\n    uint32_t l;\n    /* Make the first and second block in each lane as G(H0||i||0) or\n       G(H0||i||1) */\n    uint8_t blockhash_bytes[ARGON2_BLOCK_SIZE];\n    for (l = 0; l \u003c instance-\u003elanes; ++l) {\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH, 0);\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH + 4, l);\n        blake2b_long(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash,\n                     ARGON2_PREHASH_SEED_LENGTH);\n        load_block(\u0026instance-\u003eregion-\u003ememory[l * instance-\u003elane_length + 0],\n                   blockhash_bytes);\n\n        STORE32_LE(blockhash + ARGON2_PREHASH_DIGEST_LENGTH, 1);\n        blake2b_long(blockhash_bytes, ARGON2_BLOCK_SIZE, blockhash,\n                     ARGON2_PREHASH_SEED_LENGTH);\n        load_block(\u0026instance-\u003eregion-\u003ememory[l * instance-\u003elane_length + 1],\n                   blockhash_bytes);\n    }\n    sodium_memzero(blockhash_bytes, ARGON2_BLOCK_SIZE);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":440,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"695742":{"score":0.8051324,"function_name":"initial_hash","code":"void\ninitial_hash(uint8_t *blockhash, argon2_context *context, argon2_type type)\n{\n    crypto_generichash_blake2b_state BlakeHash;\n    uint8_t                          value[4U /* sizeof(uint32_t) */];\n\n    if (NULL == context || NULL == blockhash) {\n        return; /* LCOV_EXCL_LINE */\n    }\n\n    crypto_generichash_blake2b_init(\u0026BlakeHash, NULL, 0U,\n                                    ARGON2_PREHASH_DIGEST_LENGTH);\n\n    STORE32_LE(value, context-\u003elanes);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003eoutlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003em_cost);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003et_cost);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, ARGON2_VERSION_NUMBER);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, (uint32_t) type);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    STORE32_LE(value, context-\u003epwdlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    if (context-\u003epwd != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003epwd, context-\u003epwdlen);\n\n        /* LCOV_EXCL_START */\n        if (context-\u003eflags \u0026 ARGON2_FLAG_CLEAR_PASSWORD) {\n            sodium_memzero(context-\u003epwd, context-\u003epwdlen);\n            context-\u003epwdlen = 0;\n        }\n        /* LCOV_EXCL_STOP */\n    }\n\n    STORE32_LE(value, context-\u003esaltlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    if (context-\u003esalt != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003esalt, context-\u003esaltlen);\n    }\n\n    STORE32_LE(value, context-\u003esecretlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    /* LCOV_EXCL_START */\n    if (context-\u003esecret != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003esecret, context-\u003esecretlen);\n\n        if (context-\u003eflags \u0026 ARGON2_FLAG_CLEAR_SECRET) {\n            sodium_memzero(context-\u003esecret, context-\u003esecretlen);\n            context-\u003esecretlen = 0;\n        }\n    }\n    /* LCOV_EXCL_STOP */\n\n    STORE32_LE(value, context-\u003eadlen);\n    crypto_generichash_blake2b_update(\u0026BlakeHash, value, sizeof(value));\n\n    /* LCOV_EXCL_START */\n    if (context-\u003ead != NULL) {\n        crypto_generichash_blake2b_update(\n            \u0026BlakeHash, (const uint8_t *) context-\u003ead, context-\u003eadlen);\n    }\n    /* LCOV_EXCL_STOP */\n\n    crypto_generichash_blake2b_final(\u0026BlakeHash, blockhash,\n                                     ARGON2_PREHASH_DIGEST_LENGTH);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":464,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"696710":{"score":0.9228302,"function_name":"initialize","code":"int\ninitialize(argon2_instance_t *instance, argon2_context *context)\n{\n    uint8_t blockhash[ARGON2_PREHASH_SEED_LENGTH];\n    int     result = ARGON2_OK;\n\n    if (instance == NULL || context == NULL) {\n        return ARGON2_INCORRECT_PARAMETER;\n    }\n\n    /* 1. Memory allocation */\n\n    if ((instance-\u003epseudo_rands = (uint64_t *)\n         malloc(sizeof(uint64_t) * instance-\u003esegment_length)) == NULL) {\n        return ARGON2_MEMORY_ALLOCATION_ERROR;\n    }\n\n    result = allocate_memory(\u0026(instance-\u003eregion), instance-\u003ememory_blocks);\n    if (ARGON2_OK != result) {\n        free_instance(instance, context-\u003eflags);\n        return result;\n    }\n\n    /* 2. Initial hashing */\n    /* H_0 + 8 extra bytes to produce the first blocks */\n    /* uint8_t blockhash[ARGON2_PREHASH_SEED_LENGTH]; */\n    /* Hashing all inputs */\n    initial_hash(blockhash, context, instance-\u003etype);\n    /* Zeroing 8 extra bytes */\n    sodium_memzero(blockhash + ARGON2_PREHASH_DIGEST_LENGTH,\n                   ARGON2_PREHASH_SEED_LENGTH - ARGON2_PREHASH_DIGEST_LENGTH);\n\n    /* 3. Creating first blocks, we always have at least two blocks in a slice\n     */\n    fill_first_blocks(blockhash, instance);\n    /* Clearing the hash */\n    sodium_memzero(blockhash, ARGON2_PREHASH_SEED_LENGTH);\n\n    return ARGON2_OK;\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-core.c","line_number":547,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"711700":{"score":0.76110876,"function_name":"fill_block_with_xor","code":"static void\nfill_block_with_xor(const block *prev_block, const block *ref_block,\n                    block *next_block)\n{\n    block    blockR, block_tmp;\n    unsigned i;\n\n    copy_block(\u0026blockR, ref_block);\n    xor_block(\u0026blockR, prev_block);\n    copy_block(\u0026block_tmp, \u0026blockR);\n    xor_block(\u0026block_tmp,\n              next_block); /* Saving the next block contents for XOR over */\n    /* Now blockR = ref_block + prev_block and bloc_tmp = ref_block + prev_block\n     * + next_block */\n    /* Apply Blake2 on columns of 64-bit words: (0,1,...,15) , then\n       (16,17,..31)... finally (112,113,...127) */\n    for (i = 0; i \u003c 8; ++i) {\n        BLAKE2_ROUND_NOMSG(\n            blockR.v[16 * i], blockR.v[16 * i + 1], blockR.v[16 * i + 2],\n            blockR.v[16 * i + 3], blockR.v[16 * i + 4], blockR.v[16 * i + 5],\n            blockR.v[16 * i + 6], blockR.v[16 * i + 7], blockR.v[16 * i + 8],\n            blockR.v[16 * i + 9], blockR.v[16 * i + 10], blockR.v[16 * i + 11],\n            blockR.v[16 * i + 12], blockR.v[16 * i + 13], blockR.v[16 * i + 14],\n            blockR.v[16 * i + 15]);\n    }\n\n    /* Apply Blake2 on rows of 64-bit words: (0,1,16,17,...112,113), then\n       (2,3,18,19,...,114,115).. finally (14,15,30,31,...,126,127) */\n    for (i = 0; i \u003c 8; i++) {\n        BLAKE2_ROUND_NOMSG(\n            blockR.v[2 * i], blockR.v[2 * i + 1], blockR.v[2 * i + 16],\n            blockR.v[2 * i + 17], blockR.v[2 * i + 32], blockR.v[2 * i + 33],\n            blockR.v[2 * i + 48], blockR.v[2 * i + 49], blockR.v[2 * i + 64],\n            blockR.v[2 * i + 65], blockR.v[2 * i + 80], blockR.v[2 * i + 81],\n            blockR.v[2 * i + 96], blockR.v[2 * i + 97], blockR.v[2 * i + 112],\n            blockR.v[2 * i + 113]);\n    }\n\n    copy_block(next_block, \u0026block_tmp);\n    xor_block(next_block, \u0026blockR);\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":61,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"725409":{"score":0.8095519,"function_name":"generate_addresses","code":"static void\ngenerate_addresses(const argon2_instance_t *instance,\n                   const argon2_position_t *position, uint64_t *pseudo_rands)\n{\n    block    zero_block, input_block, address_block, tmp_block;\n    uint32_t i;\n\n    init_block_value(\u0026zero_block, 0);\n    init_block_value(\u0026input_block, 0);\n\n    if (instance != NULL \u0026\u0026 position != NULL) {\n        input_block.v[0] = position-\u003epass;\n        input_block.v[1] = position-\u003elane;\n        input_block.v[2] = position-\u003eslice;\n        input_block.v[3] = instance-\u003ememory_blocks;\n        input_block.v[4] = instance-\u003epasses;\n        input_block.v[5] = instance-\u003etype;\n\n        for (i = 0; i \u003c instance-\u003esegment_length; ++i) {\n            if (i % ARGON2_ADDRESSES_IN_BLOCK == 0) {\n                input_block.v[6]++;\n                init_block_value(\u0026tmp_block, 0);\n                init_block_value(\u0026address_block, 0);\n                fill_block_with_xor(\u0026zero_block, \u0026input_block, \u0026tmp_block);\n                fill_block_with_xor(\u0026zero_block, \u0026tmp_block, \u0026address_block);\n            }\n\n            pseudo_rands[i] = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":111,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"725954":{"score":0.8540511,"function_name":"fill_segment_ref","code":"void\nfill_segment_ref(const argon2_instance_t *instance, argon2_position_t position)\n{\n    block    *ref_block = NULL, *curr_block = NULL;\n    /* Pseudo-random values that determine the reference block position */\n    uint64_t *pseudo_rands = NULL;\n    uint64_t  pseudo_rand, ref_index, ref_lane;\n    uint32_t  prev_offset, curr_offset;\n    uint32_t  starting_index;\n    uint32_t  i;\n    int       data_independent_addressing = 1;\n\n    if (instance == NULL) {\n        return;\n    }\n\n    if (instance-\u003etype == Argon2_id \u0026\u0026\n        (position.pass != 0 || position.slice \u003e= ARGON2_SYNC_POINTS / 2)) {\n        data_independent_addressing = 0;\n    }\n\n    pseudo_rands = instance-\u003epseudo_rands;\n\n    if (data_independent_addressing) {\n        generate_addresses(instance, \u0026position, pseudo_rands);\n    }\n\n    starting_index = 0;\n\n    if ((0 == position.pass) \u0026\u0026 (0 == position.slice)) {\n        starting_index = 2; /* we have already generated the first two blocks */\n    }\n\n    /* Offset of the current block */\n    curr_offset = position.lane * instance-\u003elane_length +\n                  position.slice * instance-\u003esegment_length + starting_index;\n\n    if (0 == curr_offset % instance-\u003elane_length) {\n        /* Last block in this lane */\n        prev_offset = curr_offset + instance-\u003elane_length - 1;\n    } else {\n        /* Previous block */\n        prev_offset = curr_offset - 1;\n    }\n\n    for (i = starting_index; i \u003c instance-\u003esegment_length;\n         ++i, ++curr_offset, ++prev_offset) {\n        /*1.1 Rotating prev_offset if needed */\n        if (curr_offset % instance-\u003elane_length == 1) {\n            prev_offset = curr_offset - 1;\n        }\n\n        /* 1.2 Computing the index of the reference block */\n        /* 1.2.1 Taking pseudo-random value from the previous block */\n        if (data_independent_addressing) {\n#pragma warning(push)\n#pragma warning(disable : 6385)\n            pseudo_rand = pseudo_rands[i];\n#pragma warning(pop)\n        } else {\n            pseudo_rand = instance-\u003eregion-\u003ememory[prev_offset].v[0];\n        }\n\n        /* 1.2.2 Computing the lane of the reference block */\n        ref_lane = ((pseudo_rand \u003e\u003e 32)) % instance-\u003elanes;\n\n        if ((position.pass == 0) \u0026\u0026 (position.slice == 0)) {\n            /* Can not reference other lanes yet */\n            ref_lane = position.lane;\n        }\n\n        /* 1.2.3 Computing the number of possible reference block within the\n         * lane.\n         */\n        position.index = i;\n        ref_index = index_alpha(instance, \u0026position, pseudo_rand \u0026 0xFFFFFFFF,\n                                ref_lane == position.lane);\n\n        /* 2 Creating a new block */\n        ref_block = instance-\u003eregion-\u003ememory +\n                    instance-\u003elane_length * ref_lane + ref_index;\n        curr_block = instance-\u003eregion-\u003ememory + curr_offset;\n        if (position.pass != 0) {\n            fill_block_with_xor(instance-\u003eregion-\u003ememory + prev_offset,\n                                ref_block, curr_block);\n        } else {\n            fill_block(instance-\u003eregion-\u003ememory + prev_offset, ref_block,\n                       curr_block);\n        }\n    }\n}","filepath":"src/libsodium/crypto_pwhash/argon2/argon2-fill-block-ref.c","line_number":143,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.14"},"727933":{"score":0.81208444,"function_name":"blake2b_set_lastblock","code":"static inline int\nblake2b_set_lastblock(blake2b_state *S)\n{\n    if (S-\u003elast_node)\n        blake2b_set_lastnode(S);\n\n    S-\u003ef[0] = -1;\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":51,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"727995":{"score":0.7740961,"function_name":"blake2b_increment_counter","code":"static inline int\nblake2b_increment_counter(blake2b_state *S, const uint64_t inc)\n{\n#ifdef HAVE_TI_MODE\n    uint128_t t = ((uint128_t) S-\u003et[1] \u003c\u003c 64) | S-\u003et[0];\n    t += inc;\n    S-\u003et[0] = (uint64_t)(t \u003e\u003e 0);\n    S-\u003et[1] = (uint64_t)(t \u003e\u003e 64);\n#else\n    S-\u003et[0] += inc;\n    S-\u003et[1] += (S-\u003et[0] \u003c inc);\n#endif\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":61,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"728230":{"score":0.8857067,"function_name":"blake2b_init0","code":"static inline int\nblake2b_init0(blake2b_state *S)\n{\n    int i;\n\n    for (i  = 0; i \u003c 8; i++) {\n        S-\u003eh[i] = blake2b_IV[i];\n    }\n    memset(S-\u003et, 0, offsetof(blake2b_state, last_node) + sizeof(S-\u003elast_node)\n           - offsetof(blake2b_state, t));\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":92,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"728337":{"score":0.8849189,"function_name":"blake2b_init_param","code":"int\nblake2b_init_param(blake2b_state *S, const blake2b_param *P)\n{\n    size_t         i;\n    const uint8_t *p;\n\n    COMPILER_ASSERT(sizeof *P == 64);\n    blake2b_init0(S);\n    p = (const uint8_t *) (P);\n\n    /* IV XOR ParamBlock */\n    for (i = 0; i \u003c 8; i++) {\n        S-\u003eh[i] ^= LOAD64_LE(p + sizeof(S-\u003eh[i]) * i);\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":106,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"728480":{"score":0.8177442,"function_name":"blake2b_init","code":"int\nblake2b_init(blake2b_state *S, const uint8_t outlen)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = 0;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n    return blake2b_init_param(S, P);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":123,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"728715":{"score":0.7828871,"function_name":"blake2b_init_salt_personal","code":"int\nblake2b_init_salt_personal(blake2b_state *S, const uint8_t outlen,\n                           const void *salt, const void *personal)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = 0;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    if (salt != NULL) {\n        blake2b_param_set_salt(P, (const uint8_t *) salt);\n    } else {\n        memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    }\n    if (personal != NULL) {\n        blake2b_param_set_personal(P, (const uint8_t *) personal);\n    } else {\n        memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n    }\n    return blake2b_init_param(S, P);\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":145,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"729014":{"score":0.84740543,"function_name":"blake2b_init_key","code":"int\nblake2b_init_key(blake2b_state *S, const uint8_t outlen, const void *key,\n                 const uint8_t keylen)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    if (!key || !keylen || keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = keylen;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n\n    if (blake2b_init_param(S, P) \u003c 0) {\n        sodium_misuse();\n    }\n    {\n        uint8_t block[BLAKE2B_BLOCKBYTES];\n        memset(block, 0, BLAKE2B_BLOCKBYTES);\n        memcpy(block, key, keylen); /* keylen cannot be 0 */\n        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);\n        sodium_memzero(block, BLAKE2B_BLOCKBYTES); /* Burn the key from stack */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":176,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"729486":{"score":0.80551344,"function_name":"blake2b_init_key_salt_personal","code":"int\nblake2b_init_key_salt_personal(blake2b_state *S, const uint8_t outlen,\n                               const void *key, const uint8_t keylen,\n                               const void *salt, const void *personal)\n{\n    blake2b_param P[1];\n\n    if ((!outlen) || (outlen \u003e BLAKE2B_OUTBYTES)) {\n        sodium_misuse();\n    }\n    if (!key || !keylen || keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    P-\u003edigest_length = outlen;\n    P-\u003ekey_length    = keylen;\n    P-\u003efanout        = 1;\n    P-\u003edepth         = 1;\n    STORE32_LE(P-\u003eleaf_length, 0);\n    STORE64_LE(P-\u003enode_offset, 0);\n    P-\u003enode_depth   = 0;\n    P-\u003einner_length = 0;\n    memset(P-\u003ereserved, 0, sizeof(P-\u003ereserved));\n    if (salt != NULL) {\n        blake2b_param_set_salt(P, (const uint8_t *) salt);\n    } else {\n        memset(P-\u003esalt, 0, sizeof(P-\u003esalt));\n    }\n    if (personal != NULL) {\n        blake2b_param_set_personal(P, (const uint8_t *) personal);\n    } else {\n        memset(P-\u003epersonal, 0, sizeof(P-\u003epersonal));\n    }\n\n    if (blake2b_init_param(S, P) \u003c 0) {\n        sodium_misuse();\n    }\n    {\n        uint8_t block[BLAKE2B_BLOCKBYTES];\n        memset(block, 0, BLAKE2B_BLOCKBYTES);\n        memcpy(block, key, keylen); /* keylen cannot be 0 */\n        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);\n        sodium_memzero(block, BLAKE2B_BLOCKBYTES); /* Burn the key from stack */\n    }\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":213,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"730046":{"score":0.8870087,"function_name":"blake2b_update","code":"int\nblake2b_update(blake2b_state *S, const uint8_t *in, uint64_t inlen)\n{\n    while (inlen \u003e 0) {\n        size_t left = S-\u003ebuflen;\n        size_t fill = 2 * BLAKE2B_BLOCKBYTES - left;\n\n        if (inlen \u003e fill) {\n            memcpy(S-\u003ebuf + left, in, fill); /* Fill buffer */\n            S-\u003ebuflen += fill;\n            blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n            blake2b_compress(S, S-\u003ebuf); /* Compress */\n            memcpy(S-\u003ebuf, S-\u003ebuf + BLAKE2B_BLOCKBYTES,\n                   BLAKE2B_BLOCKBYTES); /* Shift buffer left */\n            S-\u003ebuflen -= BLAKE2B_BLOCKBYTES;\n            in += fill;\n            inlen -= fill;\n        } else /* inlen \u003c= fill */\n        {\n            memcpy(S-\u003ebuf + left, in, inlen);\n            S-\u003ebuflen += inlen; /* Be lazy, do not compress */\n            in += inlen;\n            inlen -= inlen;\n        }\n    }\n\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":260,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"730427":{"score":0.90966463,"function_name":"blake2b_final","code":"int\nblake2b_final(blake2b_state *S, uint8_t *out, uint8_t outlen)\n{\n    unsigned char buffer[BLAKE2B_OUTBYTES];\n\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (blake2b_is_lastblock(S)) {\n        return -1;\n    }\n    if (S-\u003ebuflen \u003e BLAKE2B_BLOCKBYTES) {\n        blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);\n        blake2b_compress(S, S-\u003ebuf);\n        S-\u003ebuflen -= BLAKE2B_BLOCKBYTES;\n        assert(S-\u003ebuflen \u003c= BLAKE2B_BLOCKBYTES);\n        memcpy(S-\u003ebuf, S-\u003ebuf + BLAKE2B_BLOCKBYTES, S-\u003ebuflen);\n    }\n\n    blake2b_increment_counter(S, S-\u003ebuflen);\n    blake2b_set_lastblock(S);\n    memset(S-\u003ebuf + S-\u003ebuflen, 0,\n           2 * BLAKE2B_BLOCKBYTES - S-\u003ebuflen); /* Padding */\n    blake2b_compress(S, S-\u003ebuf);\n\n    COMPILER_ASSERT(sizeof buffer == 64U);\n    STORE64_LE(buffer + 8 * 0, S-\u003eh[0]);\n    STORE64_LE(buffer + 8 * 1, S-\u003eh[1]);\n    STORE64_LE(buffer + 8 * 2, S-\u003eh[2]);\n    STORE64_LE(buffer + 8 * 3, S-\u003eh[3]);\n    STORE64_LE(buffer + 8 * 4, S-\u003eh[4]);\n    STORE64_LE(buffer + 8 * 5, S-\u003eh[5]);\n    STORE64_LE(buffer + 8 * 6, S-\u003eh[6]);\n    STORE64_LE(buffer + 8 * 7, S-\u003eh[7]);\n    memcpy(out, buffer, outlen); /* outlen \u003c= BLAKE2B_OUTBYTES (64) */\n\n    sodium_memzero(S-\u003eh, sizeof S-\u003eh);\n    sodium_memzero(S-\u003ebuf, sizeof S-\u003ebuf);\n\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":289,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"731129":{"score":0.80857027,"function_name":"blake2b","code":"int\nblake2b(uint8_t *out, const void *in, const void *key, const uint8_t outlen,\n        const uint64_t inlen, uint8_t keylen)\n{\n    blake2b_state S[1];\n\n    /* Verify parameters */\n    if (NULL == in \u0026\u0026 inlen \u003e 0) {\n        sodium_misuse();\n    }\n    if (NULL == out) {\n        sodium_misuse();\n    }\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (NULL == key \u0026\u0026 keylen \u003e 0) {\n        sodium_misuse();\n    }\n    if (keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    if (keylen \u003e 0) {\n        if (blake2b_init_key(S, outlen, key, keylen) \u003c 0) {\n            sodium_misuse();\n        }\n    } else {\n        if (blake2b_init(S, outlen) \u003c 0) {\n            sodium_misuse();\n        }\n    }\n\n    blake2b_update(S, (const uint8_t *) in, inlen);\n    blake2b_final(S, out, outlen);\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":332,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"731560":{"score":0.8048121,"function_name":"blake2b_salt_personal","code":"int\nblake2b_salt_personal(uint8_t *out, const void *in, const void *key,\n                      const uint8_t outlen, const uint64_t inlen,\n                      uint8_t keylen, const void *salt, const void *personal)\n{\n    blake2b_state S[1];\n\n    /* Verify parameters */\n    if (NULL == in \u0026\u0026 inlen \u003e 0) {\n        sodium_misuse();\n    }\n    if (NULL == out) {\n        sodium_misuse();\n    }\n    if (!outlen || outlen \u003e BLAKE2B_OUTBYTES) {\n        sodium_misuse();\n    }\n    if (NULL == key \u0026\u0026 keylen \u003e 0) {\n        sodium_misuse();\n    }\n    if (keylen \u003e BLAKE2B_KEYBYTES) {\n        sodium_misuse();\n    }\n    if (keylen \u003e 0) {\n        if (blake2b_init_key_salt_personal(S, outlen, key, keylen, salt,\n                                           personal) \u003c 0) {\n            sodium_misuse();\n        }\n    } else {\n        if (blake2b_init_salt_personal(S, outlen, salt, personal) \u003c 0) {\n            sodium_misuse();\n        }\n    }\n\n    blake2b_update(S, (const uint8_t *) in, inlen);\n    blake2b_final(S, out, outlen);\n    return 0;\n}","filepath":"src/libsodium/crypto_generichash/blake2b/ref/blake2b-ref.c","line_number":369,"entry_url":"https://github.com/jedisct1/libsodium.git","slot_name":"1.0.16"},"75079":{"score":0.9156171,"function_name":"cap_switch_init_cb","code":"void cap_switch_init_cb(IOT_CAP_HANDLE *handle, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    /* Send initial switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"on\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":61,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75294":{"score":0.934298,"function_name":"cap_switch_cmd_off_cb","code":"void cap_switch_cmd_off_cb(IOT_CAP_HANDLE *handle,\n                           iot_cap_cmd_data_t *cmd_data, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    printf(\"OFF command received\");\n\n    /* Update switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"off\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":74,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75533":{"score":0.930084,"function_name":"cap_switch_cmd_on_cb","code":"void cap_switch_cmd_on_cb(IOT_CAP_HANDLE *handle,\n                          iot_cap_cmd_data_t *cmd_data, void *usr_data)\n{\n    int32_t sequence_no = 1;\n\n    printf(\"ON command received\");\n\n    /* Update switch attribute */\n    ST_CAP_SEND_ATTR_STRING(handle, \"switch\", \"on\", NULL, NULL, sequence_no);\n\n    if (sequence_no \u003c 0)\n        printf(\"fail to send switch value\\n\");\n    else\n        printf(\"Sequence number return : %d\\n\", sequence_no);\n}","filepath":"example/example.c","line_number":90,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75772":{"score":0.95963657,"function_name":"iot_noti_cb","code":"void iot_noti_cb(iot_noti_data_t *noti_data, void *noti_usr_data)\n{\n    printf(\"Notification message received\\n\");\n\n    if (noti_data-\u003etype == IOT_NOTI_TYPE_DEV_DELETED) {\n        printf(\"[device deleted]\\n\");\n    } else if (noti_data-\u003etype == IOT_NOTI_TYPE_RATE_LIMIT) {\n        printf(\"[rate limit] Remaining time:%d, sequence number:%d\\n\",\n               noti_data-\u003eraw.rate_limit.remainingTime, noti_data-\u003eraw.rate_limit.sequenceNumber);\n    }\n}","filepath":"example/example.c","line_number":106,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"75885":{"score":0.9298808,"function_name":"main","code":"void main(void)\n{\n    /**\n\t  SmartThings Device SDK(STDK) aims to make it easier to develop IoT devices by providing\n\t  additional st_iot_core layer to the existing chip vendor SW Architecture.\n\n      That is, you can simply develop a basic application by just calling the APIs provided by st_iot_core layer\n\t  like below. st_iot_core currently offers 14 API.\n\n      //create a iot context\n\t  1. st_conn_init();\n\n      //create a handle to process capability\n\t  2. st_cap_handle_init();\n\n      //register a callback function to process capability command when it comes from the SmartThings Server.\n\t  3. st_cap_cmd_set_cb();\n\n      //needed when it is necessary to keep monitoring the device status\n\t  4. user_defined_task()\n\n      //process on-boarding procedure. There is nothing more to do on the app side than call the API.\n\t  5. st_conn_start();\n\t */\n\n    unsigned char *onboarding_config = (unsigned char *)onboarding_config_start;\n    unsigned int onboarding_config_len = onboarding_config_end - onboarding_config_start;\n    unsigned char *device_info = (unsigned char *)device_info_start;\n    unsigned int device_info_len = device_info_end - device_info_start;\n    IOT_CAP_HANDLE *handle = NULL;\n    int iot_err;\n\n    // 1. create a iot context\n    ctx = st_conn_init(onboarding_config, onboarding_config_len, device_info, device_info_len);\n    if (ctx != NULL) {\n        iot_err = st_conn_set_noti_cb(ctx, iot_noti_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set notification callback function\\n\");\n\n        // 2. create a handle to process capability\n        //\timplement init_callback function (cap_switch_init_cb)\n        handle = st_cap_handle_init(ctx, \"main\", \"switch\", cap_switch_init_cb, NULL);\n\n        // 3. register a callback function to process capability command when it comes from the SmartThings Server\n        //\timplement callback function (cap_switch_cmd_off_cb)\n        iot_err = st_cap_cmd_set_cb(handle, \"off\", cap_switch_cmd_off_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set cmd_cb for off\\n\");\n\n        //\timplement callback function (cap_switch_cmd_on_cb)\n        iot_err = st_cap_cmd_set_cb(handle, \"on\", cap_switch_cmd_on_cb, NULL);\n        if (iot_err)\n            printf(\"fail to set cmd_cb for on\\n\");\n    } else {\n        printf(\"fail to create the iot_context\\n\");\n    }\n\n    // 4. needed when it is necessary to keep monitoring the device status\n    //xTaskCreate(user_defined_task, \"user_defined_task\", 2048, (void *)handle, 10, NULL);\n\n    // 5. process on-boarding procedure. There is nothing more to do on the app side than call the API.\n    st_conn_start(ctx, (st_status_cb)\u0026iot_status_cb, IOT_STATUS_ALL, NULL, NULL);\n\n    // exit by using Ctrl+C\n    signal(SIGINT, signal_handler);\n\n    event_loop();\n}","filepath":"example/example.c","line_number":118,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77481":{"score":0.7079075,"function_name":"st_cap_attr_create_string_array","code":"DEPRECATED IOT_EVENT* st_cap_attr_create_string_array(const char *attribute,\n\t\t\tuint8_t str_num, char *string_array[], const char *unit)\n{\n\tiot_cap_val_t value;\n\tvalue.type = IOT_CAP_VAL_TYPE_STR_ARRAY;\n\tvalue.str_num = str_num;\n\tvalue.strings = string_array;\n\n\treturn _iot_cap_create_attr(attribute, \u0026value, unit, NULL);\n}","filepath":"src/iot_capability.c","line_number":79,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77631":{"score":0.9243896,"function_name":"st_cap_create_attr_with_id","code":"IOT_EVENT* st_cap_create_attr_with_id(IOT_CAP_HANDLE *cap_handle, const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data, char *command_id)\n{\n\tiot_cap_evt_data_t* evt_data;\n\n\tevt_data = (iot_cap_evt_data_t *)st_cap_create_attr(cap_handle, attribute, value, unit, data);\n\n\tif (evt_data != NULL \u0026\u0026 command_id != NULL) {\n\t\tevt_data-\u003eoptions.command_id = iot_os_strdup(command_id);\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n}","filepath":"src/iot_capability.c","line_number":96,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"77720":{"score":0.8902944,"function_name":"_iot_cap_create_attr","code":"static IOT_EVENT* _iot_cap_create_attr(const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data)\n{\n\tint i;\n\tiot_cap_evt_data_t* evt_data;\n\n\tif (!attribute) {\n\t\tIOT_ERROR(\"attribute is NULL\");\n\t\treturn NULL;\n\t}\n\n\tif (!value) {\n\t\tIOT_ERROR(\"value is NULL\");\n\t\treturn NULL;\n\t}\n\n\tevt_data = iot_os_malloc(sizeof(iot_cap_evt_data_t));\n\tif (!evt_data) {\n\t\tIOT_ERROR(\"failed to malloc for evt_data\");\n\t\treturn NULL;\n\t}\n\tmemset(evt_data, 0, sizeof(iot_cap_evt_data_t));\n\n\n\tevt_data-\u003eevt_type = iot_os_strdup(attribute);\n\tswitch (value-\u003etype) {\n\tcase IOT_CAP_VAL_TYPE_BOOLEAN:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_BOOLEAN;\n\t\tevt_data-\u003eevt_value.boolean = value-\u003eboolean;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_INTEGER:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_INTEGER;\n\t\tevt_data-\u003eevt_value.integer = value-\u003einteger;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_NUMBER:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_NUMBER;\n\t\tevt_data-\u003eevt_value.number = value-\u003enumber;\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_STRING:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_STRING;\n\t\tif (value-\u003estring) {\n\t\t\tevt_data-\u003eevt_value.string = iot_os_strdup(value-\u003estring);\n\t\t} else {\n\t\t\tIOT_ERROR(\"There is no string value\");\n\t\t\t_iot_free_evt_data(evt_data);\n\t\t\tiot_os_free(evt_data);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_STR_ARRAY:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_STR_ARRAY;\n\t\tevt_data-\u003eevt_value.str_num = value-\u003estr_num;\n\t\tevt_data-\u003eevt_value.strings = iot_os_malloc(value-\u003estr_num * sizeof(char*));\n\t\tif (value-\u003estr_num != 0 \u0026\u0026 !evt_data-\u003eevt_value.strings) {\n\t\t\tIOT_ERROR(\"failed to malloc for string array\");\n\t\t\t_iot_free_evt_data(evt_data);\n\t\t\tiot_os_free(evt_data);\n\t\t\treturn NULL;\n\t\t} else if (evt_data-\u003eevt_value.strings) {\n\t\t\tmemset(evt_data-\u003eevt_value.strings, 0, value-\u003estr_num * sizeof(char*));\n\t\t}\n\t\tfor (i = 0; i \u003c value-\u003estr_num; i++) {\n\t\t\tif (value-\u003estrings[i]) {\n\t\t\t\tevt_data-\u003eevt_value.strings[i] = iot_os_strdup(value-\u003estrings[i]);\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"found no string value in array\");\n\t\t\t\t_iot_free_evt_data(evt_data);\n\t\t\t\tiot_os_free(evt_data);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IOT_CAP_VAL_TYPE_JSON_OBJECT:\n\t\tevt_data-\u003eevt_value.type = IOT_CAP_VAL_TYPE_JSON_OBJECT;\n\t\tevt_data-\u003eevt_value.json_object = iot_os_strdup(value-\u003ejson_object);\n\t\tbreak;\n\tdefault:\n\t\tIOT_ERROR(\"unknown attribute data type\");\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t\treturn NULL;\n\t}\n\n\tif (unit != NULL) {\n\t\tevt_data-\u003eevt_unit.type = IOT_CAP_UNIT_TYPE_STRING;\n\t\tevt_data-\u003eevt_unit.string = iot_os_strdup(unit);\n\t} else {\n\t\tevt_data-\u003eevt_unit.type = IOT_CAP_UNIT_TYPE_UNUSED;\n\t}\n\n\tif (data != NULL) {\n\t\tevt_data-\u003eevt_value_data = iot_os_strdup(data);\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n}","filepath":"src/iot_capability.c","line_number":110,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"78815":{"score":0.91929126,"function_name":"st_cap_create_attr_with_option","code":"IOT_EVENT* st_cap_create_attr_with_option(IOT_CAP_HANDLE *cap_handle, const char *attribute,\n\t\t\tiot_cap_val_t *value, const char *unit, const char *data, iot_cap_attr_option_t *options)\n{\n\tiot_cap_evt_data_t* evt_data = NULL;\n\n\tif (cap_handle == NULL) {\n\t\tIOT_ERROR(\"There is no cap handle\");\n\t\treturn NULL;\n\t}\n\n\tevt_data = (iot_cap_evt_data_t *)_iot_cap_create_attr(attribute, value, unit, data);\n\tif (evt_data == NULL)\n\t\treturn NULL;\n\n\tevt_data-\u003eref_cap = (struct iot_cap_handle *)cap_handle;\n\n\tif (options != NULL)\n\t{\n\t\tevt_data-\u003eoptions.state_change = options-\u003estate_change;\n\t\tif (options-\u003ecommand_id)\n\t\t{\n\t\t\tevt_data-\u003eoptions.command_id = iot_os_strdup(options-\u003ecommand_id);\n\t\t\tif (evt_data-\u003eoptions.command_id == NULL)\n\t\t\t{\n\t\t\t\tgoto failed_creat_attr_option;\n\t\t\t}\n\t\t}\n\n\t\tif (options-\u003edisplayed != NULL)\n\t\t{\n\t\t\tevt_data-\u003eoptions.displayed = (bool *)iot_os_malloc(sizeof(bool));\n\t\t\tif (evt_data-\u003eoptions.displayed != NULL)\n\t\t\t{\n\t\t\t\t*(evt_data-\u003eoptions.displayed) = *(options-\u003edisplayed);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgoto failed_creat_attr_option;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (IOT_EVENT*)evt_data;\n\nfailed_creat_attr_option:\n\n\tif (evt_data-\u003eoptions.displayed != NULL)\n\t{\n\t\tiot_os_free(evt_data-\u003eoptions.displayed);\n\t\tevt_data-\u003eoptions.displayed = NULL;\n\t}\n\n\tif (evt_data-\u003eoptions.command_id != NULL)\n\t{\n\t\tiot_os_free(evt_data-\u003eoptions.command_id);\n\t\tevt_data-\u003eoptions.command_id = NULL;\n\t}\n\n\tif (evt_data != NULL)\n\t{\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t}\n\n\treturn NULL;\n}","filepath":"src/iot_capability.c","line_number":213,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79193":{"score":0.89373374,"function_name":"st_cap_free_attr","code":"void st_cap_free_attr(IOT_EVENT* event)\n{\n\tiot_cap_evt_data_t* evt_data = (iot_cap_evt_data_t*) event;\n\n\tif (evt_data) {\n\t\t_iot_free_evt_data(evt_data);\n\t\tiot_os_free(evt_data);\n\t}\n}","filepath":"src/iot_capability.c","line_number":290,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79321":{"score":0.9324448,"function_name":"st_cap_handle_init","code":"IOT_CAP_HANDLE *st_cap_handle_init(IOT_CTX *iot_ctx, const char *component,\n\t\t\tconst char *capability, st_cap_init_cb init_cb, void *init_usr_data)\n{\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_handle_list *cur_list;\n\tstruct iot_cap_handle_list *new_list;\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!ctx || !capability) {\n\t    return NULL;\n\t}\n\n\thandle = iot_os_malloc(sizeof(struct iot_cap_handle));\n\tif (!handle) {\n\t\tIOT_ERROR(\"failed to malloc for iot_cap_handle\");\n\t\treturn NULL;\n\t}\n\n\tmemset(handle, 0, sizeof(struct iot_cap_handle));\n\n\tif (component) {\n\t\thandle-\u003ecomponent = iot_os_strdup(component);\n\t} else {\n\t\thandle-\u003ecomponent = iot_os_strdup(\"main\");\n\t}\n\tif (!handle-\u003ecomponent) {\n\t\tIOT_ERROR(\"failed to malloc for component\");\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\thandle-\u003ecapability = iot_os_strdup(capability);\n\tif (!handle-\u003ecapability) {\n\t\tIOT_ERROR(\"failed to malloc for capability\");\n\t\tiot_os_free((void *)handle-\u003ecomponent);\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\thandle-\u003ecmd_list = NULL;\n\n\tnew_list = (iot_cap_handle_list_t *)iot_os_malloc(sizeof(iot_cap_handle_list_t));\n\tif (!new_list) {\n\t\tIOT_ERROR(\"failed to malloc for handle list\");\n\t\tiot_os_free((void *)handle-\u003ecomponent);\n\t\tiot_os_free((void *)handle-\u003ecapability);\n\t\tiot_os_free(handle);\n\t\treturn NULL;\n\t}\n\n\tif (ctx-\u003ecap_handle_list == NULL) {\n\t\tctx-\u003ecap_handle_list = new_list;\n\t\tcur_list = ctx-\u003ecap_handle_list;\n\t} else {\n\t\tcur_list = ctx-\u003ecap_handle_list;\n\t\twhile (cur_list-\u003enext != NULL)\n\t\t\tcur_list = cur_list-\u003enext;\n\t\tcur_list-\u003enext = new_list;\n\t\tcur_list = cur_list-\u003enext;\n\t}\n\tcur_list-\u003enext = NULL;\n\tcur_list-\u003ehandle = handle;\n\n\tif (init_cb)\n\t\thandle-\u003einit_cb = init_cb;\n\n\tif (init_usr_data)\n\t\thandle-\u003einit_usr_data = init_usr_data;\n\n\thandle-\u003ectx = ctx;\n\treturn (IOT_CAP_HANDLE*)handle;\n}","filepath":"src/iot_capability.c","line_number":300,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"79976":{"score":0.9198938,"function_name":"st_conn_set_noti_cb","code":"int st_conn_set_noti_cb(IOT_CTX *iot_ctx,\n\t\tst_cap_noti_cb noti_cb, void *noti_usr_data)\n{\n\tstruct iot_context *ctx = (struct iot_context*)iot_ctx;\n\n\tif (!ctx || !noti_cb) {\n\t\tIOT_ERROR(\"There is no ctx or cb !!!\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tctx-\u003enoti_cb = noti_cb;\n\n\tif (noti_usr_data)\n\t\tctx-\u003enoti_usr_data = noti_usr_data;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":373,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"80099":{"score":0.91705656,"function_name":"st_cap_cmd_set_cb","code":"int st_cap_cmd_set_cb(IOT_CAP_HANDLE *cap_handle, const char *cmd_type,\n\t\tst_cap_cmd_cb cmd_cb, void *usr_data)\n{\n\tstruct iot_cap_handle *handle = (struct iot_cap_handle*)cap_handle;\n\tstruct iot_cap_cmd_set *command;\n\tstruct iot_cap_cmd_set_list *cur_list;\n\tstruct iot_cap_cmd_set_list *new_list;\n\tconst char *needle_str, *cmd_str;\n\tsize_t str_len;\n\n\tif (!handle || !cmd_type || !cmd_cb) {\n\t\tIOT_ERROR(\"There is no handle or cb data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tneedle_str = cmd_type;\n\tstr_len = strlen(needle_str);\n\n\tcur_list = handle-\u003ecmd_list;\n\twhile (cur_list) {\n\t\tcmd_str = cur_list-\u003ecommand-\u003ecmd_type;\n\t\tif (cmd_str \u0026\u0026 !strncmp(cmd_str, needle_str, str_len)) {\n\t\t\tIOT_ERROR(\"There is already same handle for : %s\",\n\t\t\t\t\t\tneedle_str);\n\t\t\treturn IOT_ERROR_INVALID_ARGS;\n\t\t}\n\t\tcur_list = cur_list-\u003enext;\n\t}\n\n\tcommand = (iot_cap_cmd_set_t *)iot_os_malloc(sizeof(iot_cap_cmd_set_t));\n\tif (!command) {\n\t\tIOT_ERROR(\"failed to malloc for cmd set\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tcommand-\u003ecmd_type = iot_os_strdup(needle_str);\n\tcommand-\u003ecmd_cb = cmd_cb;\n\tcommand-\u003eusr_data = usr_data;\n\n\tnew_list = (iot_cap_cmd_set_list_t *)iot_os_malloc(sizeof(iot_cap_cmd_set_list_t));\n\tif (!new_list) {\n\t\tIOT_ERROR(\"failed to malloc for cmd set list\");\n\t\tiot_os_free(command-\u003ecmd_type);\n\t\tiot_os_free(command);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tnew_list-\u003ecommand = command;\n\tnew_list-\u003enext = handle-\u003ecmd_list;\n\thandle-\u003ecmd_list = new_list;\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":391,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"80579":{"score":0.88466763,"function_name":"st_cap_attr_send","code":"DEPRECATED int st_cap_attr_send(IOT_CAP_HANDLE *cap_handle,\n\t\tuint8_t evt_num, IOT_EVENT *event[])\n{\n\tiot_cap_evt_data_t** evt_data = (iot_cap_evt_data_t**)event;\n\tint ret;\n\tstruct iot_context *ctx;\n\tst_mqtt_msg msg = {0};\n\tstruct iot_cap_handle *handle = (struct iot_cap_handle*)cap_handle;\n\tint i;\n\tJSON_H *evt_root = NULL;\n\tJSON_H *evt_arr = NULL;\n\tJSON_H *evt_item = NULL;\n\n\tif (!handle || !handle-\u003ecomponent || !handle-\u003ecapability || !handle-\u003ectx || !evt_data || !evt_num) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_DATA_ERROR, 0, 0);\n\t\tIOT_ERROR(\"There is no handle or evt_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tctx = handle-\u003ectx;\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_CONNECT_ERROR, ctx-\u003ecurr_state, 0);\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif ((iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tctx-\u003erate_limit = false;\n\t\t} else {\n\t\t\tIOT_WARN(\"Exceed rate limit. Can't send attributes for a while\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (ctx-\u003eevent_sequence_num == MAX_SQNUM) {\n\t\tctx-\u003eevent_sequence_num = 0;\n\t}\n\tctx-\u003eevent_sequence_num = (ctx-\u003eevent_sequence_num + 1) \u0026 MAX_SQNUM;\n\n\tevt_root = JSON_CREATE_OBJECT();\n\tevt_arr = JSON_CREATE_ARRAY();\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_root, \"deviceEvents\", evt_arr);\n\n\t/* Make event data format \u0026 enqueue data */\n\tfor (i = 0; i \u003c evt_num; i++) {\n\t\tevt_item = _iot_make_evt_data(handle-\u003ecomponent, handle-\u003ecapability, evt_data[i], ctx-\u003eevent_sequence_num);\n\t\tif (evt_item == NULL) {\n\t\t\tIOT_ERROR(\"Cannot make evt_data!!\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_ARRAY(evt_arr, evt_item);\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(evt_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(evt_root);\n\tif (msg.payload != NULL) {\n\t\tmsg.payloadlen = strlen(msg.payload);\n\t}\n#endif\n\tJSON_DELETE(evt_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to transfer to payload\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_event_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_event_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish_async(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_WARN(\"MQTT pub error(%d)\", ret);\n\t\tfree(msg.payload);\n\t\treturn IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t}\n\n#if !defined(STDK_MQTT_TASK)\n\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_CAPABILITY);\n#endif\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_SEND_EVENT_SUCCESS, evt_num, 0);\n\n\tfree(msg.payload);\n\treturn ctx-\u003eevent_sequence_num;\n}","filepath":"src/iot_capability.c","line_number":443,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"81577":{"score":0.9133491,"function_name":"st_cap_send_attr","code":"int st_cap_send_attr(IOT_EVENT *event[], uint8_t evt_num)\n{\n\tiot_cap_evt_data_t** evt_data = (iot_cap_evt_data_t**)event;\n\tint ret;\n\tstruct iot_context *ctx = NULL;\n\tst_mqtt_msg msg = {0};\n\tint i;\n\tJSON_H *evt_root = NULL;\n\tJSON_H *evt_arr = NULL;\n\tJSON_H *evt_item = NULL;\n\n\tif (!evt_data || !evt_num || !evt_data[0] || !evt_data[0]-\u003eref_cap || !evt_data[0]-\u003eref_cap-\u003ectx) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_DATA_ERROR, 0, 0);\n\t\tIOT_ERROR(\"There is no ctx or evt_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\tctx = evt_data[0]-\u003eref_cap-\u003ectx;\n\n\tif (ctx-\u003ecurr_state \u003c IOT_STATE_CLOUD_CONNECTING || ctx-\u003eevt_mqttcli == NULL) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_ERROR, IOT_DUMP_CAPABILITY_SEND_EVENT_NO_CONNECT_ERROR, ctx-\u003ecurr_state, 0);\n\t\tIOT_ERROR(\"Target has not connected to server yet!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tif (ctx-\u003erate_limit) {\n\t\tif ((iot_os_timer_isexpired(ctx-\u003erate_limit_timeout))) {\n\t\t\tctx-\u003erate_limit = false;\n\t\t} else {\n\t\t\tIOT_WARN(\"Exceed rate limit. Can't send attributes for a while\");\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t}\n\n\tif (ctx-\u003eevent_sequence_num == MAX_SQNUM) {\n\t\tctx-\u003eevent_sequence_num = 0;\n\t}\n\tctx-\u003eevent_sequence_num = (ctx-\u003eevent_sequence_num + 1) \u0026 MAX_SQNUM;\n\n\tevt_root = JSON_CREATE_OBJECT();\n\tevt_arr = JSON_CREATE_ARRAY();\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_root, \"deviceEvents\", evt_arr);\n\n\t/* Make event data format \u0026 enqueue data */\n\tfor (i = 0; i \u003c evt_num; i++) {\n\t\tif (!evt_data[i] || !(evt_data[i]-\u003eref_cap) || ctx != evt_data[i]-\u003eref_cap-\u003ectx) {\n\t\t\tIOT_ERROR(\"There si no capability reference in event data or ctx not matched\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tevt_item = _iot_make_evt_data(evt_data[i]-\u003eref_cap-\u003ecomponent, evt_data[i]-\u003eref_cap-\u003ecapability,\n\t\t\t\tevt_data[i], ctx-\u003eevent_sequence_num);\n\t\tif (evt_item == NULL) {\n\t\t\tIOT_ERROR(\"Cannot make evt_data!!\");\n\t\t\tJSON_DELETE(evt_root);\n\t\t\treturn IOT_ERROR_BAD_REQ;\n\t\t}\n\t\tJSON_ADD_ITEM_TO_ARRAY(evt_arr, evt_item);\n\t}\n\n#if defined(STDK_IOT_CORE_SERIALIZE_CBOR)\n\tiot_serialize_json2cbor(evt_root, (uint8_t **)\u0026msg.payload, (size_t *)\u0026msg.payloadlen);\n#else\n\tmsg.payload = JSON_PRINT(evt_root);\n\tif (msg.payload != NULL) {\n\t\tmsg.payloadlen = strlen(msg.payload);\n\t}\n#endif\n\tJSON_DELETE(evt_root);\n\tif (msg.payload == NULL) {\n\t\tIOT_ERROR(\"Fail to transfer to payload\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = ctx-\u003emqtt_event_topic;\n\n\tIOT_INFO(\"publish event, topic : %s, payload :\\n%s\",\n\t\tctx-\u003emqtt_event_topic, (char *)msg.payload);\n\n\tret = st_mqtt_publish_async(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_WARN(\"MQTT pub error(%d)\", ret);\n\t\tfree(msg.payload);\n\t\treturn IOT_ERROR_MQTT_PUBLISH_FAIL;\n\t}\n\n#if !defined(STDK_MQTT_TASK)\n\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_CAPABILITY);\n#endif\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_SEND_EVENT_SUCCESS, evt_num, 0);\n\n\tfree(msg.payload);\n\treturn ctx-\u003eevent_sequence_num;\n}","filepath":"src/iot_capability.c","line_number":535,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"82741":{"score":0.8170133,"function_name":"_iot_parse_noti_data","code":"STATIC_FUNCTION\niot_error_t _iot_parse_noti_data(void *data, iot_noti_data_t *noti_data)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tJSON_H *json = NULL;\n\tJSON_H *noti_type = NULL;\n\tJSON_H *item = NULL;\n\tchar *noti_type_string = NULL;\n\tchar *payload = NULL;\n\tchar time_str[11] = {0,};\n\n\tjson = JSON_PARSE(data);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tpayload = JSON_PRINT(json);\n\tIOT_INFO(\"payload : %s\", payload);\n\tfree(payload);\n\n\tnoti_type = JSON_GET_OBJECT_ITEM(json, \"event\");\n\tif (noti_type == NULL) {\n\t\tIOT_ERROR(\"there is no event in raw_msgn\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t\tgoto out_noti_parse;\n\t}\n\n\tnoti_type_string = JSON_GET_STRING_VALUE(noti_type);\n\tif (noti_type_string == NULL) {\n\t\tIOT_ERROR(\"there is no event type string\");\n\t\tgoto out_noti_parse;\n\t}\n\tif (!strncmp(noti_type_string, SERVER_NOTI_TYPE_DEVICE_DELETED, strlen(SERVER_NOTI_TYPE_DEVICE_DELETED))) {\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_DEVICE_DELETED_RECEIVED, 0, 0);\n\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_DEV_DELETED;\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_EXPIRED_JWT, strlen(SERVER_NOTI_TYPE_EXPIRED_JWT))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_JWT_EXPIRED;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"currentTime\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no currentTime in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\n\t\tsnprintf(time_str, sizeof(time_str), \"%d\", item-\u003evalueint);\n\t\tIOT_INFO(\"Set SNTP with current time %s\", time_str);\n\t\tiot_bsp_system_set_time_in_sec(time_str);\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_EXPIRED_JWT_RECEIVED, item-\u003evalueint, 0);\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_RATE_LIMIT_REACHED, strlen(SERVER_NOTI_TYPE_RATE_LIMIT_REACHED))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_RATE_LIMIT;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"count\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no count in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.count = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"threshold\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no threshold in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.threshold = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"remainingTime\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no remainingTime in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.remainingTime = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"sequenceNumber\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no sequenceNumber in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.rate_limit.sequenceNumber = item-\u003evalueint;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_RATE_LIMIT_RECEIVED, noti_data-\u003eraw.rate_limit.sequenceNumber, 0);\n\t} else if (!strncmp(noti_type_string, SERVER_NOTI_TYPE_QUOTA_REACHED, strlen(SERVER_NOTI_TYPE_QUOTA_REACHED))) {\n\t\tnoti_data-\u003etype = _IOT_NOTI_TYPE_QUOTA_REACHED;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"used\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no used in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.quota.used = item-\u003evalueint;\n\n\t\titem = JSON_GET_OBJECT_ITEM(json, \"limit\");\n\t\tif (item == NULL) {\n\t\t\tIOT_ERROR(\"there is no limit in raw_msgn\");\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tgoto out_noti_parse;\n\t\t}\n\t\tnoti_data-\u003eraw.quota.limit = item-\u003evalueint;\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_QUOTA_LIMIT_RECEIVED, noti_data-\u003eraw.quota.used, noti_data-\u003eraw.quota.limit);\n\t} else {\n\t\tIOT_WARN(\"There is no noti_type matched\");\n\t\terr = IOT_ERROR_BAD_REQ;\n\t}\n\nout_noti_parse:\n\n\tif (json)\n\t\tJSON_DELETE(json);\n\n\treturn err;\n}","filepath":"src/iot_capability.c","line_number":631,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84127":{"score":0.9221039,"function_name":"iot_noti_sub_cb","code":"void iot_noti_sub_cb(struct iot_context *ctx, char *payload)\n{\n\tiot_error_t err;\n\tiot_noti_data_t noti_data;\n\n\tif (!ctx || !payload) {\n\t\tIOT_ERROR(\"There is no ctx or payload\");\n\t\treturn;\n\t}\n\n\tmemset(\u0026noti_data, 0, sizeof(iot_noti_data_t));\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_NOTI_RECEIVED, 0, 0);\n\terr = _iot_parse_noti_data((void *)payload, \u0026noti_data);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Cannot parse notification data\");\n\t\treturn;\n\t}\n\tif (noti_data.type == IOT_NOTI_TYPE_RATE_LIMIT) {\n\t\tctx-\u003erate_limit = true;\n\t\tiot_os_timer_count_ms(ctx-\u003erate_limit_timeout, IOT_RATE_LIMIT_BREAK_TIME);\n\t}\n\n\tiot_command_send(ctx, IOT_COMMAND_NOTIFICATION_RECEIVED,\n\t\t\u0026noti_data, sizeof(noti_data));\n}","filepath":"src/iot_capability.c","line_number":750,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84396":{"score":0.88741547,"function_name":"_iot_process_cmd","code":"static iot_error_t _iot_process_cmd(iot_cap_handle_list_t *cap_handle_list, char *component_name,\n\t\t\tchar *capability_name, char *command_name, iot_cap_cmd_data_t *cmd_data)\n{\n\tstruct iot_cap_handle_list *handle_list = NULL;\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_cmd_set_list *command_list = NULL;\n\tstruct iot_cap_cmd_set *command = NULL;\n\n\t/* find handle with capability */\n\thandle_list = cap_handle_list;\n\twhile (handle_list != NULL) {\n\t\thandle = handle_list-\u003ehandle;\n\t\tif (handle \u0026\u0026 !strcmp(component_name, handle-\u003ecomponent) \u0026\u0026 !strcmp(capability_name, handle-\u003ecapability)) {\n\t\t\tIOT_DEBUG(\"found handle for [%s]%s\", component_name, capability_name);\n\t\t\tbreak;\n\t\t}\n\t\thandle_list = handle_list-\u003enext;\n\t}\n\n\tif (handle_list == NULL) {\n\t\tIOT_ERROR(\"Cannot find handle for [%s]%s\", component_name, capability_name);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t/* find cmd set */\n\tcommand_list = handle-\u003ecmd_list;\n\twhile (command_list != NULL) {\n\t\tcommand = command_list-\u003ecommand;\n\t\tif (!strcmp(command_name, command-\u003ecmd_type)) {\n\t\t\tcommand-\u003ecmd_cb((IOT_CAP_HANDLE *)handle,\n\t\t\t\tcmd_data, command-\u003eusr_data);\n\t\t\tbreak;\n\t\t}\n\t\tcommand_list = command_list-\u003enext;\n\t}\n\n\tif (command_list == NULL) {\n\t\tIOT_WARN(\"Not registed cmd set received '%s'\", command_name);\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_COMMAND_SUCCEED, 0, 0);\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":777,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"84744":{"score":0.8644176,"function_name":"iot_cap_sub_cb","code":"void iot_cap_sub_cb(iot_cap_handle_list_t *cap_handle_list, char *payload)\n{\n\tJSON_H *json = NULL;\n\tJSON_H *cap_cmds = NULL;\n\tJSON_H *cmditem = NULL;\n\tchar *raw_data = NULL;\n\tiot_error_t err;\n\tint i;\n\tint arr_size = 0;\n\n\tif (!cap_handle_list || !payload) {\n\t\tIOT_ERROR(\"There is no cap_handle_list or payload\");\n\t\treturn;\n\t}\n\n\tjson = JSON_PARSE(payload);\n\tif (json == NULL) {\n\t\tIOT_ERROR(\"Cannot parse by json\");\n\t\tgoto out;\n\t}\n\n\traw_data = JSON_PRINT(json);\n\tIOT_INFO(\"command : %s\", raw_data);\n\tfree(raw_data);\n\n\tcap_cmds = JSON_GET_OBJECT_ITEM(json, \"commands\");\n\tif (cap_cmds == NULL) {\n\t\tIOT_ERROR(\"there is no commands in raw_data\");\n\t\tgoto out;\n\t}\n\n\tarr_size = JSON_GET_ARRAY_SIZE(cap_cmds);\n\tIOT_DEBUG(\"cap_cmds arr_size=%d\", arr_size);\n\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_COMMANDS_RECEIVED, arr_size, 0);\n\n\tif (arr_size == 0) {\n\t\tIOT_ERROR(\"There are no commands data\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i \u003c arr_size; i++) {\n\t\tchar *component_name = NULL;\n\t\tchar *capability_name = NULL;\n\t\tchar *command_name = NULL;\n\t\tiot_cap_cmd_data_t cmd_data;\n\n\t\tcmd_data.num_args = 0;\n\t\tcmd_data.total_commands_num = arr_size;\n\t\tcmd_data.order_of_command = i + 1;\n\t\tcmd_data.command_id = NULL;\n\n\t\tcmditem = JSON_GET_ARRAY_ITEM(cap_cmds, i);\n\t\tif (!cmditem) {\n\t\t\tIOT_ERROR(\"Cannot get %dth commands data\", i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tIOT_DUMP(IOT_DEBUG_LEVEL_INFO, IOT_DUMP_CAPABILITY_PROCESS_COMMAND, i + 1, 0);\n\t\terr = _iot_parse_cmd_data(cmditem, \u0026component_name, \u0026capability_name, \u0026command_name, \u0026cmd_data);\n\t\tif (err != IOT_ERROR_NONE) {\n\t\t\tIOT_ERROR(\"Cannot parse %dth command data\", i);\n\t\t} else {\n\t\t\t_iot_process_cmd(cap_handle_list, component_name, capability_name, command_name, \u0026cmd_data);\n\t\t}\n\n\t\tif (cmd_data.num_args != 0) {\n\t\t\t_iot_free_cmd_data(\u0026cmd_data);\n\t\t\tcmd_data.num_args = 0;\n\t\t}\n\n\t\tif (component_name != NULL) {\n\t\t\tiot_os_free(component_name);\n\t\t\tcomponent_name = NULL;\n\t\t}\n\n\t\tif (capability_name != NULL) {\n\t\t\tiot_os_free(capability_name);\n\t\t\tcapability_name = NULL;\n\t\t}\n\n\t\tif (command_name != NULL) {\n\t\t\tiot_os_free(command_name);\n\t\t\tcommand_name = NULL;\n\t\t}\n\n\t\tif (cmd_data.command_id != NULL) {\n\t\t\tiot_os_free(cmd_data.command_id);\n\t\t\tcmd_data.command_id = NULL;\n\t\t}\n\t}\n\nout:\n\tif (json != NULL)\n\t\tJSON_DELETE(json);\n}","filepath":"src/iot_capability.c","line_number":822,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"85802":{"score":0.8534287,"function_name":"_iot_parse_cmd_data","code":"static iot_error_t _iot_parse_cmd_data(JSON_H* cmditem, char** component,\n\t\t\tchar** capability, char** command, iot_cap_cmd_data_t* cmd_data)\n{\n\tJSON_H *cap_component = NULL;\n\tJSON_H *cap_capability = NULL;\n\tJSON_H *cap_command = NULL;\n\tJSON_H *cap_args = NULL;\n\tJSON_H *subitem = NULL;\n\tJSON_H *command_id = NULL;\n\tint arr_size = 0;\n\tint num_args = 0;\n\tint i;\n\n\tcap_component = JSON_GET_OBJECT_ITEM(cmditem, \"component\");\n\tcap_capability = JSON_GET_OBJECT_ITEM(cmditem, \"capability\");\n\tcap_command = JSON_GET_OBJECT_ITEM(cmditem, \"command\");\n\tcap_args = JSON_GET_OBJECT_ITEM(cmditem, \"arguments\");\n\tcommand_id = JSON_GET_OBJECT_ITEM(cmditem, \"id\");\n\n\tif (cap_component == NULL || cap_capability == NULL || cap_command == NULL) {\n\t\tIOT_ERROR(\"Cannot find value index!!\");\n\t\treturn IOT_ERROR_BAD_REQ;\n\t}\n\n\t*component = iot_os_strdup(cap_component-\u003evaluestring);\n\t*capability = iot_os_strdup(cap_capability-\u003evaluestring);\n\t*command = iot_os_strdup(cap_command-\u003evaluestring);\n\n\tIOT_DEBUG(\"component:%s, capability:%s command:%s\", *component, *capability, *command);\n\n\tarr_size = JSON_GET_ARRAY_SIZE(cap_args);\n\tIOT_DEBUG(\"cap_args arr_size=%d\", arr_size);\n\tsubitem = JSON_GET_ARRAY_ITEM(cap_args, 0);\n\n\tif (subitem != NULL) {\n\t\tfor (i = 0; i \u003c arr_size; i++) {\n\t\t\tif (JSON_IS_BOOL(subitem)) {\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_BOOLEAN;\n\t\t\t\tif (JSON_IS_TRUE(subitem)) {\n\t\t\t\t\tIOT_DEBUG(\"[%d] True\", num_args);\n\t\t\t\t\tcmd_data-\u003ecmd_data[num_args].boolean = true;\n\t\t\t\t} else {\n\t\t\t\t\tIOT_DEBUG(\"[%d] False\", num_args);\n\t\t\t\t\tcmd_data-\u003ecmd_data[num_args].boolean = false;\n\t\t\t\t}\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_NUMBER(subitem)) {\n\t\t\t\tIOT_DEBUG(\"[%d] %d | %f\", num_args, subitem-\u003evalueint, subitem-\u003evaluedouble);\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_INT_OR_NUM;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].integer = subitem-\u003evalueint;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].number = subitem-\u003evaluedouble;\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_STRING(subitem)) {\n\t\t\t\tIOT_DEBUG(\"[%d] %s\", num_args, JSON_GET_STRING_VALUE(subitem));\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_STRING;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].string = iot_os_strdup(JSON_GET_STRING_VALUE(subitem));\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\telse if (JSON_IS_OBJECT(subitem) || JSON_IS_ARRAY(subitem)) {\n\t\t\t\tcmd_data-\u003eargs_str[num_args] = NULL;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].type = IOT_CAP_VAL_TYPE_JSON_OBJECT;\n\t\t\t\tcmd_data-\u003ecmd_data[num_args].json_object = JSON_PRINT(subitem);\n\t\t\t\tIOT_DEBUG(\"[%d] %s\", num_args, cmd_data-\u003ecmd_data[num_args].json_object);\n\t\t\t\tnum_args++;\n\t\t\t}\n\t\t\tsubitem = subitem-\u003enext;\n\t\t}\n\t}\n\tcmd_data-\u003enum_args = num_args;\n\n\tif (command_id != NULL) {\n\t\tcmd_data-\u003ecommand_id = iot_os_strdup(JSON_GET_STRING_VALUE(command_id));\n\t}\n\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_capability.c","line_number":920,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"86785":{"score":0.77196646,"function_name":"_iot_make_evt_data","code":"static JSON_H *_iot_make_evt_data(const char* component, const char* capability, iot_cap_evt_data_t* evt_data, int seq_num)\n{\n\tJSON_H *evt_item = NULL;\n\tJSON_H *evt_subarr = NULL;\n\tJSON_H *evt_subjson = NULL;\n\tJSON_H *evt_subdata = NULL;\n\tJSON_H *prov_data = NULL;\n\tJSON_H *visibility_data = NULL;\n\tchar time_in_ms[16]; /* 155934720000 is '2019-06-01 00:00:00.00 UTC' */\n\n\tevt_item = JSON_CREATE_OBJECT();\n\n\tif (evt_data-\u003eoptions.command_id != NULL) {\n\t\t/* commandId */\n\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"commandId\", evt_data-\u003eoptions.command_id);\n\t}\n\n\t/* component */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"component\", component);\n\n\t/* capability */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"capability\", capability);\n\n\t/* attribute */\n\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"attribute\", evt_data-\u003eevt_type);\n\n\t/* value */\n\tif (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_BOOLEAN) {\n\t\tJSON_ADD_BOOL_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.boolean);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_INTEGER) {\n\t\tJSON_ADD_NUMBER_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.integer);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_NUMBER) {\n\t\tJSON_ADD_NUMBER_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.number);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_STRING) {\n\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"value\", evt_data-\u003eevt_value.string);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_STR_ARRAY) {\n\t\tif (evt_data-\u003eevt_value.str_num == 0) {\n\t\t\tevt_subarr = JSON_CREATE_ARRAY();\n\t\t} else {\n\t\t\tevt_subarr = JSON_CREATE_STRING_ARRAY(\n\t\t\t\t(const char**)evt_data-\u003eevt_value.strings, evt_data-\u003eevt_value.str_num);\n\t\t}\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"value\", evt_subarr);\n\t} else if (evt_data-\u003eevt_value.type == IOT_CAP_VAL_TYPE_JSON_OBJECT) {\n\t\tevt_subjson = JSON_PARSE(evt_data-\u003eevt_value.json_object);\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"value\", evt_subjson);\n\t} else {\n\t\tIOT_ERROR(\"Event data value type error :%d\", evt_data-\u003eevt_value.type);\n\t\tJSON_DELETE(evt_item);\n\t\treturn NULL;\n\t}\n\n\t/* unit */\n\tif (evt_data-\u003eevt_unit.type == IOT_CAP_UNIT_TYPE_STRING)\n\t\t\tJSON_ADD_STRING_TO_OBJECT(evt_item, \"unit\", evt_data-\u003eevt_unit.string);\n\n\t/* data */\n\tif (evt_data-\u003eevt_value_data) {\n\t\tevt_subdata = JSON_PARSE(evt_data-\u003eevt_value_data);\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"data\", evt_subdata);\n\t}\n\n\t/* visibility */\n\tif (evt_data-\u003eoptions.displayed != NULL)\n\t{\n\t\tvisibility_data = JSON_CREATE_OBJECT();\n\t\tJSON_ADD_BOOL_TO_OBJECT(visibility_data, \"displayed\", *(evt_data-\u003eoptions.displayed));\n\n\t\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"visibility\", visibility_data);\n\t}\n\n\t/* providerData */\n\tprov_data = JSON_CREATE_OBJECT();\n\tJSON_ADD_NUMBER_TO_OBJECT(prov_data, \"sequenceNumber\", seq_num);\n\n\tif (iot_get_time_in_ms(time_in_ms, sizeof(time_in_ms)) != IOT_ERROR_NONE)\n\t\tIOT_WARN(\"Cannot add optional timestamp value\");\n\telse\n\t\tJSON_ADD_STRING_TO_OBJECT(prov_data, \"timestamp\", time_in_ms);\n\n\tif (evt_data-\u003eoptions.state_change)\n\t\tJSON_ADD_STRING_TO_OBJECT(prov_data, \"stateChange\", \"Y\");\n\n\tJSON_ADD_ITEM_TO_OBJECT(evt_item, \"providerData\", prov_data);\n\n\treturn evt_item;\n}","filepath":"src/iot_capability.c","line_number":1002,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"87789":{"score":0.8826995,"function_name":"iot_cap_call_init_cb","code":"void iot_cap_call_init_cb(iot_cap_handle_list_t *cap_handle_list)\n{\n\tstruct iot_cap_handle *handle = NULL;\n\tstruct iot_cap_handle_list *cur_list;\n\n\tif (!cap_handle_list) {\n\t\tIOT_ERROR(\"There is no cap_handle_list\");\n\t\treturn;\n\t}\n\n\tcur_list = cap_handle_list;\n\twhile (cur_list != NULL) {\n\t\thandle = cur_list-\u003ehandle;\n\t\tif (handle \u0026\u0026 handle-\u003einit_cb) {\n\t\t\tIOT_INFO(\"Call init_cb for %s capability\",\n\t\t\t\thandle-\u003ecapability ? handle-\u003ecapability : \"NULL\");\n\t\t\thandle-\u003einit_cb((IOT_CAP_HANDLE*)handle, handle-\u003einit_usr_data);\n\t\t}\n\t\tcur_list = cur_list-\u003enext;\n\t}\n}","filepath":"src/iot_capability.c","line_number":1090,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88002":{"score":0.9650394,"function_name":"_iot_free_val","code":"static void _iot_free_val(iot_cap_val_t* val)\n{\n\tint i;\n\n\tif (val == NULL) {\n\t\treturn;\n\t}\n\n\tif (val-\u003etype == IOT_CAP_VAL_TYPE_STRING\n\t\t\t\t\u0026\u0026 val-\u003estring != NULL) {\n\t\tiot_os_free(val-\u003estring);\n\t}\n\telse if (val-\u003etype == IOT_CAP_VAL_TYPE_STR_ARRAY\n\t\t\t\t\u0026\u0026 val-\u003estrings != NULL) {\n\t\tfor (i = 0; i \u003c val-\u003estr_num; i++) {\n\t\t\tif (val-\u003estrings[i] != NULL) {\n\t\t\t\tiot_os_free(val-\u003estrings[i]);\n\t\t\t}\n\t\t}\n\t\tiot_os_free(val-\u003estrings);\n\t} else if (val-\u003etype == IOT_CAP_VAL_TYPE_JSON_OBJECT) {\n\t\tiot_os_free(val-\u003ejson_object);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1112,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88225":{"score":0.63122714,"function_name":"_iot_free_unit","code":"static void _iot_free_unit(iot_cap_unit_t* unit)\n{\n\tif (unit == NULL) {\n\t\treturn;\n\t}\n\n\tif (unit-\u003etype == IOT_CAP_UNIT_TYPE_STRING\n\t\t\t\t\u0026\u0026 unit-\u003estring != NULL) {\n\t\tiot_os_free(unit-\u003estring);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1137,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88297":{"score":0.9489959,"function_name":"_iot_free_cmd_data","code":"static void _iot_free_cmd_data(iot_cap_cmd_data_t* cmd_data)\n{\n\tint i;\n\n\tif (cmd_data == NULL) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; i \u003c cmd_data-\u003enum_args; i++) {\n\t\tif (cmd_data-\u003eargs_str[i] != NULL) {\n\t\t\tfree(cmd_data-\u003eargs_str[i]);\n\t\t}\n\t\t_iot_free_val(\u0026cmd_data-\u003ecmd_data[i]);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1149,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88428":{"score":0.9357708,"function_name":"_iot_free_evt_data","code":"static void _iot_free_evt_data(iot_cap_evt_data_t* evt_data)\n{\n\tif (evt_data == NULL) {\n\t\treturn;\n\t}\n\n\tif (evt_data-\u003eevt_type != NULL) {\n\t\tiot_os_free((void *)evt_data-\u003eevt_type);\n\t}\n\t_iot_free_val(\u0026evt_data-\u003eevt_value);\n\t_iot_free_unit(\u0026evt_data-\u003eevt_unit);\n\n\tif (evt_data-\u003eevt_value_data != NULL) {\n\t\tiot_os_free(evt_data-\u003eevt_value_data);\n\t}\n\n\tif (evt_data-\u003eoptions.command_id != NULL) {\n\t\tiot_os_free(evt_data-\u003eoptions.command_id);\n\t}\n\n\tif (evt_data-\u003eoptions.displayed != NULL) {\n\t\tiot_os_free(evt_data-\u003eoptions.displayed);\n\t}\n}","filepath":"src/iot_capability.c","line_number":1165,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"88820":{"score":0.9263198,"function_name":"_iot_command_peek","code":"STATIC_FUNCTION\niot_error_t _iot_command_peek(struct iot_context *ctx, enum iot_command_type peek_cmd)\n{\n\tstruct iot_command cmd_data;\n\tint ret;\n\tiot_error_t err;\n\tbool *cmd_only = NULL;\n\n\tif (peek_cmd != IOT_COMMAND_CHECK_PROV_STATUS) {\n\t\tIOT_ERROR(\"Unsupported peek cmd(%d)\", peek_cmd);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tcmd_only = iot_os_malloc(sizeof(bool));\n\tif (!cmd_only) {\n\t\tIOT_ERROR(\"failed to malloc for iot_command_peek param\");\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\t*cmd_only = true;\n\n\tcmd_data.param = cmd_only;\n\tcmd_data.cmd_type = peek_cmd;\n\n\tret = iot_os_queue_send(ctx-\u003ecmd_queue, \u0026cmd_data, 0);\n\tif (ret != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"Cannot put the cmd into cmd_queue\");\n\t\tiot_os_free(cmd_data.param);\n\t\terr = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_COMMAND);\n\t\terr = IOT_ERROR_NONE;\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":56,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89156":{"score":0.9103227,"function_name":"_check_prov_data_validation","code":"STATIC_FUNCTION\niot_error_t _check_prov_data_validation(struct iot_device_prov_data *prov_data)\n{\n\tstruct iot_wifi_prov_data *wifi = \u0026(prov_data-\u003ewifi);\n\tstruct iot_cloud_prov_data *cloud = \u0026(prov_data-\u003ecloud);\n\n\tif (wifi-\u003essid[0] == '\\0') {\n\t\tIOT_ERROR(\"There is no ssid on prov_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (!cloud-\u003ebroker_url) {\n\t\tIOT_ERROR(\"There is no broker_url on prov_data\");\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif (cloud-\u003ebroker_port \u003c 0) {\n\t\tIOT_ERROR(\"There is wrong port(%d) on prov_data\", cloud-\u003ebroker_port);\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\treturn IOT_ERROR_NONE;\n}","filepath":"src/iot_main.c","line_number":93,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89369":{"score":0.94999415,"function_name":"_delete_easysetup_resources_all","code":"STATIC_FUNCTION\nvoid _delete_easysetup_resources_all(struct iot_context *ctx)\n{\n\tctx-\u003ees_res_created = false;\n\n\tif (ctx-\u003epin) {\n\t\tiot_os_free(ctx-\u003epin);\n\t\tctx-\u003epin = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_security_context) {\n\t\tiot_security_deinit(ctx-\u003eeasysetup_security_context);\n\t\tctx-\u003eeasysetup_security_context = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_req_queue) {\n\t\tiot_os_queue_delete(ctx-\u003eeasysetup_req_queue);\n\t\tctx-\u003eeasysetup_req_queue = NULL;\n\t}\n\tif (ctx-\u003eeasysetup_resp_queue) {\n\t\tiot_os_queue_delete(ctx-\u003eeasysetup_resp_queue);\n\t\tctx-\u003eeasysetup_resp_queue = NULL;\n\t}\n}","filepath":"src/iot_main.c","line_number":116,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"89570":{"score":0.92785716,"function_name":"_create_easysetup_resources","code":"STATIC_FUNCTION\niot_error_t _create_easysetup_resources(struct iot_context *ctx, iot_pin_t *pin_num)\n{\n\tiot_error_t ret;\n\n\t/* If PIN type used, iot_pin_t should be set */\n\tif (ctx-\u003edevconf.ownership_validation_type \u0026 IOT_OVF_TYPE_PIN) {\n\t\tif (!ctx-\u003epin) {\n\t\t\tif ((ctx-\u003epin = iot_os_malloc(sizeof(iot_pin_t))) == NULL) {\n\t\t\t\tIOT_ERROR(\"failed to malloc for pin\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\treturn IOT_ERROR_MEM_ALLOC;\n\t\t\t}\n\t\t}\n\n\t\tif (pin_num) {\n\t\t\tmemcpy(ctx-\u003epin, pin_num, sizeof(iot_pin_t));\n\t\t} else {\n\t\t\tret = IOT_ERROR_INVALID_ARGS;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tctx-\u003eeasysetup_security_context = iot_security_init();\n\tif (ctx-\u003eeasysetup_security_context == NULL) {\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tret = IOT_ERROR_SECURITY_INIT;\n\t\tgoto create_fail;\n\t}\n\n\tif (!ctx-\u003eeasysetup_req_queue) {\n\t\tctx-\u003eeasysetup_req_queue = iot_os_queue_create(1, sizeof(struct iot_easysetup_payload));\n\t\tif (!ctx-\u003eeasysetup_req_queue) {\n\t\t\tIOT_ERROR(\"failed to create Queue for easysetup request\\n\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\tret = IOT_ERROR_BAD_REQ;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tif (!ctx-\u003eeasysetup_resp_queue) {\n\t\tctx-\u003eeasysetup_resp_queue = iot_os_queue_create(1, sizeof(struct iot_easysetup_payload));\n\t\tif (!ctx-\u003eeasysetup_resp_queue) {\n\t\t\tIOT_ERROR(\"failed to create Queue for easysetup response\\n\");\n\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\tret = IOT_ERROR_BAD_REQ;\n\t\t\tgoto create_fail;\n\t\t}\n\t}\n\n\tctx-\u003ees_res_created = true;\n\treturn IOT_ERROR_NONE;\n\ncreate_fail:\n\t_delete_easysetup_resources_all(ctx);\n\treturn ret;\n}","filepath":"src/iot_main.c","line_number":139,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90106":{"score":0.91628814,"function_name":"_do_status_report","code":"STATIC_FUNCTION\nvoid _do_status_report(struct iot_context *ctx,\n\tiot_state_t target_state, bool is_final)\n{\n\tiot_status_t fn_stat = 0;\n\tiot_stat_lv_t fn_stat_lv = 0;\n\tunsigned int curr_stat = 0;\n\tbool is_report = false;\n\n\tswitch (target_state) {\n\tcase IOT_STATE_CHANGE_FAILED:\n\t\tif (ctx-\u003ereported_stat) {\n\t\t\tfn_stat = (ctx-\u003ereported_stat \u0026 IOT_STATUS_ALL);\n\t\t\tfn_stat_lv = IOT_STAT_LV_FAIL;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_INITIALIZED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_IDLE;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_ENTER:\n\t\tif (is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_START;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONN_MOBILE:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_CONN;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_CONFIRM:\n\t\tif (ctx-\u003ecurr_otm_feature == OVF_BIT_BUTTON) {\n\t\t\tfn_stat = IOT_STATUS_NEED_INTERACT;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_PROV_DONE:\n\t\tif (is_final) {\n\t\t\tfn_stat = IOT_STATUS_PROVISIONING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_DONE;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_REGISTERING:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_SIGN_UP;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTING:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_SIGN_IN;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_CONNECTED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_CONNECTING;\n\t\t\tfn_stat_lv = IOT_STAT_LV_DONE;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tcase IOT_STATE_CLOUD_DISCONNECTED:\n\t\tif (!is_final) {\n\t\t\tfn_stat = IOT_STATUS_IDLE;\n\t\t\tfn_stat_lv = IOT_STAT_LV_STAY;\n\t\t\tis_report = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tIOT_INFO(\"Unsupported state %d for %d/%d\", target_state, fn_stat, fn_stat_lv);\n\t\tbreak;\n\t}\n\n\tif (is_report \u0026\u0026 (fn_stat \u0026 ctx-\u003estatus_maps)) {\n\t\t/* we assume that fn_stat uses only 8bits */\n\t\tcurr_stat = fn_stat | (fn_stat_lv \u003c\u003c 8);\n\n\t\tif (ctx-\u003ereported_stat != curr_stat) {\n\t\t\tIOT_INFO(\"Call usr status_cb with %d/%d\", fn_stat, fn_stat_lv);\n\t\t\tctx-\u003estatus_cb(fn_stat, fn_stat_lv, ctx-\u003estatus_usr_data);\n\t\t\tctx-\u003ereported_stat = curr_stat;\n\t\t}\n\t}\n\n}","filepath":"src/iot_main.c","line_number":204,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90776":{"score":0.7217308,"function_name":"_clear_cmd_status","code":"static void _clear_cmd_status(struct iot_context *ctx, enum iot_command_type cmd_type)\n{\n\tif (cmd_type != IOT_COMMNAD_STATE_UPDATE) {\n\t\tctx-\u003ecmd_count[cmd_type]--;\n\t\tif (!ctx-\u003ecmd_count[cmd_type])\n\t\tctx-\u003ecmd_status \u0026= ~(1u \u003c\u003c cmd_type);\n\t}\n}","filepath":"src/iot_main.c","line_number":312,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"90895":{"score":0.8775546,"function_name":"_unlikely_with_stored_dip","code":"static bool _unlikely_with_stored_dip(struct iot_dip_data *chk_dip)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_dip_data old_dip;\n\tint idx;\n\n\tif (chk_dip == NULL) {\n\t\treturn true;\n\t}\n\n\terr = iot_misc_info_load(IOT_MISC_INFO_DIP, (void *)\u0026old_dip);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to load stored DIP!! (%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\treturn true;\n\t}\n\n\tfor (idx = 0; idx \u003c IOT_UUID_BYTES; idx++) {\n\t\tif (chk_dip-\u003edip_id.id[idx] != old_dip.dip_id.id[idx]) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (chk_dip-\u003edip_major_version != old_dip.dip_major_version) {\n\t\treturn true;\n\t}\n\n\tif (chk_dip-\u003edip_minor_version != old_dip.dip_minor_version) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}","filepath":"src/iot_main.c","line_number":321,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"91147":{"score":0.9176994,"function_name":"_prepare_self_reged","code":"static iot_error_t _prepare_self_reged(struct iot_context *ctx)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_uuid old_location;\n\tchar *location_str = NULL;\n\tchar *lookup_str = NULL;\n\n\tif (!ctx) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\t/* Make new lookup_id for self-registration */\n\tlookup_str = (char *)iot_os_malloc(IOT_REG_UUID_STR_LEN + 1);\n\tif (!lookup_str) {\n\t\tIOT_ERROR(\"Failed to malloc for lookup_str\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\treturn IOT_ERROR_MEM_ALLOC;\n\t}\n\tmemset(lookup_str, 0, (IOT_REG_UUID_STR_LEN +1));\n\n\terr = iot_get_random_id_str(lookup_str,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to get new lookup_str(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\t/* Load previous locationId from NV */\n\terr = iot_misc_info_load(IOT_MISC_INFO_LOCATION,\n\t\t\t(void *)\u0026old_location);\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to load old_location(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\tlocation_str = (char *)iot_os_malloc(IOT_REG_UUID_STR_LEN +1);\n\tif (!location_str) {\n\t\tIOT_ERROR(\"Failed to malloc for location_str\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\terr = IOT_ERROR_MEM_ALLOC;\n\t\tgoto error_prepare_self;\n\t}\n\tmemset(location_str, 0, (IOT_REG_UUID_STR_LEN +1));\n\n\terr = iot_util_convert_uuid_str(\u0026old_location, location_str,\n\t\t\t(IOT_REG_UUID_STR_LEN + 1));\n\tif (err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"Failed to convert location_str(%d)\", err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\tgoto error_prepare_self;\n\t}\n\n\t/* lookup_id \u0026 location are runtime allocated string\n\t * during D2D process, so free it first to avoid memory-leak\n\t */\n\tif (ctx-\u003elookup_id) {\n\t\tiot_os_free(ctx-\u003elookup_id);\n\t}\n\tctx-\u003elookup_id = lookup_str;\n\n\tif (ctx-\u003eprov_data.cloud.location) {\n\t\tiot_os_free(ctx-\u003eprov_data.cloud.location);\n\t}\n\tctx-\u003eprov_data.cloud.location = location_str;\n\n\treturn IOT_ERROR_NONE;\n\nerror_prepare_self:\n\tif (lookup_str) {\n\t\tiot_os_free(lookup_str);\n\t}\n\n\tif (location_str) {\n\t\tiot_os_free(location_str);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":355,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"91781":{"score":0.93478036,"function_name":"_delete_dev_card_by_usr","code":"STATIC_FUNCTION\niot_error_t _delete_dev_card_by_usr(struct iot_context *ctx)\n{\n\tiot_error_t iot_err = IOT_ERROR_NONE;\n\tunsigned char curr_events;\n\tst_mqtt_msg msg;\n\tint ret;\n\n\tif (!ctx) {\n\t\treturn IOT_ERROR_INVALID_ARGS;\n\t}\n\n\tif ((!ctx-\u003eevt_mqttcli) || (ctx-\u003ecurr_state != IOT_STATE_CLOUD_CONNECTED)) {\n\t\tIOT_WARN(\"not connected, so can't send device_card deleting msg\");\n\t\treturn IOT_ERROR_NONE;\n\t}\n\n\tiot_os_eventgroup_clear_bits(ctx-\u003eusr_events, IOT_USR_INTERACT_BIT_CMD_DONE);\n\tctx-\u003eusr_delete_req = true;\n\n\t/* GreatGate wants to receive 'empty' payload */\n\tmsg.payload = NULL;\n\tmsg.payloadlen = 0;\n\tmsg.qos = st_mqtt_qos1;\n\tmsg.retained = false;\n\tmsg.topic = IOT_PUB_TOPIC_DELETE;\n\n\tret = st_mqtt_publish(ctx-\u003eevt_mqttcli, \u0026msg);\n\tif (ret) {\n\t\tIOT_ERROR(\"error MQTTpub for %s(%d)\", (char *)msg.topic, ret);\n\t\tctx-\u003eusr_delete_req = false;\n\t\tiot_err = IOT_ERROR_BAD_REQ;\n\t} else {\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eusr_events,\n\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE, true, (NEXT_STATE_TIMEOUT_MS / 2));\n\n\t\tif (!(curr_events \u0026 IOT_USR_INTERACT_BIT_CMD_DONE)) {\n\t\t\tIOT_ERROR(\"Timeout happened for device_card deleting\");\n\t\t\tctx-\u003eusr_delete_req = false;\n\t\t\tiot_err = IOT_ERROR_TIMEOUT;\n\t\t}\n\t}\n\n\treturn iot_err;\n}","filepath":"src/iot_main.c","line_number":436,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"92188":{"score":0.8334048,"function_name":"_do_iot_main_command","code":"static iot_error_t _do_iot_main_command(struct iot_context *ctx,\n\tstruct iot_command *cmd)\n{\n\tiot_error_t err = IOT_ERROR_NONE;\n\tiot_state_t next_state;\n\tint state_opt = IOT_STATE_OPT_NONE;\n\tiot_wifi_conf *conf = NULL;\n\tchar *usr_id = NULL;\n\tsize_t str_len;\n\tstruct iot_state_data *state_data;\n\tunsigned int needed_tout = 0;\n\tiot_noti_data_t *noti = NULL;\n\tbool is_diff_dip = false;\n\tbool *reboot = NULL;\n\tbool *cmd_only = NULL;\n\n\tIOT_INFO(\"curr_main_cmd:%d, curr_main_state:%d/%d\",\n\t\tcmd-\u003ecmd_type, ctx-\u003ecurr_state, ctx-\u003ereq_state);\n\n\t/* Some State has to queue several commands sequentially\n\t * But sometimes next command queuing or next process can make error\n\t * after the first command queued successfully.\n\t * So to prevent the first command handling after error occurred,\n\t * added command skipping coroutine\n\t */\n\tif (ctx-\u003ecmd_err \u0026\u0026 (cmd-\u003ecmd_type \u003c IOT_COMMAND_TYPE_MAX)) {\n\t\tIOT_WARN(\"iot-core had errors!!(0x%0x), skip cmd\", ctx-\u003ecmd_err);\n\t\tIOT_DUMP_MAIN_ARG2(WARN, COMMAND, ctx-\u003ecmd_err, ctx-\u003ecurr_state);\n\t\tgoto out_do_cmd;\n\t}\n\n\tswitch (cmd-\u003ecmd_type) {\n\t\tcase IOT_COMMNAD_STATE_UPDATE:\n\t\t\tstate_data = (struct iot_state_data *)cmd-\u003eparam;\n\t\t\tif (!state_data) {\n\t\t\t\tIOT_ERROR(\"There is no state_data for cmd :%d\", cmd-\u003ecmd_type);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((ctx-\u003ecurr_state \u003e IOT_STATE_UNKNOWN) \u0026\u0026\n\t\t\t\t\t(ctx-\u003ecurr_state == state_data-\u003eiot_state)) {\n\t\t\t\tIOT_WARN(\"Redundant command. state update in progress !\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\terr = _do_state_updating(ctx, state_data-\u003eiot_state,\n\t\t\t\t\tstate_data-\u003eopt, \u0026needed_tout);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to handle new state : %d\", state_data-\u003eiot_state);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, state_data-\u003eiot_state);\n\t\t\t} else {\n\t\t\t\tif (needed_tout) {\n\t\t\t\t\t/* Internal state will be updated with timeout */\n\t\t\t\t\tctx-\u003ecmd_err = 0;\n\t\t\t\t\tctx-\u003ereq_state = state_data-\u003eiot_state;\n\t\t\t\t\t_do_update_timeout(ctx, needed_tout);\n\t\t\t\t}\n\n\t\t\t\t/* Call the user's status_cb function if it's available */\n\t\t\t\tif (ctx-\u003estatus_cb)\n\t\t\t\t\t_do_status_report(ctx, state_data-\u003eiot_state, false);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t/* For Resource control */\n\t\tcase IOT_COMMAND_READY_TO_CTL:\n\t\t\tctx-\u003ercv_fail_state = IOT_STATE_INITIALIZED;\n\t\t\tctx-\u003ercv_try_cnt = 0;\n\t\t\tiot_cap_call_init_cb(ctx-\u003ecap_handle_list);\n\t\t\tbreak;\n\n\t\t/* For Device control */\n\t\tcase IOT_COMMAND_NETWORK_MODE:\n\t\t\tconf = (iot_wifi_conf *)cmd-\u003eparam;\n\t\t\tif (!conf) {\n\t\t\t\tIOT_ERROR(\"failed to get iot_wifi_conf\\n\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t} else {\n\t\t\t\terr = iot_bsp_wifi_set_mode(conf);\n\t\t\t\tif (err \u003c 0) {\n\t\t\t\t\tIOT_ERROR(\"failed to set wifi_set_mode\\n\");\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!conf || err \u003c 0) {\n\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (conf-\u003emode) {\n\t\t\tcase IOT_WIFI_MODE_SOFTAP:\n\t\t\t\tif (ctx-\u003ereq_state == IOT_STATE_PROV_ENTER) {\n\t\t\t\t\terr = iot_easysetup_init(ctx);\n\t\t\t\t\tIOT_MEM_CHECK(\"ES_INIT DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"failed to iot_easysetup_init(%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\n\t\t\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx-\u003ees_http_ready = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* For state related control */\n\t\tcase IOT_COMMAND_CHECK_PROV_STATUS:\n\t\t\tif (cmd-\u003eparam) {\n\t\t\t\tcmd_only = (bool *)cmd-\u003eparam;\n\t\t\t}\n\t\t\tctx-\u003eiot_reg_data.new_reged = false;\n\n\t\t\t/* Now we allow D2D process reentrant and prov_data could be loaded\n\t\t\t * at the init state or previous D2D, so free it first to avoid memory-leak\n\t\t\t */\n\t\t\tiot_api_prov_data_mem_free(\u0026ctx-\u003eprov_data);\n\t\t\terr = iot_nv_get_prov_data(\u0026ctx-\u003eprov_data);\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_DEBUG(\"There are no prov data in NV\\n\");\n\t\t\t\terr = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\t\t\t\tif ((err != IOT_ERROR_NONE) \u0026\u0026 (err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\t\t\t\tIOT_ERROR(\"Can't remove deviceId for new registraiton\");\n\t\t\t\t}\n\n\t\t\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\t\t\tnext_state = IOT_STATE_PROV_ENTER;\n\t\t\t} else {\n\t\t\t\terr = _check_prov_data_validation(\u0026ctx-\u003eprov_data);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"There are no valid prov data in NV\\n\");\n\t\t\t\t\terr = iot_nv_erase(IOT_NVD_DEVICE_ID);\n\t\t\t\t\tif ((err != IOT_ERROR_NONE) \u0026\u0026 (err != IOT_ERROR_NV_DATA_NOT_EXIST)) {\n\t\t\t\t\t\tIOT_ERROR(\"Can't remove deviceId for new registraiton\");\n\t\t\t\t\t}\n\n\t\t\t\t\tctx-\u003eiot_reg_data.new_reged = true;\n\t\t\t\t\tnext_state = IOT_STATE_PROV_ENTER;\n\t\t\t\t} else {\n\t\t\t\t\tnext_state = IOT_STATE_PROV_DONE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmd_only \u0026\u0026 *cmd_only) {\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE);\n\t\t\t\t/* We don't need recovering for command only case */\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"Internal WARN(%d) happened for command only\", err);\n\t\t\t\t}\n\n\t\t\t\treturn IOT_ERROR_NONE;\n\t\t\t} else {\n\t\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CHECK_CLOUD_STATE:\n\t\t\tctx-\u003eiot_reg_data.self_reged = false;\n\n\t\t\tif (ctx-\u003eiot_reg_data.new_reged) {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t} else if (ctx-\u003eiot_reg_data.updated) {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t} else {\n\t\t\t\terr = iot_nv_get_device_id(\u0026usr_id, \u0026str_len);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_WARN(\"There are no reged data in NV\\n\");\n\t\t\t\t\tif (ctx-\u003ereq_state == IOT_STATE_PROV_DONE) {\n\t\t\t\t\t\t/* Current server does not send any notification when the device\n\t\t\t\t\t\t * tries to start registration process with invalid information\n\t\t\t\t\t\t * such as manuall or forcely reboot case after provisioning step.\n\t\t\t\t\t\t * So, we forcely remove all data \u0026 reboot the device\n\t\t\t\t\t\t */\n\t\t\t\t\t\tIOT_WARN(\"Some thing went wrong, got provisioning but no deviceId\");\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EA);\n\n\t\t\t\t\t\tif (ctx-\u003ees_http_ready) {\n\t\t\t\t\t\t\tctx-\u003ees_http_ready = false;\n\t\t\t\t\t\t\tiot_easysetup_deinit(ctx);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ctx-\u003ees_res_created)\n\t\t\t\t\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t\t\t\t\tiot_device_cleanup(ctx);\n\n\t\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\t\t/* The device will be reboot forcely */\n\t\t\t\t\t\tIOT_REBOOT();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (str_len \u003e IOT_REG_UUID_STR_LEN) {\n\t\t\t\t\t\tIOT_WARN(\"Long deviceID in NV %s, use it insize\\n\",\n\t\t\t\t\t\t\tusr_id);\n\t\t\t\t\t\tmemcpy(ctx-\u003eiot_reg_data.deviceId, usr_id,\n\t\t\t\t\t\t\tIOT_REG_UUID_STR_LEN);\n\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId[IOT_REG_UUID_STR_LEN] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy(ctx-\u003eiot_reg_data.deviceId, usr_id, str_len);\n\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId[str_len] = '\\0';\n\n\t\t\t\t\t\tIOT_INFO(\"Current deviceID: %s (%d)\\n\",\n\t\t\t\t\t\t\tctx-\u003eiot_reg_data.deviceId, str_len);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ctx-\u003edevconf.dip) {\n\t\t\t\t\t\tis_diff_dip = _unlikely_with_stored_dip(ctx-\u003edevconf.dip);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tis_diff_dip = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_diff_dip) {\n\t\t\t\t\t\terr = _prepare_self_reged(ctx);\n\t\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\t\tIOT_ERROR(\"Failed to prepare self registration(%d)\", err);\n\t\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t\t\tis_diff_dip = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_diff_dip) {\n\t\t\t\t\t\tctx-\u003eiot_reg_data.self_reged = true;\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx-\u003eiot_reg_data.updated = true;\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t\t\t}\n\n\t\t\t\t\tfree(usr_id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_REGISTERING:\n\t\t\t/* if there is previous connection, disconnect it first. */\n\t\t\tif (ctx-\u003ereg_mqttcli != NULL) {\n\t\t\t\tIOT_INFO(\"There is active registering, disconnect it first.\\n\");\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t}\n\n\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\tif (err == IOT_ERROR_MQTT_REJECT_CONNECT) {\n\t\t\t\t/* This error case will be happended when server replies\n\t\t\t\t * some specific response, so the trial to connect with server\n\t\t\t\t * is succeeded (with REJECT). By this reason, we don't want\n\t\t\t\t * to change the STATE by the failure.\n\t\t\t\t */\n\t\t\t\tIOT_WARN(\"Intended error case(reboot), go to STATE_UNKONWN\\n\");\n\t\t\t\terr = iot_state_update(ctx, IOT_STATE_UNKNOWN, state_opt);\n\t\t\t} else if (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to iot_es_connect for registration\\n\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\n\t\t\t\tif (ctx-\u003ereq_state != IOT_STATE_CHANGE_FAILED) {\n\t\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t\t\terr = iot_state_update(ctx,\n\t\t\t\t\t\t\tnext_state, state_opt);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"Duplicated error handling, skip updating!!\");\n\t\t\t\t\terr = IOT_ERROR_DUPLICATED_CMD;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_REGISTERING DONE \u003e\u003ePT\u003c\u003c\");\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_REGISTERED:\n\t\t\tif (iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION) != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to _iot_es_disconnect for registration\\n\");\n\t\t\t}\n\n\t\t\tif (ctx-\u003eprov_data.cloud.location) {\n\t\t\t\tiot_os_free(ctx-\u003eprov_data.cloud.location);\n\t\t\t\tctx-\u003eprov_data.cloud.location = NULL;\n\t\t\t}\n\n\t\t\tif (ctx-\u003eprov_data.cloud.room) {\n\t\t\t\tiot_os_free(ctx-\u003eprov_data.cloud.room);\n\t\t\t\tctx-\u003eprov_data.cloud.room = NULL;\n\t\t\t}\n\n\t\t\tif (ctx-\u003eiot_reg_data.updated) {\n\t\t\t\tif (ctx-\u003eiot_reg_data.dip) {\n\t\t\t\t\terr = iot_misc_info_store(IOT_MISC_INFO_DIP,\n\t\t\t\t\t\t\t(const void *)ctx-\u003eiot_reg_data.dip);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"Store DIP failed!! (%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t}\n\n\t\t\t\t\tiot_os_free(ctx-\u003eiot_reg_data.dip);\n\t\t\t\t\tctx-\u003eiot_reg_data.dip = NULL;\n\t\t\t\t}\n\n\t\t\t\tif (ctx-\u003eiot_reg_data.locationId) {\n\t\t\t\t\terr = iot_misc_info_store(IOT_MISC_INFO_LOCATION,\n\t\t\t\t\t\t\t(const void *)ctx-\u003eiot_reg_data.locationId);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_ERROR(\"Store LocationId failed!! (%d)\", err);\n\t\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t\t}\n\n\t\t\t\t\tiot_os_free(ctx-\u003eiot_reg_data.locationId);\n\t\t\t\t\tctx-\u003eiot_reg_data.locationId = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"There is no locationId!!\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD2C1EA);\n\t\t\t\t}\n\n\t\t\t\terr = iot_nv_set_device_id(ctx-\u003eiot_reg_data.deviceId);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"Set deviceId failed!! (%d)\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIOT_ERROR(\"Rgistration data updated failed!!\");\n\t\t\t\terr = IOT_ERROR_REG_UPDATED;\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t}\n\n\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t} else {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_REGISTERED DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CLOUD_CONNECTING:\n\t\t\t/* we don't need this lookup_id anymore */\n\t\t\tif (ctx-\u003elookup_id) {\n\t\t\t\tfree(ctx-\u003elookup_id);\n\t\t\t\tctx-\u003elookup_id = NULL;\n\t\t\t}\n\n\t\t\t/* we don't need this hashed_sn anymore*/\n\t\t\tif (ctx-\u003edevconf.hashed_sn) {\n\t\t\t\tfree(ctx-\u003edevconf.hashed_sn);\n\t\t\t\tctx-\u003edevconf.hashed_sn = NULL;\n\t\t\t}\n\n\t\t\t/* if there is previous connection, disconnect it first. */\n\t\t\tif (ctx-\u003eevt_mqttcli != NULL) {\n\t\t\t\tIOT_INFO(\"There is previous connecting, disconnect it first.\\n\");\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t}\n\n\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\tif (err == IOT_ERROR_MQTT_REJECT_CONNECT) {\n\t\t\t\t/* This error case will be happended when server replies\n\t\t\t\t * some specific response, so the trial to connect with server\n\t\t\t\t * is succeeded (with REJECT). By this reason, we don't want\n\t\t\t\t * to change the STATE by the failure.\n\t\t\t\t */\n\t\t\t\tIOT_WARN(\"Intended error case(reboot), go to STATE_UNKONWN\\n\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\tnext_state = IOT_STATE_UNKNOWN;\n\t\t\t} else if (err != IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"failed to iot_es_connect for communication\\n\");\n\n\t\t\t\tctx-\u003ecmd_err |= (1u \u003c\u003c cmd-\u003ecmd_type);\n\t\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\t\tstate_opt = ctx-\u003ereq_state;\n\t\t\t} else {\n\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTED;\n\t\t\t}\n\n\t\t\tIOT_MEM_CHECK(\"CLOUD_CONNECTTING DONE \u003e\u003ePT\u003c\u003c\");\n\n\t\t\terr = iot_state_update(ctx, next_state, state_opt);\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_NOTIFICATION_RECEIVED:\n\t\t\tnoti = (iot_noti_data_t *)cmd-\u003eparam;\n\t\t\tif (!noti) {\n\t\t\t\tIOT_ERROR(\"There is no noti handler\");\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tIOT_DUMP_MAIN(INFO, BASE, noti-\u003etype);\n\n\t\t\tif (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_DEV_DELETED) {\n\t\t\t\tif (ctx-\u003eusr_delete_req) {\n\t\t\t\t\tIOT_INFO(\"Device-card deleting is done\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EB);\n\n\t\t\t\t\tctx-\u003eusr_delete_req = false;\n\t\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eusr_events,\n\t\t\t\t\t\tIOT_USR_INTERACT_BIT_CMD_DONE);\n\t\t\t\t} else {\n\t\t\t\t\tIOT_INFO(\"cleanup device\");\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xC1EAC1EA);\n\n\t\t\t\t\tiot_device_cleanup(ctx);\n\t\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\n\t\t\t\t\tIOT_REBOOT();\n\t\t\t\t}\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_RATE_LIMIT) {\n\t\t\t\tIOT_INFO(\"rate limit\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD22222);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_QUOTA_REACHED) {\n\t\t\t\tIOT_INFO(\"quota reached\");\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0xBAD200BE);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_SEND_FAILED) {\n\t\t\t\tIOT_INFO(\"send failed seq number : %d\", noti-\u003eraw.send_fail.failed_sequence_num);\n\n\t\t\t\tif (ctx-\u003enoti_cb)\n\t\t\t\t\tctx-\u003enoti_cb(noti, ctx-\u003enoti_usr_data);\n\t\t\t} else if (noti-\u003etype == (iot_noti_type_t)_IOT_NOTI_TYPE_JWT_EXPIRED) {\n\t\t\t\tiot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\tif (iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION) != IOT_ERROR_NONE)\n                                    IOT_ERROR(\"failed to iot_es_connect for communication\");\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_CHANGE_STATE_TIMEOUT:\n\t\t\tstate_data = (struct iot_state_data *)cmd-\u003eparam;\n\t\t\tif (!state_data) {\n\t\t\t\tIOT_ERROR(\"There is no state_data for cmd :%d\", cmd-\u003ecmd_type);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((ctx-\u003ecurr_state == ctx-\u003ereq_state) || (state_data-\u003eiot_state != ctx-\u003ereq_state)) {\n\t\t\t\tIOT_INFO(\"Already iot-stat updated or mis-matched, can't change timeout : %d for %d\",\n\t\t\t\t\tstate_data-\u003eopt, state_data-\u003eiot_state);\n\t\t\t} else {\n\t\t\t\tIOT_INFO(\"We've got timemout changing cmd for %d\", state_data-\u003eiot_state);\n\t\t\t\tIOT_DUMP_MAIN(INFO, BASE, ((state_data-\u003eiot_state \u003c\u003c 8u) | state_data-\u003eopt));\n\t\t\t\t_do_update_timeout(ctx, (unsigned int)state_data-\u003eopt);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOT_COMMAND_SELF_CLEANUP:\n\t\t\tIOT_WARN(\"self device cleanup\");\n\t\t\tif (cmd-\u003eparam) {\n\t\t\t\treboot = (bool *)cmd-\u003eparam;\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, (int)*reboot);\n\t\t\t} else {\n\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0);\n\t\t\t}\n\n\t\t\tif (ctx-\u003ees_http_ready) {\n\t\t\t\tctx-\u003ees_http_ready = false;\n\t\t\t\tiot_easysetup_deinit(ctx);\n\t\t\t}\n\n\t\t\tif (ctx-\u003ees_res_created)\n\t\t\t\t_delete_easysetup_resources_all(ctx);\n\n\t\t\tiot_device_cleanup(ctx);\n\n\t\t\tif (reboot \u0026\u0026 *reboot) {\n\t\t\t\tIOT_REBOOT();\n\t\t\t} else {\n\t\t\t\terr = iot_state_update(ctx, IOT_STATE_UNKNOWN,\n\t\t\t\t\t\tIOT_STATE_OPT_CLEANUP);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tIOT_ERROR(\"Unsupported command(%d)\", cmd-\u003ecmd_type);\n\t\t\terr = IOT_ERROR_BAD_REQ;\n\t\t\tbreak;\n\t}\n\nout_do_cmd:\n\tif (err == IOT_ERROR_NONE || err == IOT_ERROR_DUPLICATED_CMD) {\n\t\t_clear_cmd_status(ctx, cmd-\u003ecmd_type);\n\t} else {\n\t\tIOT_ERROR(\"failed to handle cmd: %d\\n\", cmd-\u003ecmd_type);\n\t\tIOT_DUMP_MAIN_ARG2(ERROR, COMMAND, cmd-\u003ecmd_type, ctx-\u003ecurr_state);\n\t}\n\n\treturn err;\n}","filepath":"src/iot_main.c","line_number":482,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97127":{"score":0.87254643,"function_name":"_do_cmd_tout_check","code":"static void _do_cmd_tout_check(struct iot_context *ctx)\n{\n\tchar is_expired;\n\tiot_state_t next_state;\n\n\t/* If the iot-core is stayed in IOT_STATE_UNKNOWN,\n\t * we don't need to check timeout \u0026 condition\n\t */\n\tif ((ctx-\u003ecurr_state == IOT_STATE_UNKNOWN) \u0026\u0026\n\t\t\t(ctx-\u003ereq_state == IOT_STATE_UNKNOWN))\n\t\treturn;\n\n\t/* If device comes to connected_state, we don't need timeout checking */\n\tif (ctx-\u003ecurr_state == IOT_STATE_CLOUD_CONNECTED)\n\t\tis_expired = 0;\n\telse\n\t\tis_expired = iot_os_timer_isexpired(ctx-\u003estate_timer);\n\n\tif ((ctx-\u003ecurr_state != ctx-\u003ereq_state) || is_expired) {\n\t\tif (is_expired \u0026\u0026 !ctx-\u003ecmd_err) {\n\t\t\tIOT_WARN(\"New state changing timeout\");\n\t\t\tIOT_DUMP_MAIN(WARN, BASE, 0x8BADF00D);\n\n\t\t\tnext_state = IOT_STATE_CHANGE_FAILED;\n\t\t\tif (iot_state_update(ctx, next_state, ctx-\u003ereq_state)\n\t\t\t\t\t!= IOT_ERROR_NONE) {\n\t\t\t\tIOT_ERROR(\"Failed state error updated (%d/%d)\",\n\t\t\t\t\tctx-\u003ecurr_state, ctx-\u003ereq_state);\n\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, ctx-\u003ereq_state);\n\t\t\t}\n\t\t} else if (!ctx-\u003ecmd_status) {\n\t\t\t/* All command processes are done for req_state */\n\t\t\tif (!ctx-\u003ecmd_err) {\n\t\t\t\tIOT_INFO(\"New state updated for %d\", ctx-\u003ereq_state);\n\t\t\t\tctx-\u003ecurr_state = ctx-\u003ereq_state;\n\n\t\t\t\tif (ctx-\u003estatus_cb)\n\t\t\t\t\t_do_status_report(ctx, ctx-\u003ecurr_state, true);\n\t\t\t} else {\n\t\t\t\t/* Some command makes error, so do not update state */\n\t\t\t\tIOT_ERROR(\"Some cmd(0x%0x) failed for %d state\",\n\t\t\t\t\tctx-\u003ecmd_err, ctx-\u003ereq_state);\n\t\t\t}\n\t\t}\n\t}\n}","filepath":"src/iot_main.c","line_number":1008,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97588":{"score":0.8912151,"function_name":"_throw_away_all_cmd_queue","code":"static void _throw_away_all_cmd_queue(struct iot_context *ctx)\n{\n\tstruct iot_command cmd;\n\tenum iot_command_type cmd_type;\n\n\tif (!ctx) {\n\t\tIOT_ERROR(\"There is no ctx!!\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\treturn;\n\t}\n\n\tcmd.param = NULL;\n\twhile (iot_os_queue_receive(ctx-\u003ecmd_queue,\n\t\t\t\t\u0026cmd, 0) == IOT_OS_TRUE) {\n\t\t_clear_cmd_status(ctx, cmd.cmd_type);\n\t\tif (cmd.param) {\n\t\t\tfree(cmd.param);\n\t\t\tcmd.param = NULL;\n\t\t}\n\t}\n\n\tif (ctx-\u003ecmd_status) {\n\t\tIOT_WARN(\"There are unfinished cmds : 0x%x\", ctx-\u003ecmd_status);\n\t\tfor (cmd_type = IOT_COMMAND_READY_TO_CTL;\n\t\t\t\tcmd_type \u003c= IOT_COMMAND_TYPE_MAX; cmd_type++) {\n\t\t\tif (ctx-\u003ecmd_count[cmd_type]) {\n\t\t\t\tIOT_WARN(\"Remained cmd[%d] = %d\", cmd_type,\n\t\t\t\t\tctx-\u003ecmd_count[cmd_type]);\n\t\t\t\tctx-\u003ecmd_count[cmd_type] = 0;\n\t\t\t}\n\t\t}\n\t\tctx-\u003ecmd_status = 0;\n\t}\n}","filepath":"src/iot_main.c","line_number":1055,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"97990":{"score":0.91171783,"function_name":"_iot_main_task","code":"static void _iot_main_task(struct iot_context *ctx)\n{\n\tstruct iot_command cmd;\n\tunsigned char curr_events;\n\tiot_error_t err = IOT_ERROR_NONE;\n\tstruct iot_easysetup_payload easysetup_req;\n#if !defined(STDK_MQTT_TASK)\n\tiot_state_t next_state;\n\tunsigned int task_cycle = IOT_MAIN_TASK_DEFAULT_CYCLE;\n#endif\n\n\tfor( ; ; ) {\n#if defined(STDK_MQTT_TASK)\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_ALL, true, false, 500);\n#else\n\t\tcurr_events = iot_os_eventgroup_wait_bits(ctx-\u003eiot_events,\n\t\t\tIOT_EVENT_BIT_ALL, true, task_cycle);\n#endif\n\t\tif (curr_events \u0026 IOT_EVENT_BIT_COMMAND) {\n\t\t\tcmd.param = NULL;\n\n\t\t\tif (iot_os_mutex_lock(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE)\n\t\t\t\tcontinue;\n\n\t\t\tif (iot_os_queue_receive(ctx-\u003ecmd_queue,\n\t\t\t\t\t\u0026cmd, 0) != IOT_OS_FALSE) {\n\n\t\t\t\tIOT_DEBUG(\"cmd: %d\\n\", cmd.cmd_type);\n\n\t\t\t\terr = _do_iot_main_command(ctx, \u0026cmd);\n\t\t\t\tif (cmd.param)\n\t\t\t\t\tfree(cmd.param);\n\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"failed handle cmd (%d): %d\\n\", cmd.cmd_type, err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t}\n\n\t\t\t\t/* Set bit again to check whether the several cmds are already\n\t\t\t\t * stacked up in the queue.\n\t\t\t\t */\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_COMMAND);\n\t\t\t}\n\t\t\tiot_os_mutex_unlock(\u0026ctx-\u003eiot_cmd_lock);\n\t\t}\n\n\t\tif ((curr_events \u0026 IOT_EVENT_BIT_EASYSETUP_REQ) \u0026\u0026\n\t\t\t\t\t\tctx-\u003eeasysetup_req_queue) {\n\t\t\teasysetup_req.payload = NULL;\n\t\t\teasysetup_req.err = IOT_ERROR_NONE;\n\t\t\tif (iot_os_queue_receive(ctx-\u003eeasysetup_req_queue,\n\t\t\t\t\t\u0026easysetup_req, 0) != IOT_OS_FALSE) {\n\t\t\t\tIOT_DEBUG(\"request step: %d\\n\", easysetup_req.step);\n\n\t\t\t\terr = iot_easysetup_request_handler(ctx, easysetup_req);\n\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\tIOT_ERROR(\"failed handle easysetup request step %d: %d\\n\", easysetup_req.step, err);\n\t\t\t\t\tIOT_DUMP_MAIN(ERROR, BASE, err);\n\t\t\t\t} else {\n\t\t\t\t\t/* The SDK can't detect mobile's disconnecting after easy-setupcomplete\n\t\t\t\t\t * so to guarantee final msg sending to mobile before disconnecting\n\t\t\t\t\t * add some experiential delay after easy-setupcomplete\n\t\t\t\t\t */\n\t\t\t\t\tif (easysetup_req.step == IOT_EASYSETUP_STEP_SETUPCOMPLETE) {\n\t\t\t\t\t\tiot_os_delay(1000); /* delay for easysetup/httpd */\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* Set bit again to check whether the several cmds are already\n\t\t\t\t * stacked up in the queue.\n\t\t\t\t */\n\t\t\t\tiot_os_eventgroup_set_bits(ctx-\u003eiot_events, IOT_EVENT_BIT_EASYSETUP_REQ);\n\t\t\t}\n\t\t}\n\n#if !defined(STDK_MQTT_TASK)\n\t\t/* check if there is MQTT packet from GG */\n\t\ttask_cycle = IOT_MAIN_TASK_DEFAULT_CYCLE;\n\t\tif (ctx-\u003ereg_mqttcli) {\n\t\t\tint rc = st_mqtt_yield(ctx-\u003ereg_mqttcli, 0);\n\t\t\tif (rc \u003c 0) {\n\t\t\t\terr = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t\tif (err == IOT_ERROR_NONE) {\n\t\t\t\t\t/* Quickly try to connect without user notification fist */\n\t\t\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_REGISTRATION);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_WARN(\"Report Disconnected..\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_DISCONNECTED;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\n\t\t\t\t\t\tIOT_WARN(\"Try MQTT self re-registering..\\n\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_REGISTERING;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"REG disconnecting failed(%d) for mqtt_yield\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t}\n\t\t\t} else if (rc \u003e 0) {\n\t\t\t\ttask_cycle = 0;\n\t\t\t}\n\t\t} else if (ctx-\u003eevt_mqttcli) {\n\t\t\tint rc = st_mqtt_yield(ctx-\u003eevt_mqttcli, 0);\n\t\t\tif (rc \u003c 0) {\n\t\t\t\terr = iot_es_disconnect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\tif (err == IOT_ERROR_NONE) {\n\t\t\t\t\t/* Quickly try to connect without user notification first */\n\t\t\t\t\terr = iot_es_connect(ctx, IOT_CONNECT_TYPE_COMMUNICATION);\n\t\t\t\t\tif (err != IOT_ERROR_NONE) {\n\t\t\t\t\t\tIOT_WARN(\"Report Disconnected..\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_DISCONNECTED;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\n\t\t\t\t\t\tIOT_WARN(\"Try MQTT self re-connecting..\\n\");\n\t\t\t\t\t\tnext_state = IOT_STATE_CLOUD_CONNECTING;\n\t\t\t\t\t\terr = iot_state_update(ctx, next_state, 0);\n\t\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tIOT_WARN(\"COMM disconnecting failed(%d) for mqtt_yield\", err);\n\t\t\t\t\tIOT_DUMP_MAIN(WARN, BASE, err);\n\t\t\t\t}\n\t\t\t} else if (rc \u003e 0) {\n\t\t\t\ttask_cycle = 0;\n\t\t\t}\n\t\t}\n#endif\n\t\t_do_cmd_tout_check(ctx);\n\t}\n}","filepath":"src/iot_main.c","line_number":1090,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"},"99145":{"score":0.8591689,"function_name":"st_conn_init","code":"IOT_CTX* st_conn_init(unsigned char *onboarding_config, unsigned int onboarding_config_len,\n\t\t\t\t\tunsigned char *device_info, unsigned int device_info_len)\n{\n\tstruct iot_context *ctx = NULL;\n\tiot_error_t iot_err;\n\tstruct iot_devconf_prov_data *devconf_prov;\n\tstruct iot_device_info *dev_info;\n\n\tif (!onboarding_config || !device_info) {\n\t\tIOT_ERROR(\"invalid parameters\\n\");\n\t\treturn NULL;\n\t}\n\n\tctx = iot_os_malloc(sizeof(struct iot_context));\n\tif (!ctx) {\n\t\tIOT_ERROR(\"failed to malloc for iot_context\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* Initialize all values */\n\tmemset(ctx, 0, sizeof(struct iot_context));\n\n\tiot_err = iot_os_timer_init(\u0026ctx-\u003estate_timer);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to malloc for state_timer\\n\");\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\n\tiot_err = iot_os_timer_init(\u0026ctx-\u003erate_limit_timeout);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed to malloc for rate_limit_timeout\\n\");\n\t\tiot_os_timer_destroy(\u0026ctx-\u003estate_timer);\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\n\t// Initialize device nv section\n\tiot_err = iot_nv_init(device_info, device_info_len);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"NV init fail\");\n\t\tgoto error_main_bsp_init;\n\t}\n\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE)\n\t/* Initialize logging task */\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE_RAM_ONLY)\n\tiot_err = iot_log_file_init(RAM_ONLY);\n#elif defined(CONFIG_STDK_IOT_CORE_LOG_FILE_FLASH_WITH_RAM)\n\tiot_err = iot_log_file_init(FLASH_WITH_RAM);\n#else\n#error \"Need to choice STDK_IOT_CORE_LOG_FILE_TYPE first\"\n#endif\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"log file init fail\");\n\t\tgoto error_main_log_file_init;\n\t}\n#endif\n\n\t// Initialize device profile \u0026 device info\n\tdevconf_prov = \u0026(ctx-\u003edevconf);\n\tiot_err = iot_api_onboarding_config_load(onboarding_config, onboarding_config_len, devconf_prov);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed loading onboarding profile (%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto error_main_load_onboarding_config;\n\t}\n\n\tdev_info = \u0026(ctx-\u003edevice_info);\n\tiot_err = iot_api_device_info_load(device_info, device_info_len, dev_info);\n\tif (iot_err != IOT_ERROR_NONE) {\n\t\tIOT_ERROR(\"failed loading device info (%d)\", iot_err);\n\t\tIOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\t\tgoto error_main_load_device_info;\n\t}\n\n    // Initialize Wi-Fi\n    iot_err = iot_bsp_wifi_init();\n    if (iot_err != IOT_ERROR_NONE) {\n        IOT_ERROR(\"failed to init iot_bsp_wifi_init (%d)\", iot_err);\n        IOT_DUMP_MAIN(ERROR, BASE, iot_err);\n\n        iot_api_device_info_mem_free(dev_info);\n        goto error_main_load_device_info;\n    }\n\n\t/* create queue */\n\tctx-\u003ecmd_queue = iot_os_queue_create(IOT_QUEUE_LENGTH,\n\t\t\tsizeof(struct iot_command));\n\n\tif (!ctx-\u003ecmd_queue) {\n\t\tIOT_ERROR(\"failed to create Queue for iot core task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, IOT_QUEUE_LENGTH);\n\t\tgoto error_main_init_cmd_q;\n\t}\n\n\t/* create msg queue for IOT_STATE */\n\tctx-\u003eusr_events = iot_os_eventgroup_create();\n\tif (!ctx-\u003eusr_events) {\n\t\tIOT_ERROR(\"failed to create EventGroup for usr_events\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_init_usr_evts;\n\t}\n\n\t/* create msg eventgroup for each queue handling */\n\tctx-\u003eiot_events = iot_os_eventgroup_create();\n\tif (!ctx-\u003eiot_events) {\n\t\tIOT_ERROR(\"failed to create EventGroup for iot_task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_init_events;\n\t}\n\n\tctx-\u003eiot_reg_data.new_reged = false;\n\tctx-\u003ecurr_state = ctx-\u003ereq_state = IOT_STATE_UNKNOWN;\n\n\t/* create mutex for iot-core's command handling */\n\tif (iot_os_mutex_init(\u0026ctx-\u003eiot_cmd_lock) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to init iot_cmd_lock\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_cmd_mutex_init;\n\t}\n\n\t/* create mutex for user level st_conn_xxx APIs */\n\tif (iot_os_mutex_init(\u0026ctx-\u003est_conn_lock) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to init st_conn_lock\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, 0xDEADBEEF);\n\t\tgoto error_main_conn_mutex_init;\n\t}\n\n\t/* create task */\n\tif (iot_os_thread_create(_iot_main_task, IOT_TASK_NAME,\n\t\t\tIOT_TASK_STACK_SIZE, (void *)ctx, IOT_TASK_PRIORITY,\n\t\t\t\u0026ctx-\u003emain_thread) != IOT_OS_TRUE) {\n\t\tIOT_ERROR(\"failed to create iot_task\\n\");\n\t\tIOT_DUMP_MAIN(ERROR, BASE, IOT_TASK_STACK_SIZE);\n\t\tgoto error_main_task_init;\n\t}\n\n\tIOT_MEM_CHECK(\"MAIN_INIT_ALL_DONE \u003e\u003ePT\u003c\u003c\");\n\n#ifdef VER_EXTRA_STR\n\tIOT_INFO(\"stdk_version : %d.%d.%d-%s\",\n\t\tVER_MAJOR, VER_MINOR, VER_PATCH, VER_EXTRA_STR);\n#else\n\tIOT_INFO(\"stdk_version : %s\", STDK_VERSION_STRING);\n#endif\n\n\tIOT_DUMP_MAIN(INFO, BASE, STDK_VERSION_CODE);\n\n\treturn (IOT_CTX*)ctx;\n\nerror_main_task_init:\n\tiot_os_mutex_destroy(\u0026ctx-\u003est_conn_lock);\n\nerror_main_conn_mutex_init:\n\tiot_os_mutex_destroy(\u0026ctx-\u003eiot_cmd_lock);\n\nerror_main_cmd_mutex_init:\n\tiot_os_eventgroup_delete(ctx-\u003eiot_events);\n\nerror_main_init_events:\n\tiot_os_eventgroup_delete(ctx-\u003eusr_events);\n\nerror_main_init_usr_evts:\n\tiot_os_queue_delete(ctx-\u003ecmd_queue);\n\nerror_main_init_cmd_q:\n\tiot_api_device_info_mem_free(dev_info);\n\nerror_main_load_device_info:\n\tiot_api_onboarding_config_mem_free(devconf_prov);\n\nerror_main_load_onboarding_config:\n#if defined(CONFIG_STDK_IOT_CORE_LOG_FILE)\n\tiot_log_file_exit();\n\nerror_main_log_file_init:\n#endif\n\tiot_nv_deinit();\n\nerror_main_bsp_init:\n\tiot_os_timer_destroy(\u0026ctx-\u003erate_limit_timeout);\n\tiot_os_timer_destroy(\u0026ctx-\u003estate_timer);\n\tfree(ctx);\n\n\treturn NULL;\n}","filepath":"src/iot_main.c","line_number":1225,"entry_url":"https://github.com/SmartThingsCommunity/st-device-sdk-c.git","slot_name":"v1.7.0"}}}