{"file_sha256":"33ead107e7a01e9eb3432baebe14172ae6fe94ce62f41afad9f884e7c9b5dfe7","base_addr":4194304,"functions":{"4618368":{"score":0.5941385,"function_name":"xmrig::NetworkState::onActive","code":"void xmrig::NetworkState::onActive(IClient *client)\n{\n    snprintf(pool, sizeof(pool) - 1, \"%s:%d\", client-\u003epool().host().data(), client-\u003epool().port());\n\n    m_ip             = client-\u003eip();\n    m_tls            = client-\u003etlsVersion();\n    m_fingerprint    = client-\u003etlsFingerprint();\n    m_active         = true;\n    m_connectionTime = Chrono::steadyMSecs();\n}","filepath":"src/net/NetworkState.cpp","line_number":101,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.4-beta"},"4618448":{"score":0.83344436,"function_name":"xmrig::NetworkState::stop","code":"void xmrig::NetworkState::stop()\n{\n    m_active      = false;\n    diff          = 0;\n    m_ip          = nullptr;\n    m_tls         = nullptr;\n    m_fingerprint = nullptr;\n\n    failures++;\n    m_latency.clear();\n}","filepath":"src/net/NetworkState.cpp","line_number":113,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.4-beta"},"4618496":{"score":0.71867,"function_name":"xmrig::NetworkState::latency","code":"uint32_t xmrig::NetworkState::latency() const\n{\n    const size_t calls = m_latency.size();\n    if (calls == 0) {\n        return 0;\n    }\n\n    auto v = m_latency;\n    std::nth_element(v.begin(), v.begin() + calls / 2, v.end());\n\n    return v[calls / 2];\n}","filepath":"src/net/NetworkState.cpp","line_number":61,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.4-beta"},"4619264":{"score":0.87081265,"function_name":"xmrig::NetworkState::add","code":"void xmrig::NetworkState::add(const SubmitResult \u0026result, const char *error)\n{\n    if (error) {\n        rejected++;\n        return;\n    }\n\n    accepted++;\n    total += result.diff;\n\n    const size_t ln = topDiff.size() - 1;\n    if (result.actualDiff \u003e topDiff[ln]) {\n        topDiff[ln] = result.actualDiff;\n        std::sort(topDiff.rbegin(), topDiff.rend());\n    }\n\n    m_latency.push_back(result.elapsed \u003e 0xFFFF ? 0xFFFF : static_cast\u003cuint16_t\u003e(result.elapsed));\n}","filepath":"src/net/NetworkState.cpp","line_number":81,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.4-beta"},"4621504":{"score":0.7879153,"function_name":"App::~App","code":"App::~App()\n{\n    uv_tty_reset_mode();\n\n    delete m_console;\n    delete m_controller;\n\n#   ifndef XMRIG_NO_HTTPD\n    delete m_httpd;\n#   endif\n}","filepath":"src/App.cpp","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4621680":{"score":0.74590206,"function_name":"App::onSignal","code":"void App::onSignal(uv_signal_t *handle, int signum)\n{\n    switch (signum)\n    {\n    case SIGHUP:\n        LOG_WARN(\"SIGHUP received, exiting\");\n        break;\n\n    case SIGTERM:\n        LOG_WARN(\"SIGTERM received, exiting\");\n        break;\n\n    case SIGINT:\n        LOG_WARN(\"SIGINT received, exiting\");\n        break;\n\n    default:\n        break;\n    }\n\n    uv_signal_stop(handle);\n    m_self-\u003eclose();\n}","filepath":"src/App.cpp","line_number":187,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4621920":{"score":0.876514,"function_name":"App::onConsoleCommand","code":"void App::onConsoleCommand(char command)\n{\n    switch (command) {\n    case 'h':\n    case 'H':\n        Workers::printHashrate(true);\n        break;\n\n    case 'p':\n    case 'P':\n        if (Workers::isEnabled()) {\n            LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;33mpaused\\x1B[0m, press \\x1B[01;35mr\\x1B[0m to resume\" : \"paused, press 'r' to resume\");\n            Workers::setEnabled(false);\n        }\n        break;\n\n    case 'r':\n    case 'R':\n        if (!Workers::isEnabled()) {\n            LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;32mresumed\" : \"resumed\");\n            Workers::setEnabled(true);\n        }\n        break;\n\n    case 3:\n        LOG_WARN(\"Ctrl+C received, exiting\");\n        close();\n        break;\n\n    default:\n        break;\n    }\n}","filepath":"src/App.cpp","line_number":138,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4622336":{"score":0.8641303,"function_name":"App::App","code":"App::App(int argc, char **argv) :\n    m_console(nullptr),\n    m_httpd(nullptr)\n{\n    m_self = this;\n\n    m_controller = new xmrig::Controller();\n    if (m_controller-\u003einit(argc, argv) != 0) {\n        return;\n    }\n\n    if (!m_controller-\u003econfig()-\u003eisBackground()) {\n        m_console = new Console(this);\n    }\n\n    uv_signal_init(uv_default_loop(), \u0026m_sigHUP);\n    uv_signal_init(uv_default_loop(), \u0026m_sigINT);\n    uv_signal_init(uv_default_loop(), \u0026m_sigTERM);\n}","filepath":"src/App.cpp","line_number":54,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4622576":{"score":0.8535839,"function_name":"App::exec","code":"int App::exec()\n{\n    if (!m_controller-\u003eisReady()) {\n        return 2;\n    }\n\n    uv_signal_start(\u0026m_sigHUP,  App::onSignal, SIGHUP);\n    uv_signal_start(\u0026m_sigINT,  App::onSignal, SIGINT);\n    uv_signal_start(\u0026m_sigTERM, App::onSignal, SIGTERM);\n\n    background();\n\n    Mem::init(m_controller-\u003econfig()-\u003eisHugePages());\n\n    Summary::print(m_controller);\n\n    if (m_controller-\u003econfig()-\u003eisDryRun()) {\n        LOG_NOTICE(\"OK\");\n        release();\n\n        return 0;\n    }\n\n#   ifndef XMRIG_NO_API\n    Api::start(m_controller);\n#   endif\n\n#   ifndef XMRIG_NO_HTTPD\n    m_httpd = new Httpd(\n                m_controller-\u003econfig()-\u003eapiPort(),\n                m_controller-\u003econfig()-\u003eapiToken(),\n                m_controller-\u003econfig()-\u003eisApiIPv6(),\n                m_controller-\u003econfig()-\u003eisApiRestricted()\n                );\n\n    m_httpd-\u003estart();\n#   endif\n\n    Workers::start(m_controller);\n\n    m_controller-\u003enetwork()-\u003econnect();\n\n    const int r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n    uv_loop_close(uv_default_loop());\n\n    release();\n    return r;\n}","filepath":"src/App.cpp","line_number":88,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4623104":{"score":0.9248942,"function_name":"xmrig::CommonConfig::parseBoolean","code":"bool xmrig::CommonConfig::parseBoolean(int key, bool enable)\n{\n    switch (key) {\n    case BackgroundKey: /* --background */\n        m_background = enable;\n        break;\n\n    case SyslogKey: /* --syslog */\n        m_syslog = enable;\n        break;\n\n    case KeepAliveKey: /* --keepalive */\n        m_pools.back().setKeepAlive(enable ? Pool::kKeepAliveTimeout : 0);\n        break;\n\n    case TlsKey: /* --tls */\n        m_pools.back().setTLS(enable);\n        break;\n\n#   ifndef XMRIG_PROXY_PROJECT\n    case NicehashKey: /* --nicehash */\n        m_pools.back().setNicehash(enable);\n        break;\n#   endif\n\n    case ColorKey: /* --no-color */\n        m_colors = enable;\n        break;\n\n    case WatchKey: /* watch */\n        m_watch = enable;\n        break;\n\n    case ApiIPv6Key: /* ipv6 */\n        m_apiIPv6 = enable;\n        break;\n\n    case ApiRestrictedKey: /* restricted */\n        m_apiRestricted = enable;\n        break;\n\n    case DryRunKey: /* --dry-run */\n        m_dryRun = enable;\n        break;\n\n    case AutoSaveKey:\n        m_autoSave = enable;\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":271,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4623648":{"score":0.68095434,"function_name":"xmrig::CommonConfig::printAPI","code":"void xmrig::CommonConfig::printAPI()\n{\n#   ifndef XMRIG_NO_API\n    if (apiPort() == 0) {\n        return;\n    }\n\n    Log::i()-\u003etext(isColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13s\") CYAN(\"%s:\") CYAN_BOLD(\"%d\")\n                              : \" * %-13s%s:%d\",\n                   \"API BIND\", isApiIPv6() ? \"[::]\" : \"0.0.0.0\", apiPort());\n#   endif\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":98,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4623792":{"score":0.8664603,"function_name":"xmrig::CommonConfig::printPools","code":"void xmrig::CommonConfig::printPools()\n{\n    for (size_t i = 0; i \u003c m_activePools.size(); ++i) {\n        if (!isColors()) {\n            Log::i()-\u003etext(\" * POOL #%-7zu%s variant=%s, TLS=%d\",\n                           i + 1,\n                           m_activePools[i].url(),\n                           m_activePools[i].algorithm().variantName(),\n                           static_cast\u003cint\u003e(m_activePools[i].isTLS())\n                           );\n        }\n        else {\n            Log::i()-\u003etext(GREEN_BOLD(\" * \") WHITE_BOLD(\"POOL #%-7zu\") \"\\x1B[1;%dm%s\\x1B[0m variant \" WHITE_BOLD(\"%s\"),\n                           i + 1,\n                           m_activePools[i].isTLS() ? 32 : 36,\n                           m_activePools[i].url(),\n                           m_activePools[i].algorithm().variantName()\n                           );\n        }\n    }\n\n#   ifdef APP_DEBUG\n    LOG_NOTICE(\"POOLS --------------------------------------------------------------------\");\n    for (const Pool \u0026pool : m_activePools) {\n        pool.print();\n    }\n    LOG_NOTICE(\"--------------------------------------------------------------------------\");\n#   endif\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":112,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4624144":{"score":0.77570784,"function_name":"xmrig::CommonConfig::printVersions","code":"void xmrig::CommonConfig::printVersions()\n{\n    char buf[256] = { 0 };\n\n#   if defined(__clang__)\n    snprintf(buf, sizeof buf, \"clang/%d.%d.%d\", __clang_major__, __clang_minor__, __clang_patchlevel__);\n#   elif defined(__GNUC__)\n    snprintf(buf, sizeof buf, \"gcc/%d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   elif defined(_MSC_VER)\n    snprintf(buf, sizeof buf, \"MSVC/%d\", MSVC_VERSION);\n#   endif\n\n    Log::i()-\u003etext(isColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13s\") CYAN_BOLD(\"%s/%s\") WHITE_BOLD(\" %s\")\n                              : \" * %-13s%s/%s %s\",\n                   \"ABOUT\", APP_NAME, APP_VERSION, buf);\n\n#   if defined(XMRIG_AMD_PROJECT)\n#   if CL_VERSION_2_0\n    const char *ocl = \"2.0\";\n#   elif CL_VERSION_1_2\n    const char *ocl = \"1.2\";\n#   elif CL_VERSION_1_1\n    const char *ocl = \"1.1\";\n#   elif CL_VERSION_1_0\n    const char *ocl = \"1.0\";\n#   else\n    const char *ocl = \"0.0\";\n#   endif\n    int length = snprintf(buf, sizeof buf, \"OpenCL/%s \", ocl);\n#   elif defined(XMRIG_NVIDIA_PROJECT)\n    const int cudaVersion = cuda_get_runtime_version();\n    int length = snprintf(buf, sizeof buf, \"CUDA/%d.%d \", cudaVersion / 1000, cudaVersion % 100);\n#   else\n    memset(buf, 0, 16);\n    int length = 0;\n#   endif\n\n#   if !defined(XMRIG_NO_TLS) \u0026\u0026 defined(OPENSSL_VERSION_TEXT)\n    {\n        constexpr const char *v = OPENSSL_VERSION_TEXT + 8;\n        length += snprintf(buf + length, (sizeof buf) - length, \"OpenSSL/%.*s \", static_cast\u003cint\u003e(strchr(v, ' ') - v), v);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_HTTPD\n    length += snprintf(buf + length, (sizeof buf) - length, \"microhttpd/%s \", MHD_get_version());\n#   endif\n\n    Log::i()-\u003etext(isColors() ? GREEN_BOLD(\" * \") WHITE_BOLD(\"%-13slibuv/%s %s\")\n                              : \" * %-13slibuv/%s %s\",\n                   \"LIBS\", uv_version_string(), buf);\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":143,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4624576":{"score":0.92916894,"function_name":"xmrig::CommonConfig::parseInt","code":"bool xmrig::CommonConfig::parseInt(int key, int arg)\n{\n    switch (key) {\n    case RetriesKey: /* --retries */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 1000) {\n            m_retries = arg;\n        }\n        break;\n\n    case RetryPauseKey: /* --retry-pause */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 3600) {\n            m_retryPause = arg;\n        }\n        break;\n\n    case KeepAliveKey: /* --keepalive */\n        m_pools.back().setKeepAlive(arg);\n        break;\n\n    case VariantKey: /* --variant */\n        m_pools.back().algorithm().parseVariant(arg);\n        break;\n\n    case DonateLevelKey: /* --donate-level */\n        if (arg \u003e= kMinimumDonateLevel \u0026\u0026 arg \u003c= 99) {\n            m_donateLevel = arg;\n        }\n        break;\n\n    case ApiPort: /* --api-port */\n        if (arg \u003e 0 \u0026\u0026 arg \u003c= 65536) {\n            m_apiPort = arg;\n        }\n        break;\n\n    case PrintTimeKey: /* --print-time */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c= 3600) {\n            m_printTime = arg;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":449,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4624800":{"score":0.7253963,"function_name":"xmrig::CommonConfig::parseString","code":"bool xmrig::CommonConfig::parseString(int key, const char *arg)\n{\n    switch (key) {\n    case AlgorithmKey: /* --algo */\n        m_algorithm.parseAlgorithm(arg);\n        break;\n\n    case UserpassKey: /* --userpass */\n        if (!m_pools.back().setUserpass(arg)) {\n            return false;\n        }\n\n        break;\n\n    case UrlKey: /* --url */\n        if (m_pools.size() \u003e 1 || m_pools[0].isValid()) {\n            Pool pool(arg);\n\n            if (pool.isValid()) {\n                m_pools.push_back(std::move(pool));\n            }\n        }\n        else {\n            m_pools[0].parse(arg);\n        }\n\n        if (!m_pools.back().isValid()) {\n            return false;\n        }\n\n        break;\n\n    case UserKey: /* --user */\n        m_pools.back().setUser(arg);\n        break;\n\n    case PasswordKey: /* --pass */\n        m_pools.back().setPassword(arg);\n        break;\n\n    case RigIdKey: /* --rig-id */\n        m_pools.back().setRigId(arg);\n        break;\n\n    case FingerprintKey: /* --tls-fingerprint */\n        m_pools.back().setFingerprint(arg);\n        break;\n\n    case VariantKey: /* --variant */\n        m_pools.back().algorithm().parseVariant(arg);\n        break;\n\n    case LogFileKey: /* --log-file */\n        m_logFile = arg;\n        break;\n\n    case ApiAccessTokenKey: /* --api-access-token */\n        m_apiToken = arg;\n        break;\n\n    case ApiWorkerIdKey: /* --api-worker-id */\n        m_apiWorkerId = arg;\n        break;\n\n    case ApiIdKey: /* --api-id */\n        m_apiId = arg;\n        break;\n\n    case UserAgentKey: /* --user-agent */\n        m_userAgent = arg;\n        break;\n\n    case RetriesKey:     /* --retries */\n    case RetryPauseKey:  /* --retry-pause */\n    case ApiPort:        /* --api-port */\n    case PrintTimeKey:   /* --cpu-priority */\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    case BackgroundKey: /* --background */\n    case SyslogKey:     /* --syslog */\n    case KeepAliveKey:  /* --keepalive */\n    case NicehashKey:   /* --nicehash */\n    case TlsKey:        /* --tls */\n    case ApiIPv6Key:    /* --api-ipv6 */\n    case DryRunKey:     /* --dry-run */\n        return parseBoolean(key, true);\n\n    case ColorKey:         /* --no-color */\n    case WatchKey:         /* --no-watch */\n    case ApiRestrictedKey: /* --api-no-restricted */\n        return parseBoolean(key, false);\n\n    case DonateLevelKey: /* --donate-level */\n#       ifdef XMRIG_PROXY_PROJECT\n        if (strncmp(arg, \"minemonero.pro\", 14) == 0) {\n            m_donateLevel = 0;\n            return true;\n        }\n#       endif\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":328,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4627232":{"score":0.85609066,"function_name":"xmrig::CommonConfig::finalize","code":"bool xmrig::CommonConfig::finalize()\n{\n    if (m_state == ReadyState) {\n        return true;\n    }\n\n    if (m_state == ErrorState) {\n        return false;\n    }\n\n    if (!m_algorithm.isValid()) {\n        return false;\n    }\n\n    for (Pool \u0026pool : m_pools) {\n        pool.adjust(m_algorithm);\n\n        if (pool.isValid() \u0026\u0026 pool.algorithm().isValid()) {\n#           ifdef XMRIG_NO_TLS\n            if (pool.isTLS()) {\n                continue;\n            }\n#           endif\n\n            m_activePools.push_back(std::move(pool));\n        }\n    }\n\n    m_pools.clear();\n\n    if (m_activePools.empty()) {\n        m_state = ErrorState;\n        return false;\n    }\n\n    m_state = ReadyState;\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":231,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4627808":{"score":0.86007154,"function_name":"xmrig::CommonConfig::CommonConfig","code":"xmrig::CommonConfig::CommonConfig() :\n    m_algorithm(CRYPTONIGHT, VARIANT_AUTO),\n    m_adjusted(false),\n    m_apiIPv6(false),\n    m_apiRestricted(true),\n    m_autoSave(true),\n    m_background(false),\n    m_colors(true),\n    m_dryRun(false),\n    m_syslog(false),\n\n#   ifdef XMRIG_PROXY_PROJECT\n    m_watch(true),\n#   else\n    m_watch(false), // TODO: enable config file watch by default when this feature propertly handled and tested.\n#   endif\n\n    m_apiPort(0),\n    m_donateLevel(kDefaultDonateLevel),\n    m_printTime(60),\n    m_retries(5),\n    m_retryPause(5),\n    m_state(NoneState)\n{\n    m_pools.push_back(Pool());\n\n#   ifdef XMRIG_PROXY_PROJECT\n    m_retries    = 2;\n    m_retryPause = 1;\n#   endif\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":65,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4628432":{"score":0.86888444,"function_name":"xmrig::CommonConfig::save","code":"bool xmrig::CommonConfig::save()\n{\n    if (m_fileName.isNull()) {\n        return false;\n    }\n\n    uv_fs_t req;\n    const int fd = uv_fs_open(uv_default_loop(), \u0026req, m_fileName.data(), O_WRONLY | O_CREAT | O_TRUNC, 0644, nullptr);\n    if (fd \u003c 0) {\n        return false;\n    }\n\n    uv_fs_req_cleanup(\u0026req);\n\n    rapidjson::Document doc;\n    getJSON(doc);\n\n    FILE *fp = fdopen(fd, \"w\");\n\n    char buf[4096];\n    rapidjson::FileWriteStream os(fp, buf, sizeof(buf));\n    rapidjson::PrettyWriter\u003crapidjson::FileWriteStream\u003e writer(os);\n    doc.Accept(writer);\n\n    fclose(fp);\n\n    uv_fs_close(uv_default_loop(), \u0026req, fd, nullptr);\n    uv_fs_req_cleanup(\u0026req);\n\n    LOG_NOTICE(\"configuration saved to: \\\"%s\\\"\", m_fileName.data());\n    return true;\n}","filepath":"src/common/config/CommonConfig.cpp","line_number":197,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.8.0-rc"},"4643872":{"score":0.6423423,"function_name":"xmrig::ConfigLoader::parseJSON","code":"void xmrig::ConfigLoader::parseJSON(xmrig::IConfig *config, const struct option *option, const rapidjson::Value \u0026object)\n{\n    if (!option-\u003ename || !object.HasMember(option-\u003ename)) {\n        return;\n    }\n\n    const rapidjson::Value \u0026value = object[option-\u003ename];\n\n    if (option-\u003ehas_arg) {\n        if (value.IsString()) {\n            config-\u003eparseString(option-\u003eval, value.GetString());\n        }\n        else if (value.IsInt64()) {\n            config-\u003eparseUint64(option-\u003eval, value.GetUint64());\n        }\n        else if (value.IsBool()) {\n            config-\u003eparseBoolean(option-\u003eval, value.IsTrue());\n        }\n    }\n    else if (value.IsBool()) {\n        config-\u003eparseBoolean(option-\u003eval, value.IsTrue());\n    }\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":259,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4646000":{"score":0.725482,"function_name":"xmrig::ConfigLoader::showVersion","code":"void xmrig::ConfigLoader::showVersion()\n{\n    printf(APP_NAME \" \" APP_VERSION \"\\n built on \" __DATE__\n\n#   if defined(__clang__)\n    \" with clang \" __clang_version__);\n#   elif defined(__GNUC__)\n    \" with GCC\");\n    printf(\" %d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   elif defined(_MSC_VER)\n    \" with MSVC\");\n    printf(\" %d\", MSVC_VERSION);\n#   else\n    );\n#   endif\n\n    printf(\"\\n features:\"\n#   if defined(__i386__) || defined(_M_IX86)\n    \" 32-bit\"\n#   elif defined(__x86_64__) || defined(_M_AMD64)\n    \" 64-bit\"\n#   endif\n\n#   if defined(__AES__) || defined(_MSC_VER)\n    \" AES\"\n#   endif\n    \"\\n\");\n\n    printf(\"\\nlibuv/%s\\n\", uv_version_string());\n\n#   ifndef XMRIG_NO_HTTPD\n    printf(\"microhttpd/%s\\n\", MHD_get_version());\n#   endif\n\n#   if !defined(XMRIG_NO_TLS) \u0026\u0026 defined(OPENSSL_VERSION_TEXT)\n    {\n        constexpr const char *v = OPENSSL_VERSION_TEXT + 8;\n        printf(\"OpenSSL/%.*s\\n\", static_cast\u003cint\u003e(strchr(v, ' ') - v), v);\n    }\n#   endif\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":290,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4648448":{"score":0.7280814,"function_name":"xmrig::ConfigLoader::reload","code":"bool xmrig::ConfigLoader::reload(xmrig::IConfig *oldConfig, const char *json)\n{\n    xmrig::IConfig *config = m_creator-\u003ecreate();\n    if (!loadFromJSON(config, json)) {\n        delete config;\n\n        return false;\n    }\n\n    config-\u003esetFileName(oldConfig-\u003efileName());\n    const bool saved = config-\u003esave();\n\n    if (config-\u003eisWatch() \u0026\u0026 m_watcher \u0026\u0026 saved) {\n        delete config;\n\n        return true;\n    }\n\n    m_listener-\u003eonNewConfig(config);\n    return true;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":121,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4648784":{"score":0.7383157,"function_name":"xmrig::ConfigLoader::getJSON","code":"bool xmrig::ConfigLoader::getJSON(const char *fileName, rapidjson::Document \u0026doc)\n{\n    uv_fs_t req;\n    const int fd = uv_fs_open(uv_default_loop(), \u0026req, fileName, O_RDONLY, 0644, nullptr);\n    if (fd \u003c 0) {\n        fprintf(stderr, \"unable to open %s: %s\\n\", fileName, uv_strerror(fd));\n        return false;\n    }\n\n    uv_fs_req_cleanup(\u0026req);\n\n    FILE *fp = fdopen(fd, \"rb\");\n    char buf[8192];\n    rapidjson::FileReadStream is(fp, buf, sizeof(buf));\n\n    doc.ParseStream(is);\n\n    uv_fs_close(uv_default_loop(), \u0026req, fd, nullptr);\n    uv_fs_req_cleanup(\u0026req);\n\n    if (doc.HasParseError()) {\n        printf(\"%s\u003c%d\u003e: %s\\n\", fileName, (int) doc.GetErrorOffset(), rapidjson::GetParseError_En(doc.GetParseError()));\n        return false;\n    }\n\n    return doc.IsObject();\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":207,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4649632":{"score":0.6517788,"function_name":"xmrig::ConfigLoader::loadFromFile","code":"bool xmrig::ConfigLoader::loadFromFile(xmrig::IConfig *config, const char *fileName)\n{\n    rapidjson::Document doc;\n    if (!getJSON(fileName, doc)) {\n        return false;\n    }\n\n    config-\u003esetFileName(fileName);\n\n    return loadFromJSON(config, doc);\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":63,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4650032":{"score":0.6672779,"function_name":"xmrig::ConfigLoader::parseArg","code":"bool xmrig::ConfigLoader::parseArg(xmrig::IConfig *config, int key, const char *arg)\n{\n    switch (key) {\n    case xmrig::IConfig::VersionKey: /* --version */\n        showVersion();\n        return false;\n\n    case xmrig::IConfig::HelpKey: /* --help */\n        showUsage();\n        return false;\n\n    case xmrig::IConfig::ConfigKey: /* --config */\n        loadFromFile(config, arg);\n        break;\n\n    default:\n        return config-\u003eparseString(key, arg);;\n    }\n\n    return true;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":236,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4650288":{"score":0.6659717,"function_name":"xmrig::ConfigLoader::load","code":"xmrig::IConfig *xmrig::ConfigLoader::load(int argc, char **argv, IConfigCreator *creator, IWatcherListener *listener)\n{\n    m_creator  = creator;\n    m_listener = listener;\n\n    xmrig::IConfig *config = m_creator-\u003ecreate();\n    int key;\n\n    while (1) {\n        key = getopt_long(argc, argv, short_options, options, NULL);\n        if (key \u003c 0) {\n            break;\n        }\n\n        if (!parseArg(config, key, optarg)) {\n            delete config;\n            return nullptr;\n        }\n    }\n\n    if (optind \u003c argc) {\n        fprintf(stderr, \"%s: unsupported non-option argument '%s'\\n\", argv[0], argv[optind]);\n        delete config;\n        return nullptr;\n    }\n\n    if (!config-\u003efinalize()) {\n        delete config;\n\n        config = m_creator-\u003ecreate();\n        loadFromFile(config, Platform::defaultConfigName());\n    }\n\n    if (!config-\u003efinalize()) {\n        if (!config-\u003ealgorithm().isValid()) {\n            fprintf(stderr, \"No valid algorithm specified. Exiting.\\n\");\n        }\n        else {\n            fprintf(stderr, \"No valid configuration found. Exiting.\\n\");\n        }\n\n        delete config;\n        return nullptr;\n    }\n\n    if (config-\u003eisWatch()) {\n        m_watcher = new xmrig::ConfigWatcher(config-\u003efileName(), creator, listener);\n    }\n\n    return config;\n}","filepath":"src/common/config/ConfigLoader.cpp","line_number":144,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4684432":{"score":0.82640123,"function_name":"xmrig::Algorithm::parseAlgorithm","code":"void xmrig::Algorithm::parseAlgorithm(const char *algo)\n{\n    m_algo    = INVALID_ALGO;\n    m_variant = VARIANT_AUTO;\n\n    assert(algo != nullptr);\n    if (algo == nullptr) {\n        return;\n    }\n\n    for (size_t i = 0; i \u003c ARRAY_SIZE(algorithms); i++) {\n        if ((strcasecmp(algo, algorithms[i].name) == 0) || (strcasecmp(algo, algorithms[i].shortName) == 0)) {\n            m_algo    = algorithms[i].algo;\n            m_variant = algorithms[i].variant;\n            break;\n        }\n    }\n\n    if (m_algo == INVALID_ALGO) {\n        assert(false);\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4684592":{"score":0.55656004,"function_name":"xmrig::Algorithm::parseVariant","code":"void xmrig::Algorithm::parseVariant(const char *variant)\n{\n    m_variant = VARIANT_AUTO;\n\n    for (size_t i = 0; i \u003c ARRAY_SIZE(variants); i++) {\n        if (strcasecmp(variant, variants[i]) == 0) {\n            m_variant = static_cast\u003cVariant\u003e(i);\n            break;\n        }\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":165,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4684960":{"score":0.8014607,"function_name":"xmrig::Algorithm::parseVariant","code":"void xmrig::Algorithm::parseVariant(int variant)\n{\n    assert(variant \u003e= -1 \u0026\u0026 variant \u003c= 2);\n\n    switch (variant) {\n    case -1:\n    case 0:\n    case 1:\n        m_variant = static_cast\u003cVariant\u003e(variant);\n        break;\n\n    case 2:\n        m_variant = VARIANT_2;\n        break;\n\n    default:\n        break;\n    }\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":178,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4685024":{"score":0.821573,"function_name":"xmrig::Algorithm::name","code":"const char *xmrig::Algorithm::name(bool shortName) const\n{\n    for (size_t i = 0; i \u003c ARRAY_SIZE(algorithms); i++) {\n        if (algorithms[i].algo == m_algo \u0026\u0026 algorithms[i].variant == m_variant) {\n            return shortName ? algorithms[i].shortName : algorithms[i].name;\n        }\n    }\n\n    return \"invalid\";\n}","filepath":"src/common/crypto/Algorithm.cpp","line_number":231,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4693552":{"score":0.6738298,"function_name":"ConsoleLog::message","code":"void ConsoleLog::message(int level, const char* fmt, va_list args)\n{\n    time_t now = time(nullptr);\n    tm stime;\n\n#   ifdef _WIN32\n    localtime_s(\u0026stime, \u0026now);\n#   else\n    localtime_r(\u0026now, \u0026stime);\n#   endif\n\n    const char* color = nullptr;\n    const bool colors = m_controller-\u003econfig()-\u003eisColors();\n\n    if (colors) {\n        switch (level) {\n        case Log::ERR:\n            color = Log::kCL_RED;\n            break;\n\n        case Log::WARNING:\n            color = Log::kCL_YELLOW;\n            break;\n\n        case Log::NOTICE:\n            color = Log::kCL_WHITE;\n            break;\n\n        case Log::DEBUG:\n            color = Log::kCL_GRAY;\n            break;\n\n        default:\n            color = \"\";\n            break;\n        }\n    }\n\n    snprintf(m_fmt, sizeof(m_fmt) - 1, \"[%d-%02d-%02d %02d:%02d:%02d]%s %s%s\\n\",\n             stime.tm_year + 1900,\n             stime.tm_mon + 1,\n             stime.tm_mday,\n             stime.tm_hour,\n             stime.tm_min,\n             stime.tm_sec,\n             colors ? color : \"\",\n             fmt,\n             colors ? Log::kCL_N : \"\"\n        );\n\n    print(args);\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4693936":{"score":0.78382814,"function_name":"ConsoleLog::ConsoleLog","code":"ConsoleLog::ConsoleLog(xmrig::Controller *controller) :\n    m_stream(nullptr),\n    m_controller(controller)\n{\n    if (uv_tty_init(uv_default_loop(), \u0026m_tty, 1, 0) \u003c 0) {\n        controller-\u003econfig()-\u003esetColors(false);\n        return;\n    }\n\n    uv_tty_set_mode(\u0026m_tty, UV_TTY_MODE_NORMAL);\n    m_uvBuf.base = m_buf;\n    m_stream     = reinterpret_cast\u003cuv_stream_t*\u003e(\u0026m_tty);\n\n#   ifdef WIN32\n    HANDLE handle = GetStdHandle(STD_INPUT_HANDLE);\n    if (handle != INVALID_HANDLE_VALUE) {\n        DWORD mode = 0;\n        if (GetConsoleMode(handle, \u0026mode)) {\n           mode \u0026= ~ENABLE_QUICK_EDIT_MODE;\n           SetConsoleMode(handle, mode | ENABLE_EXTENDED_FLAGS);\n        }\n    }\n#   endif\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":43,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4694080":{"score":0.83811045,"function_name":"ConsoleLog::isWritable","code":"bool ConsoleLog::isWritable() const\n{\n    if (!m_stream || uv_is_writable(m_stream) != 1) {\n        return false;\n    }\n\n    const uv_handle_type type = uv_guess_handle(1);\n    return type == UV_TTY || type == UV_NAMED_PIPE;\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":131,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4694160":{"score":0.7108783,"function_name":"ConsoleLog::print","code":"void ConsoleLog::print(va_list args)\n{\n    m_uvBuf.len = vsnprintf(m_buf, sizeof(m_buf) - 1, m_fmt, args);\n    if (m_uvBuf.len \u003c= 0) {\n        return;\n    }\n\n    if (!isWritable()) {\n        fputs(m_buf, stdout);\n        fflush(stdout);\n    }\n    else {\n        uv_try_write(m_stream, \u0026m_uvBuf, 1);\n    }\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":142,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.1"},"4694432":{"score":0.78048736,"function_name":"ConsoleLog::message","code":"void ConsoleLog::message(Level level, const char* fmt, va_list args)\n{\n    time_t now = time(nullptr);\n    tm stime;\n\n#   ifdef _WIN32\n    localtime_s(\u0026stime, \u0026now);\n#   else\n    localtime_r(\u0026now, \u0026stime);\n#   endif\n\n    const bool isColors = m_controller-\u003econfig()-\u003eisColors();\n\n    snprintf(m_fmt, sizeof(m_fmt) - 1, \"[%d-%02d-%02d %02d:%02d:%02d]%s %s%s\",\n             stime.tm_year + 1900,\n             stime.tm_mon + 1,\n             stime.tm_mday,\n             stime.tm_hour,\n             stime.tm_min,\n             stime.tm_sec,\n             Log::colorByLevel(level, isColors),\n             fmt,\n             Log::endl(isColors)\n        );\n\n    print(args);\n}","filepath":"src/common/log/ConsoleLog.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4695232":{"score":0.9184691,"function_name":"xmrig::Log::message","code":"void xmrig::Log::message(ILogBackend::Level level, const char* fmt, ...)\n{\n    uv_mutex_lock(\u0026m_mutex);\n\n    va_list args;\n    va_list copy;\n    va_start(args, fmt);\n\n    for (ILogBackend *backend : m_backends) {\n        va_copy(copy, args);\n        backend-\u003emessage(level, fmt, copy);\n        va_end(copy);\n    }\n\n    va_end(args);\n\n    uv_mutex_unlock(\u0026m_mutex);\n}","filepath":"src/common/log/Log.cpp","line_number":59,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4695536":{"score":0.9185508,"function_name":"xmrig::Log::text","code":"void xmrig::Log::text(const char* fmt, ...)\n{\n    uv_mutex_lock(\u0026m_mutex);\n\n    va_list args;\n    va_list copy;\n    va_start(args, fmt);\n\n    for (ILogBackend *backend : m_backends) {\n        va_copy(copy, args);\n        backend-\u003etext(fmt, copy);\n        va_end(copy);\n    }\n\n    va_end(args);\n\n    uv_mutex_unlock(\u0026m_mutex);\n}","filepath":"src/common/log/Log.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4695872":{"score":0.8815645,"function_name":"xmrig::Log::endl","code":"const char *xmrig::Log::endl(bool isColors)\n{\n#   ifdef _WIN32\n    return isColors ? \"\\x1B[0m\\r\\n\" : \"\\r\\n\";\n#   else\n    return isColors ? \"\\x1B[0m\\n\" : \"\\n\";\n#   endif\n}","filepath":"src/common/log/Log.cpp","line_number":109,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"4696432":{"score":0.6371572,"function_name":"Client::onAllocBuffer","code":"void Client::onAllocBuffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf)\n{\n    auto client = getClient(handle-\u003edata);\n    if (!client) {\n        return;\n    }\n\n    buf-\u003ebase = \u0026client-\u003em_recvBuf.base[client-\u003em_recvBufPos];\n    buf-\u003elen  = client-\u003em_recvBuf.len - client-\u003em_recvBufPos;\n}","filepath":"src/common/net/Client.cpp","line_number":874,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4697200":{"score":0.7709916,"function_name":"Client::close","code":"bool Client::close()\n{\n    if (m_state == ClosingState) {\n        return m_socket != nullptr;\n    }\n\n    if (m_state == UnconnectedState || m_socket == nullptr) {\n        return false;\n    }\n\n    setState(ClosingState);\n\n    if (uv_is_closing(reinterpret_cast\u003cuv_handle_t*\u003e(m_socket)) == 0) {\n        uv_close(reinterpret_cast\u003cuv_handle_t*\u003e(m_socket), Client::onClose);\n    }\n\n    return true;\n}","filepath":"src/common/net/Client.cpp","line_number":260,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4697344":{"score":0.9695646,"function_name":"Client::isCriticalError","code":"bool Client::isCriticalError(const char *message)\n{\n    if (!message) {\n        return false;\n    }\n\n    if (strncasecmp(message, \"Unauthenticated\", 15) == 0) {\n        return true;\n    }\n\n    if (strncasecmp(message, \"your IP is banned\", 17) == 0) {\n        return true;\n    }\n\n    if (strncasecmp(message, \"IP Address currently banned\", 27) == 0) {\n        return true;\n    }\n\n    return false;\n}","filepath":"src/common/net/Client.cpp","line_number":280,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4697488":{"score":0.571031,"function_name":"Client::send","code":"bool Client::send(BIO *bio)\n{\n#   ifndef XMRIG_NO_TLS\n    uv_buf_t buf;\n    buf.len = BIO_get_mem_data(bio, \u0026buf.base);\n\n    if (buf.len == 0) {\n        return true;\n    }\n\n    LOG_DEBUG(\"[%s] TLS send     (%d bytes)\", m_pool.url(), static_cast\u003cint\u003e(buf.len));\n\n    bool result = false;\n    if (state() == ConnectedState \u0026\u0026 uv_is_writable(m_stream)) {\n        result = uv_try_write(m_stream, \u0026buf, 1) \u003e 0;\n\n        if (!result) {\n            close();\n        }\n    }\n    else {\n        LOG_DEBUG_ERR(\"[%s] send failed, invalid state: %d\", m_pool.url(), m_state);\n    }\n\n    (void) BIO_reset(bio);\n\n    return result;\n#   else\n    return false;\n#   endif\n}","filepath":"src/common/net/Client.cpp","line_number":397,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4697680":{"score":0.76074374,"function_name":"Client::verifyAlgorithm","code":"bool Client::verifyAlgorithm(const xmrig::Algorithm \u0026algorithm) const\n{\n#   ifdef XMRIG_PROXY_PROJECT\n    if (m_pool.algorithm().variant() == xmrig::VARIANT_AUTO || m_id == -1) {\n        return true;\n    }\n#   endif\n\n    if (m_pool.isCompatible(algorithm)) {\n        return true;\n    }\n\n    if (isQuiet()) {\n        return false;\n    }\n\n    if (algorithm.isValid()) {\n        LOG_ERR(\"Incompatible algorithm \\\"%s\\\" detected, reconnect\", algorithm.name());\n    }\n    else {\n        LOG_ERR(\"Unknown/unsupported algorithm detected, reconnect\");\n    }\n\n    return false;\n}","filepath":"src/common/net/Client.cpp","line_number":430,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4697904":{"score":0.87615556,"function_name":"Client::resolve","code":"int Client::resolve(const char *host)\n{\n    setState(HostLookupState);\n\n    m_expire     = 0;\n    m_recvBufPos = 0;\n\n    if (m_failures == -1) {\n        m_failures = 0;\n    }\n\n    const int r = uv_getaddrinfo(uv_default_loop(), \u0026m_resolver, Client::onResolved, host, nullptr, \u0026m_hints);\n    if (r) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s:%u] getaddrinfo error: \\\"%s\\\"\", host, m_pool.port(), uv_strerror(r));\n        }\n        return 1;\n    }\n\n    return 0;\n}","filepath":"src/common/net/Client.cpp","line_number":457,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4698160":{"score":0.666738,"function_name":"Client::send","code":"int64_t Client::send(size_t size)\n{\n    LOG_DEBUG(\"[%s] send (%d bytes): \\\"%s\\\"\", m_pool.url(), size, m_sendBuf);\n\n#   ifndef XMRIG_NO_TLS\n    if (isTLS()) {\n        if (!m_tls-\u003esend(m_sendBuf, size)) {\n            return -1;\n        }\n    }\n    else\n#   endif\n    {\n        if (state() != ConnectedState || !uv_is_writable(m_stream)) {\n            LOG_DEBUG_ERR(\"[%s] send failed, invalid state: %d\", m_pool.url(), m_state);\n            return -1;\n        }\n\n        uv_buf_t buf = uv_buf_init(m_sendBuf, (unsigned int) size);\n\n        if (uv_try_write(m_stream, \u0026buf, 1) \u003c 0) {\n            close();\n            return -1;\n        }\n    }\n\n    m_expire = uv_now(uv_default_loop()) + kResponseTimeout;\n    return m_sequence++;\n}","filepath":"src/common/net/Client.cpp","line_number":503,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4698416":{"score":0.57836765,"function_name":"Client::tick","code":"void Client::tick(uint64_t now)\n{\n    if (m_state == ConnectedState) {\n        if (m_expire \u0026\u0026 now \u003e m_expire) {\n            LOG_DEBUG_ERR(\"[%s] timeout\", m_pool.url());\n            close();\n        }\n        else if (m_keepAlive \u0026\u0026 now \u003e m_keepAlive) {\n            ping();\n        }\n    }\n\n    if (m_expire \u0026\u0026 now \u003e m_expire \u0026\u0026 m_state == ConnectingState) {\n        connect();\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":161,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4698624":{"score":0.6288918,"function_name":"Client::connect","code":"void Client::connect(const std::vector\u003caddrinfo*\u003e \u0026ipv4, const std::vector\u003caddrinfo*\u003e \u0026ipv6)\n{\n    addrinfo *addr = nullptr;\n    m_ipv6         = ipv4.empty() \u0026\u0026 !ipv6.empty();\n\n    if (m_ipv6) {\n        addr = ipv6[ipv6.size() == 1 ? 0 : rand() % ipv6.size()];\n        uv_ip6_name(reinterpret_cast\u003csockaddr_in6*\u003e(addr-\u003eai_addr), m_ip, 45);\n    }\n    else {\n        addr = ipv4[ipv4.size() == 1 ? 0 : rand() % ipv4.size()];\n        uv_ip4_name(reinterpret_cast\u003csockaddr_in*\u003e(addr-\u003eai_addr), m_ip, 16);\n    }\n\n    connect(addr-\u003eai_addr);\n}","filepath":"src/common/net/Client.cpp","line_number":534,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4699056":{"score":0.8225456,"function_name":"Client::connect","code":"void Client::connect(sockaddr *addr)\n{\n    setState(ConnectingState);\n\n    reinterpret_cast\u003csockaddr_in*\u003e(addr)-\u003esin_port = htons(m_pool.port());\n\n    uv_connect_t *req = new uv_connect_t;\n    req-\u003edata = m_storage.ptr(m_key);\n\n    m_socket = new uv_tcp_t;\n    m_socket-\u003edata = m_storage.ptr(m_key);\n\n    uv_tcp_init(uv_default_loop(), m_socket);\n    uv_tcp_nodelay(m_socket, 1);\n\n#   ifndef WIN32\n    uv_tcp_keepalive(m_socket, 1, 60);\n#   endif\n\n    uv_tcp_connect(req, m_socket, reinterpret_cast\u003cconst sockaddr*\u003e(addr), Client::onConnect);\n}","filepath":"src/common/net/Client.cpp","line_number":552,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4699264":{"score":0.8834949,"function_name":"Client::parseExtensions","code":"void Client::parseExtensions(const rapidjson::Value \u0026value)\n{\n    m_extensions = 0;\n\n    if (!value.IsArray()) {\n        return;\n    }\n\n    for (const rapidjson::Value \u0026ext : value.GetArray()) {\n        if (!ext.IsString()) {\n            continue;\n        }\n\n        if (strcmp(ext.GetString(), \"algo\") == 0) {\n            m_extensions |= AlgoExt;\n            continue;\n        }\n\n        if (strcmp(ext.GetString(), \"nicehash\") == 0) {\n            m_extensions |= NicehashExt;\n            m_nicehash = true;\n            continue;\n        }\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":689,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4700768":{"score":0.78016764,"function_name":"Client::parseJob","code":"bool Client::parseJob(const rapidjson::Value \u0026params, int *code)\n{\n    if (!params.IsObject()) {\n        *code = 2;\n        return false;\n    }\n\n    Job job(m_id, m_nicehash, m_pool.algorithm(), m_rpcId);\n\n    if (!job.setId(params[\"job_id\"].GetString())) {\n        *code = 3;\n        return false;\n    }\n\n    if (!job.setBlob(params[\"blob\"].GetString())) {\n        *code = 4;\n        return false;\n    }\n\n    if (!job.setTarget(params[\"target\"].GetString())) {\n        *code = 5;\n        return false;\n    }\n\n    if (params.HasMember(\"algo\")) {\n        job.setAlgorithm(params[\"algo\"].GetString());\n    }\n\n    if (params.HasMember(\"variant\")) {\n        const rapidjson::Value \u0026variant = params[\"variant\"];\n\n        if (variant.IsInt()) {\n            job.setVariant(variant.GetInt());\n        }\n        else if (variant.IsString()){\n            job.setVariant(variant.GetString());\n        }\n    }\n\n    if (!verifyAlgorithm(job.algorithm())) {\n        *code = 6;\n\n        close();\n        return false;\n    }\n\n    if (m_job != job) {\n        m_jobs++;\n        m_job = std::move(job);\n        return true;\n    }\n\n    if (m_jobs == 0) { // https://github.com/xmrig/xmrig/issues/459\n        return false;\n    }\n\n    if (!isQuiet()) {\n        LOG_WARN(\"[%s] duplicate job received, reconnect\", m_pool.url());\n    }\n\n    close();\n    return false;\n}","filepath":"src/common/net/Client.cpp","line_number":312,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4703504":{"score":0.6437869,"function_name":"Client::parseLogin","code":"bool Client::parseLogin(const rapidjson::Value \u0026result, int *code)\n{\n    if (!m_rpcId.setId(result[\"id\"].GetString())) {\n        *code = 1;\n        return false;\n    }\n\n    m_nicehash = m_pool.isNicehash();\n\n    if (result.HasMember(\"extensions\")) {\n        parseExtensions(result[\"extensions\"]);\n    }\n\n    const bool rc = parseJob(result[\"job\"], code);\n    m_jobs = 0;\n\n    return rc;\n}","filepath":"src/common/net/Client.cpp","line_number":377,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4705392":{"score":0.9033575,"function_name":"Client::parseNotification","code":"void Client::parseNotification(const char *method, const rapidjson::Value \u0026params, const rapidjson::Value \u0026error)\n{\n    if (error.IsObject()) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] error: \\\"%s\\\", code: %d\", m_pool.url(), error[\"message\"].GetString(), error[\"code\"].GetInt());\n        }\n        return;\n    }\n\n    if (!method) {\n        return;\n    }\n\n    if (strcmp(method, \"job\") == 0) {\n        int code = -1;\n        if (parseJob(params, \u0026code)) {\n            m_listener-\u003eonJobReceived(this, m_job);\n        }\n\n        return;\n    }\n\n    LOG_WARN(\"[%s] unsupported method: \\\"%s\\\"\", m_pool.url(), method);\n}","filepath":"src/common/net/Client.cpp","line_number":716,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4706864":{"score":0.5829352,"function_name":"Client::deleteLater","code":"void Client::deleteLater()\n{\n    if (!m_listener) {\n        return;\n    }\n\n    m_listener = nullptr;\n\n    if (!disconnect()) {\n        m_storage.remove(m_key);\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":136,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4707504":{"score":0.6996008,"function_name":"Client::reconnect","code":"void Client::reconnect()\n{\n    if (!m_listener) {\n        m_storage.remove(m_key);\n\n        return;\n    }\n\n    m_keepAlive = 0;\n\n    if (m_failures == -1) {\n        return m_listener-\u003eonClose(this, -1);\n    }\n\n    setState(ConnectingState);\n\n    m_failures++;\n    m_listener-\u003eonClose(this, (int) m_failures);\n\n    m_expire = uv_now(uv_default_loop()) + m_retryPause;\n}","filepath":"src/common/net/Client.cpp","line_number":829,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4708112":{"score":0.70885944,"function_name":"Client::onClose","code":"void Client::onClose()\n{\n    delete m_socket;\n\n    m_stream = nullptr;\n    m_socket = nullptr;\n    setState(UnconnectedState);\n\n#   ifndef XMRIG_NO_TLS\n    if (m_tls) {\n        delete m_tls;\n        m_tls = nullptr;\n    }\n#   endif\n\n    reconnect();\n}","filepath":"src/common/net/Client.cpp","line_number":631,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4708560":{"score":0.7582797,"function_name":"Client::onResolved","code":"void Client::onResolved(uv_getaddrinfo_t *req, int status, struct addrinfo *res)\n{\n    auto client = getClient(req-\u003edata);\n    if (!client) {\n        return;\n    }\n\n    assert(client-\u003em_listener != nullptr);\n    if (!client-\u003em_listener) {\n        return client-\u003ereconnect();\n    }\n\n    if (status \u003c 0) {\n        if (!client-\u003eisQuiet()) {\n            LOG_ERR(\"[%s] DNS error: \\\"%s\\\"\", client-\u003em_pool.url(), uv_strerror(status));\n        }\n\n        return client-\u003ereconnect();\n    }\n\n    addrinfo *ptr = res;\n    std::vector\u003caddrinfo*\u003e ipv4;\n    std::vector\u003caddrinfo*\u003e ipv6;\n\n    while (ptr != nullptr) {\n        if (ptr-\u003eai_family == AF_INET) {\n            ipv4.push_back(ptr);\n        }\n\n        if (ptr-\u003eai_family == AF_INET6) {\n            ipv6.push_back(ptr);\n        }\n\n        ptr = ptr-\u003eai_next;\n    }\n\n    if (ipv4.empty() \u0026\u0026 ipv6.empty()) {\n        if (!client-\u003eisQuiet()) {\n            LOG_ERR(\"[%s] DNS error: \\\"No IPv4 (A) or IPv6 (AAAA) records found\\\"\", client-\u003em_pool.url());\n        }\n\n        uv_freeaddrinfo(res);\n        return client-\u003ereconnect();\n    }\n\n    client-\u003econnect(ipv4, ipv6);\n    uv_freeaddrinfo(res);\n}","filepath":"src/common/net/Client.cpp","line_number":969,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4709424":{"score":0.8087306,"function_name":"Client::Client","code":"Client::Client(int id, const char *agent, IClientListener *listener) :\n    m_ipv6(false),\n    m_nicehash(false),\n    m_quiet(false),\n    m_agent(agent),\n    m_listener(listener),\n    m_extensions(0),\n    m_id(id),\n    m_retries(5),\n    m_retryPause(5000),\n    m_failures(0),\n    m_recvBufPos(0),\n    m_state(UnconnectedState),\n    m_tls(nullptr),\n    m_expire(0),\n    m_jobs(0),\n    m_keepAlive(0),\n    m_key(0),\n    m_stream(nullptr),\n    m_socket(nullptr)\n{\n    m_key = m_storage.add(this);\n\n    memset(m_ip, 0, sizeof(m_ip));\n    memset(\u0026m_hints, 0, sizeof(m_hints));\n\n    m_resolver.data = m_storage.ptr(m_key);\n\n    m_hints.ai_family   = AF_UNSPEC;\n    m_hints.ai_socktype = SOCK_STREAM;\n    m_hints.ai_protocol = IPPROTO_TCP;\n\n    m_recvBuf.base = m_buf;\n    m_recvBuf.len  = sizeof(m_buf);\n}","filepath":"src/common/net/Client.cpp","line_number":69,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4710160":{"score":0.8440584,"function_name":"Client::send","code":"int64_t Client::send(const rapidjson::Document \u0026doc)\n{\n    using namespace rapidjson;\n\n    StringBuffer buffer(0, 512);\n    Writer\u003cStringBuffer\u003e writer(buffer);\n    doc.Accept(writer);\n\n    const size_t size = buffer.GetSize();\n    if (size \u003e (sizeof(m_sendBuf) - 2)) {\n        LOG_ERR(\"[%s] send failed: \\\"send buffer overflow: %zu \u003e %zu\\\"\", m_pool.url(), size, (sizeof(m_sendBuf) - 2));\n        close();\n        return -1;\n    }\n\n    memcpy(m_sendBuf, buffer.GetString(), size);\n    m_sendBuf[size]     = '\\n';\n    m_sendBuf[size + 1] = '\\0';\n\n    return send(size + 1);\n}","filepath":"src/common/net/Client.cpp","line_number":480,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4716464":{"score":0.7548451,"function_name":"Client::handshake","code":"void Client::handshake()\n{\n#   ifndef XMRIG_NO_TLS\n    if (isTLS()) {\n        m_expire = uv_now(uv_default_loop()) + kResponseTimeout;\n\n        m_tls-\u003ehandshake();\n    }\n    else\n#   endif\n    {\n        login();\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":575,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4716544":{"score":0.71518457,"function_name":"Client::onConnect","code":"void Client::onConnect(uv_connect_t *req, int status)\n{\n    auto client = getClient(req-\u003edata);\n    if (!client) {\n        delete req;\n        return;\n    }\n\n    if (status \u003c 0) {\n        if (!client-\u003eisQuiet()) {\n            LOG_ERR(\"[%s] connect error: \\\"%s\\\"\", client-\u003em_pool.url(), uv_strerror(status));\n        }\n\n        delete req;\n        client-\u003eclose();\n        return;\n    }\n\n    client-\u003em_stream = static_cast\u003cuv_stream_t*\u003e(req-\u003ehandle);\n    client-\u003em_stream-\u003edata = req-\u003edata;\n    client-\u003esetState(ConnectedState);\n\n    uv_read_start(client-\u003em_stream, Client::onAllocBuffer, Client::onRead);\n    delete req;\n\n    client-\u003ehandshake();\n}","filepath":"src/common/net/Client.cpp","line_number":897,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4722480":{"score":0.86934817,"function_name":"Client::parse","code":"void Client::parse(char *line, size_t len)\n{\n    startTimeout();\n\n    line[len - 1] = '\\0';\n\n    LOG_DEBUG(\"[%s] received (%d bytes): \\\"%s\\\"\", m_pool.url(), len, line);\n\n    if (len \u003c 32 || line[0] != '{') {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] JSON decode failed\", m_pool.url());\n        }\n\n        return;\n    }\n\n    rapidjson::Document doc;\n    if (doc.ParseInsitu(line).HasParseError()) {\n        if (!isQuiet()) {\n            LOG_ERR(\"[%s] JSON decode failed: \\\"%s\\\"\", m_pool.url(), rapidjson::GetParseError_En(doc.GetParseError()));\n        }\n\n        return;\n    }\n\n    if (!doc.IsObject()) {\n        return;\n    }\n\n    const rapidjson::Value \u0026id = doc[\"id\"];\n    if (id.IsInt64()) {\n        parseResponse(id.GetInt64(), doc[\"result\"], doc[\"error\"]);\n    }\n    else {\n        parseNotification(doc[\"method\"].GetString(), doc[\"params\"], doc[\"error\"]);\n    }\n}","filepath":"src/common/net/Client.cpp","line_number":650,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4749120":{"score":0.8380006,"function_name":"Job::Job","code":"Job::Job(int poolId, bool nicehash, const xmrig::Algorithm \u0026algorithm, const xmrig::Id \u0026clientId) :\n    m_autoVariant(algorithm.variant() == xmrig::VARIANT_AUTO),\n    m_nicehash(nicehash),\n    m_poolId(poolId),\n    m_threadId(-1),\n    m_size(0),\n    m_diff(0),\n    m_target(0),\n    m_blob(),\n    m_height(0),\n    m_algorithm(algorithm),\n    m_clientId(clientId)\n{\n}","filepath":"src/common/net/Job.cpp","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4749392":{"score":0.7354122,"function_name":"Job::setBlob","code":"bool Job::setBlob(const char *blob)\n{\n    if (!blob) {\n        return false;\n    }\n\n    m_size = strlen(blob);\n    if (m_size % 2 != 0) {\n        return false;\n    }\n\n    m_size /= 2;\n    if (m_size \u003c 76 || m_size \u003e= sizeof(m_blob)) {\n        return false;\n    }\n\n    if (!fromHex(blob, (int) m_size * 2, m_blob)) {\n        return false;\n    }\n\n    if (*nonce() != 0 \u0026\u0026 !m_nicehash) {\n        m_nicehash = true;\n    }\n\n    if (m_autoVariant) {\n        m_algorithm.setVariant(variant());\n    }\n\n    if (!m_algorithm.isForced()) {\n        if (m_algorithm.variant() == xmrig::VARIANT_XTL \u0026\u0026 m_blob[0] \u003e= 9) {\n            m_algorithm.setVariant(xmrig::VARIANT_HALF);\n        }\n        else if (m_algorithm.variant() == xmrig::VARIANT_MSR \u0026\u0026 m_blob[0] \u003e= 8) {\n            m_algorithm.setVariant(xmrig::VARIANT_HALF);\n        }\n        else if (m_algorithm.variant() == xmrig::VARIANT_WOW \u0026\u0026 m_blob[0] \u003c 11) {\n            m_algorithm.setVariant(xmrig::VARIANT_2);\n        }\n    }\n\n#   ifdef XMRIG_PROXY_PROJECT\n    memset(m_rawBlob, 0, sizeof(m_rawBlob));\n    memcpy(m_rawBlob, blob, m_size * 2);\n#   endif\n\n    return true;\n}","filepath":"src/common/net/Job.cpp","line_number":102,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4749776":{"score":0.7761875,"function_name":"Job::setTarget","code":"bool Job::setTarget(const char *target)\n{\n    if (!target) {\n        return false;\n    }\n\n    const size_t len = strlen(target);\n\n    if (len \u003c= 8) {\n        uint32_t tmp = 0;\n        char str[8];\n        memcpy(str, target, len);\n\n        if (!fromHex(str, 8, reinterpret_cast\u003cunsigned char*\u003e(\u0026tmp)) || tmp == 0) {\n            return false;\n        }\n\n        m_target = 0xFFFFFFFFFFFFFFFFULL / (0xFFFFFFFFULL / static_cast\u003cuint64_t\u003e(tmp));\n    }\n    else if (len \u003c= 16) {\n        m_target = 0;\n        char str[16];\n        memcpy(str, target, len);\n\n        if (!fromHex(str, 16, reinterpret_cast\u003cunsigned char*\u003e(\u0026m_target)) || m_target == 0) {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n\n#   ifdef XMRIG_PROXY_PROJECT\n    memset(m_rawTarget, 0, sizeof(m_rawTarget));\n    memcpy(m_rawTarget, target, len);\n#   endif\n\n    m_diff = toDiff(m_target);\n    return true;\n}","filepath":"src/common/net/Job.cpp","line_number":151,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4752320":{"score":0.8310485,"function_name":"Job::fromHex","code":"bool Job::fromHex(const char* in, unsigned int len, unsigned char* out)\n{\n    bool error = false;\n    for (unsigned int i = 0; i \u003c len; i += 2) {\n        out[i / 2] = (hf_hex2bin(in[i], error) \u003c\u003c 4) | hf_hex2bin(in[i + 1], error);\n\n        if (error) {\n            return false;\n        }\n    }\n    return true;\n}","filepath":"src/common/net/Job.cpp","line_number":209,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.12.0"},"4753552":{"score":0.58618784,"function_name":"xmrig::Pool::Pool","code":"xmrig::Pool::Pool(const char *host, uint16_t port, const char *user, const char *password, int keepAlive, bool nicehash, bool tls) :\n    m_nicehash(nicehash),\n    m_tls(tls),\n    m_keepAlive(keepAlive),\n    m_host(host),\n    m_password(password),\n    m_user(user),\n    m_port(port)\n{\n    const size_t size = m_host.size() + 8;\n    assert(size \u003e 8);\n\n    char *url = new char[size]();\n    snprintf(url, size - 1, \"%s:%d\", m_host.data(), m_port);\n\n    m_url = url;\n}","filepath":"src/base/net/Pool.cpp","line_number":134,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4753888":{"score":0.69653004,"function_name":"xmrig::Pool::isCompatible","code":"bool xmrig::Pool::isCompatible(const Algorithm \u0026algorithm) const\n{\n    if (m_algorithms.empty()) {\n        return true;\n    }\n\n    for (const auto \u0026a : m_algorithms) {\n        if (algorithm == a) {\n            return true;\n        }\n    }\n\n#   ifdef XMRIG_PROXY_PROJECT\n    if (m_algorithm.algo() == xmrig::CRYPTONIGHT \u0026\u0026 algorithm.algo() == xmrig::CRYPTONIGHT) {\n        return m_algorithm.variant() == xmrig::VARIANT_XTL || m_algorithm.variant() == xmrig::VARIANT_MSR;\n    }\n#   endif\n\n    return false;\n}","filepath":"src/base/net/Pool.cpp","line_number":153,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4754256":{"score":0.8672164,"function_name":"xmrig::Pool::parse","code":"bool xmrig::Pool::parse(const char *url)\n{\n    assert(url != nullptr);\n\n    const char *p = strstr(url, \"://\");\n    const char *base = url;\n\n    if (p) {\n        if (strncasecmp(url, \"stratum+tcp://\", 14) == 0) {\n            m_tls = false;\n        }\n        else if (strncasecmp(url, \"stratum+ssl://\", 14) == 0) {\n            m_tls = true;\n        }\n        else {\n            return false;\n        }\n\n        base = url + 14;\n    }\n\n    if (!strlen(base) || *base == '/') {\n        return false;\n    }\n\n    m_url = url;\n    if (base[0] == '[') {\n        return parseIPv6(base);\n    }\n\n    const char *port = strchr(base, ':');\n    if (!port) {\n        m_host = base;\n        return true;\n    }\n\n    const size_t size = static_cast\u003csize_t\u003e(port++ - base + 1);\n    char *host        = new char[size]();\n    memcpy(host, base, size - 1);\n\n    m_host = host;\n    m_port = static_cast\u003cuint16_t\u003e(strtol(port, nullptr, 10));\n\n    return true;\n}","filepath":"src/base/net/Pool.cpp","line_number":204,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4765888":{"score":0.8739598,"function_name":"xmrig::Pool::parseIPv6","code":"bool xmrig::Pool::parseIPv6(const char *addr)\n{\n    const char *end = strchr(addr, ']');\n    if (!end) {\n        return false;\n    }\n\n    const char *port = strchr(end, ':');\n    if (!port) {\n        return false;\n    }\n\n    const size_t size = static_cast\u003csize_t\u003e(end - addr);\n    char *host        = new char[size]();\n    memcpy(host, addr + 1, size - 1);\n\n    m_host = host;\n    m_port = static_cast\u003cuint16_t\u003e(strtol(port + 1, nullptr, 10));\n\n    return true;\n}","filepath":"src/base/net/Pool.cpp","line_number":355,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4766096":{"score":0.70464927,"function_name":"xmrig::Pool::adjustVariant","code":"void xmrig::Pool::adjustVariant(const xmrig::Variant variantHint)\n{\n#   ifndef XMRIG_PROXY_PROJECT\n    using namespace xmrig;\n\n    if (m_host.contains(\".nicehash.com\")) {\n        m_keepAlive = false;\n        m_nicehash  = true;\n        bool valid  = true;\n\n        switch (m_port) {\n        case 3355:\n        case 33355:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonight.\");\n            m_algorithm.setVariant(VARIANT_0);\n            break;\n\n        case 3363:\n        case 33363:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonightv7.\");\n            m_algorithm.setVariant(VARIANT_1);\n            break;\n\n        case 3364:\n            valid = m_algorithm.algo() == CRYPTONIGHT_HEAVY \u0026\u0026 m_host.contains(\"cryptonightheavy.\");\n            m_algorithm.setVariant(VARIANT_0);\n            break;\n\n        case 3367:\n        case 33367:\n            valid = m_algorithm.algo() == CRYPTONIGHT \u0026\u0026 m_host.contains(\"cryptonightv8.\");\n            m_algorithm.setVariant(VARIANT_2);\n            break;\n\n        default:\n            break;\n        }\n\n        if (!valid) {\n            m_algorithm.setAlgo(INVALID_ALGO);\n        }\n\n        m_tls = m_port \u003e 33000;\n        return;\n    }\n\n    if (m_host.contains(\".minergate.com\")) {\n        m_keepAlive = false;\n        bool valid  = true;\n        m_algorithm.setVariant(VARIANT_1);\n\n        if (m_host.contains(\"xmr.pool.\")) {\n            valid = m_algorithm.algo() == CRYPTONIGHT;\n            m_algorithm.setVariant(m_port == 45700 ? VARIANT_AUTO : VARIANT_0);\n        }\n        else if (m_host.contains(\"aeon.pool.\") \u0026\u0026 m_port == 45690) {\n            valid = m_algorithm.algo() == CRYPTONIGHT_LITE;\n            m_algorithm.setVariant(VARIANT_1);\n        }\n\n        if (!valid) {\n            m_algorithm.setAlgo(INVALID_ALGO);\n        }\n\n        return;\n    }\n\n    if (variantHint != VARIANT_AUTO) {\n        m_algorithm.setVariant(variantHint);\n        return;\n    }\n\n    if (m_algorithm.variant() != VARIANT_AUTO) {\n        return;\n    }\n\n    if (m_algorithm.algo() == CRYPTONIGHT_HEAVY)  {\n        m_algorithm.setVariant(VARIANT_0);\n    }\n    else if (m_algorithm.algo() == CRYPTONIGHT_LITE) {\n        m_algorithm.setVariant(VARIANT_1);\n    }\n#   endif\n}","filepath":"src/base/net/Pool.cpp","line_number":389,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4766512":{"score":0.86297596,"function_name":"xmrig::Pool::addVariant","code":"void xmrig::Pool::addVariant(xmrig::Variant variant)\n{\n    const xmrig::Algorithm algorithm(m_algorithm.algo(), variant);\n    if (!algorithm.isValid() || m_algorithm == algorithm) {\n        return;\n    }\n\n    m_algorithms.push_back(algorithm);\n}","filepath":"src/base/net/Pool.cpp","line_number":378,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4768096":{"score":0.70043725,"function_name":"xmrig::Pool::rebuild","code":"void xmrig::Pool::rebuild()\n{\n    m_algorithms.clear();\n\n    if (!m_algorithm.isValid()) {\n        return;\n    }\n\n    m_algorithms.push_back(m_algorithm);\n\n#   ifndef XMRIG_PROXY_PROJECT\n    addVariant(VARIANT_4);\n    addVariant(VARIANT_WOW);\n    addVariant(VARIANT_2);\n    addVariant(VARIANT_1);\n    addVariant(VARIANT_0);\n    addVariant(VARIANT_HALF);\n    addVariant(VARIANT_XTL);\n    addVariant(VARIANT_TUBE);\n    addVariant(VARIANT_MSR);\n    addVariant(VARIANT_XHV);\n    addVariant(VARIANT_XAO);\n    addVariant(VARIANT_RTO);\n    addVariant(VARIANT_GPU);\n    addVariant(VARIANT_AUTO);\n#   endif\n}","filepath":"src/base/net/Pool.cpp","line_number":475,"entry_url":"https://github.com/xmrig/xmrig-amd.git","slot_name":"v2.13.0"},"4771424":{"score":0.93370754,"function_name":"FailoverStrategy::onClose","code":"void FailoverStrategy::onClose(Client *client, int failures)\n{\n    if (failures == -1) {\n        return;\n    }\n\n    if (m_active == client-\u003eid()) {\n        m_active = -1;\n        m_listener-\u003eonPause(this);\n    }\n\n    if (m_index == 0 \u0026\u0026 failures \u003c m_retries) {\n        return;\n    }\n\n    if (m_index == client-\u003eid() \u0026\u0026 (m_pools.size() - m_index) \u003e 1) {\n        m_pools[++m_index]-\u003econnect();\n    }\n}","filepath":"src/common/net/strategies/FailoverStrategy.cpp","line_number":100,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4771584":{"score":0.8933257,"function_name":"FailoverStrategy::stop","code":"void FailoverStrategy::stop()\n{\n    for (size_t i = 0; i \u003c m_pools.size(); ++i) {\n        m_pools[i]-\u003edisconnect();\n    }\n\n    m_index  = 0;\n    m_active = -1;\n\n    m_listener-\u003eonPause(this);\n}","filepath":"src/common/net/strategies/FailoverStrategy.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4771824":{"score":0.8457054,"function_name":"FailoverStrategy::onLoginSuccess","code":"void FailoverStrategy::onLoginSuccess(Client *client)\n{\n    int active = m_active;\n\n    if (client-\u003eid() == 0 || !isActive()) {\n        active = client-\u003eid();\n    }\n\n    for (size_t i = 1; i \u003c m_pools.size(); ++i) {\n        if (active != static_cast\u003cint\u003e(i)) {\n            m_pools[i]-\u003edisconnect();\n        }\n    }\n\n    if (active \u003e= 0 \u0026\u0026 active != m_active) {\n        m_index = m_active = active;\n        m_listener-\u003eonActive(this, client);\n    }\n}","filepath":"src/common/net/strategies/FailoverStrategy.cpp","line_number":129,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4772288":{"score":0.87857616,"function_name":"FailoverStrategy::add","code":"void FailoverStrategy::add(const Pool \u0026pool)\n{\n    Client *client = new Client((int) m_pools.size(), Platform::userAgent(), this);\n    client-\u003esetPool(pool);\n    client-\u003esetRetries(m_retries);\n    client-\u003esetRetryPause(m_retryPause * 1000);\n    client-\u003esetQuiet(m_quiet);\n\n    m_pools.push_back(client);\n}","filepath":"src/common/net/strategies/FailoverStrategy.cpp","line_number":156,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4772512":{"score":0.7372068,"function_name":"FailoverStrategy::FailoverStrategy","code":"FailoverStrategy::FailoverStrategy(const std::vector\u003cPool\u003e \u0026urls, int retryPause, int retries, IStrategyListener *listener, bool quiet) :\n    m_quiet(quiet),\n    m_retries(retries),\n    m_retryPause(retryPause),\n    m_active(-1),\n    m_index(0),\n    m_listener(listener)\n{\n    for (const Pool \u0026url : urls) {\n        add(url);\n    }\n}","filepath":"src/common/net/strategies/FailoverStrategy.cpp","line_number":31,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.3"},"4774192":{"score":0.80702144,"function_name":"xmrig::Config::parseBoolean","code":"bool xmrig::Config::parseBoolean(int key, bool enable)\n{\n    if (!CommonConfig::parseBoolean(key, enable)) {\n        return false;\n    }\n\n    switch (key) {\n    case SafeKey: /* --safe */\n        m_safe = enable;\n        break;\n\n    case HugePagesKey: /* --no-huge-pages */\n        m_hugePages = enable;\n        break;\n\n    case HardwareAESKey: /* hw-aes config only */\n        m_aesMode = enable ? AES_HW : AES_SOFT;\n        break;\n\n#   ifndef XMRIG_NO_ASM\n    case AssemblyKey:\n        m_assembly = Asm::parse(enable);\n        break;\n#   endif\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":192,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4774368":{"score":0.7320567,"function_name":"xmrig::Config::parseUint64","code":"bool xmrig::Config::parseUint64(int key, uint64_t arg)\n{\n    if (!CommonConfig::parseUint64(key, arg)) {\n        return false;\n    }\n\n    switch (key) {\n    case CPUAffinityKey: /* --cpu-affinity */\n        if (arg) {\n            m_threads.mask = arg;\n        }\n        break;\n\n    default:\n        return parseInt(key, static_cast\u003cint\u003e(arg));\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":271,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4774560":{"score":0.84950936,"function_name":"xmrig::Config::parseString","code":"bool xmrig::Config::parseString(int key, const char *arg)\n{\n    if (!CommonConfig::parseString(key, arg)) {\n        return false;\n    }\n\n    switch (key) {\n    case AVKey:          /* --av */\n    case MaxCPUUsageKey: /* --max-cpu-usage */\n    case CPUPriorityKey: /* --cpu-priority */\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    case SafeKey: /* --safe */\n        return parseBoolean(key, true);\n\n    case HugePagesKey: /* --no-huge-pages */\n        return parseBoolean(key, false);\n\n    case ThreadsKey:  /* --threads */\n        if (strncmp(arg, \"all\", 3) == 0) {\n            m_threads.count = Cpu::info()-\u003ethreads();\n            return true;\n        }\n\n        return parseUint64(key, strtol(arg, nullptr, 10));\n\n    case CPUAffinityKey: /* --cpu-affinity */\n        {\n            const char *p  = strstr(arg, \"0x\");\n            return parseUint64(key, p ? strtoull(p, nullptr, 16) : strtoull(arg, nullptr, 10));\n        }\n\n#   ifndef XMRIG_NO_ASM\n    case AssemblyKey: /* --asm */\n        m_assembly = Asm::parse(arg);\n        break;\n#   endif\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":225,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775408":{"score":0.7332274,"function_name":"xmrig::Config::Config","code":"xmrig::Config::Config() : xmrig::CommonConfig(),\n    m_aesMode(AES_AUTO),\n    m_algoVariant(AV_AUTO),\n    m_assembly(ASM_AUTO),\n    m_hugePages(true),\n    m_safe(false),\n    m_shouldSave(false),\n    m_maxCpuUsage(75),\n    m_priority(-1)\n{\n}","filepath":"src/core/Config.cpp","line_number":44,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775680":{"score":0.95357454,"function_name":"xmrig::Config::parseInt","code":"bool xmrig::Config::parseInt(int key, int arg)\n{\n    switch (key) {\n    case ThreadsKey: /* --threads */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c 1024) {\n            m_threads.count = arg;\n        }\n        break;\n\n    case AVKey: /* --av */\n        if (arg \u003e= AV_AUTO \u0026\u0026 arg \u003c AV_MAX) {\n            m_algoVariant = static_cast\u003cAlgoVariant\u003e(arg);\n        }\n        break;\n\n    case MaxCPUUsageKey: /* --max-cpu-usage */\n        if (m_maxCpuUsage \u003e 0 \u0026\u0026 arg \u003c= 100) {\n            m_maxCpuUsage = arg;\n        }\n        break;\n\n    case CPUPriorityKey: /* --cpu-priority */\n        if (arg \u003e= 0 \u0026\u0026 arg \u003c= 5) {\n            m_priority = arg;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":314,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775824":{"score":0.85153025,"function_name":"xmrig::Config::getAlgoVariant","code":"xmrig::AlgoVariant xmrig::Config::getAlgoVariant() const\n{\n#   ifndef XMRIG_NO_AEON\n    if (m_algorithm.algo() == xmrig::CRYPTONIGHT_LITE) {\n        return getAlgoVariantLite();\n    }\n#   endif\n\n    if (m_algoVariant \u003c= AV_AUTO || m_algoVariant \u003e= AV_MAX) {\n        return Cpu::info()-\u003ehasAES() ? AV_SINGLE : AV_SINGLE_SOFT;\n    }\n\n    if (m_safe \u0026\u0026 !Cpu::info()-\u003ehasAES() \u0026\u0026 m_algoVariant \u003c= AV_DOUBLE) {\n        return static_cast\u003cAlgoVariant\u003e(m_algoVariant + 2);\n    }\n\n    return m_algoVariant;\n}","filepath":"src/core/Config.cpp","line_number":349,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4775968":{"score":0.8918966,"function_name":"xmrig::Config::getAlgoVariantLite","code":"xmrig::AlgoVariant xmrig::Config::getAlgoVariantLite() const\n{\n    if (m_algoVariant \u003c= AV_AUTO || m_algoVariant \u003e= AV_MAX) {\n        return Cpu::info()-\u003ehasAES() ? AV_DOUBLE : AV_DOUBLE_SOFT;\n    }\n\n    if (m_safe \u0026\u0026 !Cpu::info()-\u003ehasAES() \u0026\u0026 m_algoVariant \u003c= AV_DOUBLE) {\n        return static_cast\u003cAlgoVariant\u003e(m_algoVariant + 2);\n    }\n\n    return m_algoVariant;\n}","filepath":"src/core/Config.cpp","line_number":370,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4785792":{"score":0.9036587,"function_name":"xmrig::Config::finalize","code":"bool xmrig::Config::finalize()\n{\n    if (m_state != NoneState) {\n        return CommonConfig::finalize();\n    }\n\n    if (!CommonConfig::finalize()) {\n        return false;\n    }\n\n    if (!m_threads.cpu.empty()) {\n        m_threads.mode     = Advanced;\n        const bool softAES = (m_aesMode == AES_AUTO ? (Cpu::info()-\u003ehasAES() ? AES_HW : AES_SOFT) : m_aesMode) == AES_SOFT;\n\n        for (size_t i = 0; i \u003c m_threads.cpu.size(); ++i) {\n            m_threads.list.push_back(CpuThread::createFromData(i, m_algorithm.algo(), m_threads.cpu[i], m_priority, softAES));\n        }\n\n        return true;\n    }\n\n    const AlgoVariant av = getAlgoVariant();   \n    m_threads.mode = m_threads.count ? Simple : Automatic;\n\n    const size_t size = CpuThread::multiway(av) * cn_select_memory(m_algorithm.algo()) / 1024;\n\n    if (!m_threads.count) {\n        m_threads.count = Cpu::info()-\u003eoptimalThreadsCount(size, m_maxCpuUsage);\n    }\n    else if (m_safe) {\n        const size_t count = Cpu::info()-\u003eoptimalThreadsCount(size, m_maxCpuUsage);\n        if (m_threads.count \u003e count) {\n            m_threads.count = count;\n        }\n    }\n\n    for (size_t i = 0; i \u003c m_threads.count; ++i) {\n        m_threads.list.push_back(CpuThread::createFromAV(i, m_algorithm.algo(), av, m_threads.mask, m_priority, m_assembly));\n    }\n\n    m_shouldSave = m_threads.mode == Automatic;\n    return true;\n}","filepath":"src/core/Config.cpp","line_number":147,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4786512":{"score":0.6998311,"function_name":"xmrig::Config::parseJSON","code":"void xmrig::Config::parseJSON(const rapidjson::Document \u0026doc)\n{\n    const rapidjson::Value \u0026threads = doc[\"threads\"];\n\n    if (threads.IsArray()) {\n        for (const rapidjson::Value \u0026value : threads.GetArray()) {\n            if (!value.IsObject()) {\n                continue;\n            }\n\n            if (value.HasMember(\"low_power_mode\")) {\n                auto data = CpuThread::parse(value);\n\n                if (data.valid) {\n                    m_threads.cpu.push_back(std::move(data));\n                }\n            }\n        }\n    }\n}","filepath":"src/core/Config.cpp","line_number":292,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.0-rc"},"4791616":{"score":0.8960006,"function_name":"Network::onJobResult","code":"void Network::onJobResult(const JobResult \u0026result)\n{\n    if (result.poolId == -1 \u0026\u0026 m_donate) {\n        m_donate-\u003esubmit(result);\n        return;\n    }\n\n    m_strategy-\u003esubmit(result);\n}","filepath":"src/net/Network.cpp","line_number":126,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4791792":{"score":0.80698764,"function_name":"Network::onActive","code":"void Network::onActive(IStrategy *strategy, Client *client)\n{\n    if (m_donate \u0026\u0026 m_donate == strategy) {\n        LOG_NOTICE(\"dev donate started\");\n        return;\n    }\n\n    m_state.setPool(client-\u003ehost(), client-\u003eport(), client-\u003eip());\n\n    const char *tlsVersion = client-\u003etlsVersion();\n    LOG_INFO(isColors() ? WHITE_BOLD(\"use pool \") CYAN_BOLD(\"%s:%d \") GREEN_BOLD(\"%s\") \" \\x1B[1;30m%s \"\n                        : \"use pool %s:%d %s %s\",\n             client-\u003ehost(), client-\u003eport(), tlsVersion ? tlsVersion : \"\", client-\u003eip());\n\n    const char *fingerprint = client-\u003etlsFingerprint();\n    if (fingerprint != nullptr) {\n        LOG_INFO(\"%sfingerprint (SHA-256): \\\"%s\\\"\", isColors() ? \"\\x1B[1;30m\" : \"\", fingerprint);\n    }\n}","filepath":"src/net/Network.cpp","line_number":95,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4792256":{"score":0.8596811,"function_name":"Network::onPause","code":"void Network::onPause(IStrategy *strategy)\n{\n    if (m_donate \u0026\u0026 m_donate == strategy) {\n        LOG_NOTICE(\"dev donate finished\");\n        m_strategy-\u003eresume();\n    }\n\n    if (!m_strategy-\u003eisActive()) {\n        LOG_ERR(\"no active pools, stop mining\");\n        m_state.stop();\n        return Workers::pause();\n    }\n}","filepath":"src/net/Network.cpp","line_number":137,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4792464":{"score":0.8001184,"function_name":"Network::onResultAccepted","code":"void Network::onResultAccepted(IStrategy *strategy, Client *client, const SubmitResult \u0026result, const char *error)\n{\n    m_state.add(result, error);\n\n    if (error) {\n        LOG_INFO(isColors() ? \"\\x1B[01;31mrejected\\x1B[0m (%\" PRId64 \"/%\" PRId64 \") diff \\x1B[01;37m%u\\x1B[0m \\x1B[31m\\\"%s\\\"\\x1B[0m \\x1B[01;30m(%\" PRIu64 \" ms)\"\n                            : \"rejected (%\" PRId64 \"/%\" PRId64 \") diff %u \\\"%s\\\" (%\" PRIu64 \" ms)\",\n                 m_state.accepted, m_state.rejected, result.diff, error, result.elapsed);\n    }\n    else {\n        LOG_INFO(isColors() ? \"\\x1B[01;32maccepted\\x1B[0m (%\" PRId64 \"/%\" PRId64 \") diff \\x1B[01;37m%u\\x1B[0m \\x1B[01;30m(%\" PRIu64 \" ms)\"\n                            : \"accepted (%\" PRId64 \"/%\" PRId64 \") diff %u (%\" PRIu64 \" ms)\",\n                 m_state.accepted, m_state.rejected, result.diff, result.elapsed);\n    }\n}","filepath":"src/net/Network.cpp","line_number":152,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4793152":{"score":0.8088768,"function_name":"Network::Network","code":"Network::Network(xmrig::Controller *controller) :\n    m_donate(nullptr),\n    m_controller(controller)\n{\n    srand(time(0) ^ (uintptr_t) this);\n\n    Workers::setListener(this);\n\n    const std::vector\u003cPool\u003e \u0026pools = controller-\u003econfig()-\u003epools();\n\n    if (pools.size() \u003e 1) {\n        m_strategy = new FailoverStrategy(pools, controller-\u003econfig()-\u003eretryPause(), controller-\u003econfig()-\u003eretries(), this);\n    }\n    else {\n        m_strategy = new SinglePoolStrategy(pools.front(), controller-\u003econfig()-\u003eretryPause(), controller-\u003econfig()-\u003eretries(), this);\n    }\n\n    if (controller-\u003econfig()-\u003edonateLevel() \u003e 0) {\n        m_donate = new DonateStrategy(controller-\u003econfig()-\u003edonateLevel(), controller-\u003econfig()-\u003epools().front().user(), controller-\u003econfig()-\u003ealgorithm().algo(), this);\n    }\n\n    m_timer.data = this;\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n\n    uv_timer_start(\u0026m_timer, Network::onTick, kTickInterval, kTickInterval);\n}","filepath":"src/net/Network.cpp","line_number":46,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4793760":{"score":0.80572814,"function_name":"Network::setJob","code":"void Network::setJob(Client *client, const Job \u0026job, bool donate)\n{\n    LOG_INFO(isColors() ? MAGENTA_BOLD(\"new job\") \" from \" WHITE_BOLD(\"%s:%d\") \" diff \" WHITE_BOLD(\"%d\") \" algo \" WHITE_BOLD(\"%s\")\n                        : \"new job from %s:%d diff %d algo %s\",\n             client-\u003ehost(), client-\u003eport(), job.diff(), job.algorithm().shortName());\n\n    m_state.diff = job.diff();\n    Workers::setJob(job, donate);\n}","filepath":"src/net/Network.cpp","line_number":175,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4793984":{"score":0.7251239,"function_name":"Network::tick","code":"void Network::tick()\n{\n    const uint64_t now = uv_now(uv_default_loop());\n\n    m_strategy-\u003etick(now);\n\n    if (m_donate) {\n        m_donate-\u003etick(now);\n    }\n\n#   ifndef XMRIG_NO_API\n    Api::tick(m_state);\n#   endif\n}","filepath":"src/net/Network.cpp","line_number":186,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.8.1"},"4794240":{"score":0.9410679,"function_name":"xmrig::DonateStrategy::onActive","code":"void xmrig::DonateStrategy::onActive(IStrategy *strategy, Client *client)\n{\n    if (!isActive()) {\n        uv_timer_start(\u0026m_timer, DonateStrategy::onTimer, m_donateTime, 0);\n    }\n\n    m_active = true;\n    m_listener-\u003eonActive(this, client);\n}","filepath":"src/net/strategies/DonateStrategy.cpp","line_number":125,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4794928":{"score":0.6392203,"function_name":"xmrig::DonateStrategy::suspend","code":"void xmrig::DonateStrategy::suspend()\n{\n#   if defined(XMRIG_AMD_PROJECT) || defined(XMRIG_NVIDIA_PROJECT)\n    m_stop = m_now + 5000;\n#   else\n    m_stop = m_now + 500;\n#   endif\n\n    m_active = false;\n    m_listener-\u003eonPause(this);\n\n    idle(m_idleTime);\n}","filepath":"src/net/strategies/DonateStrategy.cpp","line_number":161,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4794992":{"score":0.89898103,"function_name":"xmrig::DonateStrategy::DonateStrategy","code":"xmrig::DonateStrategy::DonateStrategy(int level, const char *user, Algo algo, IStrategyListener *listener) :\n    m_active(false),\n    m_donateTime(level * 60 * 1000),\n    m_idleTime((100 - level) * 60 * 1000),\n    m_strategy(nullptr),\n    m_listener(listener),\n    m_now(0),\n    m_stop(0)\n{\n    uint8_t hash[200];\n    char userId[65] = { 0 };\n\n    keccak(reinterpret_cast\u003cconst uint8_t *\u003e(user), strlen(user), hash);\n    Job::toHex(hash, 32, userId);\n\n#   ifndef XMRIG_NO_TLS\n    m_pools.push_back(Pool(\"donate.ssl.xmrig.com\", 443, userId, nullptr, false, true, true));\n#   endif\n\n    m_pools.push_back(Pool(\"donate.v2.xmrig.com\", 3333, userId, nullptr, false, true));\n\n    for (Pool \u0026pool : m_pools) {\n        pool.adjust(Algorithm(algo, VARIANT_AUTO));\n    }\n\n    if (m_pools.size() \u003e 1) {\n        m_strategy = new FailoverStrategy(m_pools, 1, 2, this, true);\n    }\n    else {\n        m_strategy = new SinglePoolStrategy(m_pools.front(), 1, 2, this, true);\n    }\n\n    m_timer.data = this;\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n\n    idle(m_idleTime * randomf(0.5, 1.5));\n}","filepath":"src/net/strategies/DonateStrategy.cpp","line_number":42,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.13.0"},"4806864":{"score":0.8676068,"function_name":"aes_genkey","code":"inline void aes_genkey(const __m128i* memory, __m128i* k0, __m128i* k1, __m128i* k2, __m128i* k3, __m128i* k4, __m128i* k5, __m128i* k6, __m128i* k7, __m128i* k8, __m128i* k9)\n{\n    __m128i xout0 = _mm_load_si128(memory);\n    __m128i xout2 = _mm_load_si128(memory + 1);\n    *k0 = xout0;\n    *k1 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x1);\n    *k2 = xout0;\n    *k3 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x2);\n    *k4 = xout0;\n    *k5 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x4);\n    *k6 = xout0;\n    *k7 = xout2;\n\n    aes_genkey_sub(\u0026xout0, \u0026xout2, 0x8);\n    *k8 = xout0;\n    *k9 = xout2;\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.0"},"4813808":{"score":0.8864149,"function_name":"cn_explode_scratchpad","code":"inline void cn_explode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xin0, xin1, xin2, xin3, xin4, xin5, xin6, xin7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(input, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xin0 = _mm_load_si128(input + 4);\n    xin1 = _mm_load_si128(input + 5);\n    xin2 = _mm_load_si128(input + 6);\n    xin3 = _mm_load_si128(input + 7);\n    xin4 = _mm_load_si128(input + 8);\n    xin5 = _mm_load_si128(input + 9);\n    xin6 = _mm_load_si128(input + 10);\n    xin7 = _mm_load_si128(input + 11);\n\n    for (size_t i = 0; i \u003c MEMORY / sizeof(__m128i); i += 8) {\n        aes_round(k0, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k1, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k2, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k3, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k4, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k5, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k6, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k7, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k8, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n        aes_round(k9, \u0026xin0, \u0026xin1, \u0026xin2, \u0026xin3, \u0026xin4, \u0026xin5, \u0026xin6, \u0026xin7);\n\n        _mm_store_si128(output + i + 0, xin0);\n        _mm_store_si128(output + i + 1, xin1);\n        _mm_store_si128(output + i + 2, xin2);\n        _mm_store_si128(output + i + 3, xin3);\n        _mm_store_si128(output + i + 4, xin4);\n        _mm_store_si128(output + i + 5, xin5);\n        _mm_store_si128(output + i + 6, xin6);\n        _mm_store_si128(output + i + 7, xin7);\n    }\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":100,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.0"},"4843856":{"score":0.87163883,"function_name":"cn_implode_scratchpad","code":"inline void cn_implode_scratchpad(const __m128i* input, __m128i* output)\n{\n    // This is more than we have registers, compiler will assign 2 keys on the stack\n    __m128i xout0, xout1, xout2, xout3, xout4, xout5, xout6, xout7;\n    __m128i k0, k1, k2, k3, k4, k5, k6, k7, k8, k9;\n\n    aes_genkey(output + 2, \u0026k0, \u0026k1, \u0026k2, \u0026k3, \u0026k4, \u0026k5, \u0026k6, \u0026k7, \u0026k8, \u0026k9);\n\n    xout0 = _mm_load_si128(output + 4);\n    xout1 = _mm_load_si128(output + 5);\n    xout2 = _mm_load_si128(output + 6);\n    xout3 = _mm_load_si128(output + 7);\n    xout4 = _mm_load_si128(output + 8);\n    xout5 = _mm_load_si128(output + 9);\n    xout6 = _mm_load_si128(output + 10);\n    xout7 = _mm_load_si128(output + 11);\n\n    for (size_t i = 0; __builtin_expect(i \u003c MEMORY / sizeof(__m128i), 1); i += 8)\n    {\n        xout0 = _mm_xor_si128(_mm_load_si128(input + i + 0), xout0);\n        xout1 = _mm_xor_si128(_mm_load_si128(input + i + 1), xout1);\n        xout2 = _mm_xor_si128(_mm_load_si128(input + i + 2), xout2);\n        xout3 = _mm_xor_si128(_mm_load_si128(input + i + 3), xout3);\n        xout4 = _mm_xor_si128(_mm_load_si128(input + i + 4), xout4);\n        xout5 = _mm_xor_si128(_mm_load_si128(input + i + 5), xout5);\n        xout6 = _mm_xor_si128(_mm_load_si128(input + i + 6), xout6);\n        xout7 = _mm_xor_si128(_mm_load_si128(input + i + 7), xout7);\n\n        aes_round(k0, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k1, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k2, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k3, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k4, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k5, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k6, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k7, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k8, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n        aes_round(k9, \u0026xout0, \u0026xout1, \u0026xout2, \u0026xout3, \u0026xout4, \u0026xout5, \u0026xout6, \u0026xout7);\n    }\n\n    _mm_store_si128(output + 4, xout0);\n    _mm_store_si128(output + 5, xout1);\n    _mm_store_si128(output + 6, xout2);\n    _mm_store_si128(output + 7, xout3);\n    _mm_store_si128(output + 8, xout4);\n    _mm_store_si128(output + 9, xout5);\n    _mm_store_si128(output + 10, xout6);\n    _mm_store_si128(output + 11, xout7);\n}","filepath":"algo/cryptonight/cryptonight_softaes.h","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v0.8.0"},"4846480":{"score":0.917106,"function_name":"xmrig::CpuThread::CpuThread","code":"xmrig::CpuThread::CpuThread(size_t index, Algo algorithm, AlgoVariant av, Multiway multiway, int64_t affinity, int priority, bool softAES, bool prefetch, Assembly assembly) :\n    m_algorithm(algorithm),\n    m_av(av),\n    m_assembly(assembly),\n    m_prefetch(prefetch),\n    m_softAES(softAES),\n    m_priority(priority),\n    m_affinity(affinity),\n    m_multiway(multiway),\n    m_index(index)\n{\n}","filepath":"src/workers/CpuThread.cpp","line_number":44,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.2"},"4846720":{"score":0.7480933,"function_name":"xmrig::CpuThread::createFromAV","code":"xmrig::CpuThread *xmrig::CpuThread::createFromAV(size_t index, Algo algorithm, AlgoVariant av, int64_t affinity, int priority, Assembly assembly)\n{\n    assert(av \u003e AV_AUTO \u0026\u0026 av \u003c AV_MAX);\n\n    int64_t cpuId = -1L;\n\n    if (affinity != -1L) {\n        size_t idx = 0;\n\n        for (size_t i = 0; i \u003c 64; i++) {\n            if (!(affinity \u0026 (1ULL \u003c\u003c i))) {\n                continue;\n            }\n\n            if (idx == index) {\n                cpuId = i;\n                break;\n            }\n\n            idx++;\n        }\n    }\n\n    return new CpuThread(index, algorithm, av, multiway(av), cpuId, priority, isSoftAES(av), false, assembly);\n}","filepath":"src/workers/CpuThread.cpp","line_number":361,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.2"},"4846960":{"score":0.82340056,"function_name":"xmrig::CpuThread::createFromData","code":"xmrig::CpuThread *xmrig::CpuThread::createFromData(size_t index, Algo algorithm, const CpuThread::Data \u0026data, int priority, bool softAES)\n{\n    int av                  = AV_AUTO;\n    const Multiway multiway = data.multiway;\n\n    if (multiway \u003c= DoubleWay) {\n        av = softAES ? (multiway + 2) : multiway;\n    }\n    else {\n        av = softAES ? (multiway + 5) : (multiway + 2);\n    }\n\n    assert(av \u003e AV_AUTO \u0026\u0026 av \u003c AV_MAX);\n\n    return new CpuThread(index, algorithm, static_cast\u003cAlgoVariant\u003e(av), multiway, data.affinity, priority, softAES, false, data.assembly);\n}","filepath":"src/workers/CpuThread.cpp","line_number":388,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.2"},"4847136":{"score":0.8595515,"function_name":"xmrig::CpuThread::fnIndex","code":"size_t xmrig::CpuThread::fnIndex(Algo algorithm, AlgoVariant av, Variant variant, Assembly assembly)\n{\n    const size_t index = VARIANT_MAX * 10 * algorithm + 10 * variant + av - 1;\n\n#   ifndef XMRIG_NO_ASM\n    if (assembly == ASM_AUTO) {\n        assembly = Cpu::info()-\u003eassembly();\n    }\n\n    if (assembly == ASM_NONE) {\n        return index;\n    }\n\n    constexpr const size_t offset = VARIANT_MAX * 10 * 3;\n    size_t extra_offset           = 0;\n\n    if (algorithm == CRYPTONIGHT \u0026\u0026 (variant == VARIANT_2 || variant == VARIANT_HALF)) {\n        if (variant == VARIANT_HALF) {\n            extra_offset += 4;\n        }\n\n        if (av == AV_SINGLE) {\n            return offset + extra_offset + assembly - 2;\n        }\n\n        if (av == AV_DOUBLE) {\n            return offset + 3 + extra_offset;\n        }\n    }\n#   endif\n\n    return index;\n}","filepath":"src/workers/CpuThread.cpp","line_number":520,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.2"},"4847280":{"score":0.6846492,"function_name":"xmrig::CpuThread::parse","code":"xmrig::CpuThread::Data xmrig::CpuThread::parse(const rapidjson::Value \u0026object)\n{\n    Data data;\n\n    const auto \u0026multiway = object[\"low_power_mode\"];\n    if (multiway.IsBool()) {\n        data.multiway = multiway.IsTrue() ? DoubleWay : SingleWay;\n        data.valid    = true;\n    }\n    else if (multiway.IsUint()) {\n        data.setMultiway(multiway.GetInt());\n    }\n\n    if (!data.valid) {\n        return data;\n    }\n\n    const auto \u0026affinity = object[\"affine_to_cpu\"];\n    if (affinity.IsUint64()) {\n        data.affinity = affinity.GetInt64();\n    }\n\n#   ifndef XMRIG_NO_ASM\n    data.assembly = Asm::parse(object[\"asm\"]);\n#   endif\n\n    return data;\n}","filepath":"src/workers/CpuThread.cpp","line_number":406,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.9.2"},"4999296":{"score":0.7964332,"function_name":"Hashrate::calc","code":"double Hashrate::calc(size_t threadId, size_t ms) const\n{\n    assert(threadId \u003c m_threads);\n\n    using namespace std::chrono;\n    const uint64_t now = time_point_cast\u003cmilliseconds\u003e(high_resolution_clock::now()).time_since_epoch().count();\n\n    uint64_t earliestHashCount = 0;\n    uint64_t earliestStamp     = 0;\n    uint64_t lastestStamp      = 0;\n    uint64_t lastestHashCnt    = 0;\n    bool haveFullSet           = false;\n\n    for (size_t i = 1; i \u003c kBucketSize; i++) {\n        const size_t idx = (m_top[threadId] - i) \u0026 kBucketMask;\n\n        if (m_timestamps[threadId][idx] == 0) {\n            break;\n        }\n\n        if (lastestStamp == 0) {\n            lastestStamp = m_timestamps[threadId][idx];\n            lastestHashCnt = m_counts[threadId][idx];\n        }\n\n        if (now - m_timestamps[threadId][idx] \u003e ms) {\n            haveFullSet = true;\n            break;\n        }\n\n        earliestStamp = m_timestamps[threadId][idx];\n        earliestHashCount = m_counts[threadId][idx];\n    }\n\n    if (!haveFullSet || earliestStamp == 0 || lastestStamp == 0) {\n        return nan(\"\");\n    }\n\n    if (lastestStamp - earliestStamp == 0) {\n        return nan(\"\");\n    }\n\n    double hashes, time;\n    hashes = (double) lastestHashCnt - earliestHashCount;\n    time   = (double) lastestStamp - earliestStamp;\n    time  /= 1000.0;\n\n    return hashes / time;\n}","filepath":"src/workers/Hashrate.cpp","line_number":91,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"4999712":{"score":0.89531624,"function_name":"Hashrate::Hashrate","code":"Hashrate::Hashrate(size_t threads, xmrig::Controller *controller) :\n    m_highest(0.0),\n    m_threads(threads),\n    m_controller(controller)\n{\n    m_counts     = new uint64_t*[threads];\n    m_timestamps = new uint64_t*[threads];\n    m_top        = new uint32_t[threads];\n\n    for (size_t i = 0; i \u003c threads; i++) {\n        m_counts[i]     = new uint64_t[kBucketSize]();\n        m_timestamps[i] = new uint64_t[kBucketSize]();\n        m_top[i]        = 0;\n    }\n\n    const int printTime = controller-\u003econfig()-\u003eprintTime();\n\n    if (printTime \u003e 0) {\n        uv_timer_init(uv_default_loop(), \u0026m_timer);\n        m_timer.data = this;\n\n       uv_timer_start(\u0026m_timer, Hashrate::onReport, (printTime + 4) * 1000, printTime * 1000);\n    }\n}","filepath":"src/workers/Hashrate.cpp","line_number":49,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5000096":{"score":0.83148843,"function_name":"Hashrate::calc","code":"double Hashrate::calc(size_t ms) const\n{\n    double result = 0.0;\n    double data;\n\n    for (size_t i = 0; i \u003c m_threads; ++i) {\n        data = calc(i, ms);\n        if (isnormal(data)) {\n            result += data;\n        }\n    }\n\n    return result;\n}","filepath":"src/workers/Hashrate.cpp","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5000352":{"score":0.6352742,"function_name":"Hashrate::print","code":"void Hashrate::print()\n{\n    char num1[8];\n    char num2[8];\n    char num3[8];\n    char num4[8];\n\n    LOG_INFO(m_controller-\u003econfig()-\u003eisColors() ? \"\\x1B[01;37mspeed\\x1B[0m 2.5s/60s/15m \\x1B[01;36m%s \\x1B[22;36m%s %s \\x1B[01;36mH/s\\x1B[0m max: \\x1B[01;36m%s H/s\" : \"speed 2.5s/60s/15m %s %s %s H/s max: %s H/s\",\n             format(calc(ShortInterval),  num1, sizeof(num1)),\n             format(calc(MediumInterval), num2, sizeof(num2)),\n             format(calc(LargeInterval),  num3, sizeof(num3)),\n             format(m_highest,            num4, sizeof(num4))\n             );\n}","filepath":"src/workers/Hashrate.cpp","line_number":152,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5001472":{"score":0.88225436,"function_name":"format","code":"inline const char *format(double h, char* buf, size_t size)\n{\n    if (isnormal(h)) {\n        snprintf(buf, size, \"%03.1f\", h);\n        return buf;\n    }\n\n    return \"n/a\";\n}","filepath":"src/workers/Hashrate.cpp","line_number":38,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5011744":{"score":0.7074223,"function_name":"MultiWorker\u003cN\u003e::consumeJob","code":"void MultiWorker\u003cN\u003e::consumeJob()\n{\n    xmrig::Job job = Workers::job();\n    m_sequence = Workers::sequence();\n    if (m_state.job == job) {\n        return;\n    }\n\n    save(job);\n\n    if (resume(job)) {\n        return;\n    }\n\n    m_state.job = job;\n\n    const size_t size = m_state.job.size();\n    memcpy(m_state.blob, m_state.job.blob(), m_state.job.size());\n\n    if (N \u003e 1) {\n        for (size_t i = 1; i \u003c N; ++i) {\n            memcpy(m_state.blob + (i * size), m_state.blob, size);\n        }\n    }\n\n    for (size_t i = 0; i \u003c N; ++i) {\n        if (m_state.job.isNicehash()) {\n            *nonce(i) = (*nonce(i) \u0026 0xff000000U) + (0xffffffU / m_totalWays * (m_offset + i));\n        }\n        else {\n           *nonce(i) = 0xffffffffU / m_totalWays * (m_offset + i);\n        }\n    }\n}","filepath":"src/workers/MultiWorker.cpp","line_number":224,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5015200":{"score":0.8692226,"function_name":"MultiWorker\u003cN\u003e::verify","code":"bool MultiWorker\u003cN\u003e::verify(xmrig::Variant variant, const uint8_t *referenceValue)\n{\n\n    xmrig::CpuThread::cn_hash_fun func = m_thread-\u003efn(variant);\n    if (!func) {\n        return false;\n    }\n\n    func(test_input, 76, m_hash, m_ctx, 0);\n    return memcmp(m_hash, referenceValue, sizeof m_hash) == 0;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":163,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5015296":{"score":0.8265785,"function_name":"MultiWorker\u003cN\u003e::selfTest","code":"bool MultiWorker\u003cN\u003e::selfTest()\n{\n    using namespace xmrig;\n\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT) {\n        const bool rc = verify(VARIANT_0,      test_output_v0)   \u0026\u0026\n                        verify(VARIANT_1,      test_output_v1)   \u0026\u0026\n                        verify(VARIANT_2,      test_output_v2)   \u0026\u0026\n                        verify(VARIANT_XTL,    test_output_xtl)  \u0026\u0026\n                        verify(VARIANT_MSR,    test_output_msr)  \u0026\u0026\n                        verify(VARIANT_XAO,    test_output_xao)  \u0026\u0026\n                        verify(VARIANT_RTO,    test_output_rto)  \u0026\u0026\n                        verify(VARIANT_HALF,   test_output_half) \u0026\u0026\n                        verify2(VARIANT_WOW,   test_output_wow)  \u0026\u0026\n                        verify2(VARIANT_4,     test_output_r)    \u0026\u0026\n                        verify(VARIANT_RWZ,    test_output_rwz)  \u0026\u0026\n                        verify(VARIANT_ZLS,    test_output_zls)  \u0026\u0026\n                        verify(VARIANT_DOUBLE, test_output_double);\n\n#       ifndef XMRIG_NO_CN_GPU\n        if (!rc || N \u003e 1) {\n            return rc;\n        }\n\n        return verify(VARIANT_GPU, test_output_gpu);\n#       else\n        return rc;\n#       endif\n    }\n\n#   ifndef XMRIG_NO_AEON\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_LITE) {\n        return verify(VARIANT_0,    test_output_v0_lite) \u0026\u0026\n               verify(VARIANT_1,    test_output_v1_lite);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_SUMO\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_HEAVY) {\n        return verify(VARIANT_0,    test_output_v0_heavy)  \u0026\u0026\n               verify(VARIANT_XHV,  test_output_xhv_heavy) \u0026\u0026\n               verify(VARIANT_TUBE, test_output_tube_heavy);\n    }\n#   endif\n\n#   ifndef XMRIG_NO_CN_PICO\n    if (m_thread-\u003ealgorithm() == CRYPTONIGHT_PICO) {\n        return verify(VARIANT_TRTL, test_output_pico_trtl);\n    }\n#   endif\n\n    return false;\n}","filepath":"src/workers/MultiWorker.cpp","line_number":53,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5032400":{"score":0.59579843,"function_name":"Workers::onTick","code":"void Workers::onTick(uv_timer_t *)\n{\n    for (ThreadHandle *handle : m_workers) {\n        if (!handle-\u003eworker()) {\n            return;\n        }\n\n        m_hashrate-\u003eadd(handle-\u003ethreadId(), handle-\u003eworker()-\u003ehashCount(), handle-\u003eworker()-\u003etimestamp());\n    }\n\n    if ((m_ticks++ \u0026 0xF) == 0)  {\n        m_hashrate-\u003eupdateHighest();\n    }\n}","filepath":"src/workers/Workers.cpp","line_number":320,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5032672":{"score":0.63476515,"function_name":"Workers::onResult","code":"void Workers::onResult(uv_async_t *)\n{\n    std::list\u003cxmrig::JobResult\u003e results;\n\n    uv_mutex_lock(\u0026m_mutex);\n    while (!m_queue.empty()) {\n        results.push_back(std::move(m_queue.front()));\n        m_queue.pop_front();\n    }\n    uv_mutex_unlock(\u0026m_mutex);\n\n    for (auto result : results) {\n        m_listener-\u003eonJobResult(result);\n    }\n\n    results.clear();\n}","filepath":"src/workers/Workers.cpp","line_number":301,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5033392":{"score":0.8717159,"function_name":"Workers::printHashrate","code":"void Workers::printHashrate(bool detail)\n{\n    assert(m_controller != nullptr);\n    if (!m_controller) {\n        return;\n    }\n\n    if (detail) {\n        char num1[8] = { 0 };\n        char num2[8] = { 0 };\n        char num3[8] = { 0 };\n\n        xmrig::Log::print(WHITE_BOLD_S \"| THREAD | AFFINITY | 10s H/s | 60s H/s | 15m H/s |\");\n\n        size_t i = 0;\n        for (const xmrig::IThread *thread : m_controller-\u003econfig()-\u003ethreads()) {\n             xmrig::Log::print(\"| %6zu | %8\" PRId64 \" | %7s | %7s | %7s |\",\n                            thread-\u003eindex(),\n                            thread-\u003eaffinity(),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::ShortInterval),  num1, sizeof num1),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::MediumInterval), num2, sizeof num2),\n                            Hashrate::format(m_hashrate-\u003ecalc(thread-\u003eindex(), Hashrate::LargeInterval),  num3, sizeof num3)\n                            );\n\n             i++;\n        }\n    }\n\n    m_hashrate-\u003eprint();\n}","filepath":"src/workers/Workers.cpp","line_number":94,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5034096":{"score":0.7171728,"function_name":"Workers::setEnabled","code":"void Workers::setEnabled(bool enabled)\n{\n    if (m_enabled == enabled) {\n        return;\n    }\n\n    m_enabled = enabled;\n    if (!m_active) {\n        return;\n    }\n\n    m_paused = enabled ? 0 : 1;\n    m_sequence++;\n}","filepath":"src/workers/Workers.cpp","line_number":126,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5034160":{"score":0.6664826,"function_name":"Workers::setJob","code":"void Workers::setJob(const xmrig::Job \u0026job, bool donate)\n{\n    uv_rwlock_wrlock(\u0026m_rwlock);\n    m_job = job;\n\n    if (donate) {\n        m_job.setPoolId(-1);\n    }\n    uv_rwlock_wrunlock(\u0026m_rwlock);\n\n    m_active = true;\n    if (!m_enabled) {\n        return;\n    }\n\n    m_sequence++;\n    m_paused = 0;\n}","filepath":"src/workers/Workers.cpp","line_number":142,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5034880":{"score":0.6590815,"function_name":"Workers::stop","code":"void Workers::stop()\n{\n    xmrig::Handle::close(m_timer);\n    xmrig::Handle::close(m_async);\n    m_hashrate-\u003estop();\n\n    m_paused   = 0;\n    m_sequence = 0;\n\n    for (size_t i = 0; i \u003c m_workers.size(); ++i) {\n        m_workers[i]-\u003ejoin();\n    }\n}","filepath":"src/workers/Workers.cpp","line_number":213,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5038368":{"score":0.7476251,"function_name":"Workers::start","code":"void Workers::start(IWorker *worker)\n{\n    const Worker *w = static_cast\u003cconst Worker *\u003e(worker);\n\n    uv_mutex_lock(\u0026m_mutex);\n    m_status.started++;\n    m_status.pages     += w-\u003ememory().pages;\n    m_status.hugePages += w-\u003ememory().hugePages;\n\n    if (m_status.started == m_status.threads) {\n        const double percent = (double) m_status.hugePages / m_status.pages * 100.0;\n        const size_t memory  = m_status.ways * xmrig::cn_select_memory(m_status.algo) / 1024;\n\n        LOG_INFO(GREEN_BOLD(\"READY (CPU)\") \" threads \" CYAN_BOLD(\"%zu(%zu)\") \" huge pages %s%zu/%zu %1.0f%%\\x1B[0m memory \" CYAN_BOLD(\"%zu KB\") \"\",\n                 m_status.threads, m_status.ways,\n                 (m_status.hugePages == m_status.pages ? GREEN_BOLD_S : (m_status.hugePages == 0 ? RED_BOLD_S : YELLOW_BOLD_S)),\n                 m_status.hugePages, m_status.pages, percent, memory);\n    }\n\n    uv_mutex_unlock(\u0026m_mutex);\n\n    worker-\u003estart();\n}","filepath":"src/workers/Workers.cpp","line_number":336,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5038944":{"score":0.8477421,"function_name":"Workers::onReady","code":"void Workers::onReady(void *arg)\n{\n    auto handle = static_cast\u003cThreadHandle*\u003e(arg);\n\n    IWorker *worker = nullptr;\n\n    switch (handle-\u003econfig()-\u003emultiway()) {\n    case 1:\n        worker = new MultiWorker\u003c1\u003e(handle);\n        break;\n\n    case 2:\n        worker = new MultiWorker\u003c2\u003e(handle);\n        break;\n\n    case 3:\n        worker = new MultiWorker\u003c3\u003e(handle);\n        break;\n\n    case 4:\n        worker = new MultiWorker\u003c4\u003e(handle);\n        break;\n\n    case 5:\n        worker = new MultiWorker\u003c5\u003e(handle);\n        break;\n\n    default:\n        break;\n    }\n\n    handle-\u003esetWorker(worker);\n\n    if (!worker-\u003eselfTest()) {\n        LOG_ERR(\"thread %zu error: \\\"hash self-test failed\\\".\", handle-\u003eworker()-\u003eid());\n\n        return;\n    }\n\n    start(worker);\n}","filepath":"src/workers/Workers.cpp","line_number":258,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5039328":{"score":0.70315474,"function_name":"Workers::start","code":"void Workers::start(xmrig::Controller *controller)\n{\n#   ifdef APP_DEBUG\n    LOG_NOTICE(\"THREADS ------------------------------------------------------------------\");\n    for (const xmrig::IThread *thread : controller-\u003econfig()-\u003ethreads()) {\n        thread-\u003eprint();\n    }\n    LOG_NOTICE(\"--------------------------------------------------------------------------\");\n#   endif\n\n#   ifndef XMRIG_NO_ASM\n    xmrig::CpuThread::patchAsmVariants();\n#   endif\n\n    m_controller = controller;\n\n    const std::vector\u003cxmrig::IThread *\u003e \u0026threads = controller-\u003econfig()-\u003ethreads();\n    m_status.algo    = controller-\u003econfig()-\u003ealgorithm().algo();\n    m_status.threads = threads.size();\n\n    for (const xmrig::IThread *thread : threads) {\n       m_status.ways += thread-\u003emultiway();\n    }\n\n    m_hashrate = new Hashrate(threads.size(), controller);\n\n    uv_mutex_init(\u0026m_mutex);\n    uv_rwlock_init(\u0026m_rwlock);\n\n    m_sequence = 1;\n    m_paused   = 1;\n\n    m_async = new uv_async_t;\n    uv_async_init(uv_default_loop(), m_async, Workers::onResult);\n\n    m_timer = new uv_timer_t;\n    uv_timer_init(uv_default_loop(), m_timer);\n    uv_timer_start(m_timer, Workers::onTick, 500, 500);\n\n    uint32_t offset = 0;\n\n    for (xmrig::IThread *thread : threads) {\n        ThreadHandle *handle = new ThreadHandle(thread, offset, m_status.ways);\n        offset += thread-\u003emultiway();\n\n        m_workers.push_back(handle);\n        handle-\u003estart(Workers::onReady);\n    }\n}","filepath":"src/workers/Workers.cpp","line_number":162,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.1-beta"},"5040576":{"score":0.8796017,"function_name":"createUserAgent","code":"static inline char *createUserAgent()\n{\n    const size_t max = 160;\n\n    char *buf = new char[max];\n    int length = snprintf(buf, max, \"%s/%s (Linux \", APP_NAME, APP_VERSION);\n\n#   if defined(__x86_64__)\n    length += snprintf(buf + length, max - length, \"x86_64) libuv/%s\", uv_version_string());\n#   else\n    length += snprintf(buf + length, max - length, \"i686) libuv/%s\", uv_version_string());\n#   endif\n\n#   ifdef XMRIG_NVIDIA_PROJECT\n    const int cudaVersion = cuda_get_runtime_version();\n    length += snprintf(buf + length, max - length, \" CUDA/%d.%d\", cudaVersion / 1000, cudaVersion % 100);\n#   endif\n\n#   ifdef __GNUC__\n    length += snprintf(buf + length, max - length, \" gcc/%d.%d.%d\", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#   endif\n\n    return buf;\n}","filepath":"src/common/Platform_unix.cpp","line_number":53,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5040768":{"score":0.7026644,"function_name":"Platform::setThreadAffinity","code":"bool Platform::setThreadAffinity(uint64_t cpu_id)\n{\n    cpu_set_t mn;\n    CPU_ZERO(\u0026mn);\n    CPU_SET(cpu_id, \u0026mn);\n\n#   ifndef __ANDROID__\n    return pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), \u0026mn) == 0;\n#   else\n    return sched_setaffinity(gettid(), sizeof(cpu_set_t), \u0026mn) == 0;\n#   endif\n}","filepath":"src/common/Platform_unix.cpp","line_number":79,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5040928":{"score":0.56750983,"function_name":"Platform::setThreadPriority","code":"void Platform::setThreadPriority(int priority)\n{\n    if (priority == -1) {\n        return;\n    }\n\n    int prio = 19;\n    switch (priority)\n    {\n    case 1:\n        prio = 5;\n        break;\n\n    case 2:\n        prio = 0;\n        break;\n\n    case 3:\n        prio = -5;\n        break;\n\n    case 4:\n        prio = -10;\n        break;\n\n    case 5:\n        prio = -15;\n        break;\n\n    default:\n        break;\n    }\n\n    setpriority(PRIO_PROCESS, 0, prio);\n\n#   ifdef SCHED_IDLE\n    if (priority == 0) {\n        sched_param param;\n        param.sched_priority = 0;\n\n        if (sched_setscheduler(0, SCHED_IDLE, \u0026param) != 0) {\n            sched_setscheduler(0, SCHED_BATCH, \u0026param);\n        }\n    }\n#   endif\n}","filepath":"src/common/Platform_unix.cpp","line_number":110,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta3"},"5042960":{"score":0.88269854,"function_name":"RND512P","code":"static void RND512P(uint8_t *x, uint32_t *y, uint32_t r) {\n  uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;\n  uint32_t* x32 = (uint32_t*)x;\n  x32[ 0] ^= 0x00000000^r;\n  x32[ 2] ^= 0x00000010^r;\n  x32[ 4] ^= 0x00000020^r;\n  x32[ 6] ^= 0x00000030^r;\n  x32[ 8] ^= 0x00000040^r;\n  x32[10] ^= 0x00000050^r;\n  x32[12] ^= 0x00000060^r;\n  x32[14] ^= 0x00000070^r;\n  COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n}","filepath":"src/crypto/cn/c_groestl.c","line_number":67,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.16.1"},"5046656":{"score":0.8692586,"function_name":"RND512Q","code":"static void RND512Q(uint8_t *x, uint32_t *y, uint32_t r) {\n  uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;\n  uint32_t* x32 = (uint32_t*)x;\n  x32[ 0] = ~x32[ 0];\n  x32[ 1] ^= 0xffffffff^r;\n  x32[ 2] = ~x32[ 2];\n  x32[ 3] ^= 0xefffffff^r;\n  x32[ 4] = ~x32[ 4];\n  x32[ 5] ^= 0xdfffffff^r;\n  x32[ 6] = ~x32[ 6];\n  x32[ 7] ^= 0xcfffffff^r;\n  x32[ 8] = ~x32[ 8];\n  x32[ 9] ^= 0xbfffffff^r;\n  x32[10] = ~x32[10];\n  x32[11] ^= 0xafffffff^r;\n  x32[12] = ~x32[12];\n  x32[13] ^= 0x9fffffff^r;\n  x32[14] = ~x32[14];\n  x32[15] ^= 0x8fffffff^r;\n  COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n  COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\n}","filepath":"src/crypto/cn/c_groestl.c","line_number":89,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.16.1"},"5050384":{"score":0.71932244,"function_name":"Transform","code":"static void Transform(groestlHashState *ctx,\n\t       const uint8_t *input,\n\t       int msglen) {\n\n  /* digest message, one block at a time */\n  for (; msglen \u003e= SIZE512;\n       msglen -= SIZE512, input += SIZE512) {\n    F512(ctx-\u003echaining,(uint32_t*)input);\n\n    /* increment block counter */\n    ctx-\u003eblock_counter1++;\n    if (ctx-\u003eblock_counter1 == 0) ctx-\u003eblock_counter2++;\n  }\n}","filepath":"src/crypto/cn/c_groestl.c","line_number":163,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.16.1"},"5051696":{"score":0.7610411,"function_name":"groestl","code":"void groestl(const BitSequence* data,\n\t\tDataLength databitlen,\n\t\tBitSequence* hashval) {\n\n  groestlHashState context;\n\n  /* initialise */\n    Init(\u0026context);\n\n\n  /* process message */\n  Update(\u0026context, data, databitlen);\n\n  /* finalise */\n  Final(\u0026context, hashval);\n}","filepath":"src/crypto/cn/c_groestl.c","line_number":335,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.16.1"},"5055328":{"score":0.95888054,"function_name":"blake256_init","code":"void blake256_init(state *S) {\n    S-\u003eh[0] = 0x6A09E667;\n    S-\u003eh[1] = 0xBB67AE85;\n    S-\u003eh[2] = 0x3C6EF372;\n    S-\u003eh[3] = 0xA54FF53A;\n    S-\u003eh[4] = 0x510E527F;\n    S-\u003eh[5] = 0x9B05688C;\n    S-\u003eh[6] = 0x1F83D9AB;\n    S-\u003eh[7] = 0x5BE0CD19;\n    S-\u003et[0] = S-\u003et[1] = S-\u003ebuflen = S-\u003enullt = 0;\n    S-\u003es[0] = S-\u003es[1] = S-\u003es[2] = S-\u003es[3] = 0;\n}","filepath":"src/Native/libcryptonote/crypto/blake256.c","line_number":129,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5055440":{"score":0.9029009,"function_name":"blake224_init","code":"void blake224_init(state *S) {\n    S-\u003eh[0] = 0xC1059ED8;\n    S-\u003eh[1] = 0x367CD507;\n    S-\u003eh[2] = 0x3070DD17;\n    S-\u003eh[3] = 0xF70E5939;\n    S-\u003eh[4] = 0xFFC00B31;\n    S-\u003eh[5] = 0x68581511;\n    S-\u003eh[6] = 0x64F98FA7;\n    S-\u003eh[7] = 0xBEFA4FA4;\n    S-\u003et[0] = S-\u003et[1] = S-\u003ebuflen = S-\u003enullt = 0;\n    S-\u003es[0] = S-\u003es[1] = S-\u003es[2] = S-\u003es[3] = 0;\n}","filepath":"src/Native/libcryptonote/crypto/blake256.c","line_number":142,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5055552":{"score":0.91520023,"function_name":"blake256_update","code":"void blake256_update(state *S, const uint8_t *data, uint64_t datalen) {\n    int left = S-\u003ebuflen \u003e\u003e 3;\n    int fill = 64 - left;\n\n    if (left \u0026\u0026 (((datalen \u003e\u003e 3) \u0026 0x3F) \u003e= (unsigned) fill)) {\n        memcpy((void *) (S-\u003ebuf + left), (void *) data, fill);\n        S-\u003et[0] += 512;\n        if (S-\u003et[0] == 0) S-\u003et[1]++;\n        blake256_compress(S, S-\u003ebuf);\n        data += fill;\n        datalen -= (fill \u003c\u003c 3);\n        left = 0;\n    }\n\n    while (datalen \u003e= 512) {\n        S-\u003et[0] += 512;\n        if (S-\u003et[0] == 0) S-\u003et[1]++;\n        blake256_compress(S, data);\n        data += 64;\n        datalen -= 512;\n    }\n\n    if (datalen \u003e 0) {\n        memcpy((void *) (S-\u003ebuf + left), (void *) data, datalen \u003e\u003e 3);\n        S-\u003ebuflen = (left \u003c\u003c 3) + datalen;\n    } else {\n        S-\u003ebuflen = 0;\n    }\n}","filepath":"src/Native/libcryptonote/crypto/blake256.c","line_number":156,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5056016":{"score":0.80793077,"function_name":"Update","code":"static void Update(groestlHashState* ctx,\n\t\t  const BitSequence* input,\n\t\t  DataLength databitlen) {\n  int index = 0;\n  int msglen = (int)(databitlen/8);\n  int rem = (int)(databitlen%8);\n\n  /* if the buffer contains data that has not yet been digested, first\n     add data to buffer until full */\n  if (ctx-\u003ebuf_ptr) {\n    while (ctx-\u003ebuf_ptr \u003c SIZE512 \u0026\u0026 index \u003c msglen) {\n      ctx-\u003ebuffer[(int)ctx-\u003ebuf_ptr++] = input[index++];\n    }\n    if (ctx-\u003ebuf_ptr \u003c SIZE512) {\n      /* buffer still not full, return */\n      if (rem) {\n\tctx-\u003ebits_in_last_byte = rem;\n\tctx-\u003ebuffer[(int)ctx-\u003ebuf_ptr++] = input[index];\n      }\n      return;\n    }\n\n    /* digest buffer */\n    ctx-\u003ebuf_ptr = 0;\n    Transform(ctx, ctx-\u003ebuffer, SIZE512);\n  }\n\n  /* digest bulk of message */\n  Transform(ctx, input+index, msglen-index);\n  index += ((msglen-index)/SIZE512)*SIZE512;\n\n  /* store remaining data in buffer */\n  while (index \u003c msglen) {\n    ctx-\u003ebuffer[(int)ctx-\u003ebuf_ptr++] = input[index++];\n  }\n\n  /* if non-integral number of bytes have been supplied, store\n     remaining bits in last byte, together with information about\n     number of bits */\n  if (rem) {\n    ctx-\u003ebits_in_last_byte = rem;\n    ctx-\u003ebuffer[(int)ctx-\u003ebuf_ptr++] = input[index];\n  }\n}","filepath":"src/crypto/cn/c_groestl.c","line_number":226,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v6.16.1"},"5056480":{"score":0.8967034,"function_name":"blake256_final_h","code":"void blake256_final_h(state *S, uint8_t *digest, uint8_t pa, uint8_t pb) {\n    uint8_t msglen[8];\n    uint32_t lo = S-\u003et[0] + S-\u003ebuflen, hi = S-\u003et[1];\n    if (lo \u003c (unsigned) S-\u003ebuflen) hi++;\n    U32TO8(msglen + 0, hi);\n    U32TO8(msglen + 4, lo);\n\n    if (S-\u003ebuflen == 440) { /* one padding byte */\n        S-\u003et[0] -= 8;\n        blake256_update(S, \u0026pa, 8);\n    } else {\n        if (S-\u003ebuflen \u003c 440) { /* enough space to fill the block  */\n            if (S-\u003ebuflen == 0) S-\u003enullt = 1;\n            S-\u003et[0] -= 440 - S-\u003ebuflen;\n            blake256_update(S, padding, 440 - S-\u003ebuflen);\n        } else { /* need 2 compressions */\n            S-\u003et[0] -= 512 - S-\u003ebuflen;\n            blake256_update(S, padding, 512 - S-\u003ebuflen);\n            S-\u003et[0] -= 440;\n            blake256_update(S, padding + 1, 440);\n            S-\u003enullt = 1;\n        }\n        blake256_update(S, \u0026pb, 8);\n        S-\u003et[0] -= 8;\n    }\n    S-\u003et[0] -= 64;\n    blake256_update(S, msglen, 64);\n\n    U32TO8(digest +  0, S-\u003eh[0]);\n    U32TO8(digest +  4, S-\u003eh[1]);\n    U32TO8(digest +  8, S-\u003eh[2]);\n    U32TO8(digest + 12, S-\u003eh[3]);\n    U32TO8(digest + 16, S-\u003eh[4]);\n    U32TO8(digest + 20, S-\u003eh[5]);\n    U32TO8(digest + 24, S-\u003eh[6]);\n    U32TO8(digest + 28, S-\u003eh[7]);\n}","filepath":"src/Native/libcryptonote/crypto/blake256.c","line_number":191,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5060528":{"score":0.90825194,"function_name":"hmac_blake256_init","code":"void hmac_blake256_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {\n    const uint8_t *key = _key;\n    uint8_t keyhash[32];\n    uint8_t pad[64];\n    uint64_t i;\n\n    if (keylen \u003e 64) {\n        blake256_hash(keyhash, key, keylen);\n        key = keyhash;\n        keylen = 32;\n    }\n\n    blake256_init(\u0026S-\u003einner);\n    memset(pad, 0x36, 64);\n    for (i = 0; i \u003c keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake256_update(\u0026S-\u003einner, pad, 512);\n\n    blake256_init(\u0026S-\u003eouter);\n    memset(pad, 0x5c, 64);\n    for (i = 0; i \u003c keylen; ++i) {\n        pad[i] ^= key[i];\n    }\n    blake256_update(\u0026S-\u003eouter, pad, 512);\n\n    memset(keyhash, 0, 32);\n}","filepath":"src/Native/libcryptonote/crypto/blake256.c","line_number":254,"entry_url":"https://github.com/coinfoundry/miningcore.git","slot_name":"0.10"},"5077344":{"score":0.6405966,"function_name":"skein_hash","code":"SkeinHashReturn skein_hash(int hashbitlen, const SkeinBitSequence *data, /* all-in-one call */\n                SkeinDataLength databitlen,SkeinBitSequence *hashval)\n{\n  hashState  state;\n  SkeinHashReturn r = Init(\u0026state,hashbitlen);\n  if (r == SKEIN_SUCCESS)\n  { /* these calls do not fail when called properly */\n    r = Update(\u0026state,data,databitlen);\n    Final(\u0026state,hashval);\n  }\n  return r;\n}","filepath":"src/crypto/c_skein.c","line_number":657,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5084352":{"score":0.7150341,"function_name":"Skein_512_Process_Block","code":"static void Skein_512_Process_Block(Skein_512_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\n    { /* do it in C */\n    enum\n        {\n        WCNT = SKEIN_512_STATE_WORDS\n        };\n#undef  RCNT\n#define RCNT  (SKEIN_512_ROUNDS_TOTAL/8)\n\n#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\n#define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)\n#else\n#define SKEIN_UNROLL_512 (0)\n#endif\n\n#if SKEIN_UNROLL_512\n#if (RCNT % SKEIN_UNROLL_512)\n#error \"Invalid SKEIN_UNROLL_512\"               /* sanity check on unroll count */\n#endif\n    size_t  r;\n    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\n#else\n    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\n#endif\n    u64b_t  X0,X1,X2,X3,X4,X5,X6,X7;            /* local copy of vars, for speed */\n    u64b_t  w [WCNT];                           /* local copy of input block */\n#ifdef SKEIN_DEBUG\n    const u64b_t *Xptr[8];                      /* use for debugging (help compiler put Xn in registers) */\n    Xptr[0] = \u0026X0;  Xptr[1] = \u0026X1;  Xptr[2] = \u0026X2;  Xptr[3] = \u0026X3;\n    Xptr[4] = \u0026X4;  Xptr[5] = \u0026X5;  Xptr[6] = \u0026X6;  Xptr[7] = \u0026X7;\n#endif\n\n    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\n    ts[0] = ctx-\u003eh.T[0];\n    ts[1] = ctx-\u003eh.T[1];\n    do  {\n        /* this implementation only supports 2**64 input bytes (no carry out here) */\n        ts[0] += byteCntAdd;                    /* update processed length */\n\n        /* precompute the key schedule for this block */\n        ks[0] = ctx-\u003eX[0];\n        ks[1] = ctx-\u003eX[1];\n        ks[2] = ctx-\u003eX[2];\n        ks[3] = ctx-\u003eX[3];\n        ks[4] = ctx-\u003eX[4];\n        ks[5] = ctx-\u003eX[5];\n        ks[6] = ctx-\u003eX[6];\n        ks[7] = ctx-\u003eX[7];\n        ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ \n                ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\n\n        ts[2] = ts[0] ^ ts[1];\n\n        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\n        DebugSaveTweak(ctx);\n        Skein_Show_Block(BLK_BITS,\u0026ctx-\u003eh,ctx-\u003eX,blkPtr,w,ks,ts);\n\n        X0   = w[0] + ks[0];                    /* do the first full key injection */\n        X1   = w[1] + ks[1];\n        X2   = w[2] + ks[2];\n        X3   = w[3] + ks[3];\n        X4   = w[4] + ks[4];\n        X5   = w[5] + ks[5] + ts[0];\n        X6   = w[6] + ks[6] + ts[1];\n        X7   = w[7] + ks[7];\n\n        blkPtr += SKEIN_512_BLOCK_BYTES;\n\n        Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INITIAL,Xptr);\n        /* run the rounds */\n#define Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                  \\\n    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \\\n    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \\\n    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \\\n    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \\\n\n#if SKEIN_UNROLL_512 == 0                       \n#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)      /* unrolled */  \\\n    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,rNum,Xptr);\n\n#define I512(R)                                                     \\\n    X0   += ks[((R)+1) % 9];   /* inject the key schedule value */  \\\n    X1   += ks[((R)+2) % 9];                                        \\\n    X2   += ks[((R)+3) % 9];                                        \\\n    X3   += ks[((R)+4) % 9];                                        \\\n    X4   += ks[((R)+5) % 9];                                        \\\n    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \\\n    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \\\n    X7   += ks[((R)+8) % 9] +     (R)+1;                            \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INJECT,Xptr);\n#else                                       /* looping version */\n#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,4*(r-1)+rNum,Xptr);\n\n#define I512(R)                                                     \\\n    X0   += ks[r+(R)+0];        /* inject the key schedule value */ \\\n    X1   += ks[r+(R)+1];                                            \\\n    X2   += ks[r+(R)+2];                                            \\\n    X3   += ks[r+(R)+3];                                            \\\n    X4   += ks[r+(R)+4];                                            \\\n    X5   += ks[r+(R)+5] + ts[r+(R)+0];                              \\\n    X6   += ks[r+(R)+6] + ts[r+(R)+1];                              \\\n    X7   += ks[r+(R)+7] +    r+(R)   ;                              \\\n    ks[r +       (R)+8] = ks[r+(R)-1];  /* rotate key schedule */   \\\n    ts[r +       (R)+2] = ts[r+(R)-1];                              \\\n    Skein_Show_R_Ptr(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_KEY_INJECT,Xptr);\n\n    for (r=1;r \u003c 2*RCNT;r+=2*SKEIN_UNROLL_512)   /* loop thru it */\n#endif                         /* end of looped code definitions */\n        {\n#define R512_8_rounds(R)  /* do 8 full rounds */  \\\n        R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1);   \\\n        R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2);   \\\n        R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3);   \\\n        R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4);   \\\n        I512(2*(R));                              \\\n        R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5);   \\\n        R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6);   \\\n        R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7);   \\\n        R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8);   \\\n        I512(2*(R)+1);        /* and key injection */\n\n        R512_8_rounds( 0);\n\n#define R512_Unroll_R(NN) ((SKEIN_UNROLL_512 == 0 \u0026\u0026 SKEIN_512_ROUNDS_TOTAL/8 \u003e (NN)) || (SKEIN_UNROLL_512 \u003e (NN)))\n\n  #if   R512_Unroll_R( 1)\n        R512_8_rounds( 1);\n  #endif\n  #if   R512_Unroll_R( 2)\n        R512_8_rounds( 2);\n  #endif\n  #if   R512_Unroll_R( 3)\n        R512_8_rounds( 3);\n  #endif\n  #if   R512_Unroll_R( 4)\n        R512_8_rounds( 4);\n  #endif\n  #if   R512_Unroll_R( 5)\n        R512_8_rounds( 5);\n  #endif\n  #if   R512_Unroll_R( 6)\n        R512_8_rounds( 6);\n  #endif\n  #if   R512_Unroll_R( 7)\n        R512_8_rounds( 7);\n  #endif\n  #if   R512_Unroll_R( 8)\n        R512_8_rounds( 8);\n  #endif\n  #if   R512_Unroll_R( 9)\n        R512_8_rounds( 9);\n  #endif\n  #if   R512_Unroll_R(10)\n        R512_8_rounds(10);\n  #endif\n  #if   R512_Unroll_R(11)\n        R512_8_rounds(11);\n  #endif\n  #if   R512_Unroll_R(12)\n        R512_8_rounds(12);\n  #endif\n  #if   R512_Unroll_R(13)\n        R512_8_rounds(13);\n  #endif\n  #if   R512_Unroll_R(14)\n        R512_8_rounds(14);\n  #endif\n  #if  (SKEIN_UNROLL_512 \u003e 14)\n#error  \"need more unrolling in Skein_512_Process_Block\"\n  #endif\n        }\n\n        /* do the final \"feedforward\" xor, update context chaining vars */\n        ctx-\u003eX[0] = X0 ^ w[0];\n        ctx-\u003eX[1] = X1 ^ w[1];\n        ctx-\u003eX[2] = X2 ^ w[2];\n        ctx-\u003eX[3] = X3 ^ w[3];\n        ctx-\u003eX[4] = X4 ^ w[4];\n        ctx-\u003eX[5] = X5 ^ w[5];\n        ctx-\u003eX[6] = X6 ^ w[6];\n        ctx-\u003eX[7] = X7 ^ w[7];\n        Skein_Show_Round(BLK_BITS,\u0026ctx-\u003eh,SKEIN_RND_FEED_FWD,ctx-\u003eX);\n\n        ts[1] \u0026= ~SKEIN_T1_FLAG_FIRST;\n        }\n    while (--blkCnt);\n    ctx-\u003eh.T[0] = ts[0];\n    ctx-\u003eh.T[1] = ts[1];\n    }","filepath":"src/crypto/c_skein.c","line_number":265,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5088384":{"score":0.8733017,"function_name":"Skein_512_Update","code":"static int Skein_512_Update(Skein_512_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt)\n    {\n    size_t n;\n\n    Skein_Assert(ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\n\n    /* process full blocks, if any */\n    if (msgByteCnt + ctx-\u003eh.bCnt \u003e SKEIN_512_BLOCK_BYTES)\n        {\n        if (ctx-\u003eh.bCnt)                              /* finish up any buffered message data */\n            {\n            n = SKEIN_512_BLOCK_BYTES - ctx-\u003eh.bCnt;  /* # bytes free in buffer b[] */\n            if (n)\n                {\n                Skein_assert(n \u003c msgByteCnt);         /* check on our logic here */\n                memcpy(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],msg,n);\n                msgByteCnt  -= n;\n                msg         += n;\n                ctx-\u003eh.bCnt += n;\n                }\n            Skein_assert(ctx-\u003eh.bCnt == SKEIN_512_BLOCK_BYTES);\n            Skein_512_Process_Block(ctx,ctx-\u003eb,1,SKEIN_512_BLOCK_BYTES);\n            ctx-\u003eh.bCnt = 0;\n            }\n        /* now process any remaining full blocks, directly from input message data */\n        if (msgByteCnt \u003e SKEIN_512_BLOCK_BYTES)\n            {\n            n = (msgByteCnt-1) / SKEIN_512_BLOCK_BYTES;   /* number of full blocks to process */\n            Skein_512_Process_Block(ctx,msg,n,SKEIN_512_BLOCK_BYTES);\n            msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;\n            msg        += n * SKEIN_512_BLOCK_BYTES;\n            }\n        Skein_assert(ctx-\u003eh.bCnt == 0);\n        }\n\n    /* copy any remaining source message data bytes into b[] */\n    if (msgByteCnt)\n        {\n        Skein_assert(msgByteCnt + ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES);\n        memcpy(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],msg,msgByteCnt);\n        ctx-\u003eh.bCnt += msgByteCnt;\n        }\n\n    return SKEIN_SUCCESS;\n    }","filepath":"src/crypto/c_skein.c","line_number":506,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5088592":{"score":0.7936028,"function_name":"Skein_512_Final","code":"static int Skein_512_Final(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\n    {\n    size_t i,n,byteCnt;\n    u64b_t X[SKEIN_512_STATE_WORDS];\n    Skein_Assert(ctx-\u003eh.bCnt \u003c= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\n\n    ctx-\u003eh.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\n    if (ctx-\u003eh.bCnt \u003c SKEIN_512_BLOCK_BYTES)            /* zero pad b[] if necessary */\n        memset(\u0026ctx-\u003eb[ctx-\u003eh.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx-\u003eh.bCnt);\n\n    Skein_512_Process_Block(ctx,ctx-\u003eb,1,ctx-\u003eh.bCnt);  /* process the final block */\n    \n    /* now output the result */\n    byteCnt = (ctx-\u003eh.hashBitLen + 7) \u003e\u003e 3;             /* total number of output bytes */\n\n    /* run Threefish in \"counter mode\" to generate output */\n    memset(ctx-\u003eb,0,sizeof(ctx-\u003eb));  /* zero out b[], so it can hold the counter */\n    memcpy(X,ctx-\u003eX,sizeof(X));       /* keep a local copy of counter mode \"key\" */\n    for (i=0;i*SKEIN_512_BLOCK_BYTES \u003c byteCnt;i++)\n        {\n        ((u64b_t *)ctx-\u003eb)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\n        Skein_Start_New_Type(ctx,OUT_FINAL);\n        Skein_512_Process_Block(ctx,ctx-\u003eb,1,sizeof(u64b_t)); /* run \"counter mode\" */\n        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\n        if (n \u003e= SKEIN_512_BLOCK_BYTES)\n            n  = SKEIN_512_BLOCK_BYTES;\n        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx-\u003eX,n);   /* \"output\" the ctr mode bytes */\n        Skein_Show_Final(512,\u0026ctx-\u003eh,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\n        memcpy(ctx-\u003eX,X,sizeof(X));   /* restore the counter mode key for next time */\n        }\n    return SKEIN_SUCCESS;\n    }","filepath":"src/crypto/c_skein.c","line_number":554,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5089920":{"score":0.7253907,"function_name":"xmr_skein","code":"void xmr_skein(const SkeinBitSequence *data, SkeinBitSequence *hashval){\n  #define XMR_HASHBITLEN 256\n  #define XMR_DATABITLEN 1600\n\n  // Init\n  hashState  state;\n  state.statebits = 64*SKEIN_512_STATE_WORDS;\n\n  // Skein_512_Init(\u0026state.u.ctx_512, (size_t)XMR_HASHBITLEN);\n  state.u.ctx_512.h.hashBitLen = XMR_HASHBITLEN;\n  memcpy(state.u.ctx_512.X,SKEIN_512_IV_256,sizeof(state.u.ctx_512.X));\n  Skein_512_Ctxt_t* ctx = \u0026(state.u.ctx_512);\n  Skein_Start_New_Type(ctx,MSG);\n\n  // Update\n  if ((XMR_DATABITLEN \u0026 7) == 0){  /* partial bytes? */\n    Skein_512_Update(\u0026state.u.ctx_512,data,XMR_DATABITLEN \u003e\u003e 3);\n  }else{   /* handle partial final byte */\n    size_t bCnt = (XMR_DATABITLEN \u003e\u003e 3) + 1;                  /* number of bytes to handle (nonzero here!) */\n    u08b_t b,mask;\n\n    mask = (u08b_t) (1u \u003c\u003c (7 - (XMR_DATABITLEN \u0026 7)));       /* partial byte bit mask */\n    b    = (u08b_t) ((data[bCnt-1] \u0026 (0-mask)) | mask);   /* apply bit padding on final byte */\n\n    Skein_512_Update(\u0026state.u.ctx_512,data,bCnt-1); /* process all but the final byte    */\n    Skein_512_Update(\u0026state.u.ctx_512,\u0026b  ,  1   ); /* process the (masked) partial byte */\n    Skein_Set_Bit_Pad_Flag(state.u.h);                    /* set tweak flag for the final call */\n  }\n\n  // Finalize\n  Skein_512_Final(\u0026state.u.ctx_512, hashval);\n}","filepath":"src/crypto/c_skein.c","line_number":670,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.1.0"},"5090832":{"score":0.7834325,"function_name":"ApiRouter::exec","code":"void ApiRouter::exec(const xmrig::HttpRequest \u0026req, xmrig::HttpReply \u0026reply)\n{\n    if (req.method() == xmrig::HttpRequest::Put \u0026\u0026 req.match(\"/1/config\")) {\n        m_controller-\u003econfig()-\u003ereload(req.body());\n        return;\n    }\n\n    reply.status = 404;\n}","filepath":"src/api/ApiRouter.cpp","line_number":121,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5090944":{"score":0.71641064,"function_name":"ApiRouter::setWorkerId","code":"void ApiRouter::setWorkerId(const char *id)\n{\n    memset(m_workerId, 0, sizeof(m_workerId));\n\n    if (id \u0026\u0026 strlen(id) \u003e 0) {\n        strncpy(m_workerId, id, sizeof(m_workerId) - 1);\n    }\n    else {\n        gethostname(m_workerId, sizeof(m_workerId) - 1);\n    }\n}","filepath":"src/api/ApiRouter.cpp","line_number":311,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5091440":{"score":0.5997142,"function_name":"ApiRouter::ApiRouter","code":"ApiRouter::ApiRouter(xmrig::Controller *controller) :\n    m_controller(controller)\n{\n    m_threads  = controller-\u003econfig()-\u003ethreadsCount();\n    m_hashrate = new double[m_threads * 3]();\n\n    memset(m_totalHashrate, 0, sizeof(m_totalHashrate));\n    memset(m_workerId, 0, sizeof(m_workerId));\n\n    setWorkerId(controller-\u003econfig()-\u003eapiWorkerId());\n    genId();\n}","filepath":"src/api/ApiRouter.cpp","line_number":68,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5116464":{"score":0.78554815,"function_name":"ApiRouter::updateWorkerId","code":"void ApiRouter::updateWorkerId(const char *id, const char *previousId)\n{\n    if (id == previousId) {\n        return;\n    }\n\n    if (id != nullptr \u0026\u0026 previousId != nullptr \u0026\u0026 strcmp(id, previousId) == 0) {\n        return;\n    }\n\n    setWorkerId(id);\n}","filepath":"src/api/ApiRouter.cpp","line_number":324,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5118160":{"score":0.72262776,"function_name":"ApiRouter::finalize","code":"void ApiRouter::finalize(xmrig::HttpReply \u0026reply, rapidjson::Document \u0026doc) const\n{\n    rapidjson::StringBuffer buffer(0, 4096);\n    rapidjson::PrettyWriter\u003crapidjson::StringBuffer\u003e writer(buffer);\n    writer.SetMaxDecimalPlaces(10);\n    doc.Accept(writer);\n\n    reply.status = 200;\n    reply.buf    = strdup(buffer.GetString());\n    reply.size   = buffer.GetSize();\n}","filepath":"src/api/ApiRouter.cpp","line_number":159,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5118656":{"score":0.8940158,"function_name":"ApiRouter::ApiRouter::get","code":"void ApiRouter::ApiRouter::get(const xmrig::HttpRequest \u0026req, xmrig::HttpReply \u0026reply) const\n{\n    rapidjson::Document doc;\n\n    if (req.match(\"/1/config\")) {\n        if (req.isRestricted()) {\n            reply.status = 403;\n            return;\n        }\n\n        m_controller-\u003econfig()-\u003egetJSON(doc);\n\n        return finalize(reply, doc);\n    }\n\n    if (req.match(\"/1/threads\")) {\n        getThreads(doc);\n\n        return finalize(reply, doc);\n    }\n\n    doc.SetObject();\n\n    getIdentify(doc);\n    getMiner(doc);\n    getHashrate(doc);\n    getResults(doc);\n    getConnection(doc);\n\n    return finalize(reply, doc);\n}","filepath":"src/api/ApiRouter.cpp","line_number":88,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5130960":{"score":0.85622036,"function_name":"Httpd::Httpd","code":"Httpd::Httpd(int port, const char *accessToken, bool IPv6, bool restricted) :\n    m_idle(true),\n    m_IPv6(IPv6),\n    m_restricted(restricted),\n    m_accessToken(accessToken ? strdup(accessToken) : nullptr),\n    m_port(port),\n    m_daemon(nullptr)\n{\n    uv_timer_init(uv_default_loop(), \u0026m_timer);\n    m_timer.data = this;\n}","filepath":"src/api/Httpd.cpp","line_number":67,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131040":{"score":0.6280056,"function_name":"Httpd::~Httpd","code":"Httpd::~Httpd()\n{\n    uv_timer_stop(\u0026m_timer);\n\n    if (m_daemon) {\n        MHD_stop_daemon(m_daemon);\n    }\n\n    delete m_accessToken;\n}","filepath":"src/api/Httpd.cpp","line_number":80,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131088":{"score":0.872442,"function_name":"Httpd::start","code":"bool Httpd::start()\n{\n    if (!m_port) {\n        return false;\n    }\n\n    unsigned int flags = 0;\n#   if MHD_VERSION \u003e= 0x00093500\n    if (m_IPv6 \u0026\u0026 MHD_is_feature_supported(MHD_FEATURE_IPv6)) {\n        flags |= MHD_USE_DUAL_STACK;\n    }\n\n    if (MHD_is_feature_supported(MHD_FEATURE_EPOLL)) {\n        flags |= MHD_USE_EPOLL_LINUX_ONLY;\n    }\n#   endif\n\n    m_daemon = MHD_start_daemon(flags, m_port, nullptr, nullptr, \u0026Httpd::handler, this, MHD_OPTION_END);\n    if (!m_daemon) {\n        LOG_ERR(\"HTTP Daemon failed to start.\");\n        return false;\n    }\n\n    uv_timer_start(\u0026m_timer, Httpd::onTimer, kIdleInterval, kIdleInterval);\n    return true;\n}","filepath":"src/api/Httpd.cpp","line_number":92,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131312":{"score":0.81145436,"function_name":"Httpd::process","code":"int Httpd::process(xmrig::HttpRequest \u0026req)\n{\n    xmrig::HttpReply reply;\n    if (!req.process(m_accessToken, m_restricted, reply)) {\n        return req.end(reply);\n    }\n\n    if (!req.isFulfilled()) {\n        return MHD_YES;\n    }\n\n    Api::exec(req, reply);\n\n    return req.end(reply);\n}","filepath":"src/api/Httpd.cpp","line_number":120,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131456":{"score":0.7314218,"function_name":"Httpd::run","code":"void Httpd::run()\n{\n    MHD_run(m_daemon);\n\n    const MHD_DaemonInfo *info = MHD_get_daemon_info(m_daemon, MHD_DAEMON_INFO_CURRENT_CONNECTIONS);\n    if (m_idle \u0026\u0026 info-\u003enum_connections) {\n        uv_timer_set_repeat(\u0026m_timer, kActiveInterval);\n        m_idle = false;\n    }\n    else if (!m_idle \u0026\u0026 !info-\u003enum_connections) {\n        uv_timer_set_repeat(\u0026m_timer, kIdleInterval);\n        m_idle = true;\n    }\n}","filepath":"src/api/Httpd.cpp","line_number":137,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131568":{"score":0.818786,"function_name":"xmrig::HttpRequest::HttpRequest","code":"xmrig::HttpRequest::HttpRequest(MHD_Connection *connection, const char *url, const char *method, const char *uploadData, size_t *uploadSize, void **cls) :\n    m_fulfilled(true),\n    m_restricted(true),\n    m_uploadData(uploadData),\n    m_url(url),\n    m_body(static_cast\u003cHttpBody*\u003e(*cls)),\n    m_method(Unsupported),\n    m_connection(connection),\n    m_uploadSize(uploadSize),\n    m_cls(cls)\n{\n    if (strcmp(method, MHD_HTTP_METHOD_OPTIONS) == 0) {\n        m_method = Options;\n    }\n    else if (strcmp(method, MHD_HTTP_METHOD_GET) == 0) {\n        m_method = Get;\n    }\n    else if (strcmp(method, MHD_HTTP_METHOD_PUT) == 0) {\n        m_method = Put;\n    }\n}","filepath":"src/api/HttpRequest.cpp","line_number":38,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5131776":{"score":0.7753455,"function_name":"xmrig::HttpRequest::process","code":"bool xmrig::HttpRequest::process(const char *accessToken, bool restricted, xmrig::HttpReply \u0026reply)\n{\n    m_restricted = restricted || !accessToken;\n\n    if (m_body) {\n        if (*m_uploadSize != 0) {\n            if (!m_body-\u003ewrite(m_uploadData, *m_uploadSize)) {\n                *m_cls       = nullptr;\n                m_fulfilled  = true;\n                reply.status = MHD_HTTP_PAYLOAD_TOO_LARGE;\n                return false;\n            }\n\n            *m_uploadSize = 0;\n            m_fulfilled   = false;\n            return true;\n        }\n\n        m_fulfilled = true;\n        return true;\n    }\n\n    reply.status = auth(accessToken);\n    if (reply.status != MHD_HTTP_OK) {\n        return false;\n    }\n\n    if (m_restricted \u0026\u0026 m_method != Get) {\n        reply.status = MHD_HTTP_FORBIDDEN;\n        return false;\n    }\n\n    if (m_method == Get) {\n        return true;\n    }\n\n    const char *contentType = MHD_lookup_connection_value(m_connection, MHD_HEADER_KIND, \"Content-Type\");\n    if (!contentType || strcmp(contentType, \"application/json\") != 0) {\n        reply.status = MHD_HTTP_UNSUPPORTED_MEDIA_TYPE;\n        return false;\n    }\n\n    m_body      = new xmrig::HttpBody();\n    m_fulfilled = false;\n    *m_cls      = m_body;\n\n    return true;\n}","filepath":"src/api/HttpRequest.cpp","line_number":75,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132656":{"score":0.94162494,"function_name":"xmrig::HttpRequest::end","code":"int xmrig::HttpRequest::end(int status, MHD_Response *rsp)\n{\n    if (!rsp) {\n        rsp = MHD_create_response_from_buffer(0, nullptr, MHD_RESPMEM_PERSISTENT);\n    }\n\n    MHD_add_response_header(rsp, \"Content-Type\", \"application/json\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Origin\", \"*\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Methods\", \"GET, PUT\");\n    MHD_add_response_header(rsp, \"Access-Control-Allow-Headers\", \"Authorization\");\n\n    const int ret = MHD_queue_response(m_connection, status, rsp);\n    MHD_destroy_response(rsp);\n    return ret;\n}","filepath":"src/api/HttpRequest.cpp","line_number":141,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132800":{"score":0.8942715,"function_name":"xmrig::HttpRequest::auth","code":"int xmrig::HttpRequest::auth(const char *accessToken)\n{\n    if (!accessToken) {\n        return MHD_HTTP_OK;\n    }\n\n    const char *header = MHD_lookup_connection_value(m_connection, MHD_HEADER_KIND, \"Authorization\");\n    if (accessToken \u0026\u0026 !header) {\n        return MHD_HTTP_UNAUTHORIZED;\n    }\n\n    const size_t size = strlen(header);\n    if (size \u003c 8 || strlen(accessToken) != size - 7 || memcmp(\"Bearer \", header, 7) != 0) {\n        return MHD_HTTP_FORBIDDEN;\n    }\n\n    return strncmp(accessToken, header + 7, strlen(accessToken)) == 0 ? MHD_HTTP_OK : MHD_HTTP_FORBIDDEN;\n}","filepath":"src/api/HttpRequest.cpp","line_number":158,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.6.0-beta1"},"5132976":{"score":0.68498063,"function_name":"xmrig::Client::Tls::Tls","code":"xmrig::Client::Tls::Tls(Client *client) :\n    m_ready(false),\n    m_buf(),\n    m_fingerprint(),\n    m_client(client),\n    m_ssl(nullptr)\n{\n    m_ctx = SSL_CTX_new(SSLv23_method());\n    assert(m_ctx != nullptr);\n\n    if (!m_ctx) {\n        return;\n    }\n\n    m_writeBio = BIO_new(BIO_s_mem());\n    m_readBio  = BIO_new(BIO_s_mem());\n    SSL_CTX_set_options(m_ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);\n}","filepath":"src/base/net/stratum/Tls.cpp","line_number":41,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5133200":{"score":0.6416475,"function_name":"xmrig::Client::Tls::~Tls","code":"xmrig::Client::Tls::~Tls()\n{\n    if (m_ctx) {\n        SSL_CTX_free(m_ctx);\n    }\n\n    if (m_ssl) {\n        SSL_free(m_ssl);\n    }\n}","filepath":"src/base/net/stratum/Tls.cpp","line_number":61,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5133488":{"score":0.85662824,"function_name":"xmrig::Client::Tls::verify","code":"bool xmrig::Client::Tls::verify(X509 *cert)\n{\n    if (cert == nullptr) {\n        LOG_ERR(\"[%s] Failed to get server certificate\", m_client-\u003eurl());\n\n        return false;\n    }\n\n    if (!verifyFingerprint(cert)) {\n        LOG_ERR(\"[%s] Failed to verify server certificate fingerprint\", m_client-\u003eurl());\n\n        const char *fingerprint = m_client-\u003em_pool.fingerprint();\n        if (strlen(m_fingerprint) == 64 \u0026\u0026 fingerprint != nullptr) {\n            LOG_ERR(\"\\\"%s\\\" was given\", m_fingerprint);\n            LOG_ERR(\"\\\"%s\\\" was configured\", fingerprint);\n        }\n\n        return false;\n    }\n\n    return true;\n}","filepath":"src/base/net/stratum/Tls.cpp","line_number":150,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5134000":{"score":0.7697906,"function_name":"xmrig::Client::Tls::read","code":"void xmrig::Client::Tls::read(const char *data, size_t size)\n{\n    BIO_write(m_readBio, data, size);\n\n    if (!SSL_is_init_finished(m_ssl)) {\n        const int rc = SSL_connect(m_ssl);\n\n        if (rc \u003c 0 \u0026\u0026 SSL_get_error(m_ssl, rc) == SSL_ERROR_WANT_READ) {\n            send();\n        } else if (rc == 1) {\n            X509 *cert = SSL_get_peer_certificate(m_ssl);\n            if (!verify(cert)) {\n                X509_free(cert);\n                m_client-\u003eclose();\n\n                return;\n            }\n\n            X509_free(cert);\n            m_ready = true;\n            m_client-\u003elogin();\n      }\n\n      return;\n    }\n\n    int bytes_read = 0;\n    while ((bytes_read = SSL_read(m_ssl, m_buf, sizeof(m_buf))) \u003e 0) {\n        m_buf[bytes_read - 1] = '\\0';\n        m_client-\u003eparse(m_buf, static_cast\u003csize_t\u003e(bytes_read));\n    }\n}","filepath":"src/base/net/stratum/Tls.cpp","line_number":110,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5134272":{"score":0.89809704,"function_name":"xmrig::Client::Tls::verifyFingerprint","code":"bool xmrig::Client::Tls::verifyFingerprint(X509 *cert)\n{\n    const EVP_MD *digest = EVP_get_digestbyname(\"sha256\");\n    if (digest == nullptr) {\n        return false;\n    }\n\n    unsigned char md[EVP_MAX_MD_SIZE];\n    unsigned int dlen;\n\n    if (X509_digest(cert, digest, md, \u0026dlen) != 1) {\n        return false;\n    }\n\n    Buffer::toHex(md, 32, m_fingerprint);\n    const char *fingerprint = m_client-\u003em_pool.fingerprint();\n\n    return fingerprint == nullptr || strncasecmp(m_fingerprint, fingerprint, 64) == 0;\n}","filepath":"src/base/net/stratum/Tls.cpp","line_number":174,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v2.15.0-beta"},"5138112":{"score":0.73635995,"function_name":"uv__print_handles","code":"static void uv__print_handles(uv_loop_t* loop, int only_active) {\n  const char* type;\n  QUEUE* q;\n  uv_handle_t* h;\n\n  if (loop == NULL)\n    loop = uv_default_loop();\n\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n\n    if (only_active \u0026\u0026 !uv__is_active(h))\n      continue;\n\n    switch (h-\u003etype) {\n#define X(uc, lc) case UV_##uc: type = #lc; break;\n      UV_HANDLE_TYPE_MAP(X)\n#undef X\n      default: type = \"\u003cunknown\u003e\";\n    }\n\n    fprintf(stderr,\n            \"[%c%c%c] %-8s %p\\n\",\n            \"R-\"[!(h-\u003eflags \u0026 UV__HANDLE_REF)],\n            \"A-\"[!(h-\u003eflags \u0026 UV__HANDLE_ACTIVE)],\n            \"I-\"[!(h-\u003eflags \u0026 UV__HANDLE_INTERNAL)],\n            type,\n            (void*)h);\n  }\n}","filepath":"src/uv-common.c","line_number":356,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5138496":{"score":0.9447679,"function_name":"uv__unknown_err_code","code":"static const char* uv__unknown_err_code(int err) {\n  char buf[32];\n  char* copy;\n\n#ifndef _WIN32\n  snprintf(buf, sizeof(buf), \"Unknown system error %d\", err);\n#else\n  _snprintf(buf, sizeof(buf), \"Unknown system error %d\", err);\n#endif\n  copy = uv__strdup(buf);\n\n  return copy != NULL ? copy : \"Unknown system error\";\n}","filepath":"src/uv-common.c","line_number":140,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5138608":{"score":0.88268363,"function_name":"uv__strndup","code":"char* uv__strndup(const char* s, size_t n) {\n  char* m;\n  size_t len = strlen(s);\n  if (n \u003c len)\n    len = n;\n  m = uv__malloc(len + 1);\n  if (m == NULL)\n    return NULL;\n  m[len] = '\\0';\n  return memcpy(m, s, len);\n}","filepath":"src/uv-common.c","line_number":61,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5138752":{"score":0.9316326,"function_name":"uv_replace_allocator","code":"int uv_replace_allocator(uv_malloc_func malloc_func,\n                         uv_realloc_func realloc_func,\n                         uv_calloc_func calloc_func,\n                         uv_free_func free_func) {\n  if (malloc_func == NULL || realloc_func == NULL ||\n      calloc_func == NULL || free_func == NULL) {\n    return UV_EINVAL;\n  }\n\n  uv__allocator.local_malloc = malloc_func;\n  uv__allocator.local_realloc = realloc_func;\n  uv__allocator.local_calloc = calloc_func;\n  uv__allocator.local_free = free_func;\n\n  return 0;\n}","filepath":"src/uv-common.c","line_number":89,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5142768":{"score":0.8106915,"function_name":"uv_ip6_addr","code":"int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr) {\n  char address_part[40];\n  size_t address_part_size;\n  const char* zone_index;\n\n  memset(addr, 0, sizeof(*addr));\n  addr-\u003esin6_family = AF_INET6;\n  addr-\u003esin6_port = htons(port);\n\n  zone_index = strchr(ip, '%');\n  if (zone_index != NULL) {\n    address_part_size = zone_index - ip;\n    if (address_part_size \u003e= sizeof(address_part))\n      address_part_size = sizeof(address_part) - 1;\n\n    memcpy(address_part, ip, address_part_size);\n    address_part[address_part_size] = '\\0';\n    ip = address_part;\n\n    zone_index++; /* skip '%' */\n    /* NOTE: unknown interface (id=0) is silently ignored */\n#ifdef _WIN32\n    addr-\u003esin6_scope_id = atoi(zone_index);\n#else\n    addr-\u003esin6_scope_id = if_nametoindex(zone_index);\n#endif\n  }\n\n  return uv_inet_pton(AF_INET6, ip, \u0026addr-\u003esin6_addr);\n}","filepath":"src/uv-common.c","line_number":183,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143040":{"score":0.8827624,"function_name":"uv_udp_bind","code":"int uv_udp_bind(uv_udp_t* handle,\n                const struct sockaddr* addr,\n                unsigned int flags) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_bind(handle, addr, addrlen, flags);\n}","filepath":"src/uv-common.c","line_number":244,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143168":{"score":0.85975885,"function_name":"uv_tcp_connect","code":"int uv_tcp_connect(uv_connect_t* req,\n                   uv_tcp_t* handle,\n                   const struct sockaddr* addr,\n                   uv_connect_cb cb) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_TCP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__tcp_connect(req, handle, addr, addrlen, cb);\n}","filepath":"src/uv-common.c","line_number":263,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143232":{"score":0.89202607,"function_name":"uv_udp_send","code":"int uv_udp_send(uv_udp_send_t* req,\n                uv_udp_t* handle,\n                const uv_buf_t bufs[],\n                unsigned int nbufs,\n                const struct sockaddr* addr,\n                uv_udp_send_cb send_cb) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_send(req, handle, bufs, nbufs, addr, addrlen, send_cb);\n}","filepath":"src/uv-common.c","line_number":283,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143312":{"score":0.8465439,"function_name":"uv_udp_try_send","code":"int uv_udp_try_send(uv_udp_t* handle,\n                    const uv_buf_t bufs[],\n                    unsigned int nbufs,\n                    const struct sockaddr* addr) {\n  unsigned int addrlen;\n\n  if (handle-\u003etype != UV_UDP)\n    return UV_EINVAL;\n\n  if (addr-\u003esa_family == AF_INET)\n    addrlen = sizeof(struct sockaddr_in);\n  else if (addr-\u003esa_family == AF_INET6)\n    addrlen = sizeof(struct sockaddr_in6);\n  else\n    return UV_EINVAL;\n\n  return uv__udp_try_send(handle, bufs, nbufs, addr, addrlen);\n}","filepath":"src/uv-common.c","line_number":305,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143376":{"score":0.91331375,"function_name":"uv_udp_recv_start","code":"int uv_udp_recv_start(uv_udp_t* handle,\n                      uv_alloc_cb alloc_cb,\n                      uv_udp_recv_cb recv_cb) {\n  if (handle-\u003etype != UV_UDP || alloc_cb == NULL || recv_cb == NULL)\n    return UV_EINVAL;\n  else\n    return uv__udp_recv_start(handle, alloc_cb, recv_cb);\n}","filepath":"src/uv-common.c","line_number":325,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143440":{"score":0.7983074,"function_name":"uv_walk","code":"void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {\n  QUEUE* q;\n  uv_handle_t* h;\n\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n    if (h-\u003eflags \u0026 UV__HANDLE_INTERNAL) continue;\n    walk_cb(h, arg);\n  }\n}","filepath":"src/uv-common.c","line_number":343,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143792":{"score":0.9042087,"function_name":"uv__count_bufs","code":"size_t uv__count_bufs(const uv_buf_t bufs[], unsigned int nbufs) {\n  unsigned int i;\n  size_t bytes;\n\n  bytes = 0;\n  for (i = 0; i \u003c nbufs; i++)\n    bytes += (size_t) bufs[i].len;\n\n  return bytes;\n}","filepath":"src/uv-common.c","line_number":425,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5143888":{"score":0.8352394,"function_name":"uv_fs_event_getpath","code":"int uv_fs_event_getpath(uv_fs_event_t* handle, char* buffer, size_t* size) {\n  size_t required_len;\n\n  if (!uv__is_active(handle)) {\n    *size = 0;\n    return UV_EINVAL;\n  }\n\n  required_len = strlen(handle-\u003epath);\n  if (required_len \u003e *size) {\n    *size = required_len;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, handle-\u003epath, required_len);\n  *size = required_len;\n\n  return 0;\n}","filepath":"src/uv-common.c","line_number":444,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144000":{"score":0.7825117,"function_name":"uv__fs_scandir_cleanup","code":"void uv__fs_scandir_cleanup(uv_fs_t* req) {\n  uv__dirent_t** dents;\n\n  unsigned int* nbufs = uv__get_nbufs(req);\n\n  dents = req-\u003eptr;\n  if (*nbufs \u003e 0 \u0026\u0026 *nbufs != (unsigned int) req-\u003eresult)\n    (*nbufs)--;\n  for (; *nbufs \u003c (unsigned int) req-\u003eresult; (*nbufs)++)\n    uv__free(dents[*nbufs]);\n}","filepath":"src/uv-common.c","line_number":476,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144112":{"score":0.86219835,"function_name":"uv_fs_scandir_next","code":"int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {\n  uv__dirent_t** dents;\n  uv__dirent_t* dent;\n\n  unsigned int* nbufs = uv__get_nbufs(req);\n\n  dents = req-\u003eptr;\n\n  /* Free previous entity */\n  if (*nbufs \u003e 0)\n    uv__free(dents[*nbufs - 1]);\n\n  /* End was already reached */\n  if (*nbufs == (unsigned int) req-\u003eresult) {\n    uv__free(dents);\n    req-\u003eptr = NULL;\n    return UV_EOF;\n  }\n\n  dent = dents[(*nbufs)++];\n\n  ent-\u003ename = dent-\u003ed_name;\n#ifdef HAVE_DIRENT_TYPES\n  switch (dent-\u003ed_type) {\n    case UV__DT_DIR:\n      ent-\u003etype = UV_DIRENT_DIR;\n      break;\n    case UV__DT_FILE:\n      ent-\u003etype = UV_DIRENT_FILE;\n      break;\n    case UV__DT_LINK:\n      ent-\u003etype = UV_DIRENT_LINK;\n      break;\n    case UV__DT_FIFO:\n      ent-\u003etype = UV_DIRENT_FIFO;\n      break;\n    case UV__DT_SOCKET:\n      ent-\u003etype = UV_DIRENT_SOCKET;\n      break;\n    case UV__DT_CHAR:\n      ent-\u003etype = UV_DIRENT_CHAR;\n      break;\n    case UV__DT_BLOCK:\n      ent-\u003etype = UV_DIRENT_BLOCK;\n      break;\n    default:\n      ent-\u003etype = UV_DIRENT_UNKNOWN;\n  }\n#else\n  ent-\u003etype = UV_DIRENT_UNKNOWN;\n#endif\n\n  return 0;\n}","filepath":"src/uv-common.c","line_number":489,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144576":{"score":0.87709796,"function_name":"uv_default_loop","code":"uv_loop_t* uv_default_loop(void) {\n  if (default_loop_ptr != NULL)\n    return default_loop_ptr;\n\n  if (uv_loop_init(\u0026default_loop_struct))\n    return NULL;\n\n  default_loop_ptr = \u0026default_loop_struct;\n  return default_loop_ptr;\n}","filepath":"src/uv-common.c","line_number":562,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144640":{"score":0.86397254,"function_name":"uv_loop_new","code":"uv_loop_t* uv_loop_new(void) {\n  uv_loop_t* loop;\n\n  loop = uv__malloc(sizeof(*loop));\n  if (loop == NULL)\n    return NULL;\n\n  if (uv_loop_init(loop)) {\n    uv__free(loop);\n    return NULL;\n  }\n\n  return loop;\n}","filepath":"src/uv-common.c","line_number":574,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144720":{"score":0.85113907,"function_name":"uv_loop_close","code":"int uv_loop_close(uv_loop_t* loop) {\n  QUEUE* q;\n  uv_handle_t* h;\n\n  if (!QUEUE_EMPTY(\u0026(loop)-\u003eactive_reqs))\n    return UV_EBUSY;\n\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    h = QUEUE_DATA(q, uv_handle_t, handle_queue);\n    if (!(h-\u003eflags \u0026 UV__HANDLE_INTERNAL))\n      return UV_EBUSY;\n  }\n\n  uv__loop_close(loop);\n\n#ifndef NDEBUG\n  memset(loop, -1, sizeof(*loop));\n#endif\n  if (loop == default_loop_ptr)\n    default_loop_ptr = NULL;\n\n  return 0;\n}","filepath":"src/uv-common.c","line_number":590,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5144880":{"score":0.9295659,"function_name":"uv_loop_delete","code":"void uv_loop_delete(uv_loop_t* loop) {\n  uv_loop_t* default_loop;\n  int err;\n\n  default_loop = default_loop_ptr;\n\n  err = uv_loop_close(loop);\n  (void) err;    /* Squelch compiler warnings. */\n  assert(err == 0);\n  if (loop != default_loop)\n    uv__free(loop);\n}","filepath":"src/uv-common.c","line_number":615,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.1"},"5146480":{"score":0.92658067,"function_name":"uv__socket_sockopt","code":"int uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n  int r;\n  int fd;\n  socklen_t len;\n\n  if (handle == NULL || value == NULL)\n    return -EINVAL;\n\n  if (handle-\u003etype == UV_TCP || handle-\u003etype == UV_NAMED_PIPE)\n    fd = uv__stream_fd((uv_stream_t*) handle);\n  else if (handle-\u003etype == UV_UDP)\n    fd = ((uv_udp_t *) handle)-\u003eio_watcher.fd;\n  else\n    return -ENOTSUP;\n\n  len = sizeof(*value);\n\n  if (*value == 0)\n    r = getsockopt(fd, SOL_SOCKET, optname, value, \u0026len);\n  else\n    r = setsockopt(fd, SOL_SOCKET, optname, (const void*) value, len);\n\n  if (r \u003c 0)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":167,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5146688":{"score":0.6542078,"function_name":"uv__finish_close","code":"static void uv__finish_close(uv_handle_t* handle) {\n  /* Note: while the handle is in the UV_CLOSING state now, it's still possible\n   * for it to be active in the sense that uv__is_active() returns true.\n   * A good example is when the user calls uv_shutdown(), immediately followed\n   * by uv_close(). The handle is considered active at this point because the\n   * completion of the shutdown req is still pending.\n   */\n  assert(handle-\u003eflags \u0026 UV_CLOSING);\n  assert(!(handle-\u003eflags \u0026 UV_CLOSED));\n  handle-\u003eflags |= UV_CLOSED;\n\n  switch (handle-\u003etype) {\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_IDLE:\n    case UV_ASYNC:\n    case UV_TIMER:\n    case UV_PROCESS:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_POLL:\n    case UV_SIGNAL:\n      break;\n\n    case UV_NAMED_PIPE:\n    case UV_TCP:\n    case UV_TTY:\n      uv__stream_destroy((uv_stream_t*)handle);\n      break;\n\n    case UV_UDP:\n      uv__udp_finish_close((uv_udp_t*)handle);\n      break;\n\n    default:\n      assert(0);\n      break;\n  }\n\n  uv__handle_unref(handle);\n  QUEUE_REMOVE(\u0026handle-\u003ehandle_queue);\n\n  if (handle-\u003eclose_cb) {\n    handle-\u003eclose_cb(handle);\n  }\n}","filepath":"src/unix/core.c","line_number":203,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5146784":{"score":0.922886,"function_name":"uv_close","code":"void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!(handle-\u003eflags \u0026 (UV_CLOSING | UV_CLOSED)));\n\n  handle-\u003eflags |= UV_CLOSING;\n  handle-\u003eclose_cb = close_cb;\n\n  switch (handle-\u003etype) {\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n\n  case UV_UDP:\n    uv__udp_close((uv_udp_t*)handle);\n    break;\n\n  case UV_PREPARE:\n    uv__prepare_close((uv_prepare_t*)handle);\n    break;\n\n  case UV_CHECK:\n    uv__check_close((uv_check_t*)handle);\n    break;\n\n  case UV_IDLE:\n    uv__idle_close((uv_idle_t*)handle);\n    break;\n\n  case UV_ASYNC:\n    uv__async_close((uv_async_t*)handle);\n    break;\n\n  case UV_TIMER:\n    uv__timer_close((uv_timer_t*)handle);\n    break;\n\n  case UV_PROCESS:\n    uv__process_close((uv_process_t*)handle);\n    break;\n\n  case UV_FS_EVENT:\n    uv__fs_event_close((uv_fs_event_t*)handle);\n    break;\n\n  case UV_POLL:\n    uv__poll_close((uv_poll_t*)handle);\n    break;\n\n  case UV_FS_POLL:\n    uv__fs_poll_close((uv_fs_poll_t*)handle);\n    break;\n\n  case UV_SIGNAL:\n    uv__signal_close((uv_signal_t*) handle);\n    /* Signal handles may not be closed immediately. The signal code will */\n    /* itself close uv__make_close_pending whenever appropriate. */\n    return;\n\n  default:\n    assert(0);\n  }\n\n  uv__make_close_pending(handle);\n}","filepath":"src/unix/core.c","line_number":95,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5147168":{"score":0.8676592,"function_name":"uv_backend_timeout","code":"int uv_backend_timeout(const uv_loop_t* loop) {\n  if (loop-\u003estop_flag != 0)\n    return 0;\n\n  if (!uv__has_active_handles(loop) \u0026\u0026 !uv__has_active_reqs(loop))\n    return 0;\n\n  if (!QUEUE_EMPTY(\u0026loop-\u003eidle_handles))\n    return 0;\n\n  if (!QUEUE_EMPTY(\u0026loop-\u003epending_queue))\n    return 0;\n\n  if (loop-\u003eclosing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}","filepath":"src/unix/core.c","line_number":276,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5147296":{"score":0.79797876,"function_name":"uv_run","code":"int uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 \u0026\u0026 loop-\u003estop_flag == 0) {\n    uv__update_time(loop);\n    uv__run_timers(loop);\n    ran_pending = uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n\n    timeout = 0;\n    if ((mode == UV_RUN_ONCE \u0026\u0026 !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);\n    uv__run_check(loop);\n    uv__run_closing_handles(loop);\n\n    if (mode == UV_RUN_ONCE) {\n      /* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  /* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */\n  if (loop-\u003estop_flag != 0)\n    loop-\u003estop_flag = 0;\n\n  return r;\n}","filepath":"src/unix/core.c","line_number":308,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5148368":{"score":0.9281862,"function_name":"uv__close","code":"int uv__close(int fd) {\n  int saved_errno;\n  int rc;\n\n  assert(fd \u003e -1);  /* Catch uninitialized io_watcher.fd bugs. */\n  assert(fd \u003e STDERR_FILENO);  /* Catch stdio close bugs. */\n\n  saved_errno = errno;\n  rc = close(fd);\n  if (rc == -1) {\n    rc = -errno;\n    if (rc == -EINTR)\n      rc = -EINPROGRESS;  /* For platform/libc consistency. */\n    errno = saved_errno;\n  }\n\n  return rc;\n}","filepath":"src/unix/core.c","line_number":459,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5148496":{"score":0.8353512,"function_name":"uv__nonblock","code":"int uv__nonblock(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, FIONBIO, \u0026set);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":482,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5148592":{"score":0.78281146,"function_name":"uv__cloexec","code":"int uv__cloexec(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, set ? FIOCLEX : FIONCLEX);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":496,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5148704":{"score":0.7810398,"function_name":"uv__socket","code":"int uv__socket(int domain, int type, int protocol) {\n  int sockfd;\n  int err;\n\n#if defined(SOCK_NONBLOCK) \u0026\u0026 defined(SOCK_CLOEXEC)\n  sockfd = socket(domain, type | SOCK_NONBLOCK | SOCK_CLOEXEC, protocol);\n  if (sockfd != -1)\n    return sockfd;\n\n  if (errno != EINVAL)\n    return -errno;\n#endif\n\n  sockfd = socket(domain, type, protocol);\n  if (sockfd == -1)\n    return -errno;\n\n  err = uv__nonblock(sockfd, 1);\n  if (err == 0)\n    err = uv__cloexec(sockfd, 1);\n\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n#if defined(SO_NOSIGPIPE)\n  {\n    int on = 1;\n    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, \u0026on, sizeof(on));\n  }\n#endif\n\n  return sockfd;\n}","filepath":"src/unix/core.c","line_number":371,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5148880":{"score":0.93399644,"function_name":"uv__accept","code":"int uv__accept(int sockfd) {\n  int peerfd;\n  int err;\n\n  assert(sockfd \u003e= 0);\n\n  while (1) {\n#if defined(__linux__) || __FreeBSD__ \u003e= 10\n    static int no_accept4;\n\n    if (no_accept4)\n      goto skip;\n\n    peerfd = uv__accept4(sockfd,\n                         NULL,\n                         NULL,\n                         UV__SOCK_NONBLOCK|UV__SOCK_CLOEXEC);\n    if (peerfd != -1)\n      return peerfd;\n\n    if (errno == EINTR)\n      continue;\n\n    if (errno != ENOSYS)\n      return -errno;\n\n    no_accept4 = 1;\nskip:\n#endif\n\n    peerfd = accept(sockfd, NULL, NULL);\n    if (peerfd == -1) {\n      if (errno == EINTR)\n        continue;\n      return -errno;\n    }\n\n    err = uv__cloexec(peerfd, 1);\n    if (err == 0)\n      err = uv__nonblock(peerfd, 1);\n\n    if (err) {\n      uv__close(peerfd);\n      return err;\n    }\n\n    return peerfd;\n  }\n}","filepath":"src/unix/core.c","line_number":408,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149088":{"score":0.8935609,"function_name":"uv__dup","code":"int uv__dup(int fd) {\n  int err;\n\n  fd = dup(fd);\n\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}","filepath":"src/unix/core.c","line_number":578,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149168":{"score":0.7930374,"function_name":"uv__recvmsg","code":"ssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n  struct cmsghdr* cmsg;\n  ssize_t rc;\n  int* pfd;\n  int* end;\n#if defined(__linux__)\n  static int no_msg_cmsg_cloexec;\n  if (no_msg_cmsg_cloexec == 0) {\n    rc = recvmsg(fd, msg, flags | 0x40000000);  /* MSG_CMSG_CLOEXEC */\n    if (rc != -1)\n      return rc;\n    if (errno != EINVAL)\n      return -errno;\n    rc = recvmsg(fd, msg, flags);\n    if (rc == -1)\n      return -errno;\n    no_msg_cmsg_cloexec = 1;\n  } else {\n    rc = recvmsg(fd, msg, flags);\n  }\n#else\n  rc = recvmsg(fd, msg, flags);\n#endif\n  if (rc == -1)\n    return -errno;\n  if (msg-\u003emsg_controllen == 0)\n    return rc;\n  for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg))\n    if (cmsg-\u003ecmsg_type == SCM_RIGHTS)\n      for (pfd = (int*) CMSG_DATA(cmsg),\n           end = (int*) ((char*) cmsg + cmsg-\u003ecmsg_len);\n           pfd \u003c end;\n           pfd += 1)\n        uv__cloexec(*pfd, 1);\n  return rc;\n}","filepath":"src/unix/core.c","line_number":596,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149504":{"score":0.92856187,"function_name":"uv_cwd","code":"int uv_cwd(char* buffer, size_t* size) {\n  if (buffer == NULL || size == NULL)\n    return -EINVAL;\n\n  if (getcwd(buffer, *size) == NULL)\n    return -errno;\n\n  *size = strlen(buffer);\n  if (*size \u003e 1 \u0026\u0026 buffer[*size - 1] == '/') {\n    buffer[*size-1] = '\\0';\n    (*size)--;\n  }\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":634,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149728":{"score":0.9150351,"function_name":"uv_fileno","code":"int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {\n  int fd_out;\n\n  switch (handle-\u003etype) {\n  case UV_TCP:\n  case UV_NAMED_PIPE:\n  case UV_TTY:\n    fd_out = uv__stream_fd((uv_stream_t*) handle);\n    break;\n\n  case UV_UDP:\n    fd_out = ((uv_udp_t *) handle)-\u003eio_watcher.fd;\n    break;\n\n  case UV_POLL:\n    fd_out = ((uv_poll_t *) handle)-\u003eio_watcher.fd;\n    break;\n\n  default:\n    return -EINVAL;\n  }\n\n  if (uv__is_closing(handle) || fd_out == -1)\n    return -EBADF;\n\n  *fd = fd_out;\n  return 0;\n}","filepath":"src/unix/core.c","line_number":671,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149840":{"score":0.89933366,"function_name":"uv__io_init","code":"void uv__io_init(uv__io_t* w, uv__io_cb cb, int fd) {\n  assert(cb != NULL);\n  assert(fd \u003e= -1);\n  QUEUE_INIT(\u0026w-\u003epending_queue);\n  QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n  w-\u003ecb = cb;\n  w-\u003efd = fd;\n  w-\u003eevents = 0;\n  w-\u003epevents = 0;\n\n#if defined(UV_HAVE_KQUEUE)\n  w-\u003ercount = 0;\n  w-\u003ewcount = 0;\n#endif /* defined(UV_HAVE_KQUEUE) */\n}","filepath":"src/unix/core.c","line_number":771,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5149968":{"score":0.9320547,"function_name":"uv__io_start","code":"void uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events \u0026 ~(UV__POLLIN | UV__POLLOUT)));\n  assert(0 != events);\n  assert(w-\u003efd \u003e= 0);\n  assert(w-\u003efd \u003c INT_MAX);\n\n  w-\u003epevents |= events;\n  maybe_resize(loop, w-\u003efd + 1);\n\n#if !defined(__sun)\n  /* The event ports backend needs to rearm all file descriptors on each and\n   * every tick of the event loop but the other backends allow us to\n   * short-circuit here if the event mask is unchanged.\n   */\n  if (w-\u003eevents == w-\u003epevents) {\n    if (w-\u003eevents == 0 \u0026\u0026 !QUEUE_EMPTY(\u0026w-\u003ewatcher_queue)) {\n      QUEUE_REMOVE(\u0026w-\u003ewatcher_queue);\n      QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n    }\n    return;\n  }\n#endif\n\n  if (QUEUE_EMPTY(\u0026w-\u003ewatcher_queue))\n    QUEUE_INSERT_TAIL(\u0026loop-\u003ewatcher_queue, \u0026w-\u003ewatcher_queue);\n\n  if (loop-\u003ewatchers[w-\u003efd] == NULL) {\n    loop-\u003ewatchers[w-\u003efd] = w;\n    loop-\u003enfds++;\n  }\n}","filepath":"src/unix/core.c","line_number":788,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5150512":{"score":0.9593904,"function_name":"uv__io_stop","code":"void uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events \u0026 ~(UV__POLLIN | UV__POLLOUT)));\n  assert(0 != events);\n\n  if (w-\u003efd == -1)\n    return;\n\n  assert(w-\u003efd \u003e= 0);\n\n  /* Happens when uv__io_stop() is called on a handle that was never started. */\n  if ((unsigned) w-\u003efd \u003e= loop-\u003enwatchers)\n    return;\n\n  w-\u003epevents \u0026= ~events;\n\n  if (w-\u003epevents == 0) {\n    QUEUE_REMOVE(\u0026w-\u003ewatcher_queue);\n    QUEUE_INIT(\u0026w-\u003ewatcher_queue);\n\n    if (loop-\u003ewatchers[w-\u003efd] != NULL) {\n      assert(loop-\u003ewatchers[w-\u003efd] == w);\n      assert(loop-\u003enfds \u003e 0);\n      loop-\u003ewatchers[w-\u003efd] = NULL;\n      loop-\u003enfds--;\n      w-\u003eevents = 0;\n    }\n  }\n  else if (QUEUE_EMPTY(\u0026w-\u003ewatcher_queue))\n    QUEUE_INSERT_TAIL(\u0026loop-\u003ewatcher_queue, \u0026w-\u003ewatcher_queue);\n}","filepath":"src/unix/core.c","line_number":821,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5151024":{"score":0.7961446,"function_name":"uv_getrusage","code":"int uv_getrusage(uv_rusage_t* rusage) {\n  struct rusage usage;\n\n  if (getrusage(RUSAGE_SELF, \u0026usage))\n    return -errno;\n\n  rusage-\u003eru_utime.tv_sec = usage.ru_utime.tv_sec;\n  rusage-\u003eru_utime.tv_usec = usage.ru_utime.tv_usec;\n\n  rusage-\u003eru_stime.tv_sec = usage.ru_stime.tv_sec;\n  rusage-\u003eru_stime.tv_usec = usage.ru_stime.tv_usec;\n\n  rusage-\u003eru_maxrss = usage.ru_maxrss;\n  rusage-\u003eru_ixrss = usage.ru_ixrss;\n  rusage-\u003eru_idrss = usage.ru_idrss;\n  rusage-\u003eru_isrss = usage.ru_isrss;\n  rusage-\u003eru_minflt = usage.ru_minflt;\n  rusage-\u003eru_majflt = usage.ru_majflt;\n  rusage-\u003eru_nswap = usage.ru_nswap;\n  rusage-\u003eru_inblock = usage.ru_inblock;\n  rusage-\u003eru_oublock = usage.ru_oublock;\n  rusage-\u003eru_msgsnd = usage.ru_msgsnd;\n  rusage-\u003eru_msgrcv = usage.ru_msgrcv;\n  rusage-\u003eru_nsignals = usage.ru_nsignals;\n  rusage-\u003eru_nvcsw = usage.ru_nvcsw;\n  rusage-\u003eru_nivcsw = usage.ru_nivcsw;\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":875,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5151296":{"score":0.8560714,"function_name":"uv__open_cloexec","code":"int uv__open_cloexec(const char* path, int flags) {\n  int err;\n  int fd;\n\n#if defined(__linux__) || (defined(__FreeBSD__) \u0026\u0026 __FreeBSD__ \u003e= 9)\n  static int no_cloexec;\n\n  if (!no_cloexec) {\n    fd = open(path, flags | UV__O_CLOEXEC);\n    if (fd != -1)\n      return fd;\n\n    if (errno != EINVAL)\n      return -errno;\n\n    /* O_CLOEXEC not supported. */\n    no_cloexec = 1;\n  }\n#endif\n\n  fd = open(path, flags);\n  if (fd == -1)\n    return -errno;\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}","filepath":"src/unix/core.c","line_number":906,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5151456":{"score":0.7527539,"function_name":"uv__dup2_cloexec","code":"int uv__dup2_cloexec(int oldfd, int newfd) {\n  int r;\n#if defined(__FreeBSD__) \u0026\u0026 __FreeBSD__ \u003e= 10\n  do\n    r = dup3(oldfd, newfd, O_CLOEXEC);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n  if (r == -1)\n    return -errno;\n  return r;\n#elif defined(__FreeBSD__) \u0026\u0026 defined(F_DUP2FD_CLOEXEC)\n  do\n    r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n  if (r != -1)\n    return r;\n  if (errno != EINVAL)\n    return -errno;\n  /* Fall through. */\n#elif defined(__linux__)\n  static int no_dup3;\n  if (!no_dup3) {\n    do\n      r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);\n    while (r == -1 \u0026\u0026 (errno == EINTR || errno == EBUSY));\n    if (r != -1)\n      return r;\n    if (errno != ENOSYS)\n      return -errno;\n    /* Fall through. */\n    no_dup3 = 1;\n  }\n#endif\n  {\n    int err;\n    do\n      r = dup2(oldfd, newfd);\n#if defined(__linux__)\n    while (r == -1 \u0026\u0026 (errno == EINTR || errno == EBUSY));\n#else\n    while (r == -1 \u0026\u0026 errno == EINTR);\n#endif\n\n    if (r == -1)\n      return -errno;\n\n    err = uv__cloexec(newfd, 1);\n    if (err) {\n      uv__close(newfd);\n      return err;\n    }\n\n    return r;\n  }\n}","filepath":"src/unix/core.c","line_number":940,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5151648":{"score":0.75565463,"function_name":"uv_os_homedir","code":"int uv_os_homedir(char* buffer, size_t* size) {\n  struct passwd pw;\n  struct passwd* result;\n  char* buf;\n  uid_t uid;\n  size_t bufsize;\n  size_t len;\n  long initsize;\n  int r;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n  /* Check if the HOME environment variable is set first */\n  buf = getenv(\"HOME\");\n\n  if (buf != NULL) {\n    len = strlen(buf);\n\n    if (len \u003e= *size) {\n      *size = len;\n      return -ENOBUFS;\n    }\n\n    memcpy(buffer, buf, len + 1);\n    *size = len;\n\n    return 0;\n  }\n\n  /* HOME is not set, so call getpwuid() */\n  initsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n\n  if (initsize \u003c= 0)\n    bufsize = 4096;\n  else\n    bufsize = (size_t) initsize;\n\n  uid = getuid();\n  buf = NULL;\n\n  for (;;) {\n    uv__free(buf);\n    buf = uv__malloc(bufsize);\n\n    if (buf == NULL)\n      return -ENOMEM;\n\n    r = getpwuid_r(uid, \u0026pw, buf, bufsize, \u0026result);\n\n    if (r != ERANGE)\n      break;\n\n    bufsize *= 2;\n  }\n\n  if (r != 0) {\n    uv__free(buf);\n    return -r;\n  }\n\n  if (result == NULL) {\n    uv__free(buf);\n    return -ENOENT;\n  }\n\n  len = strlen(pw.pw_dir);\n\n  if (len \u003e= *size) {\n    *size = len;\n    uv__free(buf);\n    return -ENOBUFS;\n  }\n\n  memcpy(buffer, pw.pw_dir, len + 1);\n  *size = len;\n  uv__free(buf);\n\n  return 0;\n}","filepath":"src/unix/core.c","line_number":996,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.1"},"5152640":{"score":0.69121087,"function_name":"uv__fs_read","code":"static ssize_t uv__fs_read(uv_fs_t* req) {\n#if defined(__linux__)\n  static int no_preadv;\n#endif\n  ssize_t result;\n\n#if defined(_AIX)\n  struct stat buf;\n  if(fstat(req-\u003efile, \u0026buf))\n    return -1;\n  if(S_ISDIR(buf.st_mode)) {\n    errno = EISDIR;\n    return -1;\n  }\n#endif /* defined(_AIX) */\n  if (req-\u003eoff \u003c 0) {\n    if (req-\u003enbufs == 1)\n      result = read(req-\u003efile, req-\u003ebufs[0].base, req-\u003ebufs[0].len);\n    else\n      result = readv(req-\u003efile, (struct iovec*) req-\u003ebufs, req-\u003enbufs);\n  } else {\n    if (req-\u003enbufs == 1) {\n      result = pread(req-\u003efile, req-\u003ebufs[0].base, req-\u003ebufs[0].len, req-\u003eoff);\n      goto done;\n    }\n\n#if HAVE_PREADV\n    result = preadv(req-\u003efile, (struct iovec*) req-\u003ebufs, req-\u003enbufs, req-\u003eoff);\n#else\n# if defined(__linux__)\n    if (no_preadv) retry:\n# endif\n    {\n      off_t nread;\n      size_t index;\n\n      nread = 0;\n      index = 0;\n      result = 1;\n      do {\n        if (req-\u003ebufs[index].len \u003e 0) {\n          result = pread(req-\u003efile,\n                         req-\u003ebufs[index].base,\n                         req-\u003ebufs[index].len,\n                         req-\u003eoff + nread);\n          if (result \u003e 0)\n            nread += result;\n        }\n        index++;\n      } while (index \u003c req-\u003enbufs \u0026\u0026 result \u003e 0);\n      if (nread \u003e 0)\n        result = nread;\n    }\n# if defined(__linux__)\n    else {\n      result = uv__preadv(req-\u003efile,\n                          (struct iovec*)req-\u003ebufs,\n                          req-\u003enbufs,\n                          req-\u003eoff);\n      if (result == -1 \u0026\u0026 errno == ENOSYS) {\n        no_preadv = 1;\n        goto retry;\n      }\n    }\n# endif\n#endif\n  }\n\ndone:\n  return result;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":301,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5152944":{"score":0.8924898,"function_name":"uv__fs_sendfile_emul","code":"static ssize_t uv__fs_sendfile_emul(uv_fs_t* req) {\n  struct pollfd pfd;\n  int use_pread;\n  off_t offset;\n  ssize_t nsent;\n  ssize_t nread;\n  ssize_t nwritten;\n  size_t buflen;\n  size_t len;\n  ssize_t n;\n  int in_fd;\n  int out_fd;\n  char buf[8192];\n\n  len = req-\u003ebufsml[0].len;\n  in_fd = req-\u003eflags;\n  out_fd = req-\u003efile;\n  offset = req-\u003eoff;\n  use_pread = 1;\n\n  /* Here are the rules regarding errors:\n   *\n   * 1. Read errors are reported only if nsent==0, otherwise we return nsent.\n   *    The user needs to know that some data has already been sent, to stop\n   *    them from sending it twice.\n   *\n   * 2. Write errors are always reported. Write errors are bad because they\n   *    mean data loss: we've read data but now we can't write it out.\n   *\n   * We try to use pread() and fall back to regular read() if the source fd\n   * doesn't support positional reads, for example when it's a pipe fd.\n   *\n   * If we get EAGAIN when writing to the target fd, we poll() on it until\n   * it becomes writable again.\n   *\n   * FIXME: If we get a write error when use_pread==1, it should be safe to\n   *        return the number of sent bytes instead of an error because pread()\n   *        is, in theory, idempotent. However, special files in /dev or /proc\n   *        may support pread() but not necessarily return the same data on\n   *        successive reads.\n   *\n   * FIXME: There is no way now to signal that we managed to send *some* data\n   *        before a write error.\n   */\n  for (nsent = 0; (size_t) nsent \u003c len; ) {\n    buflen = len - nsent;\n\n    if (buflen \u003e sizeof(buf))\n      buflen = sizeof(buf);\n\n    do\n      if (use_pread)\n        nread = pread(in_fd, buf, buflen, offset);\n      else\n        nread = read(in_fd, buf, buflen);\n    while (nread == -1 \u0026\u0026 errno == EINTR);\n\n    if (nread == 0)\n      goto out;\n\n    if (nread == -1) {\n      if (use_pread \u0026\u0026 nsent == 0 \u0026\u0026 (errno == EIO || errno == ESPIPE)) {\n        use_pread = 0;\n        continue;\n      }\n\n      if (nsent == 0)\n        nsent = -1;\n\n      goto out;\n    }\n\n    for (nwritten = 0; nwritten \u003c nread; ) {\n      do\n        n = write(out_fd, buf + nwritten, nread - nwritten);\n      while (n == -1 \u0026\u0026 errno == EINTR);\n\n      if (n != -1) {\n        nwritten += n;\n        continue;\n      }\n\n      if (errno != EAGAIN \u0026\u0026 errno != EWOULDBLOCK) {\n        nsent = -1;\n        goto out;\n      }\n\n      pfd.fd = out_fd;\n      pfd.events = POLLOUT;\n      pfd.revents = 0;\n\n      do\n        n = poll(\u0026pfd, 1, -1);\n      while (n == -1 \u0026\u0026 errno == EINTR);\n\n      if (n == -1 || (pfd.revents \u0026 ~POLLOUT) != 0) {\n        errno = EIO;\n        nsent = -1;\n        goto out;\n      }\n    }\n\n    offset += nread;\n    nsent += nread;\n  }\n\nout:\n  if (nsent != -1)\n    req-\u003eoff = offset;\n\n  return nsent;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":480,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5153520":{"score":0.8376167,"function_name":"uv__fs_buf_iter","code":"static ssize_t uv__fs_buf_iter(uv_fs_t* req, uv__fs_buf_iter_processor process) {\n  unsigned int iovmax;\n  unsigned int nbufs;\n  uv_buf_t* bufs;\n  ssize_t total;\n  ssize_t result;\n\n  iovmax = uv__getiovmax();\n  nbufs = req-\u003enbufs;\n  bufs = req-\u003ebufs;\n  total = 0;\n\n  while (nbufs \u003e 0) {\n    req-\u003enbufs = nbufs;\n    if (req-\u003enbufs \u003e iovmax)\n      req-\u003enbufs = iovmax;\n\n    result = process(req);\n    if (result \u003c= 0) {\n      if (total == 0)\n        total = result;\n      break;\n    }\n\n    if (req-\u003eoff \u003e= 0)\n      req-\u003eoff += result;\n\n    req-\u003ebufs += req-\u003enbufs;\n    nbufs -= req-\u003enbufs;\n    total += result;\n  }\n\n  if (errno == EINTR \u0026\u0026 total == -1)\n    return total;\n\n  if (bufs != req-\u003ebufsml)\n    uv__free(bufs);\n\n  req-\u003ebufs = NULL;\n  req-\u003enbufs = 0;\n\n  return total;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":893,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5153728":{"score":0.9075628,"function_name":"uv__fs_done","code":"static void uv__fs_done(struct uv__work* w, int status) {\n  uv_fs_t* req;\n\n  req = container_of(w, uv_fs_t, work_req);\n  uv__req_unregister(req-\u003eloop, req);\n\n  if (status == -ECANCELED) {\n    assert(req-\u003eresult == 0);\n    req-\u003eresult = -ECANCELED;\n  }\n\n  req-\u003ecb(req);\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1001,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5153888":{"score":0.68359697,"function_name":"uv__fs_work","code":"static void uv__fs_work(struct uv__work* w) {\n  int retry_on_eintr;\n  uv_fs_t* req;\n  ssize_t r;\n\n  req = container_of(w, uv_fs_t, work_req);\n  retry_on_eintr = !(req-\u003efs_type == UV_FS_CLOSE);\n\n  do {\n    errno = 0;\n\n#define X(type, action)                                                       \\\n  case UV_FS_ ## type:                                                        \\\n    r = action;                                                               \\\n    break;\n\n    switch (req-\u003efs_type) {\n    X(ACCESS, access(req-\u003epath, req-\u003eflags));\n    X(CHMOD, chmod(req-\u003epath, req-\u003emode));\n    X(CHOWN, chown(req-\u003epath, req-\u003euid, req-\u003egid));\n    X(CLOSE, close(req-\u003efile));\n    X(FCHMOD, fchmod(req-\u003efile, req-\u003emode));\n    X(FCHOWN, fchown(req-\u003efile, req-\u003euid, req-\u003egid));\n    X(FDATASYNC, uv__fs_fdatasync(req));\n    X(FSTAT, uv__fs_fstat(req-\u003efile, \u0026req-\u003estatbuf));\n    X(FSYNC, uv__fs_fsync(req));\n    X(FTRUNCATE, ftruncate(req-\u003efile, req-\u003eoff));\n    X(FUTIME, uv__fs_futime(req));\n    X(LSTAT, uv__fs_lstat(req-\u003epath, \u0026req-\u003estatbuf));\n    X(LINK, link(req-\u003epath, req-\u003enew_path));\n    X(MKDIR, mkdir(req-\u003epath, req-\u003emode));\n    X(MKDTEMP, uv__fs_mkdtemp(req));\n    X(OPEN, uv__fs_open(req));\n    X(READ, uv__fs_buf_iter(req, uv__fs_read));\n    X(SCANDIR, uv__fs_scandir(req));\n    X(READLINK, uv__fs_readlink(req));\n    X(REALPATH, uv__fs_realpath(req));\n    X(RENAME, rename(req-\u003epath, req-\u003enew_path));\n    X(RMDIR, rmdir(req-\u003epath));\n    X(SENDFILE, uv__fs_sendfile(req));\n    X(STAT, uv__fs_stat(req-\u003epath, \u0026req-\u003estatbuf));\n    X(SYMLINK, symlink(req-\u003epath, req-\u003enew_path));\n    X(UNLINK, unlink(req-\u003epath));\n    X(UTIME, uv__fs_utime(req));\n    X(WRITE, uv__fs_buf_iter(req, uv__fs_write));\n    default: abort();\n    }\n#undef X\n  } while (r == -1 \u0026\u0026 errno == EINTR \u0026\u0026 retry_on_eintr);\n\n  if (r == -1)\n    req-\u003eresult = -errno;\n  else\n    req-\u003eresult = r;\n\n  if (r == 0 \u0026\u0026 (req-\u003efs_type == UV_FS_STAT ||\n                 req-\u003efs_type == UV_FS_FSTAT ||\n                 req-\u003efs_type == UV_FS_LSTAT)) {\n    req-\u003eptr = \u0026req-\u003estatbuf;\n  }\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":938,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5156224":{"score":0.8481847,"function_name":"uv_fs_access","code":"int uv_fs_access(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 int flags,\n                 uv_fs_cb cb) {\n  INIT(ACCESS);\n  PATH;\n  req-\u003eflags = flags;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1016,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5156624":{"score":0.8289122,"function_name":"uv_fs_chmod","code":"int uv_fs_chmod(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                int mode,\n                uv_fs_cb cb) {\n  INIT(CHMOD);\n  PATH;\n  req-\u003emode = mode;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1028,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5157024":{"score":0.86005974,"function_name":"uv_fs_chown","code":"int uv_fs_chown(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                uv_uid_t uid,\n                uv_gid_t gid,\n                uv_fs_cb cb) {\n  INIT(CHOWN);\n  PATH;\n  req-\u003euid = uid;\n  req-\u003egid = gid;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1040,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5158976":{"score":0.8587712,"function_name":"uv_fs_ftruncate","code":"int uv_fs_ftruncate(uv_loop_t* loop,\n                    uv_fs_t* req,\n                    uv_file file,\n                    int64_t off,\n                    uv_fs_cb cb) {\n  INIT(FTRUNCATE);\n  req-\u003efile = file;\n  req-\u003eoff = off;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1108,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5159248":{"score":0.80301625,"function_name":"uv_fs_futime","code":"int uv_fs_futime(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 uv_file file,\n                 double atime,\n                 double mtime,\n                 uv_fs_cb cb) {\n  INIT(FUTIME);\n  req-\u003efile = file;\n  req-\u003eatime = atime;\n  req-\u003emtime = mtime;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1120,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5159872":{"score":0.75809515,"function_name":"uv_fs_link","code":"int uv_fs_link(uv_loop_t* loop,\n               uv_fs_t* req,\n               const char* path,\n               const char* new_path,\n               uv_fs_cb cb) {\n  INIT(LINK);\n  PATH2;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1141,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5160704":{"score":0.8375819,"function_name":"uv_fs_mkdtemp","code":"int uv_fs_mkdtemp(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* tpl,\n                  uv_fs_cb cb) {\n  INIT(MKDTEMP);\n  req-\u003epath = uv__strdup(tpl);\n  if (req-\u003epath == NULL) {\n    if (cb != NULL)\n      uv__req_unregister(loop, req);\n    return -ENOMEM;\n  }\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1164,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5162288":{"score":0.8371155,"function_name":"uv_fs_readlink","code":"int uv_fs_readlink(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   const char* path,\n                   uv_fs_cb cb) {\n  INIT(READLINK);\n  PATH;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1235,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5162640":{"score":0.8325543,"function_name":"uv_fs_realpath","code":"int uv_fs_realpath(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char * path,\n                  uv_fs_cb cb) {\n  INIT(REALPATH);\n  PATH;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1245,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5162992":{"score":0.780457,"function_name":"uv_fs_rename","code":"int uv_fs_rename(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 const char* new_path,\n                 uv_fs_cb cb) {\n  INIT(RENAME);\n  PATH2;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1255,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5163776":{"score":0.872538,"function_name":"uv_fs_sendfile","code":"int uv_fs_sendfile(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   uv_file out_fd,\n                   uv_file in_fd,\n                   int64_t off,\n                   size_t len,\n                   uv_fs_cb cb) {\n  INIT(SENDFILE);\n  req-\u003eflags = in_fd; /* hack */\n  req-\u003efile = out_fd;\n  req-\u003eoff = off;\n  req-\u003ebufsml[0].len = len;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1273,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5164416":{"score":0.7886193,"function_name":"uv_fs_symlink","code":"int uv_fs_symlink(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* path,\n                  const char* new_path,\n                  int flags,\n                  uv_fs_cb cb) {\n  INIT(SYMLINK);\n  PATH2;\n  req-\u003eflags = flags;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1296,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5165216":{"score":0.8226399,"function_name":"uv_fs_utime","code":"int uv_fs_utime(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                double atime,\n                double mtime,\n                uv_fs_cb cb) {\n  INIT(UTIME);\n  PATH;\n  req-\u003eatime = atime;\n  req-\u003emtime = mtime;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1316,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5165648":{"score":0.9111215,"function_name":"uv_fs_write","code":"int uv_fs_write(uv_loop_t* loop,\n                uv_fs_t* req,\n                uv_file file,\n                const uv_buf_t bufs[],\n                unsigned int nbufs,\n                int64_t off,\n                uv_fs_cb cb) {\n  if (bufs == NULL || nbufs == 0)\n    return -EINVAL;\n\n  INIT(WRITE);\n  req-\u003efile = file;\n\n  req-\u003enbufs = nbufs;\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  if (req-\u003ebufs == NULL) {\n    if (cb != NULL)\n      uv__req_unregister(loop, req);\n    return -ENOMEM;\n  }\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(*bufs));\n\n  req-\u003eoff = off;\n  POST;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1330,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5166096":{"score":0.87372214,"function_name":"uv_fs_req_cleanup","code":"void uv_fs_req_cleanup(uv_fs_t* req) {\n  /* Only necessary for asychronous requests, i.e., requests with a callback.\n   * Synchronous ones don't copy their arguments and have req-\u003epath and\n   * req-\u003enew_path pointing to user-owned memory.  UV_FS_MKDTEMP is the\n   * exception to the rule, it always allocates memory.\n   */\n  if (req-\u003epath != NULL \u0026\u0026 (req-\u003ecb != NULL || req-\u003efs_type == UV_FS_MKDTEMP))\n    uv__free((void*) req-\u003epath);  /* Memory is shared with req-\u003enew_path. */\n\n  req-\u003epath = NULL;\n  req-\u003enew_path = NULL;\n\n  if (req-\u003efs_type == UV_FS_SCANDIR \u0026\u0026 req-\u003eptr != NULL)\n    uv__fs_scandir_cleanup(req);\n\n  if (req-\u003eptr != \u0026req-\u003estatbuf)\n    uv__free(req-\u003eptr);\n  req-\u003eptr = NULL;\n}","filepath":"Utilities/cmlibuv/src/unix/fs.c","line_number":1361,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.10.0-rc1"},"5166224":{"score":0.91977125,"function_name":"uv__getaddrinfo_done","code":"static void uv__getaddrinfo_done(struct uv__work* w, int status) {\n  uv_getaddrinfo_t* req;\n\n  req = container_of(w, uv_getaddrinfo_t, work_req);\n  uv__req_unregister(req-\u003eloop, req);\n\n  /* See initialization in uv_getaddrinfo(). */\n  if (req-\u003ehints)\n    uv__free(req-\u003ehints);\n  else if (req-\u003eservice)\n    uv__free(req-\u003eservice);\n  else if (req-\u003ehostname)\n    uv__free(req-\u003ehostname);\n  else\n    assert(0);\n\n  req-\u003ehints = NULL;\n  req-\u003eservice = NULL;\n  req-\u003ehostname = NULL;\n\n  if (status == -ECANCELED) {\n    assert(req-\u003eretcode == 0);\n    req-\u003eretcode = UV_EAI_CANCELED;\n  }\n\n  if (req-\u003ecb)\n    req-\u003ecb(req, req-\u003eretcode, req-\u003eaddrinfo);\n}","filepath":"src/unix/getaddrinfo.c","line_number":108,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.16.1"},"5166480":{"score":0.8810449,"function_name":"uv__getaddrinfo_translate_error","code":"int uv__getaddrinfo_translate_error(int sys_err) {\n  switch (sys_err) {\n  case 0: return 0;\n#if defined(EAI_ADDRFAMILY)\n  case EAI_ADDRFAMILY: return UV_EAI_ADDRFAMILY;\n#endif\n#if defined(EAI_AGAIN)\n  case EAI_AGAIN: return UV_EAI_AGAIN;\n#endif\n#if defined(EAI_BADFLAGS)\n  case EAI_BADFLAGS: return UV_EAI_BADFLAGS;\n#endif\n#if defined(EAI_BADHINTS)\n  case EAI_BADHINTS: return UV_EAI_BADHINTS;\n#endif\n#if defined(EAI_CANCELED)\n  case EAI_CANCELED: return UV_EAI_CANCELED;\n#endif\n#if defined(EAI_FAIL)\n  case EAI_FAIL: return UV_EAI_FAIL;\n#endif\n#if defined(EAI_FAMILY)\n  case EAI_FAMILY: return UV_EAI_FAMILY;\n#endif\n#if defined(EAI_MEMORY)\n  case EAI_MEMORY: return UV_EAI_MEMORY;\n#endif\n#if defined(EAI_NODATA)\n  case EAI_NODATA: return UV_EAI_NODATA;\n#endif\n#if defined(EAI_NONAME)\n# if !defined(EAI_NODATA) || EAI_NODATA != EAI_NONAME\n  case EAI_NONAME: return UV_EAI_NONAME;\n# endif\n#endif\n#if defined(EAI_OVERFLOW)\n  case EAI_OVERFLOW: return UV_EAI_OVERFLOW;\n#endif\n#if defined(EAI_PROTOCOL)\n  case EAI_PROTOCOL: return UV_EAI_PROTOCOL;\n#endif\n#if defined(EAI_SERVICE)\n  case EAI_SERVICE: return UV_EAI_SERVICE;\n#endif\n#if defined(EAI_SOCKTYPE)\n  case EAI_SOCKTYPE: return UV_EAI_SOCKTYPE;\n#endif\n#if defined(EAI_SYSTEM)\n  case EAI_SYSTEM: return -errno;\n#endif\n  }\n  assert(!\"unknown EAI_* error code\");\n  abort();\n  return 0;  /* Pacify compiler. */\n}","filepath":"src/unix/getaddrinfo.c","line_number":41,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.16.1"},"5166800":{"score":0.94649494,"function_name":"uv_getaddrinfo","code":"int uv_getaddrinfo(uv_loop_t* loop,\n                   uv_getaddrinfo_t* req,\n                   uv_getaddrinfo_cb cb,\n                   const char* hostname,\n                   const char* service,\n                   const struct addrinfo* hints) {\n  size_t hostname_len;\n  size_t service_len;\n  size_t hints_len;\n  size_t len;\n  char* buf;\n\n  if (req == NULL || (hostname == NULL \u0026\u0026 service == NULL))\n    return -EINVAL;\n\n  hostname_len = hostname ? strlen(hostname) + 1 : 0;\n  service_len = service ? strlen(service) + 1 : 0;\n  hints_len = hints ? sizeof(*hints) : 0;\n  buf = uv__malloc(hostname_len + service_len + hints_len);\n\n  if (buf == NULL)\n    return -ENOMEM;\n\n  uv__req_init(loop, req, UV_GETADDRINFO);\n  req-\u003eloop = loop;\n  req-\u003ecb = cb;\n  req-\u003eaddrinfo = NULL;\n  req-\u003ehints = NULL;\n  req-\u003eservice = NULL;\n  req-\u003ehostname = NULL;\n  req-\u003eretcode = 0;\n\n  /* order matters, see uv_getaddrinfo_done() */\n  len = 0;\n\n  if (hints) {\n    req-\u003ehints = memcpy(buf + len, hints, sizeof(*hints));\n    len += sizeof(*hints);\n  }\n\n  if (service) {\n    req-\u003eservice = memcpy(buf + len, service, service_len);\n    len += service_len;\n  }\n\n  if (hostname)\n    req-\u003ehostname = memcpy(buf + len, hostname, hostname_len);\n\n  if (cb) {\n    uv__work_submit(loop,\n                    \u0026req-\u003ework_req,\n                    uv__getaddrinfo_work,\n                    uv__getaddrinfo_done);\n    return 0;\n  } else {\n    uv__getaddrinfo_work(\u0026req-\u003ework_req);\n    uv__getaddrinfo_done(\u0026req-\u003ework_req, 0);\n    return req-\u003eretcode;\n  }\n}","filepath":"src/unix/getaddrinfo.c","line_number":138,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.16.1"},"5168672":{"score":0.82081723,"function_name":"uv_loop_init","code":"int uv_loop_init(uv_loop_t* loop) {\n  void* saved_data;\n  int err;\n\n\n  saved_data = loop-\u003edata;\n  memset(loop, 0, sizeof(*loop));\n  loop-\u003edata = saved_data;\n\n  heap_init((struct heap*) \u0026loop-\u003etimer_heap);\n  QUEUE_INIT(\u0026loop-\u003ewq);\n  QUEUE_INIT(\u0026loop-\u003eidle_handles);\n  QUEUE_INIT(\u0026loop-\u003easync_handles);\n  QUEUE_INIT(\u0026loop-\u003echeck_handles);\n  QUEUE_INIT(\u0026loop-\u003eprepare_handles);\n  QUEUE_INIT(\u0026loop-\u003ehandle_queue);\n\n  loop-\u003eactive_handles = 0;\n  loop-\u003eactive_reqs.count = 0;\n  loop-\u003enfds = 0;\n  loop-\u003ewatchers = NULL;\n  loop-\u003enwatchers = 0;\n  QUEUE_INIT(\u0026loop-\u003epending_queue);\n  QUEUE_INIT(\u0026loop-\u003ewatcher_queue);\n\n  loop-\u003eclosing_handles = NULL;\n  uv__update_time(loop);\n  loop-\u003easync_io_watcher.fd = -1;\n  loop-\u003easync_wfd = -1;\n  loop-\u003esignal_pipefd[0] = -1;\n  loop-\u003esignal_pipefd[1] = -1;\n  loop-\u003ebackend_fd = -1;\n  loop-\u003eemfile_fd = -1;\n\n  loop-\u003etimer_counter = 0;\n  loop-\u003estop_flag = 0;\n\n  err = uv__platform_loop_init(loop);\n  if (err)\n    return err;\n\n  uv__signal_global_once_init();\n  err = uv_signal_init(loop, \u0026loop-\u003echild_watcher);\n  if (err)\n    goto fail_signal_init;\n\n  uv__handle_unref(\u0026loop-\u003echild_watcher);\n  loop-\u003echild_watcher.flags |= UV_HANDLE_INTERNAL;\n  QUEUE_INIT(\u0026loop-\u003eprocess_handles);\n\n  err = uv_rwlock_init(\u0026loop-\u003ecloexec_lock);\n  if (err)\n    goto fail_rwlock_init;\n\n  err = uv_mutex_init(\u0026loop-\u003ewq_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_async_init(loop, \u0026loop-\u003ewq_async, uv__work_done);\n  if (err)\n    goto fail_async_init;\n\n  uv__handle_unref(\u0026loop-\u003ewq_async);\n  loop-\u003ewq_async.flags |= UV_HANDLE_INTERNAL;\n\n  return 0;\n\nfail_async_init:\n  uv_mutex_destroy(\u0026loop-\u003ewq_mutex);\n\nfail_mutex_init:\n  uv_rwlock_destroy(\u0026loop-\u003ecloexec_lock);\n\nfail_rwlock_init:\n  uv__signal_loop_cleanup(loop);\n\nfail_signal_init:\n  uv__platform_loop_delete(loop);\n\n  return err;\n}","filepath":"src/unix/loop.c","line_number":30,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.22.0"},"5169344":{"score":0.9357666,"function_name":"uv__loop_close","code":"void uv__loop_close(uv_loop_t* loop) {\n  uv__signal_loop_cleanup(loop);\n  uv__platform_loop_delete(loop);\n  uv__async_stop(loop);\n\n  if (loop-\u003eemfile_fd != -1) {\n    uv__close(loop-\u003eemfile_fd);\n    loop-\u003eemfile_fd = -1;\n  }\n\n  if (loop-\u003ebackend_fd != -1) {\n    uv__close(loop-\u003ebackend_fd);\n    loop-\u003ebackend_fd = -1;\n  }\n\n  uv_mutex_lock(\u0026loop-\u003ewq_mutex);\n  assert(QUEUE_EMPTY(\u0026loop-\u003ewq) \u0026\u0026 \"thread pool work queue not empty!\");\n  assert(!uv__has_active_reqs(loop));\n  uv_mutex_unlock(\u0026loop-\u003ewq_mutex);\n  uv_mutex_destroy(\u0026loop-\u003ewq_mutex);\n\n  /*\n   * Note that all thread pool stuff is finished at this point and\n   * it is safe to just destroy rw lock\n   */\n  uv_rwlock_destroy(\u0026loop-\u003ecloexec_lock);\n\n#if 0\n  assert(QUEUE_EMPTY(\u0026loop-\u003epending_queue));\n  assert(QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue));\n  assert(loop-\u003enfds == 0);\n#endif\n\n  uv__free(loop-\u003ewatchers);\n  loop-\u003ewatchers = NULL;\n  loop-\u003enwatchers = 0;\n}","filepath":"src/unix/loop.c","line_number":146,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.22.0"},"5169584":{"score":0.9331111,"function_name":"uv__loop_configure","code":"int uv__loop_configure(uv_loop_t* loop, uv_loop_option option, va_list ap) {\n  if (option != UV_LOOP_BLOCK_SIGNAL)\n    return UV_ENOSYS;\n\n  if (va_arg(ap, int) != SIGPROF)\n    return UV_EINVAL;\n\n  loop-\u003eflags |= UV_LOOP_BLOCK_SIGPROF;\n  return 0;\n}","filepath":"src/unix/loop.c","line_number":185,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.22.0"},"5169664":{"score":0.8900227,"function_name":"uv__pipe_getsockpeername","code":"static int uv__pipe_getsockpeername(const uv_pipe_t* handle,\n                                    uv__peersockfunc func,\n                                    char* buffer,\n                                    size_t* size) {\n  struct sockaddr_un sa;\n  socklen_t addrlen;\n  int err;\n\n  addrlen = sizeof(sa);\n  memset(\u0026sa, 0, addrlen);\n  err = func(uv__stream_fd(handle), (struct sockaddr*) \u0026sa, \u0026addrlen);\n  if (err \u003c 0) {\n    *size = 0;\n    return -errno;\n  }\n\n#if defined(__linux__)\n  if (sa.sun_path[0] == 0)\n    /* Linux abstract namespace */\n    addrlen -= offsetof(struct sockaddr_un, sun_path);\n  else\n#endif\n    addrlen = strlen(sa.sun_path);\n\n\n  if (addrlen \u003e *size) {\n    *size = addrlen;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, sa.sun_path, addrlen);\n  *size = addrlen;\n\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":212,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5169904":{"score":0.8962148,"function_name":"uv_pipe_init","code":"int uv_pipe_init(uv_loop_t* loop, uv_pipe_t* handle, int ipc) {\n  uv__stream_init(loop, (uv_stream_t*)handle, UV_NAMED_PIPE);\n  handle-\u003eshutdown_req = NULL;\n  handle-\u003econnect_req = NULL;\n  handle-\u003epipe_fname = NULL;\n  handle-\u003eipc = ipc;\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":33,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5169984":{"score":0.88741755,"function_name":"uv_pipe_bind","code":"int uv_pipe_bind(uv_pipe_t* handle, const char* name) {\n  struct sockaddr_un saddr;\n  const char* pipe_fname;\n  int sockfd;\n  int err;\n\n  pipe_fname = NULL;\n  sockfd = -1;\n\n  /* Already bound? */\n  if (uv__stream_fd(handle) \u003e= 0)\n    return -EINVAL;\n\n  /* Make a copy of the file name, it outlives this function's scope. */\n  pipe_fname = uv__strdup(name);\n  if (pipe_fname == NULL)\n    return -ENOMEM;\n\n  /* We've got a copy, don't touch the original any more. */\n  name = NULL;\n\n  err = uv__socket(AF_UNIX, SOCK_STREAM, 0);\n  if (err \u003c 0)\n    goto err_socket;\n  sockfd = err;\n\n  memset(\u0026saddr, 0, sizeof saddr);\n  strncpy(saddr.sun_path, pipe_fname, sizeof(saddr.sun_path) - 1);\n  saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0';\n  saddr.sun_family = AF_UNIX;\n\n  if (bind(sockfd, (struct sockaddr*)\u0026saddr, sizeof saddr)) {\n    err = -errno;\n    /* Convert ENOENT to EACCES for compatibility with Windows. */\n    if (err == -ENOENT)\n      err = -EACCES;\n    goto err_bind;\n  }\n\n  /* Success. */\n  handle-\u003epipe_fname = pipe_fname; /* Is a strdup'ed copy. */\n  handle-\u003eio_watcher.fd = sockfd;\n  return 0;\n\nerr_bind:\n  uv__close(sockfd);\n\nerr_socket:\n  uv__free((void*)pipe_fname);\n  return err;\n}","filepath":"src/unix/pipe.c","line_number":43,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5170256":{"score":0.9169594,"function_name":"uv_pipe_listen","code":"int uv_pipe_listen(uv_pipe_t* handle, int backlog, uv_connection_cb cb) {\n  if (uv__stream_fd(handle) == -1)\n    return -EINVAL;\n\n  if (listen(uv__stream_fd(handle), backlog))\n    return -errno;\n\n  handle-\u003econnection_cb = cb;\n  handle-\u003eio_watcher.cb = uv__server_io;\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, UV__POLLIN);\n  return 0;\n}","filepath":"src/unix/pipe.c","line_number":96,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5170384":{"score":0.69702893,"function_name":"uv__pipe_close","code":"void uv__pipe_close(uv_pipe_t* handle) {\n  if (handle-\u003epipe_fname) {\n    /*\n     * Unlink the file system entity before closing the file descriptor.\n     * Doing it the other way around introduces a race where our process\n     * unlinks a socket with the same name that's just been created by\n     * another thread or process.\n     */\n    unlink(handle-\u003epipe_fname);\n    uv__free((void*)handle-\u003epipe_fname);\n    handle-\u003epipe_fname = NULL;\n  }\n\n  uv__stream_close((uv_stream_t*)handle);\n}","filepath":"src/unix/pipe.c","line_number":110,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5170448":{"score":0.8214213,"function_name":"uv_pipe_open","code":"int uv_pipe_open(uv_pipe_t* handle, uv_file fd) {\n  int err;\n\n  err = uv__nonblock(fd, 1);\n  if (err)\n    return err;\n\n#if defined(__APPLE__)\n  err = uv__stream_try_select((uv_stream_t*) handle, \u0026fd);\n  if (err)\n    return err;\n#endif /* defined(__APPLE__) */\n\n  return uv__stream_open((uv_stream_t*)handle,\n                         fd,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n}","filepath":"src/unix/pipe.c","line_number":127,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5170512":{"score":0.8328998,"function_name":"uv_pipe_connect","code":"void uv_pipe_connect(uv_connect_t* req,\n                    uv_pipe_t* handle,\n                    const char* name,\n                    uv_connect_cb cb) {\n  struct sockaddr_un saddr;\n  int new_sock;\n  int err;\n  int r;\n\n  new_sock = (uv__stream_fd(handle) == -1);\n\n  if (new_sock) {\n    err = uv__socket(AF_UNIX, SOCK_STREAM, 0);\n    if (err \u003c 0)\n      goto out;\n    handle-\u003eio_watcher.fd = err;\n  }\n\n  memset(\u0026saddr, 0, sizeof saddr);\n  strncpy(saddr.sun_path, name, sizeof(saddr.sun_path) - 1);\n  saddr.sun_path[sizeof(saddr.sun_path) - 1] = '\\0';\n  saddr.sun_family = AF_UNIX;\n\n  do {\n    r = connect(uv__stream_fd(handle),\n                (struct sockaddr*)\u0026saddr, sizeof saddr);\n  }\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == -1 \u0026\u0026 errno != EINPROGRESS) {\n    err = -errno;\n    goto out;\n  }\n\n  err = 0;\n  if (new_sock) {\n    err = uv__stream_open((uv_stream_t*)handle,\n                          uv__stream_fd(handle),\n                          UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n  }\n\n  if (err == 0)\n    uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, UV__POLLIN | UV__POLLOUT);\n\nout:\n  handle-\u003edelayed_error = err;\n  handle-\u003econnect_req = req;\n\n  uv__req_init(handle-\u003eloop, req, UV_CONNECT);\n  req-\u003ehandle = (uv_stream_t*)handle;\n  req-\u003ecb = cb;\n  QUEUE_INIT(\u0026req-\u003equeue);\n\n  /* Force callback to run on next tick in case of error. */\n  if (err)\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n\n  /* Mimic the Windows pipe implementation, always\n   * return 0 and let the callback handle errors.\n   */\n}","filepath":"src/unix/pipe.c","line_number":146,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5171072":{"score":0.9023684,"function_name":"uv_pipe_pending_count","code":"int uv_pipe_pending_count(uv_pipe_t* handle) {\n  uv__stream_queued_fds_t* queued_fds;\n\n  if (!handle-\u003eipc)\n    return 0;\n\n  if (handle-\u003eaccepted_fd == -1)\n    return 0;\n\n  if (handle-\u003equeued_fds == NULL)\n    return 1;\n\n  queued_fds = handle-\u003equeued_fds;\n  return queued_fds-\u003eoffset + 1;\n}","filepath":"src/unix/pipe.c","line_number":263,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5171152":{"score":0.7536161,"function_name":"uv_pipe_pending_type","code":"uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {\n  if (!handle-\u003eipc)\n    return UV_UNKNOWN_HANDLE;\n\n  if (handle-\u003eaccepted_fd == -1)\n    return UV_UNKNOWN_HANDLE;\n  else\n    return uv__handle_type(handle-\u003eaccepted_fd);\n}","filepath":"src/unix/pipe.c","line_number":280,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5171200":{"score":0.9044937,"function_name":"uv__poll_io","code":"static void uv__poll_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_poll_t* handle;\n  int pevents;\n\n  handle = container_of(w, uv_poll_t, io_watcher);\n\n  if (events \u0026 UV__POLLERR) {\n    uv__io_stop(loop, w, UV__POLLIN | UV__POLLOUT);\n    uv__handle_stop(handle);\n    handle-\u003epoll_cb(handle, -EBADF, 0);\n    return;\n  }\n\n  pevents = 0;\n  if (events \u0026 (UV__POLLIN | UV__POLLRDHUP))\n    pevents |= UV_READABLE;\n  if (events \u0026 UV__POLLOUT)\n    pevents |= UV_WRITABLE;\n\n  handle-\u003epoll_cb(handle, 0, pevents);\n}","filepath":"src/unix/poll.c","line_number":30,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5171392":{"score":0.8798925,"function_name":"uv_poll_init","code":"int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {\n  int err;\n\n  err = uv__nonblock(fd, 1);\n  if (err)\n    return err;\n\n  uv__handle_init(loop, (uv_handle_t*) handle, UV_POLL);\n  uv__io_init(\u0026handle-\u003eio_watcher, uv__poll_io, fd);\n  handle-\u003epoll_cb = NULL;\n  return 0;\n}","filepath":"src/unix/poll.c","line_number":53,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5171584":{"score":0.9444899,"function_name":"uv_poll_start","code":"int uv_poll_start(uv_poll_t* handle, int pevents, uv_poll_cb poll_cb) {\n  int events;\n\n  assert((pevents \u0026 ~(UV_READABLE | UV_WRITABLE)) == 0);\n  assert(!(handle-\u003eflags \u0026 (UV_CLOSING | UV_CLOSED)));\n\n  uv__poll_stop(handle);\n\n  if (pevents == 0)\n    return 0;\n\n  events = 0;\n  if (pevents \u0026 UV_READABLE)\n    events |= UV__POLLIN;\n  if (pevents \u0026 UV_WRITABLE)\n    events |= UV__POLLOUT;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, events);\n  uv__handle_start(handle);\n  handle-\u003epoll_cb = poll_cb;\n\n  return 0;\n}","filepath":"src/unix/poll.c","line_number":86,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5171776":{"score":0.88882846,"function_name":"uv__chld","code":"static void uv__chld(uv_signal_t* handle, int signum) {\n  uv_process_t* process;\n  uv_loop_t* loop;\n  int exit_status;\n  int term_signal;\n  int status;\n  pid_t pid;\n  QUEUE pending;\n  QUEUE* q;\n  QUEUE* h;\n\n  assert(signum == SIGCHLD);\n\n  QUEUE_INIT(\u0026pending);\n  loop = handle-\u003eloop;\n\n  h = \u0026loop-\u003eprocess_handles;\n  q = QUEUE_HEAD(h);\n  while (q != h) {\n    process = QUEUE_DATA(q, uv_process_t, queue);\n    q = QUEUE_NEXT(q);\n\n    do\n      pid = waitpid(process-\u003epid, \u0026status, WNOHANG);\n    while (pid == -1 \u0026\u0026 errno == EINTR);\n\n    if (pid == 0)\n      continue;\n\n    if (pid == -1) {\n      if (errno != ECHILD)\n        abort();\n      continue;\n    }\n\n    process-\u003estatus = status;\n    QUEUE_REMOVE(\u0026process-\u003equeue);\n    QUEUE_INSERT_TAIL(\u0026pending, \u0026process-\u003equeue);\n  }\n\n  h = \u0026pending;\n  q = QUEUE_HEAD(h);\n  while (q != h) {\n    process = QUEUE_DATA(q, uv_process_t, queue);\n    q = QUEUE_NEXT(q);\n\n    QUEUE_REMOVE(\u0026process-\u003equeue);\n    QUEUE_INIT(\u0026process-\u003equeue);\n    uv__handle_stop(process);\n\n    if (process-\u003eexit_cb == NULL)\n      continue;\n\n    exit_status = 0;\n    if (WIFEXITED(process-\u003estatus))\n      exit_status = WEXITSTATUS(process-\u003estatus);\n\n    term_signal = 0;\n    if (WIFSIGNALED(process-\u003estatus))\n      term_signal = WTERMSIG(process-\u003estatus);\n\n    process-\u003eexit_cb(process, exit_status, term_signal);\n  }\n  assert(QUEUE_EMPTY(\u0026pending));\n}","filepath":"src/unix/process.c","line_number":48,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.13.0"},"5172432":{"score":0.7191607,"function_name":"uv__make_pipe","code":"int uv__make_pipe(int fds[2], int flags) {\n#if defined(__linux__)\n  static int no_pipe2;\n\n  if (no_pipe2)\n    goto skip;\n\n  if (uv__pipe2(fds, flags | UV__O_CLOEXEC) == 0)\n    return 0;\n\n  if (errno != ENOSYS)\n    return -errno;\n\n  no_pipe2 = 1;\n\nskip:\n#endif\n\n  if (pipe(fds))\n    return -errno;\n\n  uv__cloexec(fds[0], 1);\n  uv__cloexec(fds[1], 1);\n\n  if (flags \u0026 UV__F_NONBLOCK) {\n    uv__nonblock(fds[0], 1);\n    uv__nonblock(fds[1], 1);\n  }\n\n  return 0;\n}","filepath":"src/unix/process.c","line_number":151,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.13.0"},"5172560":{"score":0.8710618,"function_name":"uv_spawn","code":"int uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n#if defined(__APPLE__) \u0026\u0026 (TARGET_OS_TV || TARGET_OS_WATCH)\n  /* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. */\n  return -ENOSYS;\n#else\n  int signal_pipe[2] = { -1, -1 };\n  int (*pipes)[2];\n  int stdio_count;\n  ssize_t r;\n  pid_t pid;\n  int err;\n  int exec_errorno;\n  int i;\n  int status;\n\n  assert(options-\u003efile != NULL);\n  assert(!(options-\u003eflags \u0026 ~(UV_PROCESS_DETACHED |\n                              UV_PROCESS_SETGID |\n                              UV_PROCESS_SETUID |\n                              UV_PROCESS_WINDOWS_HIDE |\n                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\n\n  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n  QUEUE_INIT(\u0026process-\u003equeue);\n\n  stdio_count = options-\u003estdio_count;\n  if (stdio_count \u003c 3)\n    stdio_count = 3;\n\n  err = -ENOMEM;\n  pipes = uv__malloc(stdio_count * sizeof(*pipes));\n  if (pipes == NULL)\n    goto error;\n\n  for (i = 0; i \u003c stdio_count; i++) {\n    pipes[i][0] = -1;\n    pipes[i][1] = -1;\n  }\n\n  for (i = 0; i \u003c options-\u003estdio_count; i++) {\n    err = uv__process_init_stdio(options-\u003estdio + i, pipes[i]);\n    if (err)\n      goto error;\n  }\n\n  /* This pipe is used by the parent to wait until\n   * the child has called `execve()`. We need this\n   * to avoid the following race condition:\n   *\n   *    if ((pid = fork()) \u003e 0) {\n   *      kill(pid, SIGTERM);\n   *    }\n   *    else if (pid == 0) {\n   *      execve(\"/bin/cat\", argp, envp);\n   *    }\n   *\n   * The parent sends a signal immediately after forking.\n   * Since the child may not have called `execve()` yet,\n   * there is no telling what process receives the signal,\n   * our fork or /bin/cat.\n   *\n   * To avoid ambiguity, we create a pipe with both ends\n   * marked close-on-exec. Then, after the call to `fork()`,\n   * the parent polls the read end until it EOFs or errors with EPIPE.\n   */\n  err = uv__make_pipe(signal_pipe, 0);\n  if (err)\n    goto error;\n\n  uv_signal_start(\u0026loop-\u003echild_watcher, uv__chld, SIGCHLD);\n\n  /* Acquire write lock to prevent opening new fds in worker threads */\n  uv_rwlock_wrlock(\u0026loop-\u003ecloexec_lock);\n  pid = fork();\n\n  if (pid == -1) {\n    err = -errno;\n    uv_rwlock_wrunlock(\u0026loop-\u003ecloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n\n  /* Release lock in parent process */\n  uv_rwlock_wrunlock(\u0026loop-\u003ecloexec_lock);\n  uv__close(signal_pipe[1]);\n\n  process-\u003estatus = 0;\n  exec_errorno = 0;\n  do\n    r = read(signal_pipe[0], \u0026exec_errorno, sizeof(exec_errorno));\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == 0)\n    ; /* okay, EOF */\n  else if (r == sizeof(exec_errorno)) {\n    do\n      err = waitpid(pid, \u0026status, 0); /* okay, read errorno */\n    while (err == -1 \u0026\u0026 errno == EINTR);\n    assert(err == pid);\n  } else if (r == -1 \u0026\u0026 errno == EPIPE) {\n    do\n      err = waitpid(pid, \u0026status, 0); /* okay, got EPIPE */\n    while (err == -1 \u0026\u0026 errno == EINTR);\n    assert(err == pid);\n  } else\n    abort();\n\n  uv__close_nocheckstdio(signal_pipe[0]);\n\n  for (i = 0; i \u003c options-\u003estdio_count; i++) {\n    err = uv__process_open_stream(options-\u003estdio + i, pipes[i], i == 0);\n    if (err == 0)\n      continue;\n\n    while (i--)\n      uv__process_close_stream(options-\u003estdio + i);\n\n    goto error;\n  }\n\n  /* Only activate this handle if exec() happened successfully */\n  if (exec_errorno == 0) {\n    QUEUE_INSERT_TAIL(\u0026loop-\u003eprocess_handles, \u0026process-\u003equeue);\n    uv__handle_start(process);\n  }\n\n  process-\u003epid = pid;\n  process-\u003eexit_cb = options-\u003eexit_cb;\n\n  uv__free(pipes);\n  return exec_errorno;\n\nerror:\n  if (pipes != NULL) {\n    for (i = 0; i \u003c stdio_count; i++) {\n      if (i \u003c options-\u003estdio_count)\n        if (options-\u003estdio[i].flags \u0026 (UV_INHERIT_FD | UV_INHERIT_STREAM))\n          continue;\n      if (pipes[i][0] != -1)\n        uv__close_nocheckstdio(pipes[i][0]);\n      if (pipes[i][1] != -1)\n        uv__close_nocheckstdio(pipes[i][1]);\n    }\n    uv__free(pipes);\n  }\n\n  return err;\n#endif\n}","filepath":"src/unix/process.c","line_number":414,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.13.0"},"5174784":{"score":0.86835396,"function_name":"uv__signal_unlock","code":"static int uv__signal_unlock(void) {\n  int r;\n  char data = 42;\n\n  do {\n    r = write(uv__signal_lock_pipefd[1], \u0026data, sizeof data);\n  } while (r \u003c 0 \u0026\u0026 errno == EINTR);\n\n  return (r \u003c 0) ? -1 : 0;\n}","filepath":"src/unix/signal.c","line_number":84,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5174992":{"score":0.85962665,"function_name":"uv__signal_lock","code":"static int uv__signal_lock(void) {\n  int r;\n  char data;\n\n  do {\n    r = read(uv__signal_lock_pipefd[0], \u0026data, sizeof data);\n  } while (r \u003c 0 \u0026\u0026 errno == EINTR);\n\n  return (r \u003c 0) ? -1 : 0;\n}","filepath":"src/unix/signal.c","line_number":72,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5175104":{"score":0.741282,"function_name":"uv__signal_block_and_lock","code":"static void uv__signal_block_and_lock(sigset_t* saved_sigmask) {\n  sigset_t new_mask;\n\n  if (sigfillset(\u0026new_mask))\n    abort();\n\n  if (pthread_sigmask(SIG_SETMASK, \u0026new_mask, saved_sigmask))\n    abort();\n\n  if (uv__signal_lock())\n    abort();\n}","filepath":"src/unix/signal.c","line_number":96,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5175216":{"score":0.82359695,"function_name":"uv__signal_event","code":"static void uv__signal_event(uv_loop_t* loop,\n                             uv__io_t* w,\n                             unsigned int events) {\n  uv__signal_msg_t* msg;\n  uv_signal_t* handle;\n  char buf[sizeof(uv__signal_msg_t) * 32];\n  size_t bytes, end, i;\n  int r;\n\n  bytes = 0;\n  end = 0;\n\n  do {\n    r = read(loop-\u003esignal_pipefd[0], buf + bytes, sizeof(buf) - bytes);\n\n    if (r == -1 \u0026\u0026 errno == EINTR)\n      continue;\n\n    if (r == -1 \u0026\u0026 (errno == EAGAIN || errno == EWOULDBLOCK)) {\n      /* If there are bytes in the buffer already (which really is extremely\n       * unlikely if possible at all) we can't exit the function here. We'll\n       * spin until more bytes are read instead.\n       */\n      if (bytes \u003e 0)\n        continue;\n\n      /* Otherwise, there was nothing there. */\n      return;\n    }\n\n    /* Other errors really should never happen. */\n    if (r == -1)\n      abort();\n\n    bytes += r;\n\n    /* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */\n    end = (bytes / sizeof(uv__signal_msg_t)) * sizeof(uv__signal_msg_t);\n\n    for (i = 0; i \u003c end; i += sizeof(uv__signal_msg_t)) {\n      msg = (uv__signal_msg_t*) (buf + i);\n      handle = msg-\u003ehandle;\n\n      if (msg-\u003esignum == handle-\u003esignum) {\n        assert(!(handle-\u003eflags \u0026 UV_CLOSING));\n        handle-\u003esignal_cb(handle, handle-\u003esignum);\n      }\n\n      handle-\u003edispatched_signals++;\n\n      /* If uv_close was called while there were caught signals that were not\n       * yet dispatched, the uv__finish_close was deferred. Make close pending\n       * now if this has happened.\n       */\n      if ((handle-\u003eflags \u0026 UV_CLOSING) \u0026\u0026\n          (handle-\u003ecaught_signals == handle-\u003edispatched_signals)) {\n        uv__make_close_pending((uv_handle_t*) handle);\n      }\n    }\n\n    bytes -= end;\n\n    /* If there are any \"partial\" messages left, move them to the start of the\n     * the buffer, and spin. This should not happen.\n     */\n    if (bytes) {\n      memmove(buf, buf + end, bytes);\n      continue;\n    }\n  } while (end == sizeof buf);\n}","filepath":"src/unix/signal.c","line_number":341,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5175584":{"score":0.6178816,"function_name":"uv__signal_first_handle","code":"static uv_signal_t* uv__signal_first_handle(int signum) {\n  /* This function must be called with the signal lock held. */\n  uv_signal_t lookup;\n  uv_signal_t* handle;\n\n  lookup.signum = signum;\n  lookup.loop = NULL;\n\n  handle = RB_NFIND(uv__signal_tree_s, \u0026uv__signal_tree, \u0026lookup);\n\n  if (handle != NULL \u0026\u0026 handle-\u003esignum == signum)\n    return handle;\n\n  return NULL;\n}","filepath":"src/unix/signal.c","line_number":119,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5175744":{"score":0.87835974,"function_name":"uv__signal_handler","code":"static void uv__signal_handler(int signum) {\n  uv__signal_msg_t msg;\n  uv_signal_t* handle;\n  int saved_errno;\n\n  saved_errno = errno;\n  memset(\u0026msg, 0, sizeof msg);\n\n  if (uv__signal_lock()) {\n    errno = saved_errno;\n    return;\n  }\n\n  for (handle = uv__signal_first_handle(signum);\n       handle != NULL \u0026\u0026 handle-\u003esignum == signum;\n       handle = RB_NEXT(uv__signal_tree_s, \u0026uv__signal_tree, handle)) {\n    int r;\n\n    msg.signum = signum;\n    msg.handle = handle;\n\n    /* write() should be atomic for small data chunks, so the entire message\n     * should be written at once. In theory the pipe could become full, in\n     * which case the user is out of luck.\n     */\n    do {\n      r = write(handle-\u003eloop-\u003esignal_pipefd[1], \u0026msg, sizeof msg);\n    } while (r == -1 \u0026\u0026 errno == EINTR);\n\n    assert(r == sizeof msg ||\n           (r == -1 \u0026\u0026 (errno == EAGAIN || errno == EWOULDBLOCK)));\n\n    if (r != -1)\n      handle-\u003ecaught_signals++;\n  }\n\n  uv__signal_unlock();\n  errno = saved_errno;\n}","filepath":"src/unix/signal.c","line_number":136,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5178064":{"score":0.8929362,"function_name":"uv__signal_loop_cleanup","code":"void uv__signal_loop_cleanup(uv_loop_t* loop) {\n  QUEUE* q;\n\n  /* Stop all the signal watchers that are still attached to this loop. This\n   * ensures that the (shared) signal tree doesn't contain any invalid entries\n   * entries, and that signal handlers are removed when appropriate.\n   * It's safe to use QUEUE_FOREACH here because the handles and the handle\n   * queue are not modified by uv__signal_stop().\n   */\n  QUEUE_FOREACH(q, \u0026loop-\u003ehandle_queue) {\n    uv_handle_t* handle = QUEUE_DATA(q, uv_handle_t, handle_queue);\n\n    if (handle-\u003etype == UV_SIGNAL)\n      uv__signal_stop((uv_signal_t*) handle);\n  }\n\n  if (loop-\u003esignal_pipefd[0] != -1) {\n    uv__close(loop-\u003esignal_pipefd[0]);\n    loop-\u003esignal_pipefd[0] = -1;\n  }\n\n  if (loop-\u003esignal_pipefd[1] != -1) {\n    uv__close(loop-\u003esignal_pipefd[1]);\n    loop-\u003esignal_pipefd[1] = -1;\n  }\n}"},"5178208":{"score":0.7602052,"function_name":"uv_signal_init","code":"int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {\n  int err;\n\n  err = uv__signal_loop_once_init(loop);\n  if (err)\n    return err;\n\n  uv__handle_init(loop, (uv_handle_t*) handle, UV_SIGNAL);\n  handle-\u003esignum = 0;\n  handle-\u003ecaught_signals = 0;\n  handle-\u003edispatched_signals = 0;\n\n  return 0;\n}","filepath":"src/unix/signal.c","line_number":257,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5178448":{"score":0.9329074,"function_name":"uv_signal_start","code":"int uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {\n  sigset_t saved_sigmask;\n  int err;\n\n  assert(!(handle-\u003eflags \u0026 (UV_CLOSING | UV_CLOSED)));\n\n  /* If the user supplies signum == 0, then return an error already. If the\n   * signum is otherwise invalid then uv__signal_register will find out\n   * eventually.\n   */\n  if (signum == 0)\n    return -EINVAL;\n\n  /* Short circuit: if the signal watcher is already watching {signum} don't\n   * go through the process of deregistering and registering the handler.\n   * Additionally, this avoids pending signals getting lost in the small time\n   * time frame that handle-\u003esignum == 0.\n   */\n  if (signum == handle-\u003esignum) {\n    handle-\u003esignal_cb = signal_cb;\n    return 0;\n  }\n\n  /* If the signal handler was already active, stop it first. */\n  if (handle-\u003esignum != 0) {\n    uv__signal_stop(handle);\n  }\n\n  uv__signal_block_and_lock(\u0026saved_sigmask);\n\n  /* If at this point there are no active signal watchers for this signum (in\n   * any of the loops), it's time to try and register a handler for it here.\n   */\n  if (uv__signal_first_handle(signum) == NULL) {\n    err = uv__signal_register_handler(signum);\n    if (err) {\n      /* Registering the signal handler failed. Must be an invalid signal. */\n      uv__signal_unlock_and_unblock(\u0026saved_sigmask);\n      return err;\n    }\n  }\n\n  handle-\u003esignum = signum;\n  RB_INSERT(uv__signal_tree_s, \u0026uv__signal_tree, handle);\n\n  uv__signal_unlock_and_unblock(\u0026saved_sigmask);\n\n  handle-\u003esignal_cb = signal_cb;\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/signal.c","line_number":287,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v0.11.16"},"5179888":{"score":0.8671032,"function_name":"uv__stream_eof","code":"static void uv__stream_eof(uv_stream_t* stream, const uv_buf_t* buf) {\n  stream-\u003eflags |= UV_STREAM_READ_EOF;\n  uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  if (!uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(stream);\n  uv__stream_osx_interrupt_select(stream);\n  stream-\u003eread_cb(stream, UV_EOF, buf);\n  stream-\u003eflags \u0026= ~UV_STREAM_READING;\n}","filepath":"src/unix/stream.c","line_number":994,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5180000":{"score":0.86551285,"function_name":"uv__write_req_finish","code":"static void uv__write_req_finish(uv_write_t* req) {\n  uv_stream_t* stream = req-\u003ehandle;\n\n  /* Pop the req off tcp-\u003ewrite_queue. */\n  QUEUE_REMOVE(\u0026req-\u003equeue);\n\n  /* Only free when there was no error. On error, we touch up write_queue_size\n   * right before making the callback. The reason we don't do that right away\n   * is that a write_queue_size \u003e 0 is our only way to signal to the user that\n   * they should stop writing - which they should if we got an error. Something\n   * to revisit in future revisions of the libuv API.\n   */\n  if (req-\u003eerror == 0) {\n    if (req-\u003ebufs != req-\u003ebufsml)\n      uv__free(req-\u003ebufs);\n    req-\u003ebufs = NULL;\n  }\n\n  /* Add it to the write_completed_queue where it will have its\n   * callback called in the near future.\n   */\n  QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  uv__io_feed(stream-\u003eloop, \u0026stream-\u003eio_watcher);\n}","filepath":"src/unix/stream.c","line_number":706,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5181216":{"score":0.9018483,"function_name":"uv__read","code":"static void uv__read(uv_stream_t* stream) {\n  uv_buf_t buf;\n  ssize_t nread;\n  struct msghdr msg;\n  char cmsg_space[CMSG_SPACE(UV__CMSG_FD_SIZE)];\n  int count;\n  int err;\n  int is_ipc;\n\n  stream-\u003eflags \u0026= ~UV_STREAM_READ_PARTIAL;\n\n  /* Prevent loop starvation when the data comes in as fast as (or faster than)\n   * we can read it. XXX Need to rearm fd if we switch to edge-triggered I/O.\n   */\n  count = 32;\n\n  is_ipc = stream-\u003etype == UV_NAMED_PIPE \u0026\u0026 ((uv_pipe_t*) stream)-\u003eipc;\n\n  /* XXX: Maybe instead of having UV_STREAM_READING we just test if\n   * tcp-\u003eread_cb is NULL or not?\n   */\n  while (stream-\u003eread_cb\n      \u0026\u0026 (stream-\u003eflags \u0026 UV_STREAM_READING)\n      \u0026\u0026 (count-- \u003e 0)) {\n    assert(stream-\u003ealloc_cb != NULL);\n\n    buf = uv_buf_init(NULL, 0);\n    stream-\u003ealloc_cb((uv_handle_t*)stream, 64 * 1024, \u0026buf);\n    if (buf.base == NULL || buf.len == 0) {\n      /* User indicates it can't or won't handle the read. */\n      stream-\u003eread_cb(stream, UV_ENOBUFS, \u0026buf);\n      return;\n    }\n\n    assert(buf.base != NULL);\n    assert(uv__stream_fd(stream) \u003e= 0);\n\n    if (!is_ipc) {\n      do {\n        nread = read(uv__stream_fd(stream), buf.base, buf.len);\n      }\n      while (nread \u003c 0 \u0026\u0026 errno == EINTR);\n    } else {\n      /* ipc uses recvmsg */\n      msg.msg_flags = 0;\n      msg.msg_iov = (struct iovec*) \u0026buf;\n      msg.msg_iovlen = 1;\n      msg.msg_name = NULL;\n      msg.msg_namelen = 0;\n      /* Set up to receive a descriptor even if one isn't in the message */\n      msg.msg_controllen = sizeof(cmsg_space);\n      msg.msg_control = cmsg_space;\n\n      do {\n        nread = uv__recvmsg(uv__stream_fd(stream), \u0026msg, 0);\n      }\n      while (nread \u003c 0 \u0026\u0026 errno == EINTR);\n    }\n\n    if (nread \u003c 0) {\n      /* Error */\n      if (errno == EAGAIN || errno == EWOULDBLOCK) {\n        /* Wait for the next one. */\n        if (stream-\u003eflags \u0026 UV_STREAM_READING) {\n          uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n          uv__stream_osx_interrupt_select(stream);\n        }\n        stream-\u003eread_cb(stream, 0, \u0026buf);\n      } else {\n        /* Error. User should call uv_close(). */\n        stream-\u003eread_cb(stream, -errno, \u0026buf);\n        if (stream-\u003eflags \u0026 UV_STREAM_READING) {\n          stream-\u003eflags \u0026= ~UV_STREAM_READING;\n          uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n          if (!uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT))\n            uv__handle_stop(stream);\n          uv__stream_osx_interrupt_select(stream);\n        }\n      }\n      return;\n    } else if (nread == 0) {\n      uv__stream_eof(stream, \u0026buf);\n      return;\n    } else {\n      /* Successful read */\n      ssize_t buflen = buf.len;\n\n      if (is_ipc) {\n        err = uv__stream_recv_cmsg(stream, \u0026msg);\n        if (err != 0) {\n          stream-\u003eread_cb(stream, err, \u0026buf);\n          return;\n        }\n      }\n\n#if defined(__MVS__)\n      if (is_ipc \u0026\u0026 msg.msg_controllen \u003e 0) {\n        uv_buf_t blankbuf;\n        int nread;\n        struct iovec *old;\n\n        blankbuf.base = 0;\n        blankbuf.len = 0;\n        old = msg.msg_iov;\n        msg.msg_iov = (struct iovec*) \u0026blankbuf;\n        nread = 0;\n        do {\n          nread = uv__recvmsg(uv__stream_fd(stream), \u0026msg, 0);\n          err = uv__stream_recv_cmsg(stream, \u0026msg);\n          if (err != 0) {\n            stream-\u003eread_cb(stream, err, \u0026buf);\n            msg.msg_iov = old;\n            return;\n          }\n        } while (nread == 0 \u0026\u0026 msg.msg_controllen \u003e 0);\n        msg.msg_iov = old;\n      }\n#endif\n      stream-\u003eread_cb(stream, nread, \u0026buf);\n\n      /* Return if we didn't fill the buffer, there is no more data to read. */\n      if (nread \u003c buflen) {\n        stream-\u003eflags |= UV_STREAM_READ_PARTIAL;\n        return;\n      }\n    }\n  }\n}","filepath":"src/unix/stream.c","line_number":1103,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5182624":{"score":0.9312173,"function_name":"uv__write_req_size","code":"static size_t uv__write_req_size(uv_write_t* req) {\n  size_t size;\n\n  assert(req-\u003ebufs != NULL);\n  size = uv__count_bufs(req-\u003ebufs + req-\u003ewrite_index,\n                        req-\u003enbufs - req-\u003ewrite_index);\n  assert(req-\u003ehandle-\u003ewrite_queue_size \u003e= size);\n\n  return size;\n}","filepath":"src/unix/stream.c","line_number":694,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5182736":{"score":0.90213275,"function_name":"uv__write_callbacks","code":"static void uv__write_callbacks(uv_stream_t* stream) {\n  uv_write_t* req;\n  QUEUE* q;\n\n  while (!QUEUE_EMPTY(\u0026stream-\u003ewrite_completed_queue)) {\n    /* Pop a req off write_completed_queue. */\n    q = QUEUE_HEAD(\u0026stream-\u003ewrite_completed_queue);\n    req = QUEUE_DATA(q, uv_write_t, queue);\n    QUEUE_REMOVE(q);\n    uv__req_unregister(stream-\u003eloop, req);\n\n    if (req-\u003ebufs != NULL) {\n      stream-\u003ewrite_queue_size -= uv__write_req_size(req);\n      if (req-\u003ebufs != req-\u003ebufsml)\n        uv__free(req-\u003ebufs);\n      req-\u003ebufs = NULL;\n    }\n\n    /* NOTE: call callback AFTER freeing the request data. */\n    if (req-\u003ecb)\n      req-\u003ecb(req, req-\u003eerror);\n  }\n\n  assert(QUEUE_EMPTY(\u0026stream-\u003ewrite_completed_queue));\n}","filepath":"src/unix/stream.c","line_number":924,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5182960":{"score":0.9043768,"function_name":"uv__stream_io","code":"static void uv__stream_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_stream_t* stream;\n\n  stream = container_of(w, uv_stream_t, io_watcher);\n\n  assert(stream-\u003etype == UV_TCP ||\n         stream-\u003etype == UV_NAMED_PIPE ||\n         stream-\u003etype == UV_TTY);\n  assert(!(stream-\u003eflags \u0026 UV_CLOSING));\n\n  if (stream-\u003econnect_req) {\n    uv__stream_connect(stream);\n    return;\n  }\n\n  assert(uv__stream_fd(stream) \u003e= 0);\n\n  /* Ignore POLLHUP here. Even it it's set, there may still be data to read. */\n  if (events \u0026 (POLLIN | POLLERR | POLLHUP))\n    uv__read(stream);\n\n  if (uv__stream_fd(stream) == -1)\n    return;  /* read_cb closed stream. */\n\n  /* Short-circuit iff POLLHUP is set, the user is still interested in read\n   * events and uv__read() reported a partial read but not EOF. If the EOF\n   * flag is set, uv__read() called read_cb with err=UV_EOF and we don't\n   * have to do anything. If the partial read flag is not set, we can't\n   * report the EOF yet because there is still data to read.\n   */\n  if ((events \u0026 POLLHUP) \u0026\u0026\n      (stream-\u003eflags \u0026 UV_STREAM_READING) \u0026\u0026\n      (stream-\u003eflags \u0026 UV_STREAM_READ_PARTIAL) \u0026\u0026\n      !(stream-\u003eflags \u0026 UV_STREAM_READ_EOF)) {\n    uv_buf_t buf = { NULL, 0 };\n    uv__stream_eof(stream, \u0026buf);\n  }\n\n  if (uv__stream_fd(stream) == -1)\n    return;  /* read_cb closed stream. */\n\n  if (events \u0026 (POLLOUT | POLLERR | POLLHUP)) {\n    uv__write(stream);\n    uv__write_callbacks(stream);\n\n    /* Write queue drained. */\n    if (QUEUE_EMPTY(\u0026stream-\u003ewrite_queue))\n      uv__drain(stream);\n  }\n}","filepath":"src/unix/stream.c","line_number":1268,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5183968":{"score":0.80507934,"function_name":"uv__stream_init","code":"void uv__stream_init(uv_loop_t* loop,\n                     uv_stream_t* stream,\n                     uv_handle_type type) {\n  int err;\n\n  uv__handle_init(loop, (uv_handle_t*)stream, type);\n  stream-\u003eread_cb = NULL;\n  stream-\u003ealloc_cb = NULL;\n  stream-\u003eclose_cb = NULL;\n  stream-\u003econnection_cb = NULL;\n  stream-\u003econnect_req = NULL;\n  stream-\u003eshutdown_req = NULL;\n  stream-\u003eaccepted_fd = -1;\n  stream-\u003equeued_fds = NULL;\n  stream-\u003edelayed_error = 0;\n  QUEUE_INIT(\u0026stream-\u003ewrite_queue);\n  QUEUE_INIT(\u0026stream-\u003ewrite_completed_queue);\n  stream-\u003ewrite_queue_size = 0;\n\n  if (loop-\u003eemfile_fd == -1) {\n    err = uv__open_cloexec(\"/dev/null\", O_RDONLY);\n    if (err \u003c 0)\n        /* In the rare case that \"/dev/null\" isn't mounted open \"/\"\n         * instead.\n         */\n        err = uv__open_cloexec(\"/\", O_RDONLY);\n    if (err \u003e= 0)\n      loop-\u003eemfile_fd = err;\n  }\n\n#if defined(__APPLE__)\n  stream-\u003eselect = NULL;\n#endif /* defined(__APPLE_) */\n\n  uv__io_init(\u0026stream-\u003eio_watcher, uv__stream_io, -1);\n}","filepath":"src/unix/stream.c","line_number":71,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5184272":{"score":0.92274845,"function_name":"uv__stream_open","code":"int uv__stream_open(uv_stream_t* stream, int fd, int flags) {\n#if defined(__APPLE__) || defined(__MVS__)\n  int enable;\n#endif\n\n  if (!(stream-\u003eio_watcher.fd == -1 || stream-\u003eio_watcher.fd == fd))\n    return -EBUSY;\n\n  assert(fd \u003e= 0);\n  stream-\u003eflags |= flags;\n\n  if (stream-\u003etype == UV_TCP) {\n    if ((stream-\u003eflags \u0026 UV_TCP_NODELAY) \u0026\u0026 uv__tcp_nodelay(fd, 1))\n      return -errno;\n\n    /* TODO Use delay the user passed in. */\n    if ((stream-\u003eflags \u0026 UV_TCP_KEEPALIVE) \u0026\u0026 uv__tcp_keepalive(fd, 1, 60))\n      return -errno;\n  }\n\n#if defined(__APPLE__) || defined(__MVS__)\n  enable = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_OOBINLINE, \u0026enable, sizeof(enable)) \u0026\u0026\n      errno != ENOTSOCK \u0026\u0026\n      errno != EINVAL) {\n    return -errno;\n  }\n#endif\n\n  stream-\u003eio_watcher.fd = fd;\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":392,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5184448":{"score":0.8971088,"function_name":"uv__stream_flush_write_queue","code":"void uv__stream_flush_write_queue(uv_stream_t* stream, int error) {\n  uv_write_t* req;\n  QUEUE* q;\n  while (!QUEUE_EMPTY(\u0026stream-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026stream-\u003ewrite_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_write_t, queue);\n    req-\u003eerror = error;\n\n    QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  }\n}","filepath":"src/unix/stream.c","line_number":427,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5184544":{"score":0.91270834,"function_name":"uv__stream_destroy","code":"void uv__stream_destroy(uv_stream_t* stream) {\n  assert(!uv__io_active(\u0026stream-\u003eio_watcher, POLLIN | POLLOUT));\n  assert(stream-\u003eflags \u0026 UV_CLOSED);\n\n  if (stream-\u003econnect_req) {\n    uv__req_unregister(stream-\u003eloop, stream-\u003econnect_req);\n    stream-\u003econnect_req-\u003ecb(stream-\u003econnect_req, -ECANCELED);\n    stream-\u003econnect_req = NULL;\n  }\n\n  uv__stream_flush_write_queue(stream, -ECANCELED);\n  uv__write_callbacks(stream);\n\n  if (stream-\u003eshutdown_req) {\n    /* The ECANCELED error code is a lie, the shutdown(2) syscall is a\n     * fait accompli at this point. Maybe we should revisit this in v0.11.\n     * A possible reason for leaving it unchanged is that it informs the\n     * callee that the handle has been destroyed.\n     */\n    uv__req_unregister(stream-\u003eloop, stream-\u003eshutdown_req);\n    stream-\u003eshutdown_req-\u003ecb(stream-\u003eshutdown_req, -ECANCELED);\n    stream-\u003eshutdown_req = NULL;\n  }\n\n  assert(stream-\u003ewrite_queue_size == 0);\n}","filepath":"src/unix/stream.c","line_number":442,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5184992":{"score":0.92588973,"function_name":"uv__server_io","code":"void uv__server_io(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  uv_stream_t* stream;\n  int err;\n\n  stream = container_of(w, uv_stream_t, io_watcher);\n  assert(events == POLLIN);\n  assert(stream-\u003eaccepted_fd == -1);\n  assert(!(stream-\u003eflags \u0026 UV_CLOSING));\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n\n  /* connection_cb can close the server socket while we're\n   * in the loop so check it on each iteration.\n   */\n  while (uv__stream_fd(stream) != -1) {\n    assert(stream-\u003eaccepted_fd == -1);\n\n#if defined(UV_HAVE_KQUEUE)\n    if (w-\u003ercount \u003c= 0)\n      return;\n#endif /* defined(UV_HAVE_KQUEUE) */\n\n    err = uv__accept(uv__stream_fd(stream));\n    if (err \u003c 0) {\n      if (err == -EAGAIN || err == -EWOULDBLOCK)\n        return;  /* Not an error. */\n\n      if (err == -ECONNABORTED)\n        continue;  /* Ignore. Nothing we can do about that. */\n\n      if (err == -EMFILE || err == -ENFILE) {\n        err = uv__emfile_trick(loop, uv__stream_fd(stream));\n        if (err == -EAGAIN || err == -EWOULDBLOCK)\n          break;\n      }\n\n      stream-\u003econnection_cb(stream, err);\n      continue;\n    }\n\n    UV_DEC_BACKLOG(w)\n    stream-\u003eaccepted_fd = err;\n    stream-\u003econnection_cb(stream, 0);\n\n    if (stream-\u003eaccepted_fd != -1) {\n      /* The user hasn't yet accepted called uv_accept() */\n      uv__io_stop(loop, \u0026stream-\u003eio_watcher, POLLIN);\n      return;\n    }\n\n    if (stream-\u003etype == UV_TCP \u0026\u0026 (stream-\u003eflags \u0026 UV_TCP_SINGLE_ACCEPT)) {\n      /* Give other processes a chance to accept connections. */\n      struct timespec timeout = { 0, 1 };\n      nanosleep(\u0026timeout, NULL);\n    }\n  }\n}","filepath":"src/unix/stream.c","line_number":512,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5185888":{"score":0.7793312,"function_name":"uv_listen","code":"int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {\n  int err;\n\n  switch (stream-\u003etype) {\n  case UV_TCP:\n    err = uv_tcp_listen((uv_tcp_t*)stream, backlog, cb);\n    break;\n\n  case UV_NAMED_PIPE:\n    err = uv_pipe_listen((uv_pipe_t*)stream, backlog, cb);\n    break;\n\n  default:\n    err = -EINVAL;\n  }\n\n  if (err == 0)\n    uv__handle_start(stream);\n\n  return err;\n}","filepath":"src/unix/stream.c","line_number":639,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5185984":{"score":0.88245845,"function_name":"uv__handle_type","code":"uv_handle_type uv__handle_type(int fd) {\n  struct sockaddr_storage ss;\n  socklen_t sslen;\n  socklen_t len;\n  int type;\n\n  memset(\u0026ss, 0, sizeof(ss));\n  sslen = sizeof(ss);\n\n  if (getsockname(fd, (struct sockaddr*)\u0026ss, \u0026sslen))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof type;\n\n  if (getsockopt(fd, SOL_SOCKET, SO_TYPE, \u0026type, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  if (type == SOCK_STREAM) {\n#if defined(_AIX) || defined(__DragonFly__)\n    /* on AIX/DragonFly the getsockname call returns an empty sa structure\n     * for sockets of type AF_UNIX.  For all other types it will\n     * return a properly filled in structure.\n     */\n    if (sslen == 0)\n      return UV_NAMED_PIPE;\n#endif\n    switch (ss.ss_family) {\n      case AF_UNIX:\n        return UV_NAMED_PIPE;\n      case AF_INET:\n      case AF_INET6:\n        return UV_TCP;\n      }\n  }\n\n  if (type == SOCK_DGRAM \u0026\u0026\n      (ss.ss_family == AF_INET || ss.ss_family == AF_INET6))\n    return UV_UDP;\n\n  return UV_UNKNOWN_HANDLE;\n}","filepath":"src/unix/stream.c","line_number":951,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5186240":{"score":0.92966235,"function_name":"uv_shutdown","code":"int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {\n  assert((stream-\u003etype == UV_TCP || stream-\u003etype == UV_NAMED_PIPE) \u0026\u0026\n         \"uv_shutdown (unix) only supports uv_handle_t right now\");\n\n  if (!(stream-\u003eflags \u0026 UV_STREAM_WRITABLE) ||\n      stream-\u003eflags \u0026 UV_STREAM_SHUT ||\n      stream-\u003eflags \u0026 UV_STREAM_SHUTTING ||\n      uv__is_closing(stream)) {\n    return -ENOTCONN;\n  }\n\n  assert(uv__stream_fd(stream) \u003e= 0);\n\n  /* Initialize request */\n  uv__req_init(stream-\u003eloop, req, UV_SHUTDOWN);\n  req-\u003ehandle = stream;\n  req-\u003ecb = cb;\n  stream-\u003eshutdown_req = req;\n  stream-\u003eflags |= UV_STREAM_SHUTTING;\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLOUT);\n  uv__stream_osx_interrupt_select(stream);\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1241,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5186432":{"score":0.96269214,"function_name":"uv_write2","code":"int uv_write2(uv_write_t* req,\n              uv_stream_t* stream,\n              const uv_buf_t bufs[],\n              unsigned int nbufs,\n              uv_stream_t* send_handle,\n              uv_write_cb cb) {\n  int empty_queue;\n\n  assert(nbufs \u003e 0);\n  assert((stream-\u003etype == UV_TCP ||\n          stream-\u003etype == UV_NAMED_PIPE ||\n          stream-\u003etype == UV_TTY) \u0026\u0026\n         \"uv_write (unix) does not yet support other types of streams\");\n\n  if (uv__stream_fd(stream) \u003c 0)\n    return -EBADF;\n\n  if (send_handle) {\n    if (stream-\u003etype != UV_NAMED_PIPE || !((uv_pipe_t*)stream)-\u003eipc)\n      return -EINVAL;\n\n    /* XXX We abuse uv_write2() to send over UDP handles to child processes.\n     * Don't call uv__stream_fd() on those handles, it's a macro that on OS X\n     * evaluates to a function that operates on a uv_stream_t with a couple of\n     * OS X specific fields. On other Unices it does (handle)-\u003eio_watcher.fd,\n     * which works but only by accident.\n     */\n    if (uv__handle_fd((uv_handle_t*) send_handle) \u003c 0)\n      return -EBADF;\n  }\n\n  /* It's legal for write_queue_size \u003e 0 even when the write_queue is empty;\n   * it means there are error-state requests in the write_completed_queue that\n   * will touch up write_queue_size later, see also uv__write_req_finish().\n   * We could check that write_queue is empty instead but that implies making\n   * a write() syscall when we know that the handle is in error mode.\n   */\n  empty_queue = (stream-\u003ewrite_queue_size == 0);\n\n  /* Initialize the req */\n  uv__req_init(stream-\u003eloop, req, UV_WRITE);\n  req-\u003ecb = cb;\n  req-\u003ehandle = stream;\n  req-\u003eerror = 0;\n  req-\u003esend_handle = send_handle;\n  QUEUE_INIT(\u0026req-\u003equeue);\n\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(bufs[0]));\n\n  if (req-\u003ebufs == NULL)\n    return -ENOMEM;\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(bufs[0]));\n  req-\u003enbufs = nbufs;\n  req-\u003ewrite_index = 0;\n  stream-\u003ewrite_queue_size += uv__count_bufs(bufs, nbufs);\n\n  /* Append the request to write_queue. */\n  QUEUE_INSERT_TAIL(\u0026stream-\u003ewrite_queue, \u0026req-\u003equeue);\n\n  /* If the queue was empty when this function began, we should attempt to\n   * do the write immediately. Otherwise start the write_watcher and wait\n   * for the fd to become writable.\n   */\n  if (stream-\u003econnect_req) {\n    /* Still connecting, do nothing. */\n  }\n  else if (empty_queue) {\n    uv__write(stream);\n  }\n  else {\n    /*\n     * blocking streams should never have anything in the queue.\n     * if this assert fires then somehow the blocking stream isn't being\n     * sufficiently flushed in uv__write.\n     */\n    assert(!(stream-\u003eflags \u0026 UV_STREAM_BLOCKING));\n    uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLOUT);\n    uv__stream_osx_interrupt_select(stream);\n  }\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1374,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5187072":{"score":0.85239935,"function_name":"uv_try_write","code":"int uv_try_write(uv_stream_t* stream,\n                 const uv_buf_t bufs[],\n                 unsigned int nbufs) {\n  int r;\n  int has_pollout;\n  size_t written;\n  size_t req_size;\n  uv_write_t req;\n\n  /* Connecting or already writing some data */\n  if (stream-\u003econnect_req != NULL || stream-\u003ewrite_queue_size != 0)\n    return -EAGAIN;\n\n  has_pollout = uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT);\n\n  r = uv_write(\u0026req, stream, bufs, nbufs, uv_try_write_cb);\n  if (r != 0)\n    return r;\n\n  /* Remove not written bytes from write queue size */\n  written = uv__count_bufs(bufs, nbufs);\n  if (req.bufs != NULL)\n    req_size = uv__write_req_size(\u0026req);\n  else\n    req_size = 0;\n  written -= req_size;\n  stream-\u003ewrite_queue_size -= req_size;\n\n  /* Unqueue request, regardless of immediateness */\n  QUEUE_REMOVE(\u0026req.queue);\n  uv__req_unregister(stream-\u003eloop, \u0026req);\n  if (req.bufs != req.bufsml)\n    uv__free(req.bufs);\n  req.bufs = NULL;\n\n  /* Do not poll for writable, if we wasn't before calling this */\n  if (!has_pollout) {\n    uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLOUT);\n    uv__stream_osx_interrupt_select(stream);\n  }\n\n  if (written == 0 \u0026\u0026 req_size != 0)\n    return -EAGAIN;\n  else\n    return written;\n}","filepath":"src/unix/stream.c","line_number":1479,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5187472":{"score":0.93028766,"function_name":"uv_read_start","code":"int uv_read_start(uv_stream_t* stream,\n                  uv_alloc_cb alloc_cb,\n                  uv_read_cb read_cb) {\n  assert(stream-\u003etype == UV_TCP || stream-\u003etype == UV_NAMED_PIPE ||\n      stream-\u003etype == UV_TTY);\n\n  if (stream-\u003eflags \u0026 UV_CLOSING)\n    return -EINVAL;\n\n  /* The UV_STREAM_READING flag is irrelevant of the state of the tcp - it just\n   * expresses the desired state of the user.\n   */\n  stream-\u003eflags |= UV_STREAM_READING;\n\n  /* TODO: try to do the read inline? */\n  /* TODO: keep track of tcp state. If we've gotten a EOF then we should\n   * not start the IO watcher.\n   */\n  assert(uv__stream_fd(stream) \u003e= 0);\n  assert(alloc_cb);\n\n  stream-\u003eread_cb = read_cb;\n  stream-\u003ealloc_cb = alloc_cb;\n\n  uv__io_start(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  uv__handle_start(stream);\n  uv__stream_osx_interrupt_select(stream);\n\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1527,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5187680":{"score":0.8914405,"function_name":"uv_read_stop","code":"int uv_read_stop(uv_stream_t* stream) {\n  if (!(stream-\u003eflags \u0026 UV_STREAM_READING))\n    return 0;\n\n  stream-\u003eflags \u0026= ~UV_STREAM_READING;\n  uv__io_stop(stream-\u003eloop, \u0026stream-\u003eio_watcher, POLLIN);\n  if (!uv__io_active(\u0026stream-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(stream);\n  uv__stream_osx_interrupt_select(stream);\n\n  stream-\u003eread_cb = NULL;\n  stream-\u003ealloc_cb = NULL;\n  return 0;\n}","filepath":"src/unix/stream.c","line_number":1559,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5187840":{"score":0.87736017,"function_name":"uv__stream_close","code":"void uv__stream_close(uv_stream_t* handle) {\n  unsigned int i;\n  uv__stream_queued_fds_t* queued_fds;\n\n#if defined(__APPLE__)\n  /* Terminate select loop first */\n  if (handle-\u003eselect != NULL) {\n    uv__stream_select_t* s;\n\n    s = handle-\u003eselect;\n\n    uv_sem_post(\u0026s-\u003eclose_sem);\n    uv_sem_post(\u0026s-\u003easync_sem);\n    uv__stream_osx_interrupt_select(handle);\n    uv_thread_join(\u0026s-\u003ethread);\n    uv_sem_destroy(\u0026s-\u003eclose_sem);\n    uv_sem_destroy(\u0026s-\u003easync_sem);\n    uv__close(s-\u003efake_fd);\n    uv__close(s-\u003eint_fd);\n    uv_close((uv_handle_t*) \u0026s-\u003easync, uv__stream_osx_cb_close);\n\n    handle-\u003eselect = NULL;\n  }\n#endif /* defined(__APPLE__) */\n\n  uv__io_close(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  uv_read_stop(handle);\n  uv__handle_stop(handle);\n\n  if (handle-\u003eio_watcher.fd != -1) {\n    /* Don't close stdio file descriptors.  Nothing good comes from it. */\n    if (handle-\u003eio_watcher.fd \u003e STDERR_FILENO)\n      uv__close(handle-\u003eio_watcher.fd);\n    handle-\u003eio_watcher.fd = -1;\n  }\n\n  if (handle-\u003eaccepted_fd != -1) {\n    uv__close(handle-\u003eaccepted_fd);\n    handle-\u003eaccepted_fd = -1;\n  }\n\n  /* Close all queued fds */\n  if (handle-\u003equeued_fds != NULL) {\n    queued_fds = handle-\u003equeued_fds;\n    for (i = 0; i \u003c queued_fds-\u003eoffset; i++)\n      uv__close(queued_fds-\u003efds[i]);\n    uv__free(handle-\u003equeued_fds);\n    handle-\u003equeued_fds = NULL;\n  }\n\n  assert(!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN | POLLOUT));\n}","filepath":"src/unix/stream.c","line_number":1602,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.11.0"},"5188176":{"score":0.70656615,"function_name":"maybe_new_socket","code":"static int maybe_new_socket(uv_tcp_t* handle, int domain, int flags) {\n  int sockfd;\n  int err;\n\n  if (domain == AF_UNSPEC || uv__stream_fd(handle) != -1) {\n    handle-\u003eflags |= flags;\n    return 0;\n  }\n\n  err = uv__socket(domain, SOCK_STREAM, 0);\n  if (err \u003c 0)\n    return err;\n  sockfd = err;\n\n  err = uv__stream_open((uv_stream_t*) handle, sockfd, flags);\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":31,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5188256":{"score":0.92982185,"function_name":"uv_tcp_init_ex","code":"int uv_tcp_init_ex(uv_loop_t* loop, uv_tcp_t* tcp, unsigned int flags) {\n  int domain;\n\n  /* Use the lower 8 bits for the domain */\n  domain = flags \u0026 0xFF;\n  if (domain != AF_INET \u0026\u0026 domain != AF_INET6 \u0026\u0026 domain != AF_UNSPEC)\n    return -EINVAL;\n\n  if (flags \u0026 ~0xFF)\n    return -EINVAL;\n\n  uv__stream_init(loop, (uv_stream_t*)tcp, UV_TCP);\n\n  /* If anything fails beyond this point we need to remove the handle from\n   * the handle queue, since it was added by uv__handle_init in uv_stream_init.\n   */\n\n  if (domain != AF_UNSPEC) {\n    int err = maybe_new_socket(tcp, domain, 0);\n    if (err) {\n      QUEUE_REMOVE(\u0026tcp-\u003ehandle_queue);\n      return err;\n    }\n  }\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":55,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5188400":{"score":0.8980602,"function_name":"uv__tcp_bind","code":"int uv__tcp_bind(uv_tcp_t* tcp,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 unsigned int flags) {\n  int err;\n  int on;\n\n  /* Cannot set IPv6-only mode on non-IPv6 socket. */\n  if ((flags \u0026 UV_TCP_IPV6ONLY) \u0026\u0026 addr-\u003esa_family != AF_INET6)\n    return -EINVAL;\n\n  err = maybe_new_socket(tcp,\n                         addr-\u003esa_family,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n  if (err)\n    return err;\n\n  on = 1;\n  if (setsockopt(tcp-\u003eio_watcher.fd, SOL_SOCKET, SO_REUSEADDR, \u0026on, sizeof(on)))\n    return -errno;\n\n#ifdef IPV6_V6ONLY\n  if (addr-\u003esa_family == AF_INET6) {\n    on = (flags \u0026 UV_TCP_IPV6ONLY) != 0;\n    if (setsockopt(tcp-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   IPV6_V6ONLY,\n                   \u0026on,\n                   sizeof on) == -1) {\n      return -errno;\n    }\n  }\n#endif\n\n  errno = 0;\n  if (bind(tcp-\u003eio_watcher.fd, addr, addrlen) \u0026\u0026 errno != EADDRINUSE) {\n    if (errno == EAFNOSUPPORT)\n      /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\n       * socket created with AF_INET to an AF_INET6 address or vice versa. */\n      return -EINVAL;\n    return -errno;\n  }\n  tcp-\u003edelayed_error = -errno;\n\n  if (addr-\u003esa_family == AF_INET6)\n    tcp-\u003eflags |= UV_HANDLE_IPV6;\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":89,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5188800":{"score":0.9232551,"function_name":"uv__tcp_connect","code":"int uv__tcp_connect(uv_connect_t* req,\n                    uv_tcp_t* handle,\n                    const struct sockaddr* addr,\n                    unsigned int addrlen,\n                    uv_connect_cb cb) {\n  int err;\n  int r;\n\n  assert(handle-\u003etype == UV_TCP);\n\n  if (handle-\u003econnect_req != NULL)\n    return -EALREADY;  /* FIXME(bnoordhuis) -EINVAL or maybe -EBUSY. */\n\n  err = maybe_new_socket(handle,\n                         addr-\u003esa_family,\n                         UV_STREAM_READABLE | UV_STREAM_WRITABLE);\n  if (err)\n    return err;\n\n  handle-\u003edelayed_error = 0;\n\n  do\n    r = connect(uv__stream_fd(handle), addr, addrlen);\n  while (r == -1 \u0026\u0026 errno == EINTR);\n\n  if (r == -1) {\n    if (errno == EINPROGRESS)\n      ; /* not an error */\n    else if (errno == ECONNREFUSED)\n    /* If we get a ECONNREFUSED wait until the next tick to report the\n     * error. Solaris wants to report immediately--other unixes want to\n     * wait.\n     */\n      handle-\u003edelayed_error = -errno;\n    else\n      return -errno;\n  }\n\n  uv__req_init(handle-\u003eloop, req, UV_CONNECT);\n  req-\u003ecb = cb;\n  req-\u003ehandle = (uv_stream_t*) handle;\n  QUEUE_INIT(\u0026req-\u003equeue);\n  handle-\u003econnect_req = req;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, UV__POLLOUT);\n\n  if (handle-\u003edelayed_error)\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":140,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5189232":{"score":0.9252783,"function_name":"uv_tcp_getpeername","code":"int uv_tcp_getpeername(const uv_tcp_t* handle,\n                       struct sockaddr* name,\n                       int* namelen) {\n  socklen_t socklen;\n\n  if (handle-\u003edelayed_error)\n    return handle-\u003edelayed_error;\n\n  if (uv__stream_fd(handle) \u003c 0)\n    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n\n  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n  socklen = (socklen_t) *namelen;\n\n  if (getpeername(uv__stream_fd(handle), name, \u0026socklen))\n    return -errno;\n\n  *namelen = (int) socklen;\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":228,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5189488":{"score":0.8078993,"function_name":"uv_tcp_listen","code":"int uv_tcp_listen(uv_tcp_t* tcp, int backlog, uv_connection_cb cb) {\n  static int single_accept = -1;\n  int err;\n\n  if (tcp-\u003edelayed_error)\n    return tcp-\u003edelayed_error;\n\n  if (single_accept == -1) {\n    const char* val = getenv(\"UV_TCP_SINGLE_ACCEPT\");\n    single_accept = (val != NULL \u0026\u0026 atoi(val) != 0);  /* Off by default. */\n  }\n\n  if (single_accept)\n    tcp-\u003eflags |= UV_TCP_SINGLE_ACCEPT;\n\n  err = maybe_new_socket(tcp, AF_INET, UV_STREAM_READABLE);\n  if (err)\n    return err;\n\n  if (listen(tcp-\u003eio_watcher.fd, backlog))\n    return -errno;\n\n  tcp-\u003econnection_cb = cb;\n\n  /* Start listening for connections. */\n  tcp-\u003eio_watcher.cb = uv__server_io;\n  uv__io_start(tcp-\u003eloop, \u0026tcp-\u003eio_watcher, UV__POLLIN);\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":250,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5189824":{"score":0.8712209,"function_name":"uv__tcp_keepalive","code":"int uv__tcp_keepalive(int fd, int on, unsigned int delay) {\n  if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, \u0026on, sizeof(on)))\n    return -errno;\n\n#ifdef TCP_KEEPIDLE\n  if (on \u0026\u0026 setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, \u0026delay, sizeof(delay)))\n    return -errno;\n#endif\n\n  /* Solaris/SmartOS, if you don't support keep-alive,\n   * then don't advertise it in your system headers...\n   */\n  /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */\n#if defined(TCP_KEEPALIVE) \u0026\u0026 !defined(__sun)\n  if (on \u0026\u0026 setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, \u0026delay, sizeof(delay)))\n    return -errno;\n#endif\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":289,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5189952":{"score":0.88033247,"function_name":"uv_tcp_nodelay","code":"int uv_tcp_nodelay(uv_tcp_t* handle, int on) {\n  int err;\n\n  if (uv__stream_fd(handle) != -1) {\n    err = uv__tcp_nodelay(uv__stream_fd(handle), on);\n    if (err)\n      return err;\n  }\n\n  if (on)\n    handle-\u003eflags |= UV_TCP_NODELAY;\n  else\n    handle-\u003eflags \u0026= ~UV_TCP_NODELAY;\n\n  return 0;\n}","filepath":"src/unix/tcp.c","line_number":311,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5191824":{"score":0.8326995,"function_name":"timer_less_than","code":"static int timer_less_than(const struct heap_node* ha,\n                           const struct heap_node* hb) {\n  const uv_timer_t* a;\n  const uv_timer_t* b;\n\n  a = container_of(ha, const uv_timer_t, heap_node);\n  b = container_of(hb, const uv_timer_t, heap_node);\n\n  if (a-\u003etimeout \u003c b-\u003etimeout)\n    return 1;\n  if (b-\u003etimeout \u003c a-\u003etimeout)\n    return 0;\n\n  /* Compare start_id when both have the same timeout. start_id is\n   * allocated with loop-\u003etimer_counter in uv_timer_start().\n   */\n  if (a-\u003estart_id \u003c b-\u003estart_id)\n    return 1;\n  if (b-\u003estart_id \u003c a-\u003estart_id)\n    return 0;\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":29,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5192096":{"score":0.67677426,"function_name":"uv_timer_stop","code":"int uv_timer_stop(uv_timer_t* handle) {\n  if (!uv__is_active(handle))\n    return 0;\n\n  heap_remove((struct heap*) \u0026handle-\u003eloop-\u003etimer_heap,\n              (struct heap_node*) \u0026handle-\u003eheap_node,\n              timer_less_than);\n  uv__handle_stop(handle);\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":93,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5192608":{"score":0.9075788,"function_name":"uv_timer_start","code":"int uv_timer_start(uv_timer_t* handle,\n                   uv_timer_cb cb,\n                   uint64_t timeout,\n                   uint64_t repeat) {\n  uint64_t clamped_timeout;\n\n  if (cb == NULL)\n    return -EINVAL;\n\n  if (uv__is_active(handle))\n    uv_timer_stop(handle);\n\n  clamped_timeout = handle-\u003eloop-\u003etime + timeout;\n  if (clamped_timeout \u003c timeout)\n    clamped_timeout = (uint64_t) -1;\n\n  handle-\u003etimer_cb = cb;\n  handle-\u003etimeout = clamped_timeout;\n  handle-\u003erepeat = repeat;\n  /* start_id is the second index to be compared in uv__timer_cmp() */\n  handle-\u003estart_id = handle-\u003eloop-\u003etimer_counter++;\n\n  heap_insert((struct heap*) \u0026handle-\u003eloop-\u003etimer_heap,\n              (struct heap_node*) \u0026handle-\u003eheap_node,\n              timer_less_than);\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":62,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5192992":{"score":0.93075037,"function_name":"uv_timer_again","code":"int uv_timer_again(uv_timer_t* handle) {\n  if (handle-\u003etimer_cb == NULL)\n    return -EINVAL;\n\n  if (handle-\u003erepeat) {\n    uv_timer_stop(handle);\n    uv_timer_start(handle, handle-\u003etimer_cb, handle-\u003erepeat, handle-\u003erepeat);\n  }\n\n  return 0;\n}","filepath":"src/unix/timer.c","line_number":106,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5193088":{"score":0.8670291,"function_name":"uv__next_timeout","code":"int uv__next_timeout(const uv_loop_t* loop) {\n  const struct heap_node* heap_node;\n  const uv_timer_t* handle;\n  uint64_t diff;\n\n  heap_node = heap_min((const struct heap*) \u0026loop-\u003etimer_heap);\n  if (heap_node == NULL)\n    return -1; /* block indefinitely */\n\n  handle = container_of(heap_node, const uv_timer_t, heap_node);\n  if (handle-\u003etimeout \u003c= loop-\u003etime)\n    return 0;\n\n  diff = handle-\u003etimeout - loop-\u003etime;\n  if (diff \u003e INT_MAX)\n    diff = INT_MAX;\n\n  return diff;\n}","filepath":"src/unix/timer.c","line_number":129,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5193152":{"score":0.7658919,"function_name":"uv__run_timers","code":"void uv__run_timers(uv_loop_t* loop) {\n  struct heap_node* heap_node;\n  uv_timer_t* handle;\n\n  for (;;) {\n    heap_node = heap_min((struct heap*) \u0026loop-\u003etimer_heap);\n    if (heap_node == NULL)\n      break;\n\n    handle = container_of(heap_node, uv_timer_t, heap_node);\n    if (handle-\u003etimeout \u003e loop-\u003etime)\n      break;\n\n    uv_timer_stop(handle);\n    uv_timer_again(handle);\n    handle-\u003etimer_cb(handle);\n  }\n}","filepath":"src/unix/timer.c","line_number":150,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.0.0-rc1"},"5193328":{"score":0.8542999,"function_name":"uv_tty_set_mode","code":"int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {\n  struct termios tmp;\n  int fd;\n\n  if (tty-\u003emode == (int) mode)\n    return 0;\n\n  fd = uv__stream_fd(tty);\n  if (tty-\u003emode == UV_TTY_MODE_NORMAL \u0026\u0026 mode != UV_TTY_MODE_NORMAL) {\n    if (tcgetattr(fd, \u0026tty-\u003eorig_termios))\n      return -errno;\n\n    /* This is used for uv_tty_reset_mode() */\n    uv_spinlock_lock(\u0026termios_spinlock);\n    if (orig_termios_fd == -1) {\n      orig_termios = tty-\u003eorig_termios;\n      orig_termios_fd = fd;\n    }\n    uv_spinlock_unlock(\u0026termios_spinlock);\n  }\n\n  tmp = tty-\u003eorig_termios;\n  switch (mode) {\n    case UV_TTY_MODE_NORMAL:\n      break;\n    case UV_TTY_MODE_RAW:\n      tmp.c_iflag \u0026= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n      tmp.c_oflag |= (ONLCR);\n      tmp.c_cflag |= (CS8);\n      tmp.c_lflag \u0026= ~(ECHO | ICANON | IEXTEN | ISIG);\n      tmp.c_cc[VMIN] = 1;\n      tmp.c_cc[VTIME] = 0;\n      break;\n    case UV_TTY_MODE_IO:\n      uv__tty_make_raw(\u0026tmp);\n      break;\n  }\n\n  /* Apply changes after draining */\n  if (tcsetattr(fd, TCSADRAIN, \u0026tmp))\n    return -errno;\n\n  tty-\u003emode = mode;\n  return 0;\n}","filepath":"src/unix/tty.c","line_number":139,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5193920":{"score":0.89811933,"function_name":"uv_tty_get_winsize","code":"int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {\n  struct winsize ws;\n\n  if (ioctl(uv__stream_fd(tty), TIOCGWINSZ, \u0026ws))\n    return -errno;\n\n  *width = ws.ws_col;\n  *height = ws.ws_row;\n\n  return 0;\n}","filepath":"src/unix/tty.c","line_number":186,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5194032":{"score":0.90048075,"function_name":"uv_guess_handle","code":"uv_handle_type uv_guess_handle(uv_file file) {\n  struct sockaddr sa;\n  struct stat s;\n  socklen_t len;\n  int type;\n\n  if (file \u003c 0)\n    return UV_UNKNOWN_HANDLE;\n\n  if (isatty(file))\n    return UV_TTY;\n\n  if (fstat(file, \u0026s))\n    return UV_UNKNOWN_HANDLE;\n\n  if (S_ISREG(s.st_mode))\n    return UV_FILE;\n\n  if (S_ISCHR(s.st_mode))\n    return UV_FILE;  /* XXX UV_NAMED_PIPE? */\n\n  if (S_ISFIFO(s.st_mode))\n    return UV_NAMED_PIPE;\n\n  if (!S_ISSOCK(s.st_mode))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof(type);\n  if (getsockopt(file, SOL_SOCKET, SO_TYPE, \u0026type, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  len = sizeof(sa);\n  if (getsockname(file, \u0026sa, \u0026len))\n    return UV_UNKNOWN_HANDLE;\n\n  if (type == SOCK_DGRAM)\n    if (sa.sa_family == AF_INET || sa.sa_family == AF_INET6)\n      return UV_UDP;\n\n  if (type == SOCK_STREAM) {\n#if defined(_AIX)\n    /* on AIX the getsockname call returns an empty sa structure\n     * for sockets of type AF_UNIX.  For all other types it will\n     * return a properly filled in structure.\n     */\n    if (len == 0)\n      return UV_NAMED_PIPE;\n#endif /* defined(_AIX) */\n\n    if (sa.sa_family == AF_INET || sa.sa_family == AF_INET6)\n      return UV_TCP;\n    if (sa.sa_family == AF_UNIX)\n      return UV_NAMED_PIPE;\n  }\n\n  return UV_UNKNOWN_HANDLE;\n}","filepath":"src/unix/tty.c","line_number":199,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5194384":{"score":0.94944227,"function_name":"uv_tty_init","code":"int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, int fd, int readable) {\n  uv_handle_type type;\n  int flags;\n  int newfd;\n  int r;\n\n  /* File descriptors that refer to files cannot be monitored with epoll.\n   * That restriction also applies to character devices like /dev/random\n   * (but obviously not /dev/tty.)\n   */\n  type = uv_guess_handle(fd);\n  if (type == UV_FILE || type == UV_UNKNOWN_HANDLE)\n    return -EINVAL;\n\n  flags = 0;\n  newfd = -1;\n\n  /* Reopen the file descriptor when it refers to a tty. This lets us put the\n   * tty in non-blocking mode without affecting other processes that share it\n   * with us.\n   *\n   * Example: `node | cat` - if we put our fd 0 in non-blocking mode, it also\n   * affects fd 1 of `cat` because both file descriptors refer to the same\n   * struct file in the kernel. When we reopen our fd 0, it points to a\n   * different struct file, hence changing its properties doesn't affect\n   * other processes.\n   */\n  if (type == UV_TTY) {\n    r = uv__open_cloexec(\"/dev/tty\", O_RDWR);\n\n    if (r \u003c 0) {\n      /* fallback to using blocking writes */\n      if (!readable)\n        flags |= UV_STREAM_BLOCKING;\n      goto skip;\n    }\n\n    newfd = r;\n\n    r = uv__dup2_cloexec(newfd, fd);\n    if (r \u003c 0 \u0026\u0026 r != -EINVAL) {\n      /* EINVAL means newfd == fd which could conceivably happen if another\n       * thread called close(fd) between our calls to isatty() and open().\n       * That's a rather unlikely event but let's handle it anyway.\n       */\n      uv__close(newfd);\n      return r;\n    }\n\n    fd = newfd;\n  }\n\nskip:\n  uv__stream_init(loop, (uv_stream_t*) tty, UV_TTY);\n\n  /* If anything fails beyond this point we need to remove the handle from\n   * the handle queue, since it was added by uv__handle_init in uv_stream_init.\n   */\n\n#if defined(__APPLE__)\n  r = uv__stream_try_select((uv_stream_t*) tty, \u0026fd);\n  if (r) {\n    if (newfd != -1)\n      uv__close(newfd);\n    QUEUE_REMOVE(\u0026tty-\u003ehandle_queue);\n    return r;\n  }\n#endif\n\n  if (readable)\n    flags |= UV_STREAM_READABLE;\n  else\n    flags |= UV_STREAM_WRITABLE;\n\n  if (!(flags \u0026 UV_STREAM_BLOCKING))\n    uv__nonblock(fd, 1);\n\n  uv__stream_open((uv_stream_t*) tty, fd, flags);\n  tty-\u003emode = UV_TTY_MODE_NORMAL;\n\n  return 0;\n}","filepath":"src/unix/tty.c","line_number":37,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5194672":{"score":0.72780776,"function_name":"uv_tty_reset_mode","code":"int uv_tty_reset_mode(void) {\n  int saved_errno;\n  int err;\n\n  saved_errno = errno;\n  if (!uv_spinlock_trylock(\u0026termios_spinlock))\n    return -EBUSY;  /* In uv_tty_set_mode(). */\n\n  err = 0;\n  if (orig_termios_fd != -1)\n    if (tcsetattr(orig_termios_fd, TCSANOW, \u0026orig_termios))\n      err = -errno;\n\n  uv_spinlock_unlock(\u0026termios_spinlock);\n  errno = saved_errno;\n\n  return err;\n}","filepath":"src/unix/tty.c","line_number":262,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.8.0"},"5194784":{"score":0.9055083,"function_name":"uv__udp_run_completed","code":"static void uv__udp_run_completed(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n\n  assert(!(handle-\u003eflags \u0026 UV_UDP_PROCESSING));\n  handle-\u003eflags |= UV_UDP_PROCESSING;\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_completed_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_completed_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    uv__req_unregister(handle-\u003eloop, req);\n\n    handle-\u003esend_queue_size -= uv__count_bufs(req-\u003ebufs, req-\u003enbufs);\n    handle-\u003esend_queue_count--;\n\n    if (req-\u003ebufs != req-\u003ebufsml)\n      uv__free(req-\u003ebufs);\n    req-\u003ebufs = NULL;\n\n    if (req-\u003esend_cb == NULL)\n      continue;\n\n    /* req-\u003estatus \u003e= 0 == bytes written\n     * req-\u003estatus \u003c  0 == errno\n     */\n    if (req-\u003estatus \u003e= 0)\n      req-\u003esend_cb(req, 0);\n    else\n      req-\u003esend_cb(req, req-\u003estatus);\n  }\n\n  if (QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    /* Pending queue and completion queue empty, stop watcher. */\n    uv__io_stop(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLOUT);\n    if (!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN))\n      uv__handle_stop(handle);\n  }\n\n  handle-\u003eflags \u0026= ~UV_UDP_PROCESSING;\n}","filepath":"src/unix/udp.c","line_number":88,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5195216":{"score":0.8280554,"function_name":"uv__set_reuse","code":"static int uv__set_reuse(int fd) {\n  int yes;\n\n#if defined(SO_REUSEPORT) \u0026\u0026 !defined(__linux__)\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, \u0026yes, sizeof(yes)))\n    return -errno;\n#else\n  yes = 1;\n  if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, \u0026yes, sizeof(yes)))\n    return -errno;\n#endif\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":261,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5195312":{"score":0.9339268,"function_name":"uv__udp_sendmsg","code":"static void uv__udp_sendmsg(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n  struct msghdr h;\n  ssize_t size;\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_queue);\n    assert(q != NULL);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    assert(req != NULL);\n\n    memset(\u0026h, 0, sizeof h);\n    h.msg_name = \u0026req-\u003eaddr;\n    h.msg_namelen = (req-\u003eaddr.ss_family == AF_INET6 ?\n      sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in));\n    h.msg_iov = (struct iovec*) req-\u003ebufs;\n    h.msg_iovlen = req-\u003enbufs;\n\n    do {\n      size = sendmsg(handle-\u003eio_watcher.fd, \u0026h, 0);\n    } while (size == -1 \u0026\u0026 errno == EINTR);\n\n    if (size == -1 \u0026\u0026 (errno == EAGAIN || errno == EWOULDBLOCK))\n      break;\n\n    req-\u003estatus = (size == -1 ? -errno : size);\n\n    /* Sending a datagram is an atomic operation: either all data\n     * is written or nothing is (and EMSGSIZE is raised). That is\n     * why we don't handle partial writes. Just pop the request\n     * off the write queue and onto the completed queue, done.\n     */\n    QUEUE_REMOVE(\u0026req-\u003equeue);\n    QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n    uv__io_feed(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  }\n}","filepath":"src/unix/udp.c","line_number":212,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5195744":{"score":0.8775587,"function_name":"uv__udp_io","code":"static void uv__udp_io(uv_loop_t* loop, uv__io_t* w, unsigned int revents) {\n  uv_udp_t* handle;\n\n  handle = container_of(w, uv_udp_t, io_watcher);\n  assert(handle-\u003etype == UV_UDP);\n\n  if (revents \u0026 POLLIN)\n    uv__udp_recvmsg(handle);\n\n  if (revents \u0026 POLLOUT) {\n    uv__udp_sendmsg(handle);\n    uv__udp_run_completed(handle);\n  }\n}","filepath":"src/unix/udp.c","line_number":132,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5196304":{"score":0.6558661,"function_name":"uv__setsockopt","code":"static int uv__setsockopt(uv_udp_t* handle,\n                         int option4,\n                         int option6,\n                         const void* val,\n                         size_t size) {\n  int r;\n\n  if (handle-\u003eflags \u0026 UV_HANDLE_IPV6)\n    r = setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   option6,\n                   val,\n                   size);\n  else\n    r = setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IP,\n                   option4,\n                   val,\n                   size);\n  if (r)\n    return -errno;\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":642,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5196384":{"score":0.7375834,"function_name":"uv__udp_close","code":"void uv__udp_close(uv_udp_t* handle) {\n  uv__io_close(handle-\u003eloop, \u0026handle-\u003eio_watcher);\n  uv__handle_stop(handle);\n\n  if (handle-\u003eio_watcher.fd != -1) {\n    uv__close(handle-\u003eio_watcher.fd);\n    handle-\u003eio_watcher.fd = -1;\n  }\n}","filepath":"src/unix/udp.c","line_number":49,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5196480":{"score":0.9361156,"function_name":"uv__udp_finish_close","code":"void uv__udp_finish_close(uv_udp_t* handle) {\n  uv_udp_send_t* req;\n  QUEUE* q;\n\n  assert(!uv__io_active(\u0026handle-\u003eio_watcher, POLLIN | POLLOUT));\n  assert(handle-\u003eio_watcher.fd == -1);\n\n  while (!QUEUE_EMPTY(\u0026handle-\u003ewrite_queue)) {\n    q = QUEUE_HEAD(\u0026handle-\u003ewrite_queue);\n    QUEUE_REMOVE(q);\n\n    req = QUEUE_DATA(q, uv_udp_send_t, queue);\n    req-\u003estatus = -ECANCELED;\n    QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_completed_queue, \u0026req-\u003equeue);\n  }\n\n  uv__udp_run_completed(handle);\n\n  assert(handle-\u003esend_queue_size == 0);\n  assert(handle-\u003esend_queue_count == 0);\n\n  /* Now tear down the handle. */\n  handle-\u003erecv_cb = NULL;\n  handle-\u003ealloc_cb = NULL;\n  /* but _do not_ touch close_cb */\n}","filepath":"src/unix/udp.c","line_number":60,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5196768":{"score":0.9160067,"function_name":"uv__udp_bind","code":"int uv__udp_bind(uv_udp_t* handle,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 unsigned int flags) {\n  int err;\n  int yes;\n  int fd;\n\n  /* Check for bad flags. */\n  if (flags \u0026 ~(UV_UDP_IPV6ONLY | UV_UDP_REUSEADDR))\n    return -EINVAL;\n\n  /* Cannot set IPv6-only mode on non-IPv6 socket. */\n  if ((flags \u0026 UV_UDP_IPV6ONLY) \u0026\u0026 addr-\u003esa_family != AF_INET6)\n    return -EINVAL;\n\n  fd = handle-\u003eio_watcher.fd;\n  if (fd == -1) {\n    err = uv__socket(addr-\u003esa_family, SOCK_DGRAM, 0);\n    if (err \u003c 0)\n      return err;\n    fd = err;\n    handle-\u003eio_watcher.fd = fd;\n  }\n\n  if (flags \u0026 UV_UDP_REUSEADDR) {\n    err = uv__set_reuse(fd);\n    if (err)\n      goto out;\n  }\n\n  if (flags \u0026 UV_UDP_IPV6ONLY) {\n#ifdef IPV6_V6ONLY\n    yes = 1;\n    if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, \u0026yes, sizeof yes) == -1) {\n      err = -errno;\n      goto out;\n    }\n#else\n    err = -ENOTSUP;\n    goto out;\n#endif\n  }\n\n  if (bind(fd, addr, addrlen)) {\n    err = -errno;\n    if (errno == EAFNOSUPPORT)\n      /* OSX, other BSDs and SunoS fail with EAFNOSUPPORT when binding a\n       * socket created with AF_INET to an AF_INET6 address or vice versa. */\n      err = -EINVAL;\n    goto out;\n  }\n\n  if (addr-\u003esa_family == AF_INET6)\n    handle-\u003eflags |= UV_HANDLE_IPV6;\n\n  return 0;\n\nout:\n  uv__close(handle-\u003eio_watcher.fd);\n  handle-\u003eio_watcher.fd = -1;\n  return err;\n}","filepath":"src/unix/udp.c","line_number":278,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5197200":{"score":0.9463304,"function_name":"uv__udp_maybe_deferred_bind","code":"static int uv__udp_maybe_deferred_bind(uv_udp_t* handle,\n                                       int domain,\n                                       unsigned int flags) {\n  unsigned char taddr[sizeof(struct sockaddr_in6)];\n  socklen_t addrlen;\n\n  if (handle-\u003eio_watcher.fd != -1)\n    return 0;\n\n  switch (domain) {\n  case AF_INET:\n  {\n    struct sockaddr_in* addr = (void*)\u0026taddr;\n    memset(addr, 0, sizeof *addr);\n    addr-\u003esin_family = AF_INET;\n    addr-\u003esin_addr.s_addr = INADDR_ANY;\n    addrlen = sizeof *addr;\n    break;\n  }\n  case AF_INET6:\n  {\n    struct sockaddr_in6* addr = (void*)\u0026taddr;\n    memset(addr, 0, sizeof *addr);\n    addr-\u003esin6_family = AF_INET6;\n    addr-\u003esin6_addr = in6addr_any;\n    addrlen = sizeof *addr;\n    break;\n  }\n  default:\n    assert(0 \u0026\u0026 \"unsupported address family\");\n    abort();\n  }\n\n  return uv__udp_bind(handle, (const struct sockaddr*) \u0026taddr, addrlen, flags);\n}","filepath":"src/unix/udp.c","line_number":343,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5197424":{"score":0.95122224,"function_name":"uv__udp_send","code":"int uv__udp_send(uv_udp_send_t* req,\n                 uv_udp_t* handle,\n                 const uv_buf_t bufs[],\n                 unsigned int nbufs,\n                 const struct sockaddr* addr,\n                 unsigned int addrlen,\n                 uv_udp_send_cb send_cb) {\n  int err;\n  int empty_queue;\n\n  assert(nbufs \u003e 0);\n\n  err = uv__udp_maybe_deferred_bind(handle, addr-\u003esa_family, 0);\n  if (err)\n    return err;\n\n  /* It's legal for send_queue_count \u003e 0 even when the write_queue is empty;\n   * it means there are error-state requests in the write_completed_queue that\n   * will touch up send_queue_size/count later.\n   */\n  empty_queue = (handle-\u003esend_queue_count == 0);\n\n  uv__req_init(handle-\u003eloop, req, UV_UDP_SEND);\n  assert(addrlen \u003c= sizeof(req-\u003eaddr));\n  memcpy(\u0026req-\u003eaddr, addr, addrlen);\n  req-\u003esend_cb = send_cb;\n  req-\u003ehandle = handle;\n  req-\u003enbufs = nbufs;\n\n  req-\u003ebufs = req-\u003ebufsml;\n  if (nbufs \u003e ARRAY_SIZE(req-\u003ebufsml))\n    req-\u003ebufs = uv__malloc(nbufs * sizeof(bufs[0]));\n\n  if (req-\u003ebufs == NULL) {\n    uv__req_unregister(handle-\u003eloop, req);\n    return -ENOMEM;\n  }\n\n  memcpy(req-\u003ebufs, bufs, nbufs * sizeof(bufs[0]));\n  handle-\u003esend_queue_size += uv__count_bufs(req-\u003ebufs, req-\u003enbufs);\n  handle-\u003esend_queue_count++;\n  QUEUE_INSERT_TAIL(\u0026handle-\u003ewrite_queue, \u0026req-\u003equeue);\n  uv__handle_start(handle);\n\n  if (empty_queue \u0026\u0026 !(handle-\u003eflags \u0026 UV_UDP_PROCESSING)) {\n    uv__udp_sendmsg(handle);\n  } else {\n    uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLOUT);\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":380,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5198112":{"score":0.9378383,"function_name":"uv__udp_try_send","code":"int uv__udp_try_send(uv_udp_t* handle,\n                     const uv_buf_t bufs[],\n                     unsigned int nbufs,\n                     const struct sockaddr* addr,\n                     unsigned int addrlen) {\n  int err;\n  struct msghdr h;\n  ssize_t size;\n\n  assert(nbufs \u003e 0);\n\n  /* already sending a message */\n  if (handle-\u003esend_queue_count != 0)\n    return -EAGAIN;\n\n  err = uv__udp_maybe_deferred_bind(handle, addr-\u003esa_family, 0);\n  if (err)\n    return err;\n\n  memset(\u0026h, 0, sizeof h);\n  h.msg_name = (struct sockaddr*) addr;\n  h.msg_namelen = addrlen;\n  h.msg_iov = (struct iovec*) bufs;\n  h.msg_iovlen = nbufs;\n\n  do {\n    size = sendmsg(handle-\u003eio_watcher.fd, \u0026h, 0);\n  } while (size == -1 \u0026\u0026 errno == EINTR);\n\n  if (size == -1) {\n    if (errno == EAGAIN || errno == EWOULDBLOCK)\n      return -EAGAIN;\n    else\n      return -errno;\n  }\n\n  return size;\n}","filepath":"src/unix/udp.c","line_number":434,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5198368":{"score":0.91588354,"function_name":"uv_udp_init_ex","code":"int uv_udp_init_ex(uv_loop_t* loop, uv_udp_t* handle, unsigned int flags) {\n  int domain;\n  int err;\n  int fd;\n\n  /* Use the lower 8 bits for the domain */\n  domain = flags \u0026 0xFF;\n  if (domain != AF_INET \u0026\u0026 domain != AF_INET6 \u0026\u0026 domain != AF_UNSPEC)\n    return -EINVAL;\n\n  if (flags \u0026 ~0xFF)\n    return -EINVAL;\n\n  if (domain != AF_UNSPEC) {\n    err = uv__socket(domain, SOCK_DGRAM, 0);\n    if (err \u003c 0)\n      return err;\n    fd = err;\n  } else {\n    fd = -1;\n  }\n\n  uv__handle_init(loop, (uv_handle_t*)handle, UV_UDP);\n  handle-\u003ealloc_cb = NULL;\n  handle-\u003erecv_cb = NULL;\n  handle-\u003esend_queue_size = 0;\n  handle-\u003esend_queue_count = 0;\n  uv__io_init(\u0026handle-\u003eio_watcher, uv__udp_io, fd);\n  QUEUE_INIT(\u0026handle-\u003ewrite_queue);\n  QUEUE_INIT(\u0026handle-\u003ewrite_completed_queue);\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":560,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5198640":{"score":0.9439486,"function_name":"uv_udp_open","code":"int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {\n  int err;\n\n  /* Check for already active socket. */\n  if (handle-\u003eio_watcher.fd != -1)\n    return -EBUSY;\n\n  err = uv__nonblock(sock, 1);\n  if (err)\n    return err;\n\n  err = uv__set_reuse(sock);\n  if (err)\n    return err;\n\n  handle-\u003eio_watcher.fd = sock;\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":599,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5198736":{"score":0.7653611,"function_name":"uv_udp_set_membership","code":"int uv_udp_set_membership(uv_udp_t* handle,\n                          const char* multicast_addr,\n                          const char* interface_addr,\n                          uv_membership membership) {\n  int err;\n  struct sockaddr_in addr4;\n  struct sockaddr_in6 addr6;\n\n  if (uv_ip4_addr(multicast_addr, 0, \u0026addr4) == 0) {\n    err = uv__udp_maybe_deferred_bind(handle, AF_INET, UV_UDP_REUSEADDR);\n    if (err)\n      return err;\n    return uv__udp_set_membership4(handle, \u0026addr4, interface_addr, membership);\n  } else if (uv_ip6_addr(multicast_addr, 0, \u0026addr6) == 0) {\n    err = uv__udp_maybe_deferred_bind(handle, AF_INET6, UV_UDP_REUSEADDR);\n    if (err)\n      return err;\n    return uv__udp_set_membership6(handle, \u0026addr6, interface_addr, membership);\n  } else {\n    return -EINVAL;\n  }\n}","filepath":"src/unix/udp.c","line_number":619,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5199216":{"score":0.9112047,"function_name":"uv_udp_set_broadcast","code":"int uv_udp_set_broadcast(uv_udp_t* handle, int on) {\n  if (setsockopt(handle-\u003eio_watcher.fd,\n                 SOL_SOCKET,\n                 SO_BROADCAST,\n                 \u0026on,\n                 sizeof(on))) {\n    return -errno;\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":686,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5199280":{"score":0.8502407,"function_name":"uv_udp_set_ttl","code":"int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {\n  if (ttl \u003c 1 || ttl \u003e 255)\n    return -EINVAL;\n\n/*\n * On Solaris and derivatives such as SmartOS, the length of socket options\n * is sizeof(int) for IP_TTL and IPV6_UNICAST_HOPS,\n * so hardcode the size of these options on this platform,\n * and use the general uv__setsockopt_maybe_char call on other platforms.\n */\n#if defined(__sun) || defined(_AIX) || defined(__OpenBSD__)\n  return uv__setsockopt(handle,\n                        IP_TTL,\n                        IPV6_UNICAST_HOPS,\n                        \u0026ttl,\n                        sizeof(ttl));\n#endif /* defined(__sun) || defined(_AIX) || defined (__OpenBSD__) */\n\n  return uv__setsockopt_maybe_char(handle,\n                                   IP_TTL,\n                                   IPV6_UNICAST_HOPS,\n                                   ttl);\n}","filepath":"src/unix/udp.c","line_number":699,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5199584":{"score":0.94116265,"function_name":"uv_udp_set_multicast_interface","code":"int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr) {\n  struct sockaddr_storage addr_st;\n  struct sockaddr_in* addr4;\n  struct sockaddr_in6* addr6;\n\n  addr4 = (struct sockaddr_in*) \u0026addr_st;\n  addr6 = (struct sockaddr_in6*) \u0026addr_st;\n\n  if (!interface_addr) {\n    memset(\u0026addr_st, 0, sizeof addr_st);\n    if (handle-\u003eflags \u0026 UV_HANDLE_IPV6) {\n      addr_st.ss_family = AF_INET6;\n      addr6-\u003esin6_scope_id = 0;\n    } else {\n      addr_st.ss_family = AF_INET;\n      addr4-\u003esin_addr.s_addr = htonl(INADDR_ANY);\n    }\n  } else if (uv_ip4_addr(interface_addr, 0, addr4) == 0) {\n    /* nothing, address was parsed */\n  } else if (uv_ip6_addr(interface_addr, 0, addr6) == 0) {\n    /* nothing, address was parsed */\n  } else {\n    return -EINVAL;\n  }\n\n  if (addr_st.ss_family == AF_INET) {\n    if (setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IP,\n                   IP_MULTICAST_IF,\n                   (void*) \u0026addr4-\u003esin_addr,\n                   sizeof(addr4-\u003esin_addr)) == -1) {\n      return -errno;\n    }\n  } else if (addr_st.ss_family == AF_INET6) {\n    if (setsockopt(handle-\u003eio_watcher.fd,\n                   IPPROTO_IPV6,\n                   IPV6_MULTICAST_IF,\n                   \u0026addr6-\u003esin6_scope_id,\n                   sizeof(addr6-\u003esin6_scope_id)) == -1) {\n      return -errno;\n    }\n  } else {\n    assert(0 \u0026\u0026 \"unexpected address family\");\n    abort();\n  }\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":769,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5199936":{"score":0.9318185,"function_name":"uv_udp_getsockname","code":"int uv_udp_getsockname(const uv_udp_t* handle,\n                       struct sockaddr* name,\n                       int* namelen) {\n  socklen_t socklen;\n\n  if (handle-\u003eio_watcher.fd == -1)\n    return -EINVAL;  /* FIXME(bnoordhuis) -EBADF */\n\n  /* sizeof(socklen_t) != sizeof(int) on some systems. */\n  socklen = (socklen_t) *namelen;\n\n  if (getsockname(handle-\u003eio_watcher.fd, name, \u0026socklen))\n    return -errno;\n\n  *namelen = (int) socklen;\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":819,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5200064":{"score":0.9398837,"function_name":"uv__udp_recv_start","code":"int uv__udp_recv_start(uv_udp_t* handle,\n                       uv_alloc_cb alloc_cb,\n                       uv_udp_recv_cb recv_cb) {\n  int err;\n\n  if (alloc_cb == NULL || recv_cb == NULL)\n    return -EINVAL;\n\n  if (uv__io_active(\u0026handle-\u003eio_watcher, POLLIN))\n    return -EALREADY;  /* FIXME(bnoordhuis) Should be -EBUSY. */\n\n  err = uv__udp_maybe_deferred_bind(handle, AF_INET, 0);\n  if (err)\n    return err;\n\n  handle-\u003ealloc_cb = alloc_cb;\n  handle-\u003erecv_cb = recv_cb;\n\n  uv__io_start(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLIN);\n  uv__handle_start(handle);\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":838,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5200256":{"score":0.83049667,"function_name":"uv__udp_recv_stop","code":"int uv__udp_recv_stop(uv_udp_t* handle) {\n  uv__io_stop(handle-\u003eloop, \u0026handle-\u003eio_watcher, POLLIN);\n\n  if (!uv__io_active(\u0026handle-\u003eio_watcher, POLLOUT))\n    uv__handle_stop(handle);\n\n  handle-\u003ealloc_cb = NULL;\n  handle-\u003erecv_cb = NULL;\n\n  return 0;\n}","filepath":"src/unix/udp.c","line_number":863,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.9.1"},"5200368":{"score":0.8905776,"function_name":"read_models","code":"static int read_models(unsigned int numcpus, uv_cpu_info_t* ci) {\n  static const char model_marker[] = \"model name\\t: \";\n  static const char speed_marker[] = \"cpu MHz\\t\\t: \";\n  const char* inferred_model;\n  unsigned int model_idx;\n  unsigned int speed_idx;\n  char buf[1024];\n  char* model;\n  FILE* fp;\n\n  /* Most are unused on non-ARM, non-MIPS and non-x86 architectures. */\n  (void) \u0026model_marker;\n  (void) \u0026speed_marker;\n  (void) \u0026speed_idx;\n  (void) \u0026model;\n  (void) \u0026buf;\n  (void) \u0026fp;\n\n  model_idx = 0;\n  speed_idx = 0;\n\n#if defined(__arm__) || \\\n    defined(__i386__) || \\\n    defined(__mips__) || \\\n    defined(__x86_64__)\n  fp = fopen(\"/proc/cpuinfo\", \"r\");\n  if (fp == NULL)\n    return -errno;\n\n  while (fgets(buf, sizeof(buf), fp)) {\n    if (model_idx \u003c numcpus) {\n      if (strncmp(buf, model_marker, sizeof(model_marker) - 1) == 0) {\n        model = buf + sizeof(model_marker) - 1;\n        model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n        if (model == NULL) {\n          fclose(fp);\n          return -ENOMEM;\n        }\n        ci[model_idx++].model = model;\n        continue;\n      }\n    }\n#if defined(__arm__) || defined(__mips__)\n    if (model_idx \u003c numcpus) {\n#if defined(__arm__)\n      /* Fallback for pre-3.8 kernels. */\n      static const char model_marker[] = \"Processor\\t: \";\n#else\t/* defined(__mips__) */\n      static const char model_marker[] = \"cpu model\\t\\t: \";\n#endif\n      if (strncmp(buf, model_marker, sizeof(model_marker) - 1) == 0) {\n        model = buf + sizeof(model_marker) - 1;\n        model = uv__strndup(model, strlen(model) - 1);  /* Strip newline. */\n        if (model == NULL) {\n          fclose(fp);\n          return -ENOMEM;\n        }\n        ci[model_idx++].model = model;\n        continue;\n      }\n    }\n#else  /* !__arm__ \u0026\u0026 !__mips__ */\n    if (speed_idx \u003c numcpus) {\n      if (strncmp(buf, speed_marker, sizeof(speed_marker) - 1) == 0) {\n        ci[speed_idx++].speed = atoi(buf + sizeof(speed_marker) - 1);\n        continue;\n      }\n    }\n#endif  /* __arm__ || __mips__ */\n  }\n\n  fclose(fp);\n#endif  /* __arm__ || __i386__ || __mips__ || __x86_64__ */\n\n  /* Now we want to make sure that all the models contain *something* because\n   * it's not safe to leave them as null. Copy the last entry unless there\n   * isn't one, in that case we simply put \"unknown\" into everything.\n   */\n  inferred_model = \"unknown\";\n  if (model_idx \u003e 0)\n    inferred_model = ci[model_idx - 1].model;\n\n  while (model_idx \u003c numcpus) {\n    model = uv__strndup(inferred_model, strlen(inferred_model));\n    if (model == NULL)\n      return -ENOMEM;\n    ci[model_idx++].model = model;\n  }\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":586,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5200864":{"score":0.93685365,"function_name":"read_times","code":"static int read_times(unsigned int numcpus, uv_cpu_info_t* ci) {\n  unsigned long clock_ticks;\n  struct uv_cpu_times_s ts;\n  unsigned long user;\n  unsigned long nice;\n  unsigned long sys;\n  unsigned long idle;\n  unsigned long dummy;\n  unsigned long irq;\n  unsigned int num;\n  unsigned int len;\n  char buf[1024];\n  FILE* fp;\n\n  clock_ticks = sysconf(_SC_CLK_TCK);\n  assert(clock_ticks != (unsigned long) -1);\n  assert(clock_ticks != 0);\n\n  fp = fopen(\"/proc/stat\", \"r\");\n  if (fp == NULL)\n    return -errno;\n\n  if (!fgets(buf, sizeof(buf), fp))\n    abort();\n\n  num = 0;\n\n  while (fgets(buf, sizeof(buf), fp)) {\n    if (num \u003e= numcpus)\n      break;\n\n    if (strncmp(buf, \"cpu\", 3))\n      break;\n\n    /* skip \"cpu\u003cnum\u003e \" marker */\n    {\n      unsigned int n;\n      int r = sscanf(buf, \"cpu%u \", \u0026n);\n      assert(r == 1);\n      (void) r;  /* silence build warning */\n      for (len = sizeof(\"cpu0\"); n /= 10; len++);\n    }\n\n    /* Line contains user, nice, system, idle, iowait, irq, softirq, steal,\n     * guest, guest_nice but we're only interested in the first four + irq.\n     *\n     * Don't use %*s to skip fields or %ll to read straight into the uint64_t\n     * fields, they're not allowed in C89 mode.\n     */\n    if (6 != sscanf(buf + len,\n                    \"%lu %lu %lu %lu %lu %lu\",\n                    \u0026user,\n                    \u0026nice,\n                    \u0026sys,\n                    \u0026idle,\n                    \u0026dummy,\n                    \u0026irq))\n      abort();\n\n    ts.user = clock_ticks * user;\n    ts.nice = clock_ticks * nice;\n    ts.sys  = clock_ticks * sys;\n    ts.idle = clock_ticks * idle;\n    ts.irq  = clock_ticks * irq;\n    ci[num++].cpu_times = ts;\n  }\n  fclose(fp);\n  assert(num == numcpus);\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":679,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5201472":{"score":0.9357316,"function_name":"read_cpufreq","code":"static unsigned long read_cpufreq(unsigned int cpunum) {\n  unsigned long val;\n  char buf[1024];\n  FILE* fp;\n\n  snprintf(buf,\n           sizeof(buf),\n           \"/sys/devices/system/cpu/cpu%u/cpufreq/scaling_cur_freq\",\n           cpunum);\n\n  fp = fopen(buf, \"r\");\n  if (fp == NULL)\n    return 0;\n\n  if (fscanf(fp, \"%lu\", \u0026val) != 1)\n    val = 0;\n\n  fclose(fp);\n\n  return val;\n}","filepath":"src/unix/linux-core.c","line_number":752,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5201888":{"score":0.9048559,"function_name":"uv__platform_invalidate_fd","code":"void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) {\n  struct uv__epoll_event* events;\n  struct uv__epoll_event dummy;\n  uintptr_t i;\n  uintptr_t nfds;\n\n  assert(loop-\u003ewatchers != NULL);\n\n  events = (struct uv__epoll_event*) loop-\u003ewatchers[loop-\u003enwatchers];\n  nfds = (uintptr_t) loop-\u003ewatchers[loop-\u003enwatchers + 1];\n  if (events != NULL)\n    /* Invalidate events with same file descriptor */\n    for (i = 0; i \u003c nfds; i++)\n      if ((int) events[i].data == fd)\n        events[i].data = -1;\n\n  /* Remove the file descriptor from the epoll.\n   * This avoids a problem where the same file description remains open\n   * in another process, causing repeated junk epoll events.\n   *\n   * We pass in a dummy epoll_event, to work around a bug in old kernels.\n   */\n  if (loop-\u003ebackend_fd \u003e= 0) {\n    /* Work around a bug in kernels 3.10 to 3.19 where passing a struct that\n     * has the EPOLLWAKEUP flag set generates spurious audit syslog warnings.\n     */\n    memset(\u0026dummy, 0, sizeof(dummy));\n    uv__epoll_ctl(loop-\u003ebackend_fd, UV__EPOLL_CTL_DEL, fd, \u0026dummy);\n  }\n}","filepath":"src/unix/linux-core.c","line_number":111,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5202096":{"score":0.9011319,"function_name":"uv__hrtime","code":"uint64_t uv__hrtime(uv_clocktype_t type) {\n  static clock_t fast_clock_id = -1;\n  struct timespec t;\n  clock_t clock_id;\n\n  /* Prefer CLOCK_MONOTONIC_COARSE if available but only when it has\n   * millisecond granularity or better.  CLOCK_MONOTONIC_COARSE is\n   * serviced entirely from the vDSO, whereas CLOCK_MONOTONIC may\n   * decide to make a costly system call.\n   */\n  /* TODO(bnoordhuis) Use CLOCK_MONOTONIC_COARSE for UV_CLOCK_PRECISE\n   * when it has microsecond granularity or better (unlikely).\n   */\n  if (type == UV_CLOCK_FAST \u0026\u0026 fast_clock_id == -1) {\n    if (clock_getres(CLOCK_MONOTONIC_COARSE, \u0026t) == 0 \u0026\u0026\n        t.tv_nsec \u003c= 1 * 1000 * 1000) {\n      fast_clock_id = CLOCK_MONOTONIC_COARSE;\n    } else {\n      fast_clock_id = CLOCK_MONOTONIC;\n    }\n  }\n\n  clock_id = CLOCK_MONOTONIC;\n  if (type == UV_CLOCK_FAST)\n    clock_id = fast_clock_id;\n\n  if (clock_gettime(clock_id, \u0026t))\n    return 0;  /* Not really possible. */\n\n  return t.tv_sec * (uint64_t) 1e9 + t.tv_nsec;\n}","filepath":"src/unix/linux-core.c","line_number":379,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5202288":{"score":0.9100056,"function_name":"uv__io_poll","code":"void uv__io_poll(uv_loop_t* loop, int timeout) {\n  /* A bug in kernels \u003c 2.6.37 makes timeouts larger than ~30 minutes\n   * effectively infinite on 32 bits architectures.  To avoid blocking\n   * indefinitely, we cap the timeout and poll again if necessary.\n   *\n   * Note that \"30 minutes\" is a simplification because it depends on\n   * the value of CONFIG_HZ.  The magic constant assumes CONFIG_HZ=1200,\n   * that being the largest value I have seen in the wild (and only once.)\n   */\n  static const int max_safe_timeout = 1789569;\n  static int no_epoll_pwait;\n  static int no_epoll_wait;\n  struct uv__epoll_event events[1024];\n  struct uv__epoll_event* pe;\n  struct uv__epoll_event e;\n  int real_timeout;\n  QUEUE* q;\n  uv__io_t* w;\n  sigset_t sigset;\n  uint64_t sigmask;\n  uint64_t base;\n  int nevents;\n  int count;\n  int nfds;\n  int fd;\n  int op;\n  int i;\n\n  if (loop-\u003enfds == 0) {\n    assert(QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue));\n    return;\n  }\n\n  while (!QUEUE_EMPTY(\u0026loop-\u003ewatcher_queue)) {\n    q = QUEUE_HEAD(\u0026loop-\u003ewatcher_queue);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n\n    w = QUEUE_DATA(q, uv__io_t, watcher_queue);\n    assert(w-\u003epevents != 0);\n    assert(w-\u003efd \u003e= 0);\n    assert(w-\u003efd \u003c (int) loop-\u003enwatchers);\n\n    e.events = w-\u003epevents;\n    e.data = w-\u003efd;\n\n    if (w-\u003eevents == 0)\n      op = UV__EPOLL_CTL_ADD;\n    else\n      op = UV__EPOLL_CTL_MOD;\n\n    /* XXX Future optimization: do EPOLL_CTL_MOD lazily if we stop watching\n     * events, skip the syscall and squelch the events after epoll_wait().\n     */\n    if (uv__epoll_ctl(loop-\u003ebackend_fd, op, w-\u003efd, \u0026e)) {\n      if (errno != EEXIST)\n        abort();\n\n      assert(op == UV__EPOLL_CTL_ADD);\n\n      /* We've reactivated a file descriptor that's been watched before. */\n      if (uv__epoll_ctl(loop-\u003ebackend_fd, UV__EPOLL_CTL_MOD, w-\u003efd, \u0026e))\n        abort();\n    }\n\n    w-\u003eevents = w-\u003epevents;\n  }\n\n  sigmask = 0;\n  if (loop-\u003eflags \u0026 UV_LOOP_BLOCK_SIGPROF) {\n    sigemptyset(\u0026sigset);\n    sigaddset(\u0026sigset, SIGPROF);\n    sigmask |= 1 \u003c\u003c (SIGPROF - 1);\n  }\n\n  assert(timeout \u003e= -1);\n  base = loop-\u003etime;\n  count = 48; /* Benchmarks suggest this gives the best throughput. */\n  real_timeout = timeout;\n\n  for (;;) {\n    /* See the comment for max_safe_timeout for an explanation of why\n     * this is necessary.  Executive summary: kernel bug workaround.\n     */\n    if (sizeof(int32_t) == sizeof(long) \u0026\u0026 timeout \u003e= max_safe_timeout)\n      timeout = max_safe_timeout;\n\n    if (sigmask != 0 \u0026\u0026 no_epoll_pwait != 0)\n      if (pthread_sigmask(SIG_BLOCK, \u0026sigset, NULL))\n        abort();\n\n    if (no_epoll_wait != 0 || (sigmask != 0 \u0026\u0026 no_epoll_pwait == 0)) {\n      nfds = uv__epoll_pwait(loop-\u003ebackend_fd,\n                             events,\n                             ARRAY_SIZE(events),\n                             timeout,\n                             sigmask);\n      if (nfds == -1 \u0026\u0026 errno == ENOSYS)\n        no_epoll_pwait = 1;\n    } else {\n      nfds = uv__epoll_wait(loop-\u003ebackend_fd,\n                            events,\n                            ARRAY_SIZE(events),\n                            timeout);\n      if (nfds == -1 \u0026\u0026 errno == ENOSYS)\n        no_epoll_wait = 1;\n    }\n\n    if (sigmask != 0 \u0026\u0026 no_epoll_pwait != 0)\n      if (pthread_sigmask(SIG_UNBLOCK, \u0026sigset, NULL))\n        abort();\n\n    /* Update loop-\u003etime unconditionally. It's tempting to skip the update when\n     * timeout == 0 (i.e. non-blocking poll) but there is no guarantee that the\n     * operating system didn't reschedule our process while in the syscall.\n     */\n    SAVE_ERRNO(uv__update_time(loop));\n\n    if (nfds == 0) {\n      assert(timeout != -1);\n\n      timeout = real_timeout - timeout;\n      if (timeout \u003e 0)\n        continue;\n\n      return;\n    }\n\n    if (nfds == -1) {\n      if (errno == ENOSYS) {\n        /* epoll_wait() or epoll_pwait() failed, try the other system call. */\n        assert(no_epoll_wait == 0 || no_epoll_pwait == 0);\n        continue;\n      }\n\n      if (errno != EINTR)\n        abort();\n\n      if (timeout == -1)\n        continue;\n\n      if (timeout == 0)\n        return;\n\n      /* Interrupted by a signal. Update timeout and poll again. */\n      goto update_timeout;\n    }\n\n    nevents = 0;\n\n    assert(loop-\u003ewatchers != NULL);\n    loop-\u003ewatchers[loop-\u003enwatchers] = (void*) events;\n    loop-\u003ewatchers[loop-\u003enwatchers + 1] = (void*) (uintptr_t) nfds;\n    for (i = 0; i \u003c nfds; i++) {\n      pe = events + i;\n      fd = pe-\u003edata;\n\n      /* Skip invalidated events, see uv__platform_invalidate_fd */\n      if (fd == -1)\n        continue;\n\n      assert(fd \u003e= 0);\n      assert((unsigned) fd \u003c loop-\u003enwatchers);\n\n      w = loop-\u003ewatchers[fd];\n\n      if (w == NULL) {\n        /* File descriptor that we've stopped watching, disarm it.\n         *\n         * Ignore all errors because we may be racing with another thread\n         * when the file descriptor is closed.\n         */\n        uv__epoll_ctl(loop-\u003ebackend_fd, UV__EPOLL_CTL_DEL, fd, pe);\n        continue;\n      }\n\n      /* Give users only events they're interested in. Prevents spurious\n       * callbacks when previous callback invocation in this loop has stopped\n       * the current watcher. Also, filters out events that users has not\n       * requested us to watch.\n       */\n      pe-\u003eevents \u0026= w-\u003epevents | UV__POLLERR | UV__POLLHUP;\n\n      /* Work around an epoll quirk where it sometimes reports just the\n       * EPOLLERR or EPOLLHUP event.  In order to force the event loop to\n       * move forward, we merge in the read/write events that the watcher\n       * is interested in; uv__read() and uv__write() will then deal with\n       * the error or hangup in the usual fashion.\n       *\n       * Note to self: happens when epoll reports EPOLLIN|EPOLLHUP, the user\n       * reads the available data, calls uv_read_stop(), then sometime later\n       * calls uv_read_start() again.  By then, libuv has forgotten about the\n       * hangup and the kernel won't report EPOLLIN again because there's\n       * nothing left to read.  If anything, libuv is to blame here.  The\n       * current hack is just a quick bandaid; to properly fix it, libuv\n       * needs to remember the error/hangup event.  We should get that for\n       * free when we switch over to edge-triggered I/O.\n       */\n      if (pe-\u003eevents == UV__EPOLLERR || pe-\u003eevents == UV__EPOLLHUP)\n        pe-\u003eevents |= w-\u003epevents \u0026 (UV__EPOLLIN | UV__EPOLLOUT);\n\n      if (pe-\u003eevents != 0) {\n        w-\u003ecb(loop, w, pe-\u003eevents);\n        nevents++;\n      }\n    }\n    loop-\u003ewatchers[loop-\u003enwatchers] = NULL;\n    loop-\u003ewatchers[loop-\u003enwatchers + 1] = NULL;\n\n    if (nevents != 0) {\n      if (nfds == ARRAY_SIZE(events) \u0026\u0026 --count != 0) {\n        /* Poll for more events but don't block this time. */\n        timeout = 0;\n        continue;\n      }\n      return;\n    }\n\n    if (timeout == 0)\n      return;\n\n    if (timeout == -1)\n      continue;\n\nupdate_timeout:\n    assert(timeout \u003e 0);\n\n    real_timeout -= (loop-\u003etime - base);\n    if (real_timeout \u003c= 0)\n      return;\n\n    timeout = real_timeout;\n  }\n}","filepath":"src/unix/linux-core.c","line_number":143,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5204320":{"score":0.94961774,"function_name":"uv_exepath","code":"int uv_exepath(char* buffer, size_t* size) {\n  ssize_t n;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return -EINVAL;\n\n  n = *size - 1;\n  if (n \u003e 0)\n    n = readlink(\"/proc/self/exe\", buffer, n);\n\n  if (n == -1)\n    return -errno;\n\n  buffer[n] = '\\0';\n  *size = n;\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":423,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5204496":{"score":0.90833277,"function_name":"uv_resident_set_memory","code":"int uv_resident_set_memory(size_t* rss) {\n  char buf[1024];\n  const char* s;\n  ssize_t n;\n  long val;\n  int fd;\n  int i;\n\n  do\n    fd = open(\"/proc/self/stat\", O_RDONLY);\n  while (fd == -1 \u0026\u0026 errno == EINTR);\n\n  if (fd == -1)\n    return -errno;\n\n  do\n    n = read(fd, buf, sizeof(buf) - 1);\n  while (n == -1 \u0026\u0026 errno == EINTR);\n\n  uv__close(fd);\n  if (n == -1)\n    return -errno;\n  buf[n] = '\\0';\n\n  s = strchr(buf, ' ');\n  if (s == NULL)\n    goto err;\n\n  s += 1;\n  if (*s != '(')\n    goto err;\n\n  s = strchr(s, ')');\n  if (s == NULL)\n    goto err;\n\n  for (i = 1; i \u003c= 22; i++) {\n    s = strchr(s + 1, ' ');\n    if (s == NULL)\n      goto err;\n  }\n\n  errno = 0;\n  val = strtol(s, NULL, 10);\n  if (errno != 0)\n    goto err;\n  if (val \u003c 0)\n    goto err;\n\n  *rss = val * getpagesize();\n  return 0;\n\nerr:\n  return -EINVAL;\n}","filepath":"src/unix/linux-core.c","line_number":453,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5204864":{"score":0.7162181,"function_name":"uv_uptime","code":"int uv_uptime(double* uptime) {\n  static volatile int no_clock_boottime;\n  struct timespec now;\n  int r;\n\n  /* Try CLOCK_BOOTTIME first, fall back to CLOCK_MONOTONIC if not available\n   * (pre-2.6.39 kernels). CLOCK_MONOTONIC doesn't increase when the system\n   * is suspended.\n   */\n  if (no_clock_boottime) {\n    retry: r = clock_gettime(CLOCK_MONOTONIC, \u0026now);\n  }\n  else if ((r = clock_gettime(CLOCK_BOOTTIME, \u0026now)) \u0026\u0026 errno == EINVAL) {\n    no_clock_boottime = 1;\n    goto retry;\n  }\n\n  if (r)\n    return -errno;\n\n  *uptime = now.tv_sec;\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":510,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5205120":{"score":0.9241642,"function_name":"uv_cpu_info","code":"int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n  unsigned int numcpus;\n  uv_cpu_info_t* ci;\n  int err;\n\n  *cpu_infos = NULL;\n  *count = 0;\n\n  numcpus = sysconf(_SC_NPROCESSORS_ONLN);\n  assert(numcpus != (unsigned int) -1);\n  assert(numcpus != 0);\n\n  ci = uv__calloc(numcpus, sizeof(*ci));\n  if (ci == NULL)\n    return -ENOMEM;\n\n  err = read_models(numcpus, ci);\n  if (err == 0)\n    err = read_times(numcpus, ci);\n\n  if (err) {\n    uv_free_cpu_info(ci, numcpus);\n    return err;\n  }\n\n  /* read_models() on x86 also reads the CPU speed from /proc/cpuinfo.\n   * We don't check for errors here. Worst case, the field is left zero.\n   */\n  if (ci[0].speed == 0)\n    read_speeds(numcpus, ci);\n\n  *cpu_infos = ci;\n  *count = numcpus;\n\n  return 0;\n}","filepath":"src/unix/linux-core.c","line_number":535,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5205440":{"score":0.8898706,"function_name":"uv_interface_addresses","code":"int uv_interface_addresses(uv_interface_address_t** addresses,\n  int* count) {\n#ifndef HAVE_IFADDRS_H\n  return -ENOSYS;\n#else\n  struct ifaddrs *addrs, *ent;\n  uv_interface_address_t* address;\n  int i;\n  struct sockaddr_ll *sll;\n\n  if (getifaddrs(\u0026addrs))\n    return -errno;\n\n  *count = 0;\n  *addresses = NULL;\n\n  /* Count the number of interfaces */\n  for (ent = addrs; ent != NULL; ent = ent-\u003eifa_next) {\n    if (!((ent-\u003eifa_flags \u0026 IFF_UP) \u0026\u0026 (ent-\u003eifa_flags \u0026 IFF_RUNNING)) ||\n        (ent-\u003eifa_addr == NULL) ||\n        (ent-\u003eifa_addr-\u003esa_family == PF_PACKET)) {\n      continue;\n    }\n\n    (*count)++;\n  }\n\n  if (*count == 0)\n    return 0;\n\n  *addresses = uv__malloc(*count * sizeof(**addresses));\n  if (!(*addresses))\n    return -ENOMEM;\n\n  address = *addresses;\n\n  for (ent = addrs; ent != NULL; ent = ent-\u003eifa_next) {\n    if (!((ent-\u003eifa_flags \u0026 IFF_UP) \u0026\u0026 (ent-\u003eifa_flags \u0026 IFF_RUNNING)))\n      continue;\n\n    if (ent-\u003eifa_addr == NULL)\n      continue;\n\n    /*\n     * On Linux getifaddrs returns information related to the raw underlying\n     * devices. We're not interested in this information yet.\n     */\n    if (ent-\u003eifa_addr-\u003esa_family == PF_PACKET)\n      continue;\n\n    address-\u003ename = uv__strdup(ent-\u003eifa_name);\n\n    if (ent-\u003eifa_addr-\u003esa_family == AF_INET6) {\n      address-\u003eaddress.address6 = *((struct sockaddr_in6*) ent-\u003eifa_addr);\n    } else {\n      address-\u003eaddress.address4 = *((struct sockaddr_in*) ent-\u003eifa_addr);\n    }\n\n    if (ent-\u003eifa_netmask-\u003esa_family == AF_INET6) {\n      address-\u003enetmask.netmask6 = *((struct sockaddr_in6*) ent-\u003eifa_netmask);\n    } else {\n      address-\u003enetmask.netmask4 = *((struct sockaddr_in*) ent-\u003eifa_netmask);\n    }\n\n    address-\u003eis_internal = !!(ent-\u003eifa_flags \u0026 IFF_LOOPBACK);\n\n    address++;\n  }\n\n  /* Fill in physical addresses for each interface */\n  for (ent = addrs; ent != NULL; ent = ent-\u003eifa_next) {\n    if (!((ent-\u003eifa_flags \u0026 IFF_UP) \u0026\u0026 (ent-\u003eifa_flags \u0026 IFF_RUNNING)) ||\n        (ent-\u003eifa_addr == NULL) ||\n        (ent-\u003eifa_addr-\u003esa_family != PF_PACKET)) {\n      continue;\n    }\n\n    address = *addresses;\n\n    for (i = 0; i \u003c (*count); i++) {\n      if (strcmp(address-\u003ename, ent-\u003eifa_name) == 0) {\n        sll = (struct sockaddr_ll*)ent-\u003eifa_addr;\n        memcpy(address-\u003ephys_addr, sll-\u003esll_addr, sizeof(address-\u003ephys_addr));\n      }\n      address++;\n    }\n  }\n\n  freeifaddrs(addrs);\n\n  return 0;\n#endif\n}","filepath":"src/unix/linux-core.c","line_number":786,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5206128":{"score":0.83699685,"function_name":"uv_free_interface_addresses","code":"void uv_free_interface_addresses(uv_interface_address_t* addresses,\n  int count) {\n  int i;\n\n  for (i = 0; i \u003c count; i++) {\n    uv__free(addresses[i].name);\n  }\n\n  uv__free(addresses);\n}","filepath":"src/unix/linux-core.c","line_number":881,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5210384":{"score":0.9132954,"function_name":"poll_cb","code":"static void poll_cb(uv_fs_t* req) {\n  uv_stat_t* statbuf;\n  struct poll_ctx* ctx;\n  uint64_t interval;\n\n  ctx = container_of(req, struct poll_ctx, fs_req);\n\n  if (ctx-\u003eparent_handle == NULL) { /* handle has been stopped or closed */\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n    uv_fs_req_cleanup(req);\n    return;\n  }\n\n  if (req-\u003eresult != 0) {\n    if (ctx-\u003ebusy_polling != req-\u003eresult) {\n      ctx-\u003epoll_cb(ctx-\u003eparent_handle,\n                   req-\u003eresult,\n                   \u0026ctx-\u003estatbuf,\n                   \u0026zero_statbuf);\n      ctx-\u003ebusy_polling = req-\u003eresult;\n    }\n    goto out;\n  }\n\n  statbuf = \u0026req-\u003estatbuf;\n\n  if (ctx-\u003ebusy_polling != 0)\n    if (ctx-\u003ebusy_polling \u003c 0 || !statbuf_eq(\u0026ctx-\u003estatbuf, statbuf))\n      ctx-\u003epoll_cb(ctx-\u003eparent_handle, 0, \u0026ctx-\u003estatbuf, statbuf);\n\n  ctx-\u003estatbuf = *statbuf;\n  ctx-\u003ebusy_polling = 1;\n\nout:\n  uv_fs_req_cleanup(req);\n\n  if (ctx-\u003eparent_handle == NULL) { /* handle has been stopped by callback */\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n    return;\n  }\n\n  /* Reschedule timer, subtract the delay from doing the stat(). */\n  interval = ctx-\u003einterval;\n  interval -= (uv_now(ctx-\u003eloop) - ctx-\u003estart_time) % interval;\n\n  if (uv_timer_start(\u0026ctx-\u003etimer_handle, timer_cb, interval, 0))\n    abort();\n}","filepath":"src/fs-poll.c","line_number":171,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5210976":{"score":0.92933035,"function_name":"timer_cb","code":"static void timer_cb(uv_timer_t* timer) {\n  struct poll_ctx* ctx;\n\n  ctx = container_of(timer, struct poll_ctx, timer_handle);\n  assert(ctx-\u003eparent_handle != NULL);\n  assert(ctx-\u003eparent_handle-\u003epoll_ctx == ctx);\n  ctx-\u003estart_time = uv_now(ctx-\u003eloop);\n\n  if (uv_fs_stat(ctx-\u003eloop, \u0026ctx-\u003efs_req, ctx-\u003epath, poll_cb))\n    abort();\n}","filepath":"src/fs-poll.c","line_number":158,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211168":{"score":0.8709467,"function_name":"uv_fs_poll_start","code":"int uv_fs_poll_start(uv_fs_poll_t* handle,\n                     uv_fs_poll_cb cb,\n                     const char* path,\n                     unsigned int interval) {\n  struct poll_ctx* ctx;\n  uv_loop_t* loop;\n  size_t len;\n  int err;\n\n  if (uv__is_active(handle))\n    return 0;\n\n  loop = handle-\u003eloop;\n  len = strlen(path);\n  ctx = uv__calloc(1, sizeof(*ctx) + len);\n\n  if (ctx == NULL)\n    return UV_ENOMEM;\n\n  ctx-\u003eloop = loop;\n  ctx-\u003epoll_cb = cb;\n  ctx-\u003einterval = interval ? interval : 1;\n  ctx-\u003estart_time = uv_now(loop);\n  ctx-\u003eparent_handle = handle;\n  memcpy(ctx-\u003epath, path, len + 1);\n\n  err = uv_timer_init(loop, \u0026ctx-\u003etimer_handle);\n  if (err \u003c 0)\n    goto error;\n\n  ctx-\u003etimer_handle.flags |= UV__HANDLE_INTERNAL;\n  uv__handle_unref(\u0026ctx-\u003etimer_handle);\n\n  err = uv_fs_stat(loop, \u0026ctx-\u003efs_req, ctx-\u003epath, poll_cb);\n  if (err \u003c 0)\n    goto error;\n\n  handle-\u003epoll_ctx = ctx;\n  uv__handle_start(handle);\n\n  return 0;\n\nerror:\n  uv__free(ctx);\n  return err;\n}","filepath":"src/fs-poll.c","line_number":56,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211520":{"score":0.8819824,"function_name":"uv_fs_poll_stop","code":"int uv_fs_poll_stop(uv_fs_poll_t* handle) {\n  struct poll_ctx* ctx;\n\n  if (!uv__is_active(handle))\n    return 0;\n\n  ctx = handle-\u003epoll_ctx;\n  assert(ctx != NULL);\n  assert(ctx-\u003eparent_handle != NULL);\n  ctx-\u003eparent_handle = NULL;\n  handle-\u003epoll_ctx = NULL;\n\n  /* Close the timer if it's active. If it's inactive, there's a stat request\n   * in progress and poll_cb will take care of the cleanup.\n   */\n  if (uv__is_active(\u0026ctx-\u003etimer_handle))\n    uv_close((uv_handle_t*)\u0026ctx-\u003etimer_handle, timer_close_cb);\n\n  uv__handle_stop(handle);\n\n  return 0;\n}","filepath":"src/fs-poll.c","line_number":104,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211696":{"score":0.91207165,"function_name":"uv_fs_poll_getpath","code":"int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {\n  struct poll_ctx* ctx;\n  size_t required_len;\n\n  if (!uv__is_active(handle)) {\n    *size = 0;\n    return UV_EINVAL;\n  }\n\n  ctx = handle-\u003epoll_ctx;\n  assert(ctx != NULL);\n\n  required_len = strlen(ctx-\u003epath);\n  if (required_len \u003e *size) {\n    *size = required_len;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, ctx-\u003epath, required_len);\n  *size = required_len;\n\n  return 0;\n}","filepath":"src/fs-poll.c","line_number":128,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.6.0"},"5211872":{"score":0.9242871,"function_name":"inet_ntop4","code":"static int inet_ntop4(const unsigned char *src, char *dst, size_t size) {\n  static const char fmt[] = \"%u.%u.%u.%u\";\n  char tmp[UV__INET_ADDRSTRLEN];\n  int l;\n\n  l = snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]);\n  if (l \u003c= 0 || (size_t) l \u003e= size) {\n    return UV_ENOSPC;\n  }\n  strncpy(dst, tmp, size);\n  dst[size - 1] = '\\0';\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":53,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5212048":{"score":0.8255898,"function_name":"inet_pton4","code":"static int inet_pton4(const char *src, unsigned char *dst) {\n  static const char digits[] = \"0123456789\";\n  int saw_digit, octets, ch;\n  unsigned char tmp[sizeof(struct in_addr)], *tp;\n\n  saw_digit = 0;\n  octets = 0;\n  *(tp = tmp) = 0;\n  while ((ch = *src++) != '\\0') {\n    const char *pch;\n\n    if ((pch = strchr(digits, ch)) != NULL) {\n      unsigned int nw = *tp * 10 + (pch - digits);\n\n      if (saw_digit \u0026\u0026 *tp == 0)\n        return UV_EINVAL;\n      if (nw \u003e 255)\n        return UV_EINVAL;\n      *tp = nw;\n      if (!saw_digit) {\n        if (++octets \u003e 4)\n          return UV_EINVAL;\n        saw_digit = 1;\n      }\n    } else if (ch == '.' \u0026\u0026 saw_digit) {\n      if (octets == 4)\n        return UV_EINVAL;\n      *++tp = 0;\n      saw_digit = 0;\n    } else\n      return UV_EINVAL;\n  }\n  if (octets \u003c 4)\n    return UV_EINVAL;\n  memcpy(dst, tmp, sizeof(struct in_addr));\n  return 0;\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":186,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5212320":{"score":0.6898236,"function_name":"uv_inet_ntop","code":"int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {\n  switch (af) {\n  case AF_INET:\n    return (inet_ntop4(src, dst, size));\n  case AF_INET6:\n    return (inet_ntop6(src, dst, size));\n  default:\n    return UV_EAFNOSUPPORT;\n  }\n  /* NOTREACHED */\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":40,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5213168":{"score":0.78486365,"function_name":"uv_inet_pton","code":"int uv_inet_pton(int af, const char* src, void* dst) {\n  if (src == NULL || dst == NULL)\n    return UV_EINVAL;\n\n  switch (af) {\n  case AF_INET:\n    return (inet_pton4(src, dst));\n  case AF_INET6: {\n    int len;\n    char tmp[UV__INET6_ADDRSTRLEN], *s, *p;\n    s = (char*) src;\n    p = strchr(src, '%');\n    if (p != NULL) {\n      s = tmp;\n      len = p - src;\n      if (len \u003e UV__INET6_ADDRSTRLEN-1)\n        return UV_EINVAL;\n      memcpy(s, src, len);\n      s[len] = '\\0';\n    }\n    return inet_pton6(s, dst);\n  }\n  default:\n    return UV_EAFNOSUPPORT;\n  }\n  /* NOTREACHED */\n}","filepath":"Utilities/cmlibuv/src/inet.c","line_number":157,"entry_url":"https://github.com/Kitware/CMake.git","slot_name":"v3.7.0-rc1"},"5213936":{"score":0.7970941,"function_name":"post","code":"static void post(QUEUE* q) {\n  int empty_queue;\n  uv_mutex_lock(\u0026mutex);\n  empty_queue = QUEUE_EMPTY(\u0026wq);\n  QUEUE_INSERT_TAIL(\u0026wq, q);\n  if (empty_queue)\n    uv_cond_signal(\u0026cond);\n  uv_mutex_unlock(\u0026mutex);\n}","filepath":"src/threadpool.c","line_number":103,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214016":{"score":0.8698038,"function_name":"worker","code":"static void worker(void* arg) {\n  struct uv__work* w;\n  QUEUE* q;\n\n  (void) arg;\n\n  for (;;) {\n    uv_mutex_lock(\u0026mutex);\n\n    while (QUEUE_EMPTY(\u0026wq))\n      uv_cond_wait(\u0026cond, \u0026mutex);\n\n    q = QUEUE_HEAD(\u0026wq);\n\n    if (q == \u0026exit_message)\n      uv_cond_signal(\u0026cond);\n    else {\n      QUEUE_REMOVE(q);\n      QUEUE_INIT(q);  /* Signal uv_cancel() that the work req is\n                             executing. */\n    }\n\n    uv_mutex_unlock(\u0026mutex);\n\n    if (q == \u0026exit_message)\n      break;\n\n    w = QUEUE_DATA(q, struct uv__work, wq);\n    w-\u003ework(w);\n\n    uv_mutex_lock(\u0026w-\u003eloop-\u003ewq_mutex);\n    w-\u003ework = NULL;  /* Signal uv_cancel() that the work req is done\n                        executing. */\n    QUEUE_INSERT_TAIL(\u0026w-\u003eloop-\u003ewq, \u0026w-\u003ewq);\n    uv_async_send(\u0026w-\u003eloop-\u003ewq_async);\n    uv_mutex_unlock(\u0026w-\u003eloop-\u003ewq_mutex);\n  }\n}","filepath":"src/threadpool.c","line_number":63,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214304":{"score":0.91547436,"function_name":"init_once","code":"static void init_once(void) {\n  unsigned int i;\n  const char* val;\n\n  nthreads = ARRAY_SIZE(default_threads);\n  val = getenv(\"UV_THREADPOOL_SIZE\");\n  if (val != NULL)\n    nthreads = atoi(val);\n  if (nthreads == 0)\n    nthreads = 1;\n  if (nthreads \u003e MAX_THREADPOOL_SIZE)\n    nthreads = MAX_THREADPOOL_SIZE;\n\n  threads = default_threads;\n  if (nthreads \u003e ARRAY_SIZE(default_threads)) {\n    threads = uv__malloc(nthreads * sizeof(threads[0]));\n    if (threads == NULL) {\n      nthreads = ARRAY_SIZE(default_threads);\n      threads = default_threads;\n    }\n  }\n\n  if (uv_cond_init(\u0026cond))\n    abort();\n\n  if (uv_mutex_init(\u0026mutex))\n    abort();\n\n  QUEUE_INIT(\u0026wq);\n\n  for (i = 0; i \u003c nthreads; i++)\n    if (uv_thread_create(threads + i, worker, NULL))\n      abort();\n\n  initialized = 1;\n}","filepath":"src/threadpool.c","line_number":140,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214736":{"score":0.893399,"function_name":"uv__work_submit","code":"void uv__work_submit(uv_loop_t* loop,\n                     struct uv__work* w,\n                     void (*work)(struct uv__work* w),\n                     void (*done)(struct uv__work* w, int status)) {\n  uv_once(\u0026once, init_once);\n  w-\u003eloop = loop;\n  w-\u003ework = work;\n  w-\u003edone = done;\n  post(\u0026w-\u003ewq);\n}","filepath":"src/threadpool.c","line_number":178,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5214816":{"score":0.752575,"function_name":"uv__work_done","code":"void uv__work_done(uv_async_t* handle) {\n  struct uv__work* w;\n  uv_loop_t* loop;\n  QUEUE* q;\n  QUEUE wq;\n  int err;\n\n  loop = container_of(handle, uv_loop_t, wq_async);\n  QUEUE_INIT(\u0026wq);\n\n  uv_mutex_lock(\u0026loop-\u003ewq_mutex);\n  if (!QUEUE_EMPTY(\u0026loop-\u003ewq)) {\n    q = QUEUE_HEAD(\u0026loop-\u003ewq);\n    QUEUE_SPLIT(\u0026loop-\u003ewq, q, \u0026wq);\n  }\n  uv_mutex_unlock(\u0026loop-\u003ewq_mutex);\n\n  while (!QUEUE_EMPTY(\u0026wq)) {\n    q = QUEUE_HEAD(\u0026wq);\n    QUEUE_REMOVE(q);\n\n    w = container_of(q, struct uv__work, wq);\n    err = (w-\u003ework == uv__cancelled) ? UV_ECANCELED : 0;\n    w-\u003edone(w, err);\n  }\n}","filepath":"src/threadpool.c","line_number":216,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5215056":{"score":0.910711,"function_name":"uv_queue_work","code":"int uv_queue_work(uv_loop_t* loop,\n                  uv_work_t* req,\n                  uv_work_cb work_cb,\n                  uv_after_work_cb after_work_cb) {\n  if (work_cb == NULL)\n    return UV_EINVAL;\n\n  uv__req_init(loop, req, UV_WORK);\n  req-\u003eloop = loop;\n  req-\u003ework_cb = work_cb;\n  req-\u003eafter_work_cb = after_work_cb;\n  uv__work_submit(loop, \u0026req-\u003ework_req, uv__queue_work, uv__queue_done);\n  return 0;\n}","filepath":"src/threadpool.c","line_number":264,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5215184":{"score":0.846915,"function_name":"uv_cancel","code":"int uv_cancel(uv_req_t* req) {\n  struct uv__work* wreq;\n  uv_loop_t* loop;\n\n  switch (req-\u003etype) {\n  case UV_FS:\n    loop =  ((uv_fs_t*) req)-\u003eloop;\n    wreq = \u0026((uv_fs_t*) req)-\u003ework_req;\n    break;\n  case UV_GETADDRINFO:\n    loop =  ((uv_getaddrinfo_t*) req)-\u003eloop;\n    wreq = \u0026((uv_getaddrinfo_t*) req)-\u003ework_req;\n    break;\n  case UV_GETNAMEINFO:\n    loop = ((uv_getnameinfo_t*) req)-\u003eloop;\n    wreq = \u0026((uv_getnameinfo_t*) req)-\u003ework_req;\n    break;\n  case UV_WORK:\n    loop =  ((uv_work_t*) req)-\u003eloop;\n    wreq = \u0026((uv_work_t*) req)-\u003ework_req;\n    break;\n  default:\n    return UV_EINVAL;\n  }\n\n  return uv__work_cancel(loop, req, wreq);\n}","filepath":"src/threadpool.c","line_number":280,"entry_url":"https://github.com/libuv/libuv.git","slot_name":"v1.7.0"},"5217961":{"score":0.63343084,"function_name":"cpuid_identify_intel","code":"int cpuid_identify_intel(struct cpu_raw_data_t* raw, struct cpu_id_t* data, struct internal_id_info_t* internal)\n{\n\tintel_code_and_bits_t brand;\n\n\tload_intel_features(raw, data);\n\tif (raw-\u003ebasic_cpuid[0][0] \u003e= 4) {\n\t\t/* Deterministic way is preferred, being more generic */\n\t\tdecode_intel_deterministic_cache_info(raw, data);\n\t} else if (raw-\u003ebasic_cpuid[0][0] \u003e= 2) {\n\t\tdecode_intel_oldstyle_cache_info(raw, data);\n\t}\n\tdecode_intel_number_of_cores(raw, data);\n\n\tbrand = get_brand_code_and_bits(data);\n\t\n\tinternal-\u003ecode.intel = brand.code;\n\tinternal-\u003ebits = brand.bits;\n\t\n\tif (data-\u003eflags[CPU_FEATURE_SGX]) {\n\t\t// if SGX is indicated by the CPU, verify its presence:\n\t\tdecode_intel_sgx_features(raw, data);\n\t}\n\n\treturn 0;\n}","filepath":"src/3rdparty/libcpuid/recog_intel.c","line_number":518,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"5218561":{"score":0.82603395,"function_name":"cpuid_get_epc","code":"struct cpu_epc_t cpuid_get_epc(int index, const struct cpu_raw_data_t* raw)\n{\n\tuint32_t regs[4];\n\tstruct cpu_epc_t retval = {0, 0};\n\tif (raw \u0026\u0026 index \u003c MAX_INTELFN12H_LEVEL - 2) {\n\t\t// this was queried already, use the data:\n\t\tmemcpy(regs, raw-\u003eintel_fn12h[2 + index], sizeof(regs));\n\t} else {\n\t\t// query this ourselves:\n\t\tregs[0] = 0x12;\n\t\tregs[2] = 2 + index;\n\t\tregs[1] = regs[3] = 0;\n\t\tcpu_exec_cpuid_ext(regs);\n\t}\n\t\n\t// decode values:\n\tif ((regs[0] \u0026 0xf) == 0x1) {\n\t\tretval.start_addr |= (regs[0] \u0026 0xfffff000); // bits [12, 32) -\u003e bits [12, 32)\n\t\tretval.start_addr |= ((uint64_t) (regs[1] \u0026 0x000fffff)) \u003c\u003c 32; // bits [0, 20) -\u003e bits [32, 52)\n\t\tretval.length     |= (regs[2] \u0026 0xfffff000); // bits [12, 32) -\u003e bits [12, 32)\n\t\tretval.length     |= ((uint64_t) (regs[3] \u0026 0x000fffff)) \u003c\u003c 32; // bits [0, 20) -\u003e bits [32, 52)\n\t}\n\treturn retval;\n}","filepath":"src/3rdparty/libcpuid/recog_intel.c","line_number":493,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"5218746":{"score":0.63740796,"function_name":"decode_intel_oldstyle_cache_info","code":"static void decode_intel_oldstyle_cache_info(struct cpu_raw_data_t* raw, struct cpu_id_t* data)\n{\n\tuint8_t f[256] = {0};\n\tint reg, off;\n\tuint32_t x;\n\tfor (reg = 0; reg \u003c 4; reg++) {\n\t\tx = raw-\u003ebasic_cpuid[2][reg];\n\t\tif (x \u0026 0x80000000) continue;\n\t\tfor (off = 0; off \u003c 4; off++) {\n\t\t\tf[x \u0026 0xff] = 1;\n\t\t\tx \u003e\u003e= 8;\n\t\t}\n\t}\n\t\n\tcheck_case(f[0x06], L1I,      8,  4,  32, data);\n\tcheck_case(f[0x08], L1I,     16,  4,  32, data);\n\tcheck_case(f[0x0A], L1D,      8,  2,  32, data);\n\tcheck_case(f[0x0C], L1D,     16,  4,  32, data);\n\tcheck_case(f[0x22],  L3,    512,  4,  64, data);\n\tcheck_case(f[0x23],  L3,   1024,  8,  64, data);\n\tcheck_case(f[0x25],  L3,   2048,  8,  64, data);\n\tcheck_case(f[0x29],  L3,   4096,  8,  64, data);\n\tcheck_case(f[0x2C], L1D,     32,  8,  64, data);\n\tcheck_case(f[0x30], L1I,     32,  8,  64, data);\n\tcheck_case(f[0x39],  L2,    128,  4,  64, data);\n\tcheck_case(f[0x3A],  L2,    192,  6,  64, data);\n\tcheck_case(f[0x3B],  L2,    128,  2,  64, data);\n\tcheck_case(f[0x3C],  L2,    256,  4,  64, data);\n\tcheck_case(f[0x3D],  L2,    384,  6,  64, data);\n\tcheck_case(f[0x3E],  L2,    512,  4,  64, data);\n\tcheck_case(f[0x41],  L2,    128,  4,  32, data);\n\tcheck_case(f[0x42],  L2,    256,  4,  32, data);\n\tcheck_case(f[0x43],  L2,    512,  4,  32, data);\n\tcheck_case(f[0x44],  L2,   1024,  4,  32, data);\n\tcheck_case(f[0x45],  L2,   2048,  4,  32, data);\n\tcheck_case(f[0x46],  L3,   4096,  4,  64, data);\n\tcheck_case(f[0x47],  L3,   8192,  8,  64, data);\n\tcheck_case(f[0x4A],  L3,   6144, 12,  64, data);\n\tcheck_case(f[0x4B],  L3,   8192, 16,  64, data);\n\tcheck_case(f[0x4C],  L3,  12288, 12,  64, data);\n\tcheck_case(f[0x4D],  L3,  16384, 16,  64, data);\n\tcheck_case(f[0x4E],  L2,   6144, 24,  64, data);\n\tcheck_case(f[0x60], L1D,     16,  8,  64, data);\n\tcheck_case(f[0x66], L1D,      8,  4,  64, data);\n\tcheck_case(f[0x67], L1D,     16,  4,  64, data);\n\tcheck_case(f[0x68], L1D,     32,  4,  64, data);\n\t/* The following four entries are trace cache. Intel does not\n\t * specify a cache-line size, so we use -1 instead\n\t */\n\tcheck_case(f[0x70], L1I,     12,  8,  -1, data);\n\tcheck_case(f[0x71], L1I,     16,  8,  -1, data);\n\tcheck_case(f[0x72], L1I,     32,  8,  -1, data);\n\tcheck_case(f[0x73], L1I,     64,  8,  -1, data);\n\t\n\tcheck_case(f[0x78],  L2,   1024,  4,  64, data);\n\tcheck_case(f[0x79],  L2,    128,  8,  64, data);\n\tcheck_case(f[0x7A],  L2,    256,  8,  64, data);\n\tcheck_case(f[0x7B],  L2,    512,  8,  64, data);\n\tcheck_case(f[0x7C],  L2,   1024,  8,  64, data);\n\tcheck_case(f[0x7D],  L2,   2048,  8,  64, data);\n\tcheck_case(f[0x7F],  L2,    512,  2,  64, data);\n\tcheck_case(f[0x82],  L2,    256,  8,  32, data);\n\tcheck_case(f[0x83],  L2,    512,  8,  32, data);\n\tcheck_case(f[0x84],  L2,   1024,  8,  32, data);\n\tcheck_case(f[0x85],  L2,   2048,  8,  32, data);\n\tcheck_case(f[0x86],  L2,    512,  4,  64, data);\n\tcheck_case(f[0x87],  L2,   1024,  8,  64, data);\n\t\n\tif (f[0x49]) {\n\t\t/* This flag is overloaded with two meanings. On Xeon MP\n\t\t * (family 0xf, model 0x6) this means L3 cache. On all other\n\t\t * CPUs (notably Conroe et al), this is L2 cache. In both cases\n\t\t * it means 4MB, 16-way associative, 64-byte line size.\n\t\t */\n\t\tif (data-\u003efamily == 0xf \u0026\u0026 data-\u003emodel == 0x6) {\n\t\t\tdata-\u003el3_cache = 4096;\n\t\t\tdata-\u003el3_assoc = 16;\n\t\t\tdata-\u003el3_cacheline = 64;\n\t\t} else {\n\t\t\tdata-\u003el2_cache = 4096;\n\t\t\tdata-\u003el2_assoc = 16;\n\t\t\tdata-\u003el2_cacheline = 64;\n\t\t}\n\t}\n\tif (f[0x40]) {\n\t\t/* Again, a special flag. It means:\n\t\t * 1) If no L2 is specified, then CPU is w/o L2 (0 KB)\n\t\t * 2) If L2 is specified by other flags, then, CPU is w/o L3.\n\t\t */\n\t\tif (data-\u003el2_cache == -1) {\n\t\t\tdata-\u003el2_cache = 0;\n\t\t} else {\n\t\t\tdata-\u003el3_cache = 0;\n\t\t}\n\t}\n}","filepath":"src/3rdparty/libcpuid/recog_intel.c","line_number":158,"entry_url":"https://github.com/xmrig/xmrig.git","slot_name":"v1.0.0"},"5222533":{"score":0.92755044,"function_name":"xmatch_entry","code":"static int xmatch_entry(char c, const char* p)\n{\n\tint i, j;\n\tif (c == 0) return -1;\n\tif (c == p[0]) return 1;\n\tif (p[0] == '.') return 1;\n\tif (p[0] == '#' \u0026\u0026 isdigit(c)) return 1;\n\tif (p[0] == '[') {\n\t\tj = 1;\n\t\twhile (p[j] \u0026\u0026 p[j] != ']') j++;\n\t\tif (!p[j]) return -1;\n\t\tfor (i = 1; i \u003c j; i++)\n\t\t\tif (p[i] == c) return j + 1;\n\t}\n\treturn -1;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":142,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.3.0"},"5222713":{"score":0.92432106,"function_name":"match_pattern","code":"int match_pattern(const char* s, const char* p)\n{\n\tint i, j, dj, k, n, m;\n\tn = (int) strlen(s);\n\tm = (int) strlen(p);\n\tfor (i = 0; i \u003c n; i++) {\n\t\tif (xmatch_entry(s[i], p) != -1) {\n\t\t\tj = 0;\n\t\t\tk = 0;\n\t\t\twhile (j \u003c m \u0026\u0026 ((dj = xmatch_entry(s[i + k], p + j)) != -1)) {\n\t\t\t\tk++;\n\t\t\t\tj += dj;\n\t\t\t}\n\t\t\tif (j == m) return i + 1;\n\t\t}\n\t}\n\treturn 0;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":159,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.3.0"},"5222867":{"score":0.86718655,"function_name":"get_cached_cpuid","code":"struct cpu_id_t* get_cached_cpuid(void)\n{\n\tstatic int initialized = 0;\n\tstatic struct cpu_id_t id;\n\tif (initialized) return \u0026id;\n\tif (cpu_identify(NULL, \u0026id))\n\t\tmemset(\u0026id, 0, sizeof(id));\n\tinitialized = 1;\n\treturn \u0026id;\n}","filepath":"libcpuid/libcpuid_util.c","line_number":178,"entry_url":"https://github.com/anrieff/libcpuid.git","slot_name":"v0.3.0"},"5223360":{"score":0.6699302,"function_name":"get_ttype_entry","code":"static const std::type_info *\nget_ttype_entry (lsda_header_info *info, _Unwind_Word i)\n{\n  _Unwind_Ptr ptr;\n\n  i *= size_of_encoded_value (info-\u003ettype_encoding);\n  read_encoded_value_with_base (info-\u003ettype_encoding, info-\u003ettype_base,\n\t\t\t\tinfo-\u003eTType - i, \u0026ptr);\n\n  return reinterpret_cast\u003cconst std::type_info *\u003e(ptr);\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":87,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5223648":{"score":0.831785,"function_name":"parse_lsda_header","code":"static const unsigned char *\nparse_lsda_header (_Unwind_Context *context, const unsigned char *p,\n\t\t   lsda_header_info *info)\n{\n  _Unwind_Word tmp;\n  unsigned char lpstart_encoding;\n\n  info-\u003eStart = (context ? _Unwind_GetRegionStart (context) : 0);\n\n  // Find @LPStart, the base to which landing pad offsets are relative.\n  lpstart_encoding = *p++;\n  if (lpstart_encoding != DW_EH_PE_omit)\n    p = read_encoded_value (context, lpstart_encoding, p, \u0026info-\u003eLPStart);\n  else\n    info-\u003eLPStart = info-\u003eStart;\n\n  // Find @TType, the base of the handler and exception spec type data.\n  info-\u003ettype_encoding = *p++;\n  if (info-\u003ettype_encoding != DW_EH_PE_omit)\n    {\n      p = read_uleb128 (p, \u0026tmp);\n      info-\u003eTType = p + tmp;\n    }\n  else\n    info-\u003eTType = 0;\n\n  // The encoding and length of the call-site table; the action table\n  // immediately follows.\n  info-\u003ecall_site_encoding = *p++;\n  p = read_uleb128 (p, \u0026tmp);\n  info-\u003eaction_table = p + tmp;\n\n  return p;\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":52,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5223888":{"score":0.8408725,"function_name":"get_adjusted_ptr","code":"static bool\nget_adjusted_ptr (const std::type_info *catch_type,\n\t\t  const std::type_info *throw_type,\n\t\t  void **thrown_ptr_p)\n{\n  void *thrown_ptr = *thrown_ptr_p;\n\n  // Pointer types need to adjust the actual pointer, not\n  // the pointer to pointer that is the exception object.\n  // This also has the effect of passing pointer types\n  // \"by value\" through the __cxa_begin_catch return value.\n  if (throw_type-\u003e__is_pointer_p ())\n    thrown_ptr = *(void **) thrown_ptr;\n\n  if (catch_type-\u003e__do_catch (throw_type, \u0026thrown_ptr, 1))\n    {\n      *thrown_ptr_p = thrown_ptr;\n      return true;\n    }\n\n  return false;\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":104,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5224016":{"score":0.739245,"function_name":"check_exception_spec","code":"static bool\ncheck_exception_spec (lsda_header_info *info, const std::type_info *throw_type,\n\t\t      void *thrown_ptr, _Unwind_Sword filter_value)\n{\n  const unsigned char *e = info-\u003eTType - filter_value - 1;\n\n  while (1)\n    {\n      const std::type_info *catch_type;\n      _Unwind_Word tmp;\n\n      e = read_uleb128 (e, \u0026tmp);\n\n      // Zero signals the end of the list.  If we've not found\n      // a match by now, then we've failed the specification.\n      if (tmp == 0)\n        return false;\n\n      // Match a ttype entry.\n      catch_type = get_ttype_entry (info, tmp);\n\n      // ??? There is currently no way to ask the RTTI code about the\n      // relationship between two types without reference to a specific\n      // object.  There should be; then we wouldn't need to mess with\n      // thrown_ptr here.\n      if (get_adjusted_ptr (catch_type, throw_type, \u0026thrown_ptr))\n\treturn true;\n    }\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5224160":{"score":0.8523214,"function_name":"PERSONALITY_FUNCTION","code":"_Unwind_Reason_Code\nPERSONALITY_FUNCTION (int version,\n\t\t      _Unwind_Action actions,\n\t\t      _Unwind_Exception_Class exception_class,\n\t\t      struct _Unwind_Exception *ue_header,\n\t\t      struct _Unwind_Context *context)\n{\n  __cxa_exception *xh = __get_exception_header_from_ue (ue_header);\n\n  enum found_handler_type\n  {\n    found_nothing,\n    found_terminate,\n    found_cleanup,\n    found_handler\n  } found_type;\n\n  lsda_header_info info;\n  const unsigned char *language_specific_data;\n  const unsigned char *action_record;\n  const unsigned char *p;\n  _Unwind_Ptr landing_pad, ip;\n  int handler_switch_value;\n  void *thrown_ptr = xh + 1;\n\n  // Interface version check.\n  if (version != 1)\n    return _URC_FATAL_PHASE1_ERROR;\n\n  // Shortcut for phase 2 found handler for domestic exception.\n  if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME)\n      \u0026\u0026 exception_class == __gxx_exception_class)\n    {\n      handler_switch_value = xh-\u003ehandlerSwitchValue;\n      language_specific_data = xh-\u003elanguageSpecificData;\n      landing_pad = (_Unwind_Ptr) xh-\u003ecatchTemp;\n      found_type = (landing_pad == 0 ? found_terminate : found_handler);\n      goto install_context;\n    }\n\n  language_specific_data = (const unsigned char *)\n    _Unwind_GetLanguageSpecificData (context);\n\n  // If no LSDA, then there are no handlers or cleanups.\n  if (! language_specific_data)\n    return _URC_CONTINUE_UNWIND;\n\n  // Parse the LSDA header.\n  p = parse_lsda_header (context, language_specific_data, \u0026info);\n  info.ttype_base = base_of_encoded_value (info.ttype_encoding, context);\n  ip = _Unwind_GetIP (context) - 1;\n  landing_pad = 0;\n  action_record = 0;\n  handler_switch_value = 0;\n\n#ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n  // The given \"IP\" is an index into the call-site table, with two\n  // exceptions -- -1 means no-action, and 0 means terminate.  But\n  // since we're using uleb128 values, we've not got random access\n  // to the array.\n  if ((int) ip \u003c 0)\n    return _URC_CONTINUE_UNWIND;\n  else if (ip == 0)\n    {\n      // Fall through to set found_terminate.\n    }\n  else\n    {\n      _Unwind_Word cs_lp, cs_action;\n      do\n\t{\n\t  p = read_uleb128 (p, \u0026cs_lp);\n\t  p = read_uleb128 (p, \u0026cs_action);\n\t}\n      while (--ip);\n\n      // Can never have null landing pad for sjlj -- that would have\n      // been indicated by a -1 call site index.\n      landing_pad = cs_lp + 1;\n      if (cs_action)\n\taction_record = info.action_table + cs_action - 1;\n      goto found_something;\n    }\n#else\n  // Search the call-site table for the action associated with this IP.\n  while (p \u003c info.action_table)\n    {\n      _Unwind_Ptr cs_start, cs_len, cs_lp;\n      _Unwind_Word cs_action;\n\n      // Note that all call-site encodings are \"absolute\" displacements.\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_start);\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_len);\n      p = read_encoded_value (0, info.call_site_encoding, p, \u0026cs_lp);\n      p = read_uleb128 (p, \u0026cs_action);\n\n      // The table is sorted, so if we've passed the ip, stop.\n      if (ip \u003c info.Start + cs_start)\n\tp = info.action_table;\n      else if (ip \u003c info.Start + cs_start + cs_len)\n\t{\n\t  if (cs_lp)\n\t    landing_pad = info.LPStart + cs_lp;\n\t  if (cs_action)\n\t    action_record = info.action_table + cs_action - 1;\n\t  goto found_something;\n\t}\n    }\n#endif // _GLIBCXX_SJLJ_EXCEPTIONS\n\n  // If ip is not present in the table, call terminate.  This is for\n  // a destructor inside a cleanup, or a library routine the compiler\n  // was not expecting to throw.\n  found_type = found_terminate;\n  goto do_something;\n\n found_something:\n  if (landing_pad == 0)\n    {\n      // If ip is present, and has a null landing pad, there are\n      // no cleanups or handlers to be run.\n      found_type = found_nothing;\n    }\n  else if (action_record == 0)\n    {\n      // If ip is present, has a non-null landing pad, and a null\n      // action table offset, then there are only cleanups present.\n      // Cleanups use a zero switch value, as set above.\n      found_type = found_cleanup;\n    }\n  else\n    {\n      // Otherwise we have a catch handler or exception specification.\n\n      _Unwind_Sword ar_filter, ar_disp;\n      const std::type_info *throw_type, *catch_type;\n      bool saw_cleanup = false;\n      bool saw_handler = false;\n\n      // During forced unwinding, we only run cleanups.  With a foreign\n      // exception class, there's no exception type.\n      // ??? What to do about GNU Java and GNU Ada exceptions.\n\n      if ((actions \u0026 _UA_FORCE_UNWIND)\n\t  || exception_class != __gxx_exception_class)\n\tthrow_type = 0;\n      else\n\tthrow_type = xh-\u003eexceptionType;\n\n      while (1)\n\t{\n\t  p = action_record;\n\t  p = read_sleb128 (p, \u0026ar_filter);\n\t  read_sleb128 (p, \u0026ar_disp);\n\n\t  if (ar_filter == 0)\n\t    {\n\t      // Zero filter values are cleanups.\n\t      saw_cleanup = true;\n\t    }\n\t  else if (ar_filter \u003e 0)\n\t    {\n\t      // Positive filter values are handlers.\n\t      catch_type = get_ttype_entry (\u0026info, ar_filter);\n\n\t      // Null catch type is a catch-all handler; we can catch foreign\n\t      // exceptions with this.  Otherwise we must match types.\n\t      if (! catch_type\n\t\t  || (throw_type\n\t\t      \u0026\u0026 get_adjusted_ptr (catch_type, throw_type,\n\t\t\t\t\t   \u0026thrown_ptr)))\n\t\t{\n\t\t  saw_handler = true;\n\t\t  break;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      // Negative filter values are exception specifications.\n\t      // ??? How do foreign exceptions fit in?  As far as I can\n\t      // see we can't match because there's no __cxa_exception\n\t      // object to stuff bits in for __cxa_call_unexpected to use.\n\t      // Allow them iff the exception spec is non-empty.  I.e.\n\t      // a throw() specification results in __unexpected.\n\t      if (throw_type\n\t\t  ? ! check_exception_spec (\u0026info, throw_type, thrown_ptr,\n\t\t\t\t\t    ar_filter)\n\t\t  : empty_exception_spec (\u0026info, ar_filter))\n\t\t{\n\t\t  saw_handler = true;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  if (ar_disp == 0)\n\t    break;\n\t  action_record = p + ar_disp;\n\t}\n\n      if (saw_handler)\n\t{\n\t  handler_switch_value = ar_filter;\n\t  found_type = found_handler;\n\t}\n      else\n\tfound_type = (saw_cleanup ? found_cleanup : found_nothing);\n    }\n\n do_something:\n   if (found_type == found_nothing)\n     return _URC_CONTINUE_UNWIND;\n\n  if (actions \u0026 _UA_SEARCH_PHASE)\n    {\n      if (found_type == found_cleanup)\n\treturn _URC_CONTINUE_UNWIND;\n\n      // For domestic exceptions, we cache data from phase 1 for phase 2.\n      if (exception_class == __gxx_exception_class)\n        {\n          xh-\u003ehandlerSwitchValue = handler_switch_value;\n          xh-\u003eactionRecord = action_record;\n          xh-\u003elanguageSpecificData = language_specific_data;\n          xh-\u003eadjustedPtr = thrown_ptr;\n\n          // ??? Completely unknown what this field is supposed to be for.\n          // ??? Need to cache TType encoding base for call_unexpected.\n          xh-\u003ecatchTemp = landing_pad;\n\t}\n      return _URC_HANDLER_FOUND;\n    }\n\n install_context:\n  // We can't use any of the cxa routines with foreign exceptions,\n  // because they all expect ue_header to be a struct __cxa_exception.\n  // So in that case, call terminate or unexpected directly.\n  if ((actions \u0026 _UA_FORCE_UNWIND)\n      || exception_class != __gxx_exception_class)\n    {\n      if (found_type == found_terminate)\n\tstd::terminate ();\n      else if (handler_switch_value \u003c 0)\n\t{\n\t  try \n\t    { std::unexpected (); } \n\t  catch(...) \n\t    { std::terminate (); }\n\t}\n    }\n  else\n    {\n      if (found_type == found_terminate)\n\t{\n\t  __cxa_begin_catch (\u0026xh-\u003eunwindHeader);\n\t  __terminate (xh-\u003eterminateHandler);\n\t}\n\n      // Cache the TType base value for __cxa_call_unexpected, as we won't\n      // have an _Unwind_Context then.\n      if (handler_switch_value \u003c 0)\n\t{\n\t  parse_lsda_header (context, language_specific_data, \u0026info);\n\t  xh-\u003ecatchTemp = base_of_encoded_value (info.ttype_encoding, context);\n\t}\n    }\n\n  /* For targets with pointers smaller than the word size, we must extend the\n     pointer, and this extension is target dependent.  */\n  _Unwind_SetGR (context, __builtin_eh_return_data_regno (0),\n\t\t __builtin_extend_pointer (\u0026xh-\u003eunwindHeader));\n  _Unwind_SetGR (context, __builtin_eh_return_data_regno (1),\n\t\t handler_switch_value);\n  _Unwind_SetIP (context, landing_pad);\n  return _URC_INSTALL_CONTEXT;\n}","filepath":"libstdc++-v3/libsupc++/eh_personality.cc","line_number":180,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-3.4.0"},"5228352":{"score":0.8713417,"function_name":"__si_class_type_info::\n__do_dyncast","code":"bool __si_class_type_info::\n__do_dyncast (ptrdiff_t src2dst,\n              __sub_kind access_path,\n              const __class_type_info *dst_type,\n              const void *obj_ptr,\n              const __class_type_info *src_type,\n              const void *src_ptr,\n              __dyncast_result \u0026__restrict result) const\n{\n  if (*this == *dst_type)\n    {\n      result.dst_ptr = obj_ptr;\n      result.whole2dst = access_path;\n      if (src2dst \u003e= 0)\n        result.dst2src = adjust_pointer \u003cvoid\u003e (obj_ptr, src2dst) == src_ptr\n              ? __contained_public : __not_contained;\n      else if (src2dst == -2)\n        result.dst2src = __not_contained;\n      return false;\n    }\n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    {\n      // The src object we started from. Indicate how we are accessible from\n      // the most derived object.\n      result.whole2src = access_path;\n      return false;\n    }\n  return __base_type-\u003e__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n                             src_type, src_ptr, result);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":43,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5228672":{"score":0.8178225,"function_name":"__si_class_type_info::\n__do_find_public_src","code":"__class_type_info::__sub_kind __si_class_type_info::\n__do_find_public_src (ptrdiff_t src2dst,\n                      const void *obj_ptr,\n                      const __class_type_info *src_type,\n                      const void *src_ptr) const\n{\n  if (src_ptr == obj_ptr \u0026\u0026 *this == *src_type)\n    return __contained_public;\n  return __base_type-\u003e__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":32,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5228800":{"score":0.7409875,"function_name":"__si_class_type_info::\n__do_upcast","code":"bool __si_class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n             __upcast_result \u0026__restrict result) const\n{\n  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n    return true;\n  \n  return __base_type-\u003e__do_upcast (dst, obj_ptr, result);\n}","filepath":"libstdc++-v3/libsupc++/si_class_type_info.cc","line_number":74,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5228896":{"score":0.9131733,"function_name":"local_Rb_tree_decrement","code":"static _Rb_tree_node_base*\n  local_Rb_tree_decrement(_Rb_tree_node_base* __x) throw ()\n  {\n    if (__x-\u003e_M_color == _S_red \n        \u0026\u0026 __x-\u003e_M_parent-\u003e_M_parent == __x)\n      __x = __x-\u003e_M_right;\n    else if (__x-\u003e_M_left != 0) \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_left;\n        while (__y-\u003e_M_right != 0)\n          __y = __y-\u003e_M_right;\n        __x = __y;\n      }\n    else \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_parent;\n        while (__x == __y-\u003e_M_left) \n          {\n            __x = __y;\n            __y = __y-\u003e_M_parent;\n          }\n        __x = __y;\n      }\n    return __x;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":94,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5228992":{"score":0.87859255,"function_name":"local_Rb_tree_increment","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  static _Rb_tree_node_base*\n  local_Rb_tree_increment(_Rb_tree_node_base* __x) throw ()\n  {\n    if (__x-\u003e_M_right != 0) \n      {\n        __x = __x-\u003e_M_right;\n        while (__x-\u003e_M_left != 0)\n          __x = __x-\u003e_M_left;\n      }\n    else \n      {\n        _Rb_tree_node_base* __y = __x-\u003e_M_parent;\n        while (__x == __y-\u003e_M_right) \n          {\n            __x = __y;\n            __y = __y-\u003e_M_parent;\n          }\n        if (__x-\u003e_M_right != __y)\n          __x = __y;\n      }\n    return __x;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":57,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5229120":{"score":0.9116745,"function_name":"local_Rb_tree_rotate_right","code":"static void \n  local_Rb_tree_rotate_right(_Rb_tree_node_base* const __x, \n\t\t\t     _Rb_tree_node_base*\u0026 __root)\n  {\n    _Rb_tree_node_base* const __y = __x-\u003e_M_left;\n\n    __x-\u003e_M_left = __y-\u003e_M_right;\n    if (__y-\u003e_M_right != 0)\n      __y-\u003e_M_right-\u003e_M_parent = __x;\n    __y-\u003e_M_parent = __x-\u003e_M_parent;\n\n    if (__x == __root)\n      __root = __y;\n    else if (__x == __x-\u003e_M_parent-\u003e_M_right)\n      __x-\u003e_M_parent-\u003e_M_right = __y;\n    else\n      __x-\u003e_M_parent-\u003e_M_left = __y;\n    __y-\u003e_M_right = __x;\n    __x-\u003e_M_parent = __y;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":163,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5229216":{"score":0.9113671,"function_name":"local_Rb_tree_rotate_left","code":"static void \n  local_Rb_tree_rotate_left(_Rb_tree_node_base* const __x, \n\t\t             _Rb_tree_node_base*\u0026 __root)\n  {\n    _Rb_tree_node_base* const __y = __x-\u003e_M_right;\n\n    __x-\u003e_M_right = __y-\u003e_M_left;\n    if (__y-\u003e_M_left !=0)\n      __y-\u003e_M_left-\u003e_M_parent = __x;\n    __y-\u003e_M_parent = __x-\u003e_M_parent;\n    \n    if (__x == __root)\n      __root = __y;\n    else if (__x == __x-\u003e_M_parent-\u003e_M_left)\n      __x-\u003e_M_parent-\u003e_M_left = __y;\n    else\n      __x-\u003e_M_parent-\u003e_M_right = __y;\n    __y-\u003e_M_left = __x;\n    __x-\u003e_M_parent = __y;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":132,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5229312":{"score":0.8919467,"function_name":"_Rb_tree_insert_and_rebalance","code":"void \n  _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n                                _Rb_tree_node_base* __x,\n                                _Rb_tree_node_base* __p,\n                                _Rb_tree_node_base\u0026 __header) throw ()\n  {\n    _Rb_tree_node_base *\u0026 __root = __header._M_parent;\n\n    // Initialize fields in new node to insert.\n    __x-\u003e_M_parent = __p;\n    __x-\u003e_M_left = 0;\n    __x-\u003e_M_right = 0;\n    __x-\u003e_M_color = _S_red;\n\n    // Insert.\n    // Make new node child of parent and maintain root, leftmost and\n    // rightmost nodes.\n    // N.B. First node is always inserted left.\n    if (__insert_left)\n      {\n        __p-\u003e_M_left = __x; // also makes leftmost = __x when __p == \u0026__header\n\n        if (__p == \u0026__header)\n        {\n            __header._M_parent = __x;\n            __header._M_right = __x;\n        }\n        else if (__p == __header._M_left)\n          __header._M_left = __x; // maintain leftmost pointing to min node\n      }\n    else\n      {\n        __p-\u003e_M_right = __x;\n\n        if (__p == __header._M_right)\n          __header._M_right = __x; // maintain rightmost pointing to max node\n      }\n    // Rebalance.\n    while (__x != __root \n\t   \u0026\u0026 __x-\u003e_M_parent-\u003e_M_color == _S_red) \n      {\n\t_Rb_tree_node_base* const __xpp = __x-\u003e_M_parent-\u003e_M_parent;\n\n\tif (__x-\u003e_M_parent == __xpp-\u003e_M_left) \n\t  {\n\t    _Rb_tree_node_base* const __y = __xpp-\u003e_M_right;\n\t    if (__y \u0026\u0026 __y-\u003e_M_color == _S_red) \n\t      {\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__y-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\t__x = __xpp;\n\t      }\n\t    else \n\t      {\n\t\tif (__x == __x-\u003e_M_parent-\u003e_M_right) \n\t\t  {\n\t\t    __x = __x-\u003e_M_parent;\n\t\t    local_Rb_tree_rotate_left(__x, __root);\n\t\t  }\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\tlocal_Rb_tree_rotate_right(__xpp, __root);\n\t      }\n\t  }\n\telse \n\t  {\n\t    _Rb_tree_node_base* const __y = __xpp-\u003e_M_left;\n\t    if (__y \u0026\u0026 __y-\u003e_M_color == _S_red) \n\t      {\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__y-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\t__x = __xpp;\n\t      }\n\t    else \n\t      {\n\t\tif (__x == __x-\u003e_M_parent-\u003e_M_left) \n\t\t  {\n\t\t    __x = __x-\u003e_M_parent;\n\t\t    local_Rb_tree_rotate_right(__x, __root);\n\t\t  }\n\t\t__x-\u003e_M_parent-\u003e_M_color = _S_black;\n\t\t__xpp-\u003e_M_color = _S_red;\n\t\tlocal_Rb_tree_rotate_left(__xpp, __root);\n\t      }\n\t  }\n      }\n    __root-\u003e_M_color = _S_black;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":194,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5231424":{"score":0.8847286,"function_name":"_Rb_tree_black_count","code":"unsigned int\n  _Rb_tree_black_count(const _Rb_tree_node_base* __node,\n                       const _Rb_tree_node_base* __root) throw ()\n  {\n    if (__node == 0)\n      return 0;\n    unsigned int __sum = 0;\n    do \n      {\n\tif (__node-\u003e_M_color == _S_black) \n\t  ++__sum;\n\tif (__node == __root) \n\t  break;\n\t__node = __node-\u003e_M_parent;\n      } \n    while (1);\n    return __sum;\n  }","filepath":"libstdc++-v3/src/c++98/tree.cc","line_number":446,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5231472":{"score":0.8450816,"function_name":"_List_node_base::swap","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n    void\n    _List_node_base::swap(_List_node_base\u0026 __x, _List_node_base\u0026 __y) throw()\n    {\n      if ( __x._M_next != \u0026__x )\n\t{\n\t  if ( __y._M_next != \u0026__y )\n\t    {\n\t      // Both __x and __y are not empty.\n\t      std::swap(__x._M_next,__y._M_next);\n\t      std::swap(__x._M_prev,__y._M_prev);\n\t      __x._M_next-\u003e_M_prev = __x._M_prev-\u003e_M_next = \u0026__x;\n\t      __y._M_next-\u003e_M_prev = __y._M_prev-\u003e_M_next = \u0026__y;\n\t    }\n\t  else\n\t    {\n\t      // __x is not empty, __y is empty.\n\t      __y._M_next = __x._M_next;\n\t      __y._M_prev = __x._M_prev;\n\t      __y._M_next-\u003e_M_prev = __y._M_prev-\u003e_M_next = \u0026__y;\n\t      __x._M_next = __x._M_prev = \u0026__x;\n\t    }\n\t}\n      else if ( __y._M_next != \u0026__y )\n\t{\n\t  // __x is empty, __y is not empty.\n\t  __x._M_next = __y._M_next;\n\t  __x._M_prev = __y._M_prev;\n\t  __x._M_next-\u003e_M_prev = __x._M_prev-\u003e_M_next = \u0026__x;\n\t  __y._M_next = __y._M_prev = \u0026__y;\n\t}\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":57,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231616":{"score":0.9091248,"function_name":"_List_node_base::_M_transfer","code":"void\n    _List_node_base::_M_transfer(_List_node_base * const __first,\n\t\t\t\t _List_node_base * const __last) throw()\n    {\n      if (this != __last)\n\t{\n\t  // Remove [first, last) from its old position.\n\t  __last-\u003e_M_prev-\u003e_M_next  = this;\n\t  __first-\u003e_M_prev-\u003e_M_next = __last;\n\t  this-\u003e_M_prev-\u003e_M_next    = __first;\n\n\t  // Splice [first, last) into its new position.\n\t  _List_node_base* const __tmp = this-\u003e_M_prev;\n\t  this-\u003e_M_prev                = __last-\u003e_M_prev;\n\t  __last-\u003e_M_prev              = __first-\u003e_M_prev;\n\t  __first-\u003e_M_prev             = __tmp;\n\t}\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":91,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231664":{"score":0.8555507,"function_name":"_List_node_base::_M_reverse","code":"void\n    _List_node_base::_M_reverse() throw()\n    {\n      _List_node_base* __tmp = this;\n      do\n\t{\n\t  std::swap(__tmp-\u003e_M_next, __tmp-\u003e_M_prev);\n\n\t  // Old next node is now prev.\n\t  __tmp = __tmp-\u003e_M_prev;\n\t}\n      while (__tmp != this);\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":110,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231696":{"score":0.88975215,"function_name":"_List_node_base::_M_hook","code":"void\n    _List_node_base::_M_hook(_List_node_base* const __position) throw()\n    {\n      this-\u003e_M_next = __position;\n      this-\u003e_M_prev = __position-\u003e_M_prev;\n      __position-\u003e_M_prev-\u003e_M_next = this;\n      __position-\u003e_M_prev = this;\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":124,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5231728":{"score":0.8823977,"function_name":"_List_node_base::_M_unhook","code":"void\n    _List_node_base::_M_unhook() throw()\n    {\n      _List_node_base* const __next_node = this-\u003e_M_next;\n      _List_node_base* const __prev_node = this-\u003e_M_prev;\n      __prev_node-\u003e_M_next = __next_node;\n      __next_node-\u003e_M_prev = __prev_node;\n    }","filepath":"libstdc++-v3/src/list.cc","line_number":133,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.6.0"},"5254928":{"score":0.7570077,"function_name":"__gxx_dependent_exception_cleanup","code":"static void\n__gxx_dependent_exception_cleanup(_Unwind_Reason_Code code,\n\t\t\t\t  _Unwind_Exception *exc)\n{\n  // This cleanup is set only for dependents.\n  __cxa_dependent_exception *dep = __get_dependent_exception_from_ue (exc);\n  __cxa_refcounted_exception *header =\n    __get_refcounted_exception_header_from_obj (dep-\u003eprimaryException);\n\n  // We only want to be called through _Unwind_DeleteException.\n  // _Unwind_DeleteException in the HP-UX IA64 libunwind library\n  // returns _URC_NO_REASON and not _URC_FOREIGN_EXCEPTION_CAUGHT\n  // like the GCC _Unwind_DeleteException function does.\n  if (code != _URC_FOREIGN_EXCEPTION_CAUGHT \u0026\u0026 code != _URC_NO_REASON)\n    __terminate (header-\u003eexc.terminateHandler);\n\n  __cxa_free_dependent_exception (dep);\n\n  if (__gnu_cxx::__eh_atomic_dec (\u0026header-\u003ereferenceCount))\n    {\n      if (header-\u003eexc.exceptionDestructor)\n\theader-\u003eexc.exceptionDestructor (header + 1);\n\n      __cxa_free_exception (header + 1);\n    }\n}","filepath":"libstdc++-v3/libsupc++/eh_ptr.cc","line_number":162,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5255040":{"score":0.71468586,"function_name":"std::__exception_ptr::exception_ptr::_M_addref","code":"void\nstd::__exception_ptr::exception_ptr::_M_addref() noexcept\n{\n  if (__builtin_expect(_M_exception_object != nullptr, true))\n    {\n      __cxa_refcounted_exception *eh =\n\t__get_refcounted_exception_header_from_obj (_M_exception_object);\n      __gnu_cxx::__eh_atomic_inc (\u0026eh-\u003ereferenceCount);\n    }\n}","filepath":"libstdc++-v3/libsupc++/eh_ptr.cc","line_number":83,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5255088":{"score":0.79132825,"function_name":"std::__exception_ptr::exception_ptr::_M_release","code":"void\nstd::__exception_ptr::exception_ptr::_M_release() noexcept\n{\n  if (__builtin_expect(_M_exception_object != nullptr, true))\n    {\n      __cxa_refcounted_exception *eh =\n\t__get_refcounted_exception_header_from_obj (_M_exception_object);\n      if (__gnu_cxx::__eh_atomic_dec (\u0026eh-\u003ereferenceCount))\n        {\n\t  if (eh-\u003eexc.exceptionDestructor)\n\t    eh-\u003eexc.exceptionDestructor (_M_exception_object);\n\n          __cxa_free_exception (_M_exception_object);\n          _M_exception_object = nullptr;\n        }\n    }\n}","filepath":"libstdc++-v3/libsupc++/eh_ptr.cc","line_number":95,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5255408":{"score":0.76032627,"function_name":"std::current_exception","code":"std::exception_ptr\nstd::current_exception() noexcept\n{\n  __cxa_eh_globals *globals = __cxa_get_globals ();\n  __cxa_exception *header = globals-\u003ecaughtExceptions;\n\n  if (!header)\n    return std::exception_ptr();\n\n  // Since foreign exceptions can't be counted, we can't return them.\n  if (!__is_gxx_exception_class (header-\u003eunwindHeader.exception_class))\n    return std::exception_ptr();\n\n  return std::exception_ptr(\n    __get_object_from_ambiguous_exception (header));\n}","filepath":"libstdc++-v3/libsupc++/eh_ptr.cc","line_number":144,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-13"},"5256704":{"score":0.76858974,"function_name":"__class_type_info::\n__do_upcast","code":"bool __class_type_info::\n__do_upcast (const __class_type_info *dst_type,\n             void **obj_ptr) const\n{\n  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n  \n  __do_upcast (dst_type, *obj_ptr, result);\n  if (!contained_public_p (result.part2dst))\n    return false;\n  *obj_ptr = const_cast \u003cvoid *\u003e (result.dst_ptr);\n  return true;\n}","filepath":"libstdc++-v3/libsupc++/class_type_info.cc","line_number":45,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5256912":{"score":0.791969,"function_name":"__class_type_info::\n__do_upcast","code":"bool __class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj,\n             __upcast_result \u0026__restrict result) const\n{\n  if (*this == *dst)\n    {\n      result.dst_ptr = obj;\n      result.base_type = nonvirtual_base_type;\n      result.part2dst = __contained_public;\n      return true;\n    }\n  return false;\n}","filepath":"libstdc++-v3/libsupc++/class_type_info.cc","line_number":96,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5256992":{"score":0.84205186,"function_name":"__class_type_info::\n__do_dyncast","code":"bool __class_type_info::\n__do_dyncast (ptrdiff_t,\n              __sub_kind access_path,\n              const __class_type_info *dst_type,\n              const void *obj_ptr,\n              const __class_type_info *src_type,\n              const void *src_ptr,\n              __dyncast_result \u0026__restrict result) const\n{\n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    {\n      // The src object we started from. Indicate how we are accessible from\n      // the most derived object.\n      result.whole2src = access_path;\n      return false;\n    }\n  if (*this == *dst_type)\n    {\n      result.dst_ptr = obj_ptr;\n      result.whole2dst = access_path;\n      result.dst2src = __not_contained;\n      return false;\n    }\n  return false;\n}","filepath":"libstdc++-v3/libsupc++/class_type_info.cc","line_number":70,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5257184":{"score":0.72590613,"function_name":"__class_type_info::\n__do_catch","code":"bool __class_type_info::\n__do_catch (const type_info *thr_type,\n            void **thr_obj,\n            unsigned outer) const\n{\n  if (*this == *thr_type)\n    return true;\n  if (outer \u003e= 4)\n    // Neither `A' nor `A *'.\n    return false;\n  return thr_type-\u003e__do_upcast (this, thr_obj);\n}","filepath":"libstdc++-v3/libsupc++/class_type_info.cc","line_number":32,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-6"},"5257312":{"score":0.88737375,"function_name":"d_make_comp","code":"static struct demangle_component *\nd_make_comp (struct d_info *di, enum demangle_component_type type,\n             struct demangle_component *left,\n             struct demangle_component *right)\n{\n  struct demangle_component *p;\n\n  /* We check for errors here.  A typical error would be a NULL return\n     from a subroutine.  We catch those here, and return NULL\n     upward.  */\n  switch (type)\n    {\n      /* These types require two parameters.  */\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_CLONE:\n      if (left == NULL || right == NULL)\n\treturn NULL;\n      break;\n\n      /* These types only require one parameter.  */\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      if (left == NULL)\n\treturn NULL;\n      break;\n\n      /* This needs a right parameter, but the left parameter can be\n\t empty.  */\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      if (right == NULL)\n\treturn NULL;\n      break;\n\n      /* These are allowed to have no parameters--in some cases they\n\t will be filled in later.  */\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n      break;\n\n      /* Other types should not be seen here.  */\n    default:\n      return NULL;\n    }\n\n  p = d_make_empty (di);\n  if (p != NULL)\n    {\n      p-\u003etype = type;\n      p-\u003eu.s_binary.left = left;\n      p-\u003eu.s_binary.right = right;\n    }\n  return p;\n}","filepath":"libiberty/cp-demangle.c","line_number":902,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5257456":{"score":0.90848416,"function_name":"d_cv_qualifiers","code":"static struct demangle_component **\nd_cv_qualifiers (struct d_info *di,\n                 struct demangle_component **pret, int member_fn)\n{\n  struct demangle_component **pstart;\n  char peek;\n\n  pstart = pret;\n  peek = d_peek_char (di);\n  while (peek == 'r' || peek == 'V' || peek == 'K'\n\t || (peek == 'D' \u0026\u0026 d_peek_next_char (di) == 'x'))\n    {\n      enum demangle_component_type t;\n\n      d_advance (di, 1);\n      if (peek == 'r')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_RESTRICT_THIS\n\t       : DEMANGLE_COMPONENT_RESTRICT);\n\t  di-\u003eexpansion += sizeof \"restrict\";\n\t}\n      else if (peek == 'V')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_VOLATILE_THIS\n\t       : DEMANGLE_COMPONENT_VOLATILE);\n\t  di-\u003eexpansion += sizeof \"volatile\";\n\t}\n      else if (peek == 'K')\n\t{\n\t  t = (member_fn\n\t       ? DEMANGLE_COMPONENT_CONST_THIS\n\t       : DEMANGLE_COMPONENT_CONST);\n\t  di-\u003eexpansion += sizeof \"const\";\n\t}\n      else\n\t{\n\t  t = DEMANGLE_COMPONENT_TRANSACTION_SAFE;\n\t  di-\u003eexpansion += sizeof \"transaction_safe\";\n\t  d_advance (di, 1);\n\t}\n\n      *pret = d_make_comp (di, t, NULL, NULL);\n      if (*pret == NULL)\n\treturn NULL;\n      pret = \u0026d_left (*pret);\n\n      peek = d_peek_char (di);\n    }\n\n  if (!member_fn \u0026\u0026 peek == 'F')\n    {\n      while (pstart != pret)\n\t{\n\t  switch ((*pstart)-\u003etype)\n\t    {\n\t    case DEMANGLE_COMPONENT_RESTRICT:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_RESTRICT_THIS;\n\t      break;\n\t    case DEMANGLE_COMPONENT_VOLATILE:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_VOLATILE_THIS;\n\t      break;\n\t    case DEMANGLE_COMPONENT_CONST:\n\t      (*pstart)-\u003etype = DEMANGLE_COMPONENT_CONST_THIS;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t  pstart = \u0026d_left (*pstart);\n\t}\n    }\n\n  return pret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2630,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5257744":{"score":0.80169725,"function_name":"d_ref_qualifier","code":"static struct demangle_component *\nd_ref_qualifier (struct d_info *di, struct demangle_component *sub)\n{\n  struct demangle_component *ret = sub;\n  char peek;\n\n  peek = d_peek_char (di);\n  if (peek == 'R' || peek == 'O')\n    {\n      enum demangle_component_type t;\n      if (peek == 'R')\n\t{\n\t  t = DEMANGLE_COMPONENT_REFERENCE_THIS;\n\t  di-\u003eexpansion += sizeof \"\u0026\";\n\t}\n      else\n\t{\n\t  t = DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS;\n\t  di-\u003eexpansion += sizeof \"\u0026\u0026\";\n\t}\n      d_advance (di, 1);\n\n      ret = d_make_comp (di, t, ret, NULL);\n    }\n\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2709,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5257840":{"score":0.8321537,"function_name":"d_count_templates_scopes","code":"static void\nd_count_templates_scopes (int *num_templates, int *num_scopes,\n\t\t\t  const struct demangle_component *dc)\n{\n  if (dc == NULL)\n    return;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_NAME:\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n    case DEMANGLE_COMPONENT_SUB_STD:\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n    case DEMANGLE_COMPONENT_OPERATOR:\n    case DEMANGLE_COMPONENT_CHARACTER:\n    case DEMANGLE_COMPONENT_NUMBER:\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n      break;\n\n    case DEMANGLE_COMPONENT_TEMPLATE:\n      (*num_templates)++;\n      goto recurse_left_right;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t(*num_scopes)++;\n      goto recurse_left_right;\n\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n    case DEMANGLE_COMPONENT_VTABLE:\n    case DEMANGLE_COMPONENT_VTT:\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n    case DEMANGLE_COMPONENT_TYPEINFO:\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n    case DEMANGLE_COMPONENT_THUNK:\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n    case DEMANGLE_COMPONENT_GUARD:\n    case DEMANGLE_COMPONENT_TLS_INIT:\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n    case DEMANGLE_COMPONENT_REFTEMP:\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n    case DEMANGLE_COMPONENT_CAST:\n    case DEMANGLE_COMPONENT_CONVERSION:\n    case DEMANGLE_COMPONENT_NULLARY:\n    case DEMANGLE_COMPONENT_UNARY:\n    case DEMANGLE_COMPONENT_BINARY:\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n    case DEMANGLE_COMPONENT_TRINARY:\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n    case DEMANGLE_COMPONENT_DECLTYPE:\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_CLONE:\n    recurse_left_right:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_left (dc));\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_right (dc));\n      break;\n\n    case DEMANGLE_COMPONENT_CTOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_ctor.name);\n      break;\n\n    case DEMANGLE_COMPONENT_DTOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_dtor.name);\n      break;\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_extended_operator.name);\n      break;\n\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n      d_count_templates_scopes (num_templates, num_scopes,\n                                dc-\u003eu.s_fixed.length);\n      break;\n\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\td_left (dc));\n      break;\n\n    case DEMANGLE_COMPONENT_LAMBDA:\n    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n      d_count_templates_scopes (num_templates, num_scopes,\n\t\t\t\tdc-\u003eu.s_unary_num.sub);\n      break;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3907,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258160":{"score":0.8724528,"function_name":"d_number","code":"static int\nd_number (struct d_info *di)\n{\n  int negative;\n  char peek;\n  int ret;\n\n  negative = 0;\n  peek = d_peek_char (di);\n  if (peek == 'n')\n    {\n      negative = 1;\n      d_advance (di, 1);\n      peek = d_peek_char (di);\n    }\n\n  ret = 0;\n  while (1)\n    {\n      if (! IS_DIGIT (peek))\n\t{\n\t  if (negative)\n\t    ret = - ret;\n\t  return ret;\n\t}\n      ret = ret * 10 + peek - '0';\n      d_advance (di, 1);\n      peek = d_peek_char (di);\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":1644,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258368":{"score":0.9032318,"function_name":"d_compact_number","code":"static int\nd_compact_number (struct d_info *di)\n{\n  int num;\n  if (d_peek_char (di) == '_')\n    num = 0;\n  else if (d_peek_char (di) == 'n')\n    return -1;\n  else\n    num = d_number (di) + 1;\n\n  if (num \u003c 0 || ! d_check_char (di, '_'))\n    return -1;\n  return num;\n}","filepath":"libiberty/cp-demangle.c","line_number":2963,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258448":{"score":0.78508925,"function_name":"d_template_param","code":"static struct demangle_component *\nd_template_param (struct d_info *di)\n{\n  int param;\n\n  if (! d_check_char (di, 'T'))\n    return NULL;\n\n  param = d_compact_number (di);\n  if (param \u003c 0)\n    return NULL;\n\n  ++di-\u003edid_subs;\n\n  return d_make_template_param (di, param);\n}","filepath":"libiberty/cp-demangle.c","line_number":2983,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258544":{"score":0.6045927,"function_name":"d_source_name","code":"static struct demangle_component *\nd_source_name (struct d_info *di)\n{\n  int len;\n  struct demangle_component *ret;\n\n  len = d_number (di);\n  if (len \u003c= 0)\n    return NULL;\n  ret = d_identifier (di, len);\n  di-\u003elast_name = ret;\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":1628,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258864":{"score":0.83445007,"function_name":"d_abi_tags","code":"static struct demangle_component *\nd_abi_tags (struct d_info *di, struct demangle_component *dc)\n{\n  struct demangle_component *hold_last_name;\n  char peek;\n\n  /* Preserve the last name, so the ABI tag doesn't clobber it.  */\n  hold_last_name = di-\u003elast_name;\n\n  while (peek = d_peek_char (di),\n\t peek == 'B')\n    {\n      struct demangle_component *tag;\n      d_advance (di, 1);\n      tag = d_source_name (di);\n      dc = d_make_comp (di, DEMANGLE_COMPONENT_TAGGED_NAME, dc, tag);\n    }\n\n  di-\u003elast_name = hold_last_name;\n\n  return dc;\n}","filepath":"libiberty/cp-demangle.c","line_number":1327,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5258960":{"score":0.91197044,"function_name":"d_substitution","code":"static struct demangle_component *\nd_substitution (struct d_info *di, int prefix)\n{\n  char c;\n\n  if (! d_check_char (di, 'S'))\n    return NULL;\n\n  c = d_next_char (di);\n  if (c == '_' || IS_DIGIT (c) || IS_UPPER (c))\n    {\n      unsigned int id;\n\n      id = 0;\n      if (c != '_')\n\t{\n\t  do\n\t    {\n\t      unsigned int new_id;\n\n\t      if (IS_DIGIT (c))\n\t\tnew_id = id * 36 + c - '0';\n\t      else if (IS_UPPER (c))\n\t\tnew_id = id * 36 + c - 'A' + 10;\n\t      else\n\t\treturn NULL;\n\t      if (new_id \u003c id)\n\t\treturn NULL;\n\t      id = new_id;\n\t      c = d_next_char (di);\n\t    }\n\t  while (c != '_');\n\n\t  ++id;\n\t}\n\n      if (id \u003e= (unsigned int) di-\u003enext_sub)\n\treturn NULL;\n\n      ++di-\u003edid_subs;\n\n      return di-\u003esubs[id];\n    }\n  else\n    {\n      int verbose;\n      const struct d_standard_sub_info *p;\n      const struct d_standard_sub_info *pend;\n\n      verbose = (di-\u003eoptions \u0026 DMGL_VERBOSE) != 0;\n      if (! verbose \u0026\u0026 prefix)\n\t{\n\t  char peek;\n\n\t  peek = d_peek_char (di);\n\t  if (peek == 'C' || peek == 'D')\n\t    verbose = 1;\n\t}\n\n      pend = (\u0026standard_subs[0]\n\t      + sizeof standard_subs / sizeof standard_subs[0]);\n      for (p = \u0026standard_subs[0]; p \u003c pend; ++p)\n\t{\n\t  if (c == p-\u003ecode)\n\t    {\n\t      const char *s;\n\t      int len;\n\t      struct demangle_component *c;\n\n\t      if (p-\u003eset_last_name != NULL)\n\t\tdi-\u003elast_name = d_make_sub (di, p-\u003eset_last_name,\n\t\t\t\t\t    p-\u003eset_last_name_len);\n\t      if (verbose)\n\t\t{\n\t\t  s = p-\u003efull_expansion;\n\t\t  len = p-\u003efull_len;\n\t\t}\n\t      else\n\t\t{\n\t\t  s = p-\u003esimple_expansion;\n\t\t  len = p-\u003esimple_len;\n\t\t}\n\t      di-\u003eexpansion += len;\n\t      c = d_make_sub (di, s, len);\n\t      if (d_peek_char (di) == 'B')\n\t\t{\n\t\t  /* If there are ABI tags on the abbreviation, it becomes\n\t\t     a substitution candidate.  */\n\t\t  c = d_abi_tags (di, c);\n\t\t  d_add_substitution (di, c);\n\t\t}\n\t      return c;\n\t    }\n\t}\n\n      return NULL;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3705,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5259520":{"score":0.90473604,"function_name":"d_call_offset","code":"static int\nd_call_offset (struct d_info *di, int c)\n{\n  if (c == '\\0')\n    c = d_next_char (di);\n\n  if (c == 'h')\n    d_number (di);\n  else if (c == 'v')\n    {\n      d_number (di);\n      if (! d_check_char (di, '_'))\n\treturn 0;\n      d_number (di);\n    }\n  else\n    return 0;\n\n  if (! d_check_char (di, '_'))\n    return 0;\n\n  return 1;\n}","filepath":"libiberty/cp-demangle.c","line_number":2124,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5259744":{"score":0.85718,"function_name":"d_find_pack","code":"static struct demangle_component *\nd_find_pack (struct d_print_info *dpi,\n\t     const struct demangle_component *dc)\n{\n  struct demangle_component *a;\n  if (dc == NULL)\n    return NULL;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n      a = d_lookup_template_argument (dpi, dc);\n      if (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\treturn a;\n      return NULL;\n\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n      return NULL;\n      \n    case DEMANGLE_COMPONENT_LAMBDA:\n    case DEMANGLE_COMPONENT_NAME:\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n    case DEMANGLE_COMPONENT_OPERATOR:\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n    case DEMANGLE_COMPONENT_SUB_STD:\n    case DEMANGLE_COMPONENT_CHARACTER:\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n    case DEMANGLE_COMPONENT_DEFAULT_ARG:\n    case DEMANGLE_COMPONENT_NUMBER:\n      return NULL;\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      return d_find_pack (dpi, dc-\u003eu.s_extended_operator.name);\n    case DEMANGLE_COMPONENT_CTOR:\n      return d_find_pack (dpi, dc-\u003eu.s_ctor.name);\n    case DEMANGLE_COMPONENT_DTOR:\n      return d_find_pack (dpi, dc-\u003eu.s_dtor.name);\n\n    default:\n      a = d_find_pack (dpi, d_left (dc));\n      if (a)\n\treturn a;\n      return d_find_pack (dpi, d_right (dc));\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":4260,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5259872":{"score":0.60581857,"function_name":"d_growable_string_append_buffer","code":"static inline void\nd_growable_string_append_buffer (struct d_growable_string *dgs,\n                                 const char *s, size_t l)\n{\n  size_t need;\n\n  need = dgs-\u003elen + l + 1;\n  if (need \u003e dgs-\u003ealc)\n    d_growable_string_resize (dgs, need);\n\n  if (dgs-\u003eallocation_failure)\n    return;\n\n  memcpy (dgs-\u003ebuf + dgs-\u003elen, s, l);\n  dgs-\u003ebuf[dgs-\u003elen + l] = '\\0';\n  dgs-\u003elen += l;\n}","filepath":"libiberty/cp-demangle.c","line_number":3872,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5262048":{"score":0.9582262,"function_name":"d_expression_1","code":"static inline struct demangle_component *\nd_expression_1 (struct d_info *di)\n{\n  char peek;\n\n  peek = d_peek_char (di);\n  if (peek == 'L')\n    return d_expr_primary (di);\n  else if (peek == 'T')\n    return d_template_param (di);\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'r')\n    {\n      struct demangle_component *type;\n      struct demangle_component *name;\n\n      d_advance (di, 2);\n      type = cplus_demangle_type (di);\n      name = d_unqualified_name (di);\n      if (d_peek_char (di) != 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type, name);\n      else\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_QUAL_NAME, type,\n\t\t\t    d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t\t\t d_template_args (di)));\n    }\n  else if (peek == 's' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t  d_expression_1 (di), NULL);\n    }\n  else if (peek == 'f' \u0026\u0026 d_peek_next_char (di) == 'p')\n    {\n      /* Function parameter used in a late-specified return type.  */\n      int index;\n      d_advance (di, 2);\n      if (d_peek_char (di) == 'T')\n\t{\n\t  /* 'this' parameter.  */\n\t  d_advance (di, 1);\n\t  index = 0;\n\t}\n      else\n\t{\n\t  index = d_compact_number (di);\n\t  if (index == INT_MAX || index == -1)\n\t    return NULL;\n\t  index++;\n\t}\n      return d_make_function_param (di, index);\n    }\n  else if (IS_DIGIT (peek)\n\t   || (peek == 'o' \u0026\u0026 d_peek_next_char (di) == 'n'))\n    {\n      /* We can get an unqualified name as an expression in the case of\n         a dependent function call, i.e. decltype(f(t)).  */\n      struct demangle_component *name;\n\n      if (peek == 'o')\n\t/* operator-function-id, i.e. operator+(t).  */\n\td_advance (di, 2);\n\n      name = d_unqualified_name (di);\n      if (name == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'I')\n\treturn d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, name,\n\t\t\t    d_template_args (di));\n      else\n\treturn name;\n    }\n  else if ((peek == 'i' || peek == 't')\n\t   \u0026\u0026 d_peek_next_char (di) == 'l')\n    {\n      /* Brace-enclosed initializer list, untyped or typed.  */\n      struct demangle_component *type = NULL;\n      if (peek == 't')\n\ttype = cplus_demangle_type (di);\n      if (!d_peek_next_char (di))\n\treturn NULL;\n      d_advance (di, 2);\n      return d_make_comp (di, DEMANGLE_COMPONENT_INITIALIZER_LIST,\n\t\t\t  type, d_exprlist (di, 'E'));\n    }\n  else\n    {\n      struct demangle_component *op;\n      const char *code = NULL;\n      int args;\n\n      op = d_operator_name (di);\n      if (op == NULL)\n\treturn NULL;\n\n      if (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\t{\n\t  code = op-\u003eu.s_operator.op-\u003ecode;\n\t  di-\u003eexpansion += op-\u003eu.s_operator.op-\u003elen - 2;\n\t  if (strcmp (code, \"st\") == 0)\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\tcplus_demangle_type (di));\n\t}\n\n      switch (op-\u003etype)\n\t{\n\tdefault:\n\t  return NULL;\n\tcase DEMANGLE_COMPONENT_OPERATOR:\n\t  args = op-\u003eu.s_operator.op-\u003eargs;\n\t  break;\n\tcase DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n\t  args = op-\u003eu.s_extended_operator.args;\n\t  break;\n\tcase DEMANGLE_COMPONENT_CAST:\n\t  args = 1;\n\t  break;\n\t}\n\n      switch (args)\n\t{\n\tcase 0:\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_NULLARY, op, NULL);\n\n\tcase 1:\n\t  {\n\t    struct demangle_component *operand;\n\t    int suffix = 0;\n\n\t    if (code \u0026\u0026 (code[0] == 'p' || code[0] == 'm')\n\t\t\u0026\u0026 code[1] == code[0])\n\t      /* pp_ and mm_ are the prefix variants.  */\n\t      suffix = !d_check_char (di, '_');\n\n\t    if (op-\u003etype == DEMANGLE_COMPONENT_CAST\n\t\t\u0026\u0026 d_check_char (di, '_'))\n\t      operand = d_exprlist (di, 'E');\n\t    else if (code \u0026\u0026 !strcmp (code, \"sP\"))\n\t      operand = d_template_args_1 (di);\n\t    else\n\t      operand = d_expression_1 (di);\n\n\t    if (suffix)\n\t      /* Indicate the suffix variant for d_print_comp.  */\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  d_make_comp (di,\n\t\t\t\t\t       DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t       operand, operand));\n\t    else\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_UNARY, op,\n\t\t\t\t  operand);\n\t  }\n\tcase 2:\n\t  {\n\t    struct demangle_component *left;\n\t    struct demangle_component *right;\n\n\t    if (code == NULL)\n\t      return NULL;\n\t    if (op_is_new_cast (op))\n\t      left = cplus_demangle_type (di);\n\t    else if (code[0] == 'f')\n\t      /* fold-expression.  */\n\t      left = d_operator_name (di);\n\t    else\n\t      left = d_expression_1 (di);\n\t    if (!strcmp (code, \"cl\"))\n\t      right = d_exprlist (di, 'E');\n\t    else if (!strcmp (code, \"dt\") || !strcmp (code, \"pt\"))\n\t      {\n\t\tright = d_unqualified_name (di);\n\t\tif (d_peek_char (di) == 'I')\n\t\t  right = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE,\n\t\t\t\t       right, d_template_args (di));\n\t      }\n\t    else\n\t      right = d_expression_1 (di);\n\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_BINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_BINARY_ARGS,\n\t\t\t\t\t     left, right));\n\t  }\n\tcase 3:\n\t  {\n\t    struct demangle_component *first;\n\t    struct demangle_component *second;\n\t    struct demangle_component *third;\n\n\t    if (code == NULL)\n\t      return NULL;\n\t    else if (!strcmp (code, \"qu\"))\n\t      {\n\t\t/* ?: expression.  */\n\t\tfirst = d_expression_1 (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'f')\n\t      {\n\t\t/* fold-expression.  */\n\t\tfirst = d_operator_name (di);\n\t\tsecond = d_expression_1 (di);\n\t\tthird = d_expression_1 (di);\n\t      }\n\t    else if (code[0] == 'n')\n\t      {\n\t\t/* new-expression.  */\n\t\tif (code[1] != 'w' \u0026\u0026 code[1] != 'a')\n\t\t  return NULL;\n\t\tfirst = d_exprlist (di, '_');\n\t\tsecond = cplus_demangle_type (di);\n\t\tif (d_peek_char (di) == 'E')\n\t\t  {\n\t\t    d_advance (di, 1);\n\t\t    third = NULL;\n\t\t  }\n\t\telse if (d_peek_char (di) == 'p'\n\t\t\t \u0026\u0026 d_peek_next_char (di) == 'i')\n\t\t  {\n\t\t    /* Parenthesized initializer.  */\n\t\t    d_advance (di, 2);\n\t\t    third = d_exprlist (di, 'E');\n\t\t  }\n\t\telse if (d_peek_char (di) == 'i'\n\t\t\t \u0026\u0026 d_peek_next_char (di) == 'l')\n\t\t  /* initializer-list.  */\n\t\t  third = d_expression_1 (di);\n\t\telse\n\t\t  return NULL;\n\t      }\n\t    else\n\t      return NULL;\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_TRINARY, op,\n\t\t\t\td_make_comp (di,\n\t\t\t\t\t     DEMANGLE_COMPONENT_TRINARY_ARG1,\n\t\t\t\t\t     first,\n\t\t\t\t\t     d_make_comp (di,\n\t\t\t\t\t\t\t  DEMANGLE_COMPONENT_TRINARY_ARG2,\n\t\t\t\t\t\t\t  second, third)));\n\t  }\n\tdefault:\n\t  return NULL;\n\t}\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":3152,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5263648":{"score":0.8194171,"function_name":"d_template_args_1","code":"static struct demangle_component *\nd_template_args_1 (struct d_info *di)\n{\n  struct demangle_component *hold_last_name;\n  struct demangle_component *al;\n  struct demangle_component **pal;\n\n  /* Preserve the last name we saw--don't let the template arguments\n     clobber it, as that would give us the wrong name for a subsequent\n     constructor or destructor.  */\n  hold_last_name = di-\u003elast_name;\n\n  if (d_peek_char (di) == 'E')\n    {\n      /* An argument pack can be empty.  */\n      d_advance (di, 1);\n      return d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, NULL, NULL);\n    }\n\n  al = NULL;\n  pal = \u0026al;\n  while (1)\n    {\n      struct demangle_component *a;\n\n      a = d_template_arg (di);\n      if (a == NULL)\n\treturn NULL;\n\n      *pal = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, a, NULL);\n      if (*pal == NULL)\n\treturn NULL;\n      pal = \u0026d_right (*pal);\n\n      if (d_peek_char (di) == 'E')\n\t{\n\t  d_advance (di, 1);\n\t  break;\n\t}\n    }\n\n  di-\u003elast_name = hold_last_name;\n\n  return al;\n}","filepath":"libiberty/cp-demangle.c","line_number":3015,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5265520":{"score":0.9236851,"function_name":"cplus_demangle_type","code":"demangle_component *\ncplus_demangle_type (struct d_info *di)\n{\n  char peek;\n  struct demangle_component *ret;\n  int can_subst;\n\n  /* The ABI specifies that when CV-qualifiers are used, the base type\n     is substitutable, and the fully qualified type is substitutable,\n     but the base type with a strict subset of the CV-qualifiers is\n     not substitutable.  The natural recursive implementation of the\n     CV-qualifiers would cause subsets to be substitutable, so instead\n     we pull them all off now.\n\n     FIXME: The ABI says that order-insensitive vendor qualifiers\n     should be handled in the same way, but we have no way to tell\n     which vendor qualifiers are order-insensitive and which are\n     order-sensitive.  So we just assume that they are all\n     order-sensitive.  g++ 3.4 supports only one vendor qualifier,\n     __vector, and it treats it as order-sensitive when mangling\n     names.  */\n\n  peek = d_peek_char (di);\n  if (peek == 'r' || peek == 'V' || peek == 'K'\n      || (peek == 'D' \u0026\u0026 d_peek_next_char (di) == 'x'))\n    {\n      struct demangle_component **pret;\n\n      pret = d_cv_qualifiers (di, \u0026ret, 0);\n      if (pret == NULL)\n\treturn NULL;\n      if (d_peek_char (di) == 'F')\n\t{\n\t  /* cv-qualifiers before a function type apply to 'this',\n\t     so avoid adding the unqualified function type to\n\t     the substitution list.  */\n\t  *pret = d_function_type (di);\n\t}\n      else\n\t*pret = cplus_demangle_type (di);\n      if (!*pret)\n\treturn NULL;\n      if ((*pret)-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t  || (*pret)-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t{\n\t  /* Move the ref-qualifier outside the cv-qualifiers so that\n\t     they are printed in the right order.  */\n\t  struct demangle_component *fn = d_left (*pret);\n\t  d_left (*pret) = ret;\n\t  ret = *pret;\n\t  *pret = fn;\n\t}\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n      return ret;\n    }\n\n  can_subst = 1;\n\n  switch (peek)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n    case 'h': case 'i': case 'j':           case 'l': case 'm': case 'n':\n    case 'o':                               case 's': case 't':\n    case 'v': case 'w': case 'x': case 'y': case 'z':\n      ret = d_make_builtin_type (di,\n\t\t\t\t \u0026cplus_demangle_builtin_types[peek - 'a']);\n      di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n      can_subst = 0;\n      d_advance (di, 1);\n      break;\n\n    case 'u':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,\n\t\t\t d_source_name (di), NULL);\n      break;\n\n    case 'F':\n      ret = d_function_type (di);\n      break;\n\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9':\n    case 'N':\n    case 'Z':\n      ret = d_class_enum_type (di);\n      break;\n\n    case 'A':\n      ret = d_array_type (di);\n      break;\n\n    case 'M':\n      ret = d_pointer_to_member_type (di);\n      break;\n\n    case 'T':\n      ret = d_template_param (di);\n      if (d_peek_char (di) == 'I')\n\t{\n\t  /* This may be \u003ctemplate-template-param\u003e \u003ctemplate-args\u003e.\n\t     If this is the type for a conversion operator, we can\n\t     have a \u003ctemplate-template-param\u003e here only by following\n\t     a derivation like this:\n\n\t     \u003cnested-name\u003e\n\t     -\u003e \u003ctemplate-prefix\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cprefix\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cunqualified-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003coperator-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctype\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctemplate-template-param\u003e \u003ctemplate-args\u003e \u003ctemplate-args\u003e\n\n\t     where the \u003ctemplate-args\u003e is followed by another.\n\t     Otherwise, we must have a derivation like this:\n\n\t     \u003cnested-name\u003e\n\t     -\u003e \u003ctemplate-prefix\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cprefix\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003cunqualified-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003ctemplate-unqualified-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e \u003coperator-name\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctype\u003e \u003ctemplate-args\u003e\n\t     -\u003e \u003csource-name\u003e cv \u003ctemplate-param\u003e \u003ctemplate-args\u003e\n\n\t     where we need to leave the \u003ctemplate-args\u003e to be processed\n\t     by d_prefix (following the \u003ctemplate-prefix\u003e).\n\n\t     The \u003ctemplate-template-param\u003e part is a substitution\n\t     candidate.  */\n\t  if (! di-\u003eis_conversion)\n\t    {\n\t      if (! d_add_substitution (di, ret))\n\t\treturn NULL;\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    }\n\t  else\n\t    {\n\t      struct demangle_component *args;\n\t      struct d_info_checkpoint checkpoint;\n\n\t      d_checkpoint (di, \u0026checkpoint);\n\t      args = d_template_args (di);\n\t      if (d_peek_char (di) == 'I')\n\t\t{\n\t\t  if (! d_add_substitution (di, ret))\n\t\t    return NULL;\n\t\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t     args);\n\t\t}\n\t      else\n\t\td_backtrack (di, \u0026checkpoint);\n\t    }\n\t}\n      break;\n\n    case 'S':\n      /* If this is a special substitution, then it is the start of\n\t \u003cclass-enum-type\u003e.  */\n      {\n\tchar peek_next;\n\n\tpeek_next = d_peek_next_char (di);\n\tif (IS_DIGIT (peek_next)\n\t    || peek_next == '_'\n\t    || IS_UPPER (peek_next))\n\t  {\n\t    ret = d_substitution (di, 0);\n\t    /* The substituted name may have been a template name and\n\t       may be followed by tepmlate args.  */\n\t    if (d_peek_char (di) == 'I')\n\t      ret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t\t d_template_args (di));\n\t    else\n\t      can_subst = 0;\n\t  }\n\telse\n\t  {\n\t    ret = d_class_enum_type (di);\n\t    /* If the substitution was a complete type, then it is not\n\t       a new substitution candidate.  However, if the\n\t       substitution was followed by template arguments, then\n\t       the whole thing is a substitution candidate.  */\n\t    if (ret != NULL \u0026\u0026 ret-\u003etype == DEMANGLE_COMPONENT_SUB_STD)\n\t      can_subst = 0;\n\t  }\n      }\n      break;\n\n    case 'O':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_RVALUE_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'P':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_POINTER,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'R':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_REFERENCE,\n                         cplus_demangle_type (di), NULL);\n      break;\n\n    case 'C':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_COMPLEX,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'G':\n      d_advance (di, 1);\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_IMAGINARY,\n\t\t\t cplus_demangle_type (di), NULL);\n      break;\n\n    case 'U':\n      d_advance (di, 1);\n      ret = d_source_name (di);\n      if (d_peek_char (di) == 'I')\n\tret = d_make_comp (di, DEMANGLE_COMPONENT_TEMPLATE, ret,\n\t\t\t   d_template_args (di));\n      ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL,\n\t\t\t cplus_demangle_type (di), ret);\n      break;\n\n    case 'D':\n      can_subst = 0;\n      d_advance (di, 1);\n      peek = d_next_char (di);\n      switch (peek)\n\t{\n\tcase 'T':\n\tcase 't':\n\t  /* decltype (expression) */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_DECLTYPE,\n\t\t\t     d_expression (di), NULL);\n\t  if (ret \u0026\u0026 d_next_char (di) != 'E')\n\t    ret = NULL;\n\t  can_subst = 1;\n\t  break;\n\t  \n\tcase 'p':\n\t  /* Pack expansion.  */\n\t  ret = d_make_comp (di, DEMANGLE_COMPONENT_PACK_EXPANSION,\n\t\t\t     cplus_demangle_type (di), NULL);\n\t  can_subst = 1;\n\t  break;\n\n\tcase 'a':\n\t  /* auto */\n\t  ret = d_make_name (di, \"auto\", 4);\n\t  break;\n\t  \n\tcase 'f':\n\t  /* 32-bit decimal floating point */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[26]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'd':\n\t  /* 64-bit DFP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[27]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'e':\n\t  /* 128-bit DFP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[28]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'h':\n\t  /* 16-bit half-precision FP */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[29]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 's':\n\t  /* char16_t */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[30]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\tcase 'i':\n\t  /* char32_t */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[31]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\n\tcase 'F':\n\t  /* Fixed point types. DF\u003cint bits\u003e\u003clength\u003e\u003cfract bits\u003e\u003csat\u003e  */\n\t  ret = d_make_empty (di);\n\t  ret-\u003etype = DEMANGLE_COMPONENT_FIXED_TYPE;\n\t  if ((ret-\u003eu.s_fixed.accum = IS_DIGIT (d_peek_char (di))))\n\t    /* For demangling we don't care about the bits.  */\n\t    d_number (di);\n\t  ret-\u003eu.s_fixed.length = cplus_demangle_type (di);\n\t  if (ret-\u003eu.s_fixed.length == NULL)\n\t    return NULL;\n\t  d_number (di);\n\t  peek = d_next_char (di);\n\t  ret-\u003eu.s_fixed.sat = (peek == 's');\n\t  break;\n\n\tcase 'v':\n\t  ret = d_vector_type (di);\n\t  can_subst = 1;\n\t  break;\n\n        case 'n':\n          /* decltype(nullptr) */\n\t  ret = d_make_builtin_type (di, \u0026cplus_demangle_builtin_types[32]);\n\t  di-\u003eexpansion += ret-\u003eu.s_builtin.type-\u003elen;\n\t  break;\n\n\tdefault:\n\t  return NULL;\n\t}\n      break;\n\n    default:\n      return NULL;\n    }\n\n  if (can_subst)\n    {\n      if (! d_add_substitution (di, ret))\n\treturn NULL;\n    }\n\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2293,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5268064":{"score":0.80945796,"function_name":"d_operator_name","code":"static struct demangle_component *\nd_operator_name (struct d_info *di)\n{\n  char c1;\n  char c2;\n\n  c1 = d_next_char (di);\n  c2 = d_next_char (di);\n  if (c1 == 'v' \u0026\u0026 IS_DIGIT (c2))\n    return d_make_extended_operator (di, c2 - '0', d_source_name (di));\n  else if (c1 == 'c' \u0026\u0026 c2 == 'v')\n    {\n      struct demangle_component *type;\n      int was_conversion = di-\u003eis_conversion;\n      struct demangle_component *res;\n\n      di-\u003eis_conversion = ! di-\u003eis_expression;\n      type = cplus_demangle_type (di);\n      if (di-\u003eis_conversion)\n\tres = d_make_comp (di, DEMANGLE_COMPONENT_CONVERSION, type, NULL);\n      else\n\tres = d_make_comp (di, DEMANGLE_COMPONENT_CAST, type, NULL);\n      di-\u003eis_conversion = was_conversion;\n      return res;\n    }\n  else\n    {\n      /* LOW is the inclusive lower bound.  */\n      int low = 0;\n      /* HIGH is the exclusive upper bound.  We subtract one to ignore\n\t the sentinel at the end of the array.  */\n      int high = ((sizeof (cplus_demangle_operators)\n\t\t   / sizeof (cplus_demangle_operators[0]))\n\t\t  - 1);\n\n      while (1)\n\t{\n\t  int i;\n\t  const struct demangle_operator_info *p;\n\n\t  i = low + (high - low) / 2;\n\t  p = cplus_demangle_operators + i;\n\n\t  if (c1 == p-\u003ecode[0] \u0026\u0026 c2 == p-\u003ecode[1])\n\t    return d_make_operator (di, p);\n\n\t  if (c1 \u003c p-\u003ecode[0] || (c1 == p-\u003ecode[0] \u0026\u0026 c2 \u003c p-\u003ecode[1]))\n\t    high = i;\n\t  else\n\t    low = i + 1;\n\t  if (low == high)\n\t    return NULL;\n\t}\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":1813,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5268480":{"score":0.90836453,"function_name":"d_parmlist","code":"static struct demangle_component *\nd_parmlist (struct d_info *di)\n{\n  struct demangle_component *tl;\n  struct demangle_component **ptl;\n\n  tl = NULL;\n  ptl = \u0026tl;\n  while (1)\n    {\n      struct demangle_component *type;\n\n      char peek = d_peek_char (di);\n      if (peek == '\\0' || peek == 'E' || peek == '.')\n\tbreak;\n      if ((peek == 'R' || peek == 'O')\n\t  \u0026\u0026 d_peek_next_char (di) == 'E')\n\t/* Function ref-qualifier, not a ref prefix for a parameter type.  */\n\tbreak;\n      type = cplus_demangle_type (di);\n      if (type == NULL)\n\treturn NULL;\n      *ptl = d_make_comp (di, DEMANGLE_COMPONENT_ARGLIST, type, NULL);\n      if (*ptl == NULL)\n\treturn NULL;\n      ptl = \u0026d_right (*ptl);\n    }\n\n  /* There should be at least one parameter type besides the optional\n     return type.  A function which takes no arguments will have a\n     single parameter type void.  */\n  if (tl == NULL)\n    return NULL;\n\n  /* If we have a single parameter type void, omit it.  */\n  if (d_right (tl) == NULL\n      \u0026\u0026 d_left (tl)-\u003etype == DEMANGLE_COMPONENT_BUILTIN_TYPE\n      \u0026\u0026 d_left (tl)-\u003eu.s_builtin.type-\u003eprint == D_PRINT_VOID)\n    {\n      di-\u003eexpansion -= d_left (tl)-\u003eu.s_builtin.type-\u003elen;\n      d_left (tl) = NULL;\n    }\n\n  return tl;\n}","filepath":"libiberty/cp-demangle.c","line_number":2762,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5268736":{"score":0.89904064,"function_name":"d_unqualified_name","code":"static struct demangle_component *\nd_unqualified_name (struct d_info *di)\n{\n  struct demangle_component *ret;\n  char peek;\n\n  peek = d_peek_char (di);\n  if (IS_DIGIT (peek))\n    ret = d_source_name (di);\n  else if (IS_LOWER (peek))\n    {\n      ret = d_operator_name (di);\n      if (ret != NULL \u0026\u0026 ret-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\t{\n\t  di-\u003eexpansion += sizeof \"operator\" + ret-\u003eu.s_operator.op-\u003elen - 2;\n\t  if (!strcmp (ret-\u003eu.s_operator.op-\u003ecode, \"li\"))\n\t    ret = d_make_comp (di, DEMANGLE_COMPONENT_UNARY, ret,\n\t\t\t       d_source_name (di));\n\t}\n    }\n  else if (peek == 'C' || peek == 'D')\n    ret = d_ctor_dtor_name (di);\n  else if (peek == 'L')\n    {\n      d_advance (di, 1);\n\n      ret = d_source_name (di);\n      if (ret == NULL)\n\treturn NULL;\n      if (! d_discriminator (di))\n\treturn NULL;\n    }\n  else if (peek == 'U')\n    {\n      switch (d_peek_next_char (di))\n\t{\n\tcase 'l':\n\t  ret = d_lambda (di);\n\t  break;\n\tcase 't':\n\t  ret = d_unnamed_type (di);\n\t  break;\n\tdefault:\n\t  return NULL;\n\t}\n    }\n  else\n    return NULL;\n\n  if (d_peek_char (di) == 'B')\n    ret = d_abi_tags (di, ret);\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":1572,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5269760":{"score":0.9087859,"function_name":"d_bare_function_type","code":"static struct demangle_component *\nd_bare_function_type (struct d_info *di, int has_return_type)\n{\n  struct demangle_component *return_type;\n  struct demangle_component *tl;\n  char peek;\n\n  /* Detect special qualifier indicating that the first argument\n     is the return type.  */\n  peek = d_peek_char (di);\n  if (peek == 'J')\n    {\n      d_advance (di, 1);\n      has_return_type = 1;\n    }\n\n  if (has_return_type)\n    {\n      return_type = cplus_demangle_type (di);\n      if (return_type == NULL)\n\treturn NULL;\n    }\n  else\n    return_type = NULL;\n\n  tl = d_parmlist (di);\n  if (tl == NULL)\n    return NULL;\n\n  return d_make_comp (di, DEMANGLE_COMPONENT_FUNCTION_TYPE,\n\t\t      return_type, tl);\n}","filepath":"libiberty/cp-demangle.c","line_number":2810,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5269872":{"score":0.90561545,"function_name":"d_function_type","code":"static struct demangle_component *\nd_function_type (struct d_info *di)\n{\n  struct demangle_component *ret;\n\n  if (! d_check_char (di, 'F'))\n    return NULL;\n  if (d_peek_char (di) == 'Y')\n    {\n      /* Function has C linkage.  We don't print this information.\n\t FIXME: We should print it in verbose mode.  */\n      d_advance (di, 1);\n    }\n  ret = d_bare_function_type (di, 1);\n  ret = d_ref_qualifier (di, ret);\n\n  if (! d_check_char (di, 'E'))\n    return NULL;\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":2739,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5269984":{"score":0.85232294,"function_name":"d_special_name","code":"static struct demangle_component *\nd_special_name (struct d_info *di)\n{\n  di-\u003eexpansion += 20;\n  if (d_check_char (di, 'T'))\n    {\n      switch (d_next_char (di))\n\t{\n\tcase 'V':\n\t  di-\u003eexpansion -= 5;\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_VTABLE,\n\t\t\t      cplus_demangle_type (di), NULL);\n\tcase 'T':\n\t  di-\u003eexpansion -= 10;\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_VTT,\n\t\t\t      cplus_demangle_type (di), NULL);\n\tcase 'I':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO,\n\t\t\t      cplus_demangle_type (di), NULL);\n\tcase 'S':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_NAME,\n\t\t\t      cplus_demangle_type (di), NULL);\n\n\tcase 'h':\n\t  if (! d_call_offset (di, 'h'))\n\t    return NULL;\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_THUNK,\n\t\t\t      d_encoding (di, 0), NULL);\n\n\tcase 'v':\n\t  if (! d_call_offset (di, 'v'))\n\t    return NULL;\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_VIRTUAL_THUNK,\n\t\t\t      d_encoding (di, 0), NULL);\n\n\tcase 'c':\n\t  if (! d_call_offset (di, '\\0'))\n\t    return NULL;\n\t  if (! d_call_offset (di, '\\0'))\n\t    return NULL;\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_COVARIANT_THUNK,\n\t\t\t      d_encoding (di, 0), NULL);\n\n\tcase 'C':\n\t  {\n\t    struct demangle_component *derived_type;\n\t    int offset;\n\t    struct demangle_component *base_type;\n\n\t    derived_type = cplus_demangle_type (di);\n\t    offset = d_number (di);\n\t    if (offset \u003c 0)\n\t      return NULL;\n\t    if (! d_check_char (di, '_'))\n\t      return NULL;\n\t    base_type = cplus_demangle_type (di);\n\t    /* We don't display the offset.  FIXME: We should display\n\t       it in verbose mode.  */\n\t    di-\u003eexpansion += 5;\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE,\n\t\t\t\tbase_type, derived_type);\n\t  }\n\n\tcase 'F':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_TYPEINFO_FN,\n\t\t\t      cplus_demangle_type (di), NULL);\n\tcase 'J':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_JAVA_CLASS,\n\t\t\t      cplus_demangle_type (di), NULL);\n\n\tcase 'H':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_INIT,\n\t\t\t      d_name (di), NULL);\n\n\tcase 'W':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_WRAPPER,\n\t\t\t      d_name (di), NULL);\n\n\tdefault:\n\t  return NULL;\n\t}\n    }\n  else if (d_check_char (di, 'G'))\n    {\n      switch (d_next_char (di))\n\t{\n\tcase 'V':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD, d_name (di), NULL);\n\n\tcase 'R':\n\t  {\n\t    struct demangle_component *name = d_name (di);\n\t    return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, name,\n\t\t\t\td_number_component (di));\n\t  }\n\n\tcase 'A':\n\t  return d_make_comp (di, DEMANGLE_COMPONENT_HIDDEN_ALIAS,\n\t\t\t      d_encoding (di, 0), NULL);\n\n\tcase 'T':\n\t  switch (d_next_char (di))\n\t    {\n\t    case 'n':\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,\n\t\t\t\t  d_encoding (di, 0), NULL);\n\t    default:\n\t      /* ??? The proposal is that other letters (such as 'h') stand\n\t\t for different variants of transaction cloning, such as\n\t\t compiling directly for hardware transaction support.  But\n\t\t they still should all be transactional clones of some sort\n\t\t so go ahead and call them that.  */\n\t    case 't':\n\t      return d_make_comp (di, DEMANGLE_COMPONENT_TRANSACTION_CLONE,\n\t\t\t\t  d_encoding (di, 0), NULL);\n\t    }\n\n\tcase 'r':\n\t  return d_java_resource (di);\n\n\tdefault:\n\t  return NULL;\n\t}\n    }\n  else\n    return NULL;\n}","filepath":"libiberty/cp-demangle.c","line_number":1983,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5271504":{"score":0.8799203,"function_name":"d_expr_primary","code":"static struct demangle_component *\nd_expr_primary (struct d_info *di)\n{\n  struct demangle_component *ret;\n\n  if (! d_check_char (di, 'L'))\n    return NULL;\n  if (d_peek_char (di) == '_'\n      /* Workaround for G++ bug; see comment in write_template_arg.  */\n      || d_peek_char (di) == 'Z')\n    ret = cplus_demangle_mangled_name (di, 0);\n  else\n    {\n      struct demangle_component *type;\n      enum demangle_component_type t;\n      const char *s;\n\n      type = cplus_demangle_type (di);\n      if (type == NULL)\n\treturn NULL;\n\n      /* If we have a type we know how to print, we aren't going to\n\t print the type name itself.  */\n      if (type-\u003etype == DEMANGLE_COMPONENT_BUILTIN_TYPE\n\t  \u0026\u0026 type-\u003eu.s_builtin.type-\u003eprint != D_PRINT_DEFAULT)\n\tdi-\u003eexpansion -= type-\u003eu.s_builtin.type-\u003elen;\n\n      /* Rather than try to interpret the literal value, we just\n\t collect it as a string.  Note that it's possible to have a\n\t floating point literal here.  The ABI specifies that the\n\t format of such literals is machine independent.  That's fine,\n\t but what's not fine is that versions of g++ up to 3.2 with\n\t -fabi-version=1 used upper case letters in the hex constant,\n\t and dumped out gcc's internal representation.  That makes it\n\t hard to tell where the constant ends, and hard to dump the\n\t constant in any readable form anyhow.  We don't attempt to\n\t handle these cases.  */\n\n      t = DEMANGLE_COMPONENT_LITERAL;\n      if (d_peek_char (di) == 'n')\n\t{\n\t  t = DEMANGLE_COMPONENT_LITERAL_NEG;\n\t  d_advance (di, 1);\n\t}\n      s = d_str (di);\n      while (d_peek_char (di) != 'E')\n\t{\n\t  if (d_peek_char (di) == '\\0')\n\t    return NULL;\n\t  d_advance (di, 1);\n\t}\n      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));\n    }\n  if (! d_check_char (di, 'E'))\n    return NULL;\n  return ret;\n}","filepath":"libiberty/cp-demangle.c","line_number":3415,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5271920":{"score":0.83438516,"function_name":"d_print_comp_inner","code":"static void\nd_print_comp_inner (struct d_print_info *dpi, int options,\n\t\t  const struct demangle_component *dc)\n{\n  /* Magic variable to let reference smashing skip over the next modifier\n     without needing to modify *dc.  */\n  const struct demangle_component *mod_inner = NULL;\n\n  /* Variable used to store the current templates while a previously\n     captured scope is used.  */\n  struct d_print_template *saved_templates;\n\n  /* Nonzero if templates have been stored in the above variable.  */\n  int need_template_restore = 0;\n\n  if (dc == NULL)\n    {\n      d_print_error (dpi);\n      return;\n    }\n  if (d_print_saw_error (dpi))\n    return;\n\n  switch (dc-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_NAME:\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc-\u003eu.s_name.s, dc-\u003eu.s_name.len);\n      else\n\td_print_java_identifier (dpi, dc-\u003eu.s_name.s, dc-\u003eu.s_name.len);\n      return;\n\n    case DEMANGLE_COMPONENT_TAGGED_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"[abi:\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    case DEMANGLE_COMPONENT_QUAL_NAME:\n    case DEMANGLE_COMPONENT_LOCAL_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_string (dpi, \"::\");\n      else\n\td_append_char (dpi, '.');\n      {\n\tstruct demangle_component *local_name = d_right (dc);\n\tif (local_name-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t  {\n\t    d_append_string (dpi, \"{default arg#\");\n\t    d_append_num (dpi, local_name-\u003eu.s_unary_num.num + 1);\n\t    d_append_string (dpi, \"}::\");\n\t    local_name = local_name-\u003eu.s_unary_num.sub;\n\t  }\n\td_print_comp (dpi, options, local_name);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct demangle_component *typed_name;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_template dpt;\n\n\t/* Pass the name down to the type so that it can be printed in\n\t   the right place for the type.  We also have to pass down\n\t   any CV-qualifiers, which apply to the this parameter.  */\n\thold_modifiers = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = 0;\n\ti = 0;\n\ttyped_name = d_left (dc);\n\twhile (typed_name != NULL)\n\t  {\n\t    if (i \u003e= sizeof adpm / sizeof adpm[0])\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    adpm[i].next = dpi-\u003emodifiers;\n\t    dpi-\u003emodifiers = \u0026adpm[i];\n\t    adpm[i].mod = typed_name;\n\t    adpm[i].printed = 0;\n\t    adpm[i].templates = dpi-\u003etemplates;\n\t    ++i;\n\n\t    if (typed_name-\u003etype != DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_CONST_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t\u0026\u0026 typed_name-\u003etype != DEMANGLE_COMPONENT_REFERENCE_THIS)\n\t      break;\n\n\t    typed_name = d_left (typed_name);\n\t  }\n\n\tif (typed_name == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* If typed_name is a template, then it applies to the\n\t   function type as well.  */\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_TEMPLATE)\n\t  {\n\t    dpt.next = dpi-\u003etemplates;\n\t    dpi-\u003etemplates = \u0026dpt;\n\t    dpt.template_decl = typed_name;\n\t  }\n\n\t/* If typed_name is a DEMANGLE_COMPONENT_LOCAL_NAME, then\n\t   there may be CV-qualifiers on its right argument which\n\t   really apply here; this happens when parsing a class which\n\t   is local to a function.  */\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_LOCAL_NAME)\n\t  {\n\t    struct demangle_component *local_name;\n\n\t    local_name = d_right (typed_name);\n\t    if (local_name-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t      local_name = local_name-\u003eu.s_unary_num.sub;\n\t    if (local_name == NULL)\n\t      {\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\t    while (local_name-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t\t   || local_name-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t\t   || (local_name-\u003etype\n\t\t       == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))\n\t      {\n\t\tif (i \u003e= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = adpm[i - 1];\n\t\tadpm[i].next = \u0026adpm[i - 1];\n\t\tdpi-\u003emodifiers = \u0026adpm[i];\n\n\t\tadpm[i - 1].mod = local_name;\n\t\tadpm[i - 1].printed = 0;\n\t\tadpm[i - 1].templates = dpi-\u003etemplates;\n\t\t++i;\n\n\t\tlocal_name = d_left (local_name);\n\t      }\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tif (typed_name-\u003etype == DEMANGLE_COMPONENT_TEMPLATE)\n\t  dpi-\u003etemplates = dpt.next;\n\n\t/* If the modifiers didn't get printed by the type, print them\n\t   now.  */\n\twhile (i \u003e 0)\n\t  {\n\t    --i;\n\t    if (! adpm[i].printed)\n\t      {\n\t\td_append_char (dpi, ' ');\n\t\td_print_mod (dpi, options, adpm[i].mod);\n\t      }\n\t  }\n\n\tdpi-\u003emodifiers = hold_modifiers;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE:\n      {\n\tstruct d_print_mod *hold_dpm;\n\tstruct demangle_component *dcl;\n\tconst struct demangle_component *hold_current;\n\n\t/* This template may need to be referenced by a cast operator\n\t   contained in its subtree.  */\n\thold_current = dpi-\u003ecurrent_template;\n\tdpi-\u003ecurrent_template = dc;\n\n\t/* Don't push modifiers into a template definition.  Doing so\n\t   could give the wrong definition for a template argument.\n\t   Instead, treat the template essentially as a name.  */\n\n\thold_dpm = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = NULL;\n\n        dcl = d_left (dc);\n\n        if ((options \u0026 DMGL_JAVA) != 0\n            \u0026\u0026 dcl-\u003etype == DEMANGLE_COMPONENT_NAME\n            \u0026\u0026 dcl-\u003eu.s_name.len == 6\n            \u0026\u0026 strncmp (dcl-\u003eu.s_name.s, \"JArray\", 6) == 0)\n          {\n            /* Special-case Java arrays, so that JArray\u003cTYPE\u003e appears\n               instead as TYPE[].  */\n\n            d_print_comp (dpi, options, d_right (dc));\n            d_append_string (dpi, \"[]\");\n          }\n        else\n          {\n\t    d_print_comp (dpi, options, dcl);\n\t    if (d_last_char (dpi) == '\u003c')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '\u003c');\n\t    d_print_comp (dpi, options, d_right (dc));\n\t    /* Avoid generating two consecutive '\u003e' characters, to avoid\n\t       the C++ syntactic ambiguity.  */\n\t    if (d_last_char (dpi) == '\u003e')\n\t      d_append_char (dpi, ' ');\n\t    d_append_char (dpi, '\u003e');\n          }\n\n\tdpi-\u003emodifiers = hold_dpm;\n\tdpi-\u003ecurrent_template = hold_current;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_TEMPLATE_PARAM:\n      {\n\tstruct d_print_template *hold_dpt;\n\tstruct demangle_component *a = d_lookup_template_argument (dpi, dc);\n\n\tif (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t  a = d_index_template_argument (a, dpi-\u003epack_index);\n\n\tif (a == NULL)\n\t  {\n\t    d_print_error (dpi);\n\t    return;\n\t  }\n\n\t/* While processing this parameter, we need to pop the list of\n\t   templates.  This is because the template parameter may\n\t   itself be a reference to a parameter of an outer\n\t   template.  */\n\n\thold_dpt = dpi-\u003etemplates;\n\tdpi-\u003etemplates = hold_dpt-\u003enext;\n\n\td_print_comp (dpi, options, a);\n\n\tdpi-\u003etemplates = hold_dpt;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_CTOR:\n      d_print_comp (dpi, options, dc-\u003eu.s_ctor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_DTOR:\n      d_append_char (dpi, '~');\n      d_print_comp (dpi, options, dc-\u003eu.s_dtor.name);\n      return;\n\n    case DEMANGLE_COMPONENT_VTABLE:\n      d_append_string (dpi, \"vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VTT:\n      d_append_string (dpi, \"VTT for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE:\n      d_append_string (dpi, \"construction vtable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \"-in-\");\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO:\n      d_append_string (dpi, \"typeinfo for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_NAME:\n      d_append_string (dpi, \"typeinfo name for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TYPEINFO_FN:\n      d_append_string (dpi, \"typeinfo fn for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_THUNK:\n      d_append_string (dpi, \"non-virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_VIRTUAL_THUNK:\n      d_append_string (dpi, \"virtual thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n      d_append_string (dpi, \"covariant return thunk to \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_CLASS:\n      d_append_string (dpi, \"java Class for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_GUARD:\n      d_append_string (dpi, \"guard variable for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_INIT:\n      d_append_string (dpi, \"TLS init function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n      d_append_string (dpi, \"TLS wrapper function for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_REFTEMP:\n      d_append_string (dpi, \"reference temporary #\");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_string (dpi, \" for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n      d_append_string (dpi, \"hidden alias for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n      d_append_string (dpi, \"transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n      d_append_string (dpi, \"non-transaction clone for \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_SUB_STD:\n      d_append_buffer (dpi, dc-\u003eu.s_string.string, dc-\u003eu.s_string.len);\n      return;\n\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_CONST:\n      {\n\tstruct d_print_mod *pdpm;\n\n\t/* When printing arrays, it's possible to have cases where the\n\t   same CV-qualifier gets pushed on the stack multiple times.\n\t   We only need to print it once.  */\n\n\tfor (pdpm = dpi-\u003emodifiers; pdpm != NULL; pdpm = pdpm-\u003enext)\n\t  {\n\t    if (! pdpm-\u003eprinted)\n\t      {\n\t\tif (pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_RESTRICT\n\t\t    \u0026\u0026 pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_VOLATILE\n\t\t    \u0026\u0026 pdpm-\u003emod-\u003etype != DEMANGLE_COMPONENT_CONST)\n\t\t  break;\n\t\tif (pdpm-\u003emod-\u003etype == dc-\u003etype)\n\t\t  {\n\t\t    d_print_comp (dpi, options, d_left (dc));\n\t\t    return;\n\t\t  }\n\t      }\n\t  }\n      }\n      goto modifier;\n\n    case DEMANGLE_COMPONENT_REFERENCE:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      {\n\t/* Handle reference smashing: \u0026 + \u0026\u0026 = \u0026.  */\n\tconst struct demangle_component *sub = d_left (dc);\n\tif (sub-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n\t  {\n\t    struct d_saved_scope *scope = d_get_saved_scope (dpi, sub);\n\t    struct demangle_component *a;\n\n\t    if (scope == NULL)\n\t      {\n\t\t/* This is the first time SUB has been traversed.\n\t\t   We need to capture the current templates so\n\t\t   they can be restored if SUB is reentered as a\n\t\t   substitution.  */\n\t\td_save_scope (dpi, sub);\n\t\tif (d_print_saw_error (dpi))\n\t\t  return;\n\t      }\n\t    else\n\t      {\n\t\tconst struct d_component_stack *dcse;\n\t\tint found_self_or_parent = 0;\n\n\t\t/* This traversal is reentering SUB as a substition.\n\t\t   If we are not beneath SUB or DC in the tree then we\n\t\t   need to restore SUB's template stack temporarily.  */\n\t\tfor (dcse = dpi-\u003ecomponent_stack; dcse != NULL;\n\t\t     dcse = dcse-\u003eparent)\n\t\t  {\n\t\t    if (dcse-\u003edc == sub\n\t\t\t|| (dcse-\u003edc == dc\n\t\t\t    \u0026\u0026 dcse != dpi-\u003ecomponent_stack))\n\t\t      {\n\t\t\tfound_self_or_parent = 1;\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\n\t\tif (!found_self_or_parent)\n\t\t  {\n\t\t    saved_templates = dpi-\u003etemplates;\n\t\t    dpi-\u003etemplates = scope-\u003etemplates;\n\t\t    need_template_restore = 1;\n\t\t  }\n\t      }\n\n\t    a = d_lookup_template_argument (dpi, sub);\n\t    if (a \u0026\u0026 a-\u003etype == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n\t      a = d_index_template_argument (a, dpi-\u003epack_index);\n\n\t    if (a == NULL)\n\t      {\n\t\tif (need_template_restore)\n\t\t  dpi-\u003etemplates = saved_templates;\n\n\t\td_print_error (dpi);\n\t\treturn;\n\t      }\n\n\t    sub = a;\n\t  }\n\n\tif (sub-\u003etype == DEMANGLE_COMPONENT_REFERENCE\n\t    || sub-\u003etype == dc-\u003etype)\n\t  dc = sub;\n\telse if (sub-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE)\n\t  mod_inner = d_left (sub);\n      }\n      /* Fall through.  */\n\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n    case DEMANGLE_COMPONENT_POINTER:\n    case DEMANGLE_COMPONENT_COMPLEX:\n    case DEMANGLE_COMPONENT_IMAGINARY:\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n    modifier:\n      {\n\t/* We keep a list of modifiers on the stack.  */\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = \u0026dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi-\u003etemplates;\n\n\tif (!mod_inner)\n\t  mod_inner = d_left (dc);\n\n\td_print_comp (dpi, options, mod_inner);\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi-\u003emodifiers = dpm.next;\n\n\tif (need_template_restore)\n\t  dpi-\u003etemplates = saved_templates;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_BUILTIN_TYPE:\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_buffer (dpi, dc-\u003eu.s_builtin.type-\u003ename,\n\t\t\t dc-\u003eu.s_builtin.type-\u003elen);\n      else\n\td_append_buffer (dpi, dc-\u003eu.s_builtin.type-\u003ejava_name,\n\t\t\t dc-\u003eu.s_builtin.type-\u003ejava_len);\n      return;\n\n    case DEMANGLE_COMPONENT_VENDOR_TYPE:\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_TYPE:\n      {\n\tif ((options \u0026 DMGL_RET_POSTFIX) != 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi-\u003emodifiers);\n\n\t/* Print return type if present */\n\tif (d_left (dc) != NULL \u0026\u0026 (options \u0026 DMGL_RET_POSTFIX) != 0)\n\t  d_print_comp (dpi, options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\td_left (dc));\n\telse if (d_left (dc) != NULL \u0026\u0026 (options \u0026 DMGL_RET_DROP) == 0)\n\t  {\n\t    struct d_print_mod dpm;\n\n\t    /* We must pass this type down as a modifier in order to\n\t       print it in the right location.  */\n\t    dpm.next = dpi-\u003emodifiers;\n\t    dpi-\u003emodifiers = \u0026dpm;\n\t    dpm.mod = dc;\n\t    dpm.printed = 0;\n\t    dpm.templates = dpi-\u003etemplates;\n\n\t    d_print_comp (dpi, options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t  d_left (dc));\n\n\t    dpi-\u003emodifiers = dpm.next;\n\n\t    if (dpm.printed)\n\t      return;\n\n\t    /* In standard prefix notation, there is a space between the\n\t       return type and the function signature.  */\n\t    if ((options \u0026 DMGL_RET_POSTFIX) == 0)\n\t      d_append_char (dpi, ' ');\n\t  }\n\n\tif ((options \u0026 DMGL_RET_POSTFIX) == 0)\n\t  d_print_function_type (dpi,\n\t\t\t\t options \u0026 ~(DMGL_RET_POSTFIX | DMGL_RET_DROP),\n\t\t\t\t dc, dpi-\u003emodifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_ARRAY_TYPE:\n      {\n\tstruct d_print_mod *hold_modifiers;\n\tstruct d_print_mod adpm[4];\n\tunsigned int i;\n\tstruct d_print_mod *pdpm;\n\n\t/* We must pass this type down as a modifier in order to print\n\t   multi-dimensional arrays correctly.  If the array itself is\n\t   CV-qualified, we act as though the element type were\n\t   CV-qualified.  We do this by copying the modifiers down\n\t   rather than fiddling pointers, so that we don't wind up\n\t   with a d_print_mod higher on the stack pointing into our\n\t   stack frame after we return.  */\n\n\thold_modifiers = dpi-\u003emodifiers;\n\n\tadpm[0].next = hold_modifiers;\n\tdpi-\u003emodifiers = \u0026adpm[0];\n\tadpm[0].mod = dc;\n\tadpm[0].printed = 0;\n\tadpm[0].templates = dpi-\u003etemplates;\n\n\ti = 1;\n\tpdpm = hold_modifiers;\n\twhile (pdpm != NULL\n\t       \u0026\u0026 (pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_RESTRICT\n\t\t   || pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_VOLATILE\n\t\t   || pdpm-\u003emod-\u003etype == DEMANGLE_COMPONENT_CONST))\n\t  {\n\t    if (! pdpm-\u003eprinted)\n\t      {\n\t\tif (i \u003e= sizeof adpm / sizeof adpm[0])\n\t\t  {\n\t\t    d_print_error (dpi);\n\t\t    return;\n\t\t  }\n\n\t\tadpm[i] = *pdpm;\n\t\tadpm[i].next = dpi-\u003emodifiers;\n\t\tdpi-\u003emodifiers = \u0026adpm[i];\n\t\tpdpm-\u003eprinted = 1;\n\t\t++i;\n\t      }\n\n\t    pdpm = pdpm-\u003enext;\n\t  }\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\tdpi-\u003emodifiers = hold_modifiers;\n\n\tif (adpm[0].printed)\n\t  return;\n\n\twhile (i \u003e 1)\n\t  {\n\t    --i;\n\t    d_print_mod (dpi, options, adpm[i].mod);\n\t  }\n\n\td_print_array_type (dpi, options, dc, dpi-\u003emodifiers);\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n      {\n\tstruct d_print_mod dpm;\n\n\tdpm.next = dpi-\u003emodifiers;\n\tdpi-\u003emodifiers = \u0026dpm;\n\tdpm.mod = dc;\n\tdpm.printed = 0;\n\tdpm.templates = dpi-\u003etemplates;\n\n\td_print_comp (dpi, options, d_right (dc));\n\n\t/* If the modifier didn't get printed by the type, print it\n\t   now.  */\n\tif (! dpm.printed)\n\t  d_print_mod (dpi, options, dc);\n\n\tdpi-\u003emodifiers = dpm.next;\n\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_FIXED_TYPE:\n      if (dc-\u003eu.s_fixed.sat)\n\td_append_string (dpi, \"_Sat \");\n      /* Don't print \"int _Accum\".  */\n      if (dc-\u003eu.s_fixed.length-\u003eu.s_builtin.type\n\t  != \u0026cplus_demangle_builtin_types['i'-'a'])\n\t{\n\t  d_print_comp (dpi, options, dc-\u003eu.s_fixed.length);\n\t  d_append_char (dpi, ' ');\n\t}\n      if (dc-\u003eu.s_fixed.accum)\n\td_append_string (dpi, \"_Accum\");\n      else\n\td_append_string (dpi, \"_Fract\");\n      return;\n\n    case DEMANGLE_COMPONENT_ARGLIST:\n    case DEMANGLE_COMPONENT_TEMPLATE_ARGLIST:\n      if (d_left (dc) != NULL)\n\td_print_comp (dpi, options, d_left (dc));\n      if (d_right (dc) != NULL)\n\t{\n\t  size_t len;\n\t  unsigned long int flush_count;\n\t  /* Make sure \", \" isn't flushed by d_append_string, otherwise\n\t     dpi-\u003elen -= 2 wouldn't work.  */\n\t  if (dpi-\u003elen \u003e= sizeof (dpi-\u003ebuf) - 2)\n\t    d_print_flush (dpi);\n\t  d_append_string (dpi, \", \");\n\t  len = dpi-\u003elen;\n\t  flush_count = dpi-\u003eflush_count;\n\t  d_print_comp (dpi, options, d_right (dc));\n\t  /* If that didn't print anything (which can happen with empty\n\t     template argument packs), remove the comma and space.  */\n\t  if (dpi-\u003eflush_count == flush_count \u0026\u0026 dpi-\u003elen == len)\n\t    dpi-\u003elen -= 2;\n\t}\n      return;\n\n    case DEMANGLE_COMPONENT_INITIALIZER_LIST:\n      {\n\tstruct demangle_component *type = d_left (dc);\n\tstruct demangle_component *list = d_right (dc);\n\n\tif (type)\n\t  d_print_comp (dpi, options, type);\n\td_append_char (dpi, '{');\n\td_print_comp (dpi, options, list);\n\td_append_char (dpi, '}');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_OPERATOR:\n      {\n\tconst struct demangle_operator_info *op = dc-\u003eu.s_operator.op;\n\tint len = op-\u003elen;\n\n\td_append_string (dpi, \"operator\");\n\t/* Add a space before new/delete.  */\n\tif (IS_LOWER (op-\u003ename[0]))\n\t  d_append_char (dpi, ' ');\n\t/* Omit a trailing space.  */\n\tif (op-\u003ename[len-1] == ' ')\n\t  --len;\n\td_append_buffer (dpi, op-\u003ename, len);\n\treturn;\n      }\n\n    case DEMANGLE_COMPONENT_EXTENDED_OPERATOR:\n      d_append_string (dpi, \"operator \");\n      d_print_comp (dpi, options, dc-\u003eu.s_extended_operator.name);\n      return;\n\n    case DEMANGLE_COMPONENT_CONVERSION:\n      d_append_string (dpi, \"operator \");\n      d_print_conversion (dpi, options, dc);\n      return;\n\n    case DEMANGLE_COMPONENT_NULLARY:\n      d_print_expr_op (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_UNARY:\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *operand = d_right (dc);\n\tconst char *code = NULL;\n\n\tif (op-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n\t  {\n\t    code = op-\u003eu.s_operator.op-\u003ecode;\n\t    if (!strcmp (code, \"ad\"))\n\t      {\n\t\t/* Don't print the argument list for the address of a\n\t\t   function.  */\n\t\tif (operand-\u003etype == DEMANGLE_COMPONENT_TYPED_NAME\n\t\t    \u0026\u0026 d_left (operand)-\u003etype == DEMANGLE_COMPONENT_QUAL_NAME\n\t\t    \u0026\u0026 d_right (operand)-\u003etype == DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t\t  operand = d_left (operand);\n\t      }\n\t    if (operand-\u003etype == DEMANGLE_COMPONENT_BINARY_ARGS)\n\t      {\n\t\t/* This indicates a suffix operator.  */\n\t\toperand = d_left (operand);\n\t\td_print_subexpr (dpi, options, operand);\n\t\td_print_expr_op (dpi, options, op);\n\t\treturn;\n\t      }\n\t  }\n\n\t/* For sizeof..., just print the pack length.  */\n\tif (code \u0026\u0026 !strcmp (code, \"sZ\"))\n\t  {\n\t    struct demangle_component *a = d_find_pack (dpi, operand);\n\t    int len = d_pack_length (a);\n\t    d_append_num (dpi, len);\n\t    return;\n\t  }\n\telse if (code \u0026\u0026 !strcmp (code, \"sP\"))\n\t  {\n\t    int len = d_args_length (dpi, operand);\n\t    d_append_num (dpi, len);\n\t    return;\n\t  }\n\n\tif (op-\u003etype != DEMANGLE_COMPONENT_CAST)\n\t  d_print_expr_op (dpi, options, op);\n\telse\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_cast (dpi, options, op);\n\t    d_append_char (dpi, ')');\n\t  }\n\tif (code \u0026\u0026 !strcmp (code, \"gs\"))\n\t  /* Avoid parens after '::'.  */\n\t  d_print_comp (dpi, options, operand);\n\telse if (code \u0026\u0026 !strcmp (code, \"st\"))\n\t  /* Always print parens for sizeof (type).  */\n\t  {\n\t    d_append_char (dpi, '(');\n\t    d_print_comp (dpi, options, operand);\n\t    d_append_char (dpi, ')');\n\t  }\n\telse\n\t  d_print_subexpr (dpi, options, operand);\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY:\n      if (d_right (dc)-\u003etype != DEMANGLE_COMPONENT_BINARY_ARGS)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n\n      if (op_is_new_cast (d_left (dc)))\n\t{\n\t  d_print_expr_op (dpi, options, d_left (dc));\n\t  d_append_char (dpi, '\u003c');\n\t  d_print_comp (dpi, options, d_left (d_right (dc)));\n\t  d_append_string (dpi, \"\u003e(\");\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ')');\n\t  return;\n\t}\n\n      if (d_maybe_print_fold_expression (dpi, options, dc))\n\treturn;\n\n      /* We wrap an expression which uses the greater-than operator in\n\t an extra layer of parens so that it does not get confused\n\t with the '\u003e' which ends the template parameters.  */\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_OPERATOR\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003elen == 1\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003ename[0] == '\u003e')\n\td_append_char (dpi, '(');\n\n      if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"cl\") == 0\n          \u0026\u0026 d_left (d_right (dc))-\u003etype == DEMANGLE_COMPONENT_TYPED_NAME)\n\t{\n\t  /* Function call used in an expression should not have printed types\n\t     of the function arguments.  Values of the function arguments still\n\t     get printed below.  */\n\n\t  const struct demangle_component *func = d_left (d_right (dc));\n\n\t  if (d_right (func)-\u003etype != DEMANGLE_COMPONENT_FUNCTION_TYPE)\n\t    d_print_error (dpi);\n\t  d_print_subexpr (dpi, options, d_left (func));\n\t}\n      else\n\td_print_subexpr (dpi, options, d_left (d_right (dc)));\n      if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"ix\") == 0)\n\t{\n\t  d_append_char (dpi, '[');\n\t  d_print_comp (dpi, options, d_right (d_right (dc)));\n\t  d_append_char (dpi, ']');\n\t}\n      else\n\t{\n\t  if (strcmp (d_left (dc)-\u003eu.s_operator.op-\u003ecode, \"cl\") != 0)\n\t    d_print_expr_op (dpi, options, d_left (dc));\n\t  d_print_subexpr (dpi, options, d_right (d_right (dc)));\n\t}\n\n      if (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_OPERATOR\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003elen == 1\n\t  \u0026\u0026 d_left (dc)-\u003eu.s_operator.op-\u003ename[0] == '\u003e')\n\td_append_char (dpi, ')');\n\n      return;\n\n    case DEMANGLE_COMPONENT_BINARY_ARGS:\n      /* We should only see this as part of DEMANGLE_COMPONENT_BINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY:\n      if (d_right (dc)-\u003etype != DEMANGLE_COMPONENT_TRINARY_ARG1\n\t  || d_right (d_right (dc))-\u003etype != DEMANGLE_COMPONENT_TRINARY_ARG2)\n\t{\n\t  d_print_error (dpi);\n\t  return;\n\t}\n      if (d_maybe_print_fold_expression (dpi, options, dc))\n\treturn;\n      {\n\tstruct demangle_component *op = d_left (dc);\n\tstruct demangle_component *first = d_left (d_right (dc));\n\tstruct demangle_component *second = d_left (d_right (d_right (dc)));\n\tstruct demangle_component *third = d_right (d_right (d_right (dc)));\n\n\tif (!strcmp (op-\u003eu.s_operator.op-\u003ecode, \"qu\"))\n\t  {\n\t    d_print_subexpr (dpi, options, first);\n\t    d_print_expr_op (dpi, options, op);\n\t    d_print_subexpr (dpi, options, second);\n\t    d_append_string (dpi, \" : \");\n\t    d_print_subexpr (dpi, options, third);\n\t  }\n\telse\n\t  {\n\t    d_append_string (dpi, \"new \");\n\t    if (d_left (first) != NULL)\n\t      {\n\t\td_print_subexpr (dpi, options, first);\n\t\td_append_char (dpi, ' ');\n\t      }\n\t    d_print_comp (dpi, options, second);\n\t    if (third)\n\t      d_print_subexpr (dpi, options, third);\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_TRINARY_ARG1:\n    case DEMANGLE_COMPONENT_TRINARY_ARG2:\n      /* We should only see these are part of DEMANGLE_COMPONENT_TRINARY.  */\n      d_print_error (dpi);\n      return;\n\n    case DEMANGLE_COMPONENT_LITERAL:\n    case DEMANGLE_COMPONENT_LITERAL_NEG:\n      {\n\tenum d_builtin_type_print tp;\n\n\t/* For some builtin types, produce simpler output.  */\n\ttp = D_PRINT_DEFAULT;\n\tif (d_left (dc)-\u003etype == DEMANGLE_COMPONENT_BUILTIN_TYPE)\n\t  {\n\t    tp = d_left (dc)-\u003eu.s_builtin.type-\u003eprint;\n\t    switch (tp)\n\t      {\n\t      case D_PRINT_INT:\n\t      case D_PRINT_UNSIGNED:\n\t      case D_PRINT_LONG:\n\t      case D_PRINT_UNSIGNED_LONG:\n\t      case D_PRINT_LONG_LONG:\n\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\tif (d_right (dc)-\u003etype == DEMANGLE_COMPONENT_NAME)\n\t\t  {\n\t\t    if (dc-\u003etype == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t\t      d_append_char (dpi, '-');\n\t\t    d_print_comp (dpi, options, d_right (dc));\n\t\t    switch (tp)\n\t\t      {\n\t\t      default:\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED:\n\t\t\td_append_char (dpi, 'u');\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG:\n\t\t\td_append_char (dpi, 'l');\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG:\n\t\t\td_append_string (dpi, \"ul\");\n\t\t\tbreak;\n\t\t      case D_PRINT_LONG_LONG:\n\t\t\td_append_string (dpi, \"ll\");\n\t\t\tbreak;\n\t\t      case D_PRINT_UNSIGNED_LONG_LONG:\n\t\t\td_append_string (dpi, \"ull\");\n\t\t\tbreak;\n\t\t      }\n\t\t    return;\n\t\t  }\n\t\tbreak;\n\n\t      case D_PRINT_BOOL:\n\t\tif (d_right (dc)-\u003etype == DEMANGLE_COMPONENT_NAME\n\t\t    \u0026\u0026 d_right (dc)-\u003eu.s_name.len == 1\n\t\t    \u0026\u0026 dc-\u003etype == DEMANGLE_COMPONENT_LITERAL)\n\t\t  {\n\t\t    switch (d_right (dc)-\u003eu.s_name.s[0])\n\t\t      {\n\t\t      case '0':\n\t\t\td_append_string (dpi, \"false\");\n\t\t\treturn;\n\t\t      case '1':\n\t\t\td_append_string (dpi, \"true\");\n\t\t\treturn;\n\t\t      default:\n\t\t\tbreak;\n\t\t      }\n\t\t  }\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t      }\n\t  }\n\n\td_append_char (dpi, '(');\n\td_print_comp (dpi, options, d_left (dc));\n\td_append_char (dpi, ')');\n\tif (dc-\u003etype == DEMANGLE_COMPONENT_LITERAL_NEG)\n\t  d_append_char (dpi, '-');\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, '[');\n\td_print_comp (dpi, options, d_right (dc));\n\tif (tp == D_PRINT_FLOAT)\n\t  d_append_char (dpi, ']');\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_NUMBER:\n      d_append_num (dpi, dc-\u003eu.s_number.number);\n      return;\n\n    case DEMANGLE_COMPONENT_JAVA_RESOURCE:\n      d_append_string (dpi, \"java resource \");\n      d_print_comp (dpi, options, d_left (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_COMPOUND_NAME:\n      d_print_comp (dpi, options, d_left (dc));\n      d_print_comp (dpi, options, d_right (dc));\n      return;\n\n    case DEMANGLE_COMPONENT_CHARACTER:\n      d_append_char (dpi, dc-\u003eu.s_character.character);\n      return;\n\n    case DEMANGLE_COMPONENT_DECLTYPE:\n      d_append_string (dpi, \"decltype (\");\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_char (dpi, ')');\n      return;\n\n    case DEMANGLE_COMPONENT_PACK_EXPANSION:\n      {\n\tint len;\n\tint i;\n\tstruct demangle_component *a = d_find_pack (dpi, d_left (dc));\n\tif (a == NULL)\n\t  {\n\t    /* d_find_pack won't find anything if the only packs involved\n\t       in this expansion are function parameter packs; in that\n\t       case, just print the pattern and \"...\".  */\n\t    d_print_subexpr (dpi, options, d_left (dc));\n\t    d_append_string (dpi, \"...\");\n\t    return;\n\t  }\n\n\tlen = d_pack_length (a);\n\tdc = d_left (dc);\n\tfor (i = 0; i \u003c len; ++i)\n\t  {\n\t    dpi-\u003epack_index = i;\n\t    d_print_comp (dpi, options, dc);\n\t    if (i \u003c len-1)\n\t      d_append_string (dpi, \", \");\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_FUNCTION_PARAM:\n      {\n\tlong num = dc-\u003eu.s_number.number;\n\tif (num == 0)\n\t  d_append_string (dpi, \"this\");\n\telse\n\t  {\n\t    d_append_string (dpi, \"{parm#\");\n\t    d_append_num (dpi, num);\n\t    d_append_char (dpi, '}');\n\t  }\n      }\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS:\n      d_append_string (dpi, \"global constructors keyed to \");\n      d_print_comp (dpi, options, dc-\u003eu.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS:\n      d_append_string (dpi, \"global destructors keyed to \");\n      d_print_comp (dpi, options, dc-\u003eu.s_binary.left);\n      return;\n\n    case DEMANGLE_COMPONENT_LAMBDA:\n      d_append_string (dpi, \"{lambda(\");\n      d_print_comp (dpi, options, dc-\u003eu.s_unary_num.sub);\n      d_append_string (dpi, \")#\");\n      d_append_num (dpi, dc-\u003eu.s_unary_num.num + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_UNNAMED_TYPE:\n      d_append_string (dpi, \"{unnamed type#\");\n      d_append_num (dpi, dc-\u003eu.s_number.number + 1);\n      d_append_char (dpi, '}');\n      return;\n\n    case DEMANGLE_COMPONENT_CLONE:\n      d_print_comp (dpi, options, d_left (dc));\n      d_append_string (dpi, \" [clone \");\n      d_print_comp (dpi, options, d_right (dc));\n      d_append_char (dpi, ']');\n      return;\n\n    default:\n      d_print_error (dpi);\n      return;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":4489,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5288304":{"score":0.81487525,"function_name":"d_print_comp","code":"static void\nd_print_comp (struct d_print_info *dpi, int options,\n\t      const struct demangle_component *dc)\n{\n  struct d_component_stack self;\n\n  self.dc = dc;\n  self.parent = dpi-\u003ecomponent_stack;\n  dpi-\u003ecomponent_stack = \u0026self;\n\n  d_print_comp_inner (dpi, options, dc);\n\n  dpi-\u003ecomponent_stack = self.parent;\n}","filepath":"libiberty/cp-demangle.c","line_number":5584,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5288400":{"score":0.86801565,"function_name":"d_print_mod","code":"static void\nd_print_mod (struct d_print_info *dpi, int options,\n             const struct demangle_component *mod)\n{\n  switch (mod-\u003etype)\n    {\n    case DEMANGLE_COMPONENT_RESTRICT:\n    case DEMANGLE_COMPONENT_RESTRICT_THIS:\n      d_append_string (dpi, \" restrict\");\n      return;\n    case DEMANGLE_COMPONENT_VOLATILE:\n    case DEMANGLE_COMPONENT_VOLATILE_THIS:\n      d_append_string (dpi, \" volatile\");\n      return;\n    case DEMANGLE_COMPONENT_CONST:\n    case DEMANGLE_COMPONENT_CONST_THIS:\n      d_append_string (dpi, \" const\");\n      return;\n    case DEMANGLE_COMPONENT_TRANSACTION_SAFE:\n      d_append_string (dpi, \" transaction_safe\");\n      return;\n    case DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL:\n      d_append_char (dpi, ' ');\n      d_print_comp (dpi, options, d_right (mod));\n      return;\n    case DEMANGLE_COMPONENT_POINTER:\n      /* There is no pointer symbol in Java.  */\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_char (dpi, '*');\n      return;\n    case DEMANGLE_COMPONENT_REFERENCE_THIS:\n      /* For the ref-qualifier, put a space before the \u0026.  */\n      d_append_char (dpi, ' ');\n    case DEMANGLE_COMPONENT_REFERENCE:\n      d_append_char (dpi, '\u0026');\n      return;\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS:\n      d_append_char (dpi, ' ');\n    case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n      d_append_string (dpi, \"\u0026\u0026\");\n      return;\n    case DEMANGLE_COMPONENT_COMPLEX:\n      d_append_string (dpi, \"complex \");\n      return;\n    case DEMANGLE_COMPONENT_IMAGINARY:\n      d_append_string (dpi, \"imaginary \");\n      return;\n    case DEMANGLE_COMPONENT_PTRMEM_TYPE:\n      if (d_last_char (dpi) != '(')\n\td_append_char (dpi, ' ');\n      d_print_comp (dpi, options, d_left (mod));\n      d_append_string (dpi, \"::*\");\n      return;\n    case DEMANGLE_COMPONENT_TYPED_NAME:\n      d_print_comp (dpi, options, d_left (mod));\n      return;\n    case DEMANGLE_COMPONENT_VECTOR_TYPE:\n      d_append_string (dpi, \" __vector(\");\n      d_print_comp (dpi, options, d_left (mod));\n      d_append_char (dpi, ')');\n      return;\n\n    default:\n      /* Otherwise, we have something that won't go back on the\n\t modifier stack, so we can just print it.  */\n      d_print_comp (dpi, options, mod);\n      return;\n    }\n}","filepath":"libiberty/cp-demangle.c","line_number":5747,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5291184":{"score":0.83598495,"function_name":"d_print_mod_list","code":"static void\nd_print_mod_list (struct d_print_info *dpi, int options,\n                  struct d_print_mod *mods, int suffix)\n{\n  struct d_print_template *hold_dpt;\n\n  if (mods == NULL || d_print_saw_error (dpi))\n    return;\n\n  if (mods-\u003eprinted\n      || (! suffix\n\t  \u0026\u0026 (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t      || mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t      || (mods-\u003emod-\u003etype\n\t\t  == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS))))\n    {\n      d_print_mod_list (dpi, options, mods-\u003enext, suffix);\n      return;\n    }\n\n  mods-\u003eprinted = 1;\n\n  hold_dpt = dpi-\u003etemplates;\n  dpi-\u003etemplates = mods-\u003etemplates;\n\n  if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_FUNCTION_TYPE)\n    {\n      d_print_function_type (dpi, options, mods-\u003emod, mods-\u003enext);\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n  else if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_ARRAY_TYPE)\n    {\n      d_print_array_type (dpi, options, mods-\u003emod, mods-\u003enext);\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n  else if (mods-\u003emod-\u003etype == DEMANGLE_COMPONENT_LOCAL_NAME)\n    {\n      struct d_print_mod *hold_modifiers;\n      struct demangle_component *dc;\n\n      /* When this is on the modifier stack, we have pulled any\n\t qualifiers off the right argument already.  Otherwise, we\n\t print it as usual, but don't let the left argument see any\n\t modifiers.  */\n\n      hold_modifiers = dpi-\u003emodifiers;\n      dpi-\u003emodifiers = NULL;\n      d_print_comp (dpi, options, d_left (mods-\u003emod));\n      dpi-\u003emodifiers = hold_modifiers;\n\n      if ((options \u0026 DMGL_JAVA) == 0)\n\td_append_string (dpi, \"::\");\n      else\n\td_append_char (dpi, '.');\n\n      dc = d_right (mods-\u003emod);\n\n      if (dc-\u003etype == DEMANGLE_COMPONENT_DEFAULT_ARG)\n\t{\n\t  d_append_string (dpi, \"{default arg#\");\n\t  d_append_num (dpi, dc-\u003eu.s_unary_num.num + 1);\n\t  d_append_string (dpi, \"}::\");\n\t  dc = dc-\u003eu.s_unary_num.sub;\n\t}\n\n      while (dc-\u003etype == DEMANGLE_COMPONENT_RESTRICT_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_VOLATILE_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_CONST_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_REFERENCE_THIS\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_TRANSACTION_SAFE\n\t     || dc-\u003etype == DEMANGLE_COMPONENT_RVALUE_REFERENCE_THIS)\n\tdc = d_left (dc);\n\n      d_print_comp (dpi, options, dc);\n\n      dpi-\u003etemplates = hold_dpt;\n      return;\n    }\n\n  d_print_mod (dpi, options, mods-\u003emod);\n\n  dpi-\u003etemplates = hold_dpt;\n\n  d_print_mod_list (dpi, options, mods-\u003enext, suffix);\n}","filepath":"libiberty/cp-demangle.c","line_number":5654,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5292416":{"score":0.83220416,"function_name":"d_print_array_type","code":"static void\nd_print_array_type (struct d_print_info *dpi, int options,\n                    const struct demangle_component *dc,\n                    struct d_print_mod *mods)\n{\n  int need_space;\n\n  need_space = 1;\n  if (mods != NULL)\n    {\n      int need_paren;\n      struct d_print_mod *p;\n\n      need_paren = 0;\n      for (p = mods; p != NULL; p = p-\u003enext)\n\t{\n\t  if (! p-\u003eprinted)\n\t    {\n\t      if (p-\u003emod-\u003etype == DEMANGLE_COMPONENT_ARRAY_TYPE)\n\t\t{\n\t\t  need_space = 0;\n\t\t  break;\n\t\t}\n\t      else\n\t\t{\n\t\t  need_paren = 1;\n\t\t  need_space = 1;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (need_paren)\n\td_append_string (dpi, \" (\");\n\n      d_print_mod_list (dpi, options, mods, 0);\n\n      if (need_paren)\n\td_append_char (dpi, ')');\n    }\n\n  if (need_space)\n    d_append_char (dpi, ' ');\n\n  d_append_char (dpi, '[');\n\n  if (d_left (dc) != NULL)\n    d_print_comp (dpi, options, d_left (dc));\n\n  d_append_char (dpi, ']');\n}","filepath":"libiberty/cp-demangle.c","line_number":5902,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5293248":{"score":0.6469359,"function_name":"d_print_expr_op","code":"static void\nd_print_expr_op (struct d_print_info *dpi, int options,\n                 const struct demangle_component *dc)\n{\n  if (dc-\u003etype == DEMANGLE_COMPONENT_OPERATOR)\n    d_append_buffer (dpi, dc-\u003eu.s_operator.op-\u003ename,\n\t\t     dc-\u003eu.s_operator.op-\u003elen);\n  else\n    d_print_comp (dpi, options, dc);\n}","filepath":"libiberty/cp-demangle.c","line_number":5956,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5293504":{"score":0.8178444,"function_name":"d_print_subexpr","code":"static void\nd_print_subexpr (struct d_print_info *dpi, int options,\n\t\t const struct demangle_component *dc)\n{\n  int simple = 0;\n  if (dc-\u003etype == DEMANGLE_COMPONENT_NAME\n      || dc-\u003etype == DEMANGLE_COMPONENT_QUAL_NAME\n      || dc-\u003etype == DEMANGLE_COMPONENT_INITIALIZER_LIST\n      || dc-\u003etype == DEMANGLE_COMPONENT_FUNCTION_PARAM)\n    simple = 1;\n  if (!simple)\n    d_append_char (dpi, '(');\n  d_print_comp (dpi, options, dc);\n  if (!simple)\n    d_append_char (dpi, ')');\n}","filepath":"libiberty/cp-demangle.c","line_number":4350,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5293888":{"score":0.66130257,"function_name":"d_demangle_callback","code":"static int\nd_demangle_callback (const char *mangled, int options,\n                     demangle_callbackref callback, void *opaque)\n{\n  enum\n    {\n      DCT_TYPE,\n      DCT_MANGLED,\n      DCT_GLOBAL_CTORS,\n      DCT_GLOBAL_DTORS\n    }\n  type;\n  struct d_info di;\n  struct demangle_component *dc;\n  int status;\n\n  if (mangled[0] == '_' \u0026\u0026 mangled[1] == 'Z')\n    type = DCT_MANGLED;\n  else if (strncmp (mangled, \"_GLOBAL_\", 8) == 0\n\t   \u0026\u0026 (mangled[8] == '.' || mangled[8] == '_' || mangled[8] == '$')\n\t   \u0026\u0026 (mangled[9] == 'D' || mangled[9] == 'I')\n\t   \u0026\u0026 mangled[10] == '_')\n    type = mangled[9] == 'I' ? DCT_GLOBAL_CTORS : DCT_GLOBAL_DTORS;\n  else\n    {\n      if ((options \u0026 DMGL_TYPES) == 0)\n\treturn 0;\n      type = DCT_TYPE;\n    }\n\n  cplus_demangle_init_info (mangled, options, strlen (mangled), \u0026di);\n\n  {\n#ifdef CP_DYNAMIC_ARRAYS\n    __extension__ struct demangle_component comps[di.num_comps];\n    __extension__ struct demangle_component *subs[di.num_subs];\n\n    di.comps = comps;\n    di.subs = subs;\n#else\n    di.comps = alloca (di.num_comps * sizeof (*di.comps));\n    di.subs = alloca (di.num_subs * sizeof (*di.subs));\n#endif\n\n    switch (type)\n      {\n      case DCT_TYPE:\n\tdc = cplus_demangle_type (\u0026di);\n\tbreak;\n      case DCT_MANGLED:\n\tdc = cplus_demangle_mangled_name (\u0026di, 1);\n\tbreak;\n      case DCT_GLOBAL_CTORS:\n      case DCT_GLOBAL_DTORS:\n\td_advance (\u0026di, 11);\n\tdc = d_make_comp (\u0026di,\n\t\t\t  (type == DCT_GLOBAL_CTORS\n\t\t\t   ? DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS\n\t\t\t   : DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS),\n\t\t\t  d_make_demangle_mangled_name (\u0026di, d_str (\u0026di)),\n\t\t\t  NULL);\n\td_advance (\u0026di, strlen (d_str (\u0026di)));\n\tbreak;\n      default:\n\tabort (); /* We have listed all the cases.  */\n      }\n\n    /* If DMGL_PARAMS is set, then if we didn't consume the entire\n       mangled string, then we didn't successfully demangle it.  If\n       DMGL_PARAMS is not set, we didn't look at the trailing\n       parameters.  */\n    if (((options \u0026 DMGL_PARAMS) != 0) \u0026\u0026 d_peek_char (\u0026di) != '\\0')\n      dc = NULL;\n\n#ifdef CP_DEMANGLE_DEBUG\n    d_dump (dc, 0);\n#endif\n\n    status = (dc != NULL)\n             ? cplus_demangle_print_callback (options, dc, callback, opaque)\n             : 0;\n  }\n\n  return status;\n}","filepath":"libiberty/cp-demangle.c","line_number":6059,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5295312":{"score":0.8258272,"function_name":"__cxa_demangle","code":"char *\n__cxa_demangle (const char *mangled_name, char *output_buffer,\n                size_t *length, int *status)\n{\n  char *demangled;\n  size_t alc;\n\n  if (mangled_name == NULL)\n    {\n      if (status != NULL)\n\t*status = -3;\n      return NULL;\n    }\n\n  if (output_buffer != NULL \u0026\u0026 length == NULL)\n    {\n      if (status != NULL)\n\t*status = -3;\n      return NULL;\n    }\n\n  demangled = d_demangle (mangled_name, DMGL_PARAMS | DMGL_TYPES, \u0026alc);\n\n  if (demangled == NULL)\n    {\n      if (status != NULL)\n\t{\n\t  if (alc == 1)\n\t    *status = -1;\n\t  else\n\t    *status = -2;\n\t}\n      return NULL;\n    }\n\n  if (output_buffer == NULL)\n    {\n      if (length != NULL)\n\t*length = alc;\n    }\n  else\n    {\n      if (strlen (demangled) \u003c *length)\n\t{\n\t  strcpy (output_buffer, demangled);\n\t  free (demangled);\n\t  demangled = output_buffer;\n\t}\n      else\n\t{\n\t  free (output_buffer);\n\t  *length = alc;\n\t}\n    }\n\n  if (status != NULL)\n    *status = 0;\n\n  return demangled;\n}","filepath":"libiberty/cp-demangle.c","line_number":6203,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5295712":{"score":0.7950106,"function_name":"__gcclibcxx_demangle_callback","code":"int\n__gcclibcxx_demangle_callback (const char *mangled_name,\n                               void (*callback) (const char *, size_t, void *),\n                               void *opaque)\n{\n  int status;\n\n  if (mangled_name == NULL || callback == NULL)\n    return -3;\n\n  status = d_demangle_callback (mangled_name, DMGL_PARAMS | DMGL_TYPES,\n                                callback, opaque);\n  if (status == 0)\n    return -2;\n\n  return 0;\n}","filepath":"libiberty/cp-demangle.c","line_number":6288,"entry_url":"https://ftp.gnu.org/gnu/gdb/","slot_name":"gdb.7.12"},"5309504":{"score":0.68916506,"function_name":"__throw_insufficient_space","code":"void\n  __throw_insufficient_space(const char *__buf, const char *__bufend)\n  {\n    // Include space for trailing NUL.\n    const size_t __len = __bufend - __buf + 1;\n\n    const char __err[] = \"not enough space for format expansion \"\n      \"(Please submit full bug report at http://gcc.gnu.org/bugs.html):\\n    \";\n    const size_t __errlen = sizeof(__err) - 1;\n\n    char *const __e\n      = static_cast\u003cchar*\u003e(__builtin_alloca(__errlen + __len));\n\n    __builtin_memcpy(__e, __err, __errlen);\n    __builtin_memcpy(__e + __errlen, __buf, __len - 1);\n    __e[__errlen + __len - 1] = '\\0';\n    std::__throw_logic_error(__e);\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":48,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-7"},"5309904":{"score":0.8122772,"function_name":"__concat_size_t","code":"int __concat_size_t(char *__buf, size_t __bufsize, size_t __val)\n  {\n    // __int_to_char is explicitly instantiated and available only for\n    // some, but not all, types. See locale-inst.cc.\n#ifdef _GLIBCXX_USE_LONG_LONG\n    unsigned long long __val2 = __val;\n#else\n    unsigned long __val2 = __val;\n#endif\n    // Long enough for decimal representation.\n    int __ilen = 3 * sizeof(__val2);\n    char *__cs = static_cast\u003cchar*\u003e(__builtin_alloca(__ilen));\n    size_t __len = std::__int_to_char(__cs + __ilen, __val2,\n\t\t\t\t      std::__num_base::_S_atoms_out,\n\t\t\t\t      std::ios_base::dec, true);\n    if (__bufsize \u003c __len)\n      return -1;\n\n    __builtin_memcpy(__buf, __cs + __ilen - __len, __len);\n    return __len;\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":72,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-7"},"5310064":{"score":0.898046,"function_name":"__snprintf_lite","code":"int __snprintf_lite(char *__buf, size_t __bufsize, const char *__fmt,\n\t\t      va_list __ap)\n  {\n    char *__d = __buf;\n    const char *__s = __fmt;\n    const char *const __limit = __d + __bufsize - 1;  // Leave space for NUL.\n\n    while (__s[0] != '\\0' \u0026\u0026 __d \u003c __limit)\n      {\n\tif (__s[0] == '%')\n\t  switch (__s[1])\n\t    {\n\t    default:  // Stray '%'. Just print it.\n\t      break;\n\t    case '%':  // '%%'\n\t      __s += 1;\n\t      break;\n\t    case 's':  // '%s'.\n\t      {\n\t\tconst char *__v = va_arg(__ap, const char *);\n\n\t\twhile (__v[0] != '\\0' \u0026\u0026 __d \u003c __limit)\n\t\t  *__d++ = *__v++;\n\n\t\tif (__v[0] != '\\0')\n\t\t  // Not enough space for __fmt expansion.\n\t\t  __throw_insufficient_space(__buf, __d);\n\n\t\t__s += 2;  // Step over %s.\n\t\tcontinue;\n\t      }\n\t      break;\n\t    case 'z':\n\t      if (__s[2] == 'u')  // '%zu' -- expand next size_t arg.\n\t\t{\n\t\t  const int __len = __concat_size_t(__d, __limit - __d,\n\t\t\t\t\t\t    va_arg(__ap, size_t));\n\t\t  if (__len \u003e 0)\n\t\t    __d += __len;\n\t\t  else\n\t\t    // Not enough space for __fmt expansion.\n\t\t    __throw_insufficient_space(__buf, __d);\n\n\t\t  __s += 3;  // Step over %zu\n\t\t  continue;\n\t\t}\n\t      // Stray '%zX'. Just print it.\n\t      break;\n\t    }\n\t*__d++ = *__s++;\n      }\n\n    if (__s[0] != '\\0')\n      // Not enough space for __fmt expansion.\n      __throw_insufficient_space(__buf, __d);\n\n    *__d = '\\0';\n    return __d - __buf;\n  }","filepath":"libstdc++-v3/src/c++11/snprintf_lite.cc","line_number":101,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-7"},"5332496":{"score":0.7635335,"function_name":"ios_base::_M_grow_words","code":"ios_base::_Words\u0026\n  ios_base::_M_grow_words(int __ix, bool __iword)\n  {\n    // Precondition: _M_word_size \u003c= __ix\n    int __newsize = _S_local_word_size;\n    _Words* __words = _M_local_word;\n    if (__ix \u003e _S_local_word_size - 1)\n      {\n\tif (__ix \u003c numeric_limits\u003cint\u003e::max())\n\t  {\n\t    __newsize = __ix + 1;\n\t    /* We still need to catch bad_alloc even though we use\n\t       a nothrow new, because the new-expression can throw\n\t       a bad_array_new_length.  */\n\t    __try\n\t      { __words = new (std::nothrow) _Words[__newsize]; }\n\t    __catch(const std::bad_alloc\u0026)\n\t      { __words = nullptr; }\n\t    if (!__words)\n\t      {\n\t\t_M_streambuf_state |= badbit;\n\t\tif (_M_streambuf_state \u0026 _M_exception)\n\t\t  __throw_ios_failure(__N(\"ios_base::_M_grow_words \"\n\t\t\t\t\t  \"allocation failed\"));\n\t\tif (__iword)\n\t\t  _M_word_zero._M_iword = 0;\n\t\telse\n\t\t  _M_word_zero._M_pword = 0;\n\t\treturn _M_word_zero;\n\t      }\n\t    for (int __i = 0; __i \u003c _M_word_size; __i++)\n\t      __words[__i] = _M_word[__i];\n\t    if (_M_word \u0026\u0026 _M_word != _M_local_word)\n\t      {\n\t\tdelete [] _M_word;\n\t\t_M_word = 0;\n\t      }\n\t  }\n\telse\n\t  {\n\t    _M_streambuf_state |= badbit;\n\t    if (_M_streambuf_state \u0026 _M_exception)\n\t      __throw_ios_failure(__N(\"ios_base::_M_grow_words is not valid\"));\n\t    if (__iword)\n\t      _M_word_zero._M_iword = 0;\n\t    else\n\t      _M_word_zero._M_pword = 0;\n\t    return _M_word_zero;\n\t  }\n      }","filepath":"libstdc++-v3/src/c++11/ios.cc","line_number":129,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5332944":{"score":0.76799023,"function_name":"ios_base::_M_call_callbacks","code":"void\n  ios_base::_M_call_callbacks(event __e) throw()\n  {\n    _Callback_list* __p = _M_callbacks;\n    while (__p)\n      {\n\t__try\n\t  { (*__p-\u003e_M_fn) (__e, *this, __p-\u003e_M_index); }\n\t__catch(...)\n\t  { }\n\t__p = __p-\u003e_M_next;\n      }","filepath":"libstdc++-v3/src/c++11/ios.cc","line_number":184,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5333136":{"score":0.6191336,"function_name":"ios_base::~ios_base","code":"ios_base::~ios_base()\n  {\n    _M_call_callbacks(erase_event);\n    _M_dispose_callbacks();\n    if (_M_word != _M_local_word)\n      {\n\tdelete [] _M_word;\n\t_M_word = 0;\n      }\n  }","filepath":"libstdc++-v3/src/c++11/ios.cc","line_number":103,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5333264":{"score":0.7430629,"function_name":"ios_base::_M_move","code":"void\n  ios_base::_M_move(ios_base\u0026 __rhs) noexcept\n  {\n    _M_precision = __rhs._M_precision;\n    _M_width = __rhs._M_width;\n    _M_flags = __rhs._M_flags;\n    _M_exception = __rhs._M_exception;\n    _M_streambuf_state = __rhs._M_streambuf_state;\n    _M_callbacks = std::__exchange(__rhs._M_callbacks, nullptr);\n    if (_M_word != _M_local_word)\n       delete[] _M_word;\n    if (__rhs._M_word == __rhs._M_local_word)\n     {\n       _M_word = _M_local_word;\n       _M_word_size = _S_local_word_size;\n       for (int __i = 0; __i \u003c _S_local_word_size; __i++)\n\t _M_word[__i] = std::__exchange(__rhs._M_word[__i], {});\n     }\n    else\n     {\n       _M_word = std::__exchange(__rhs._M_word, __rhs._M_local_word);\n       _M_word_size\n\t = std::__exchange(__rhs._M_word_size, _S_local_word_size);\n     }\n    _M_ios_locale = __rhs._M_ios_locale;\n  }","filepath":"libstdc++-v3/src/c++11/ios.cc","line_number":211,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5333520":{"score":0.83533764,"function_name":"ios_base::_M_swap","code":"void\n  ios_base::_M_swap(ios_base\u0026 __rhs) noexcept\n  {\n    std::swap(_M_precision, __rhs._M_precision);\n    std::swap(_M_width, __rhs._M_width);\n    std::swap(_M_flags, __rhs._M_flags);\n    std::swap(_M_exception, __rhs._M_exception);\n    std::swap(_M_streambuf_state, __rhs._M_streambuf_state);\n    std::swap(_M_callbacks, __rhs._M_callbacks);\n    const bool __lhs_local = _M_word == _M_local_word;\n    const bool __rhs_local = __rhs._M_word == __rhs._M_local_word;\n    if (__lhs_local \u0026\u0026 __rhs_local)\n     std::swap(_M_local_word, __rhs._M_local_word); // array swap\n    else\n     {\n       if (!__lhs_local \u0026\u0026 !__rhs_local)\n\t std::swap(_M_word, __rhs._M_word);\n       else\n\t {\n\t   ios_base* __local;\n\t   ios_base* __allocated;\n\t   if (__lhs_local)\n\t     {\n\t       __local = this;\n\t       __allocated = \u0026__rhs;\n\t     }\n\t   else\n\t     {\n\t       __local = \u0026__rhs;\n\t       __allocated= this;\n\t     }\n\t   for (int __i = 0; __i \u003c _S_local_word_size; __i++)\n\t     __allocated-\u003e_M_local_word[__i] = __local-\u003e_M_local_word[__i];\n\t   __local-\u003e_M_word = __allocated-\u003e_M_word;\n\t   __allocated-\u003e_M_word = __allocated-\u003e_M_local_word;\n\t }\n       std::swap(_M_word_size, __rhs._M_word_size);\n     }\n    std::swap(_M_ios_locale, __rhs._M_ios_locale);\n  }","filepath":"libstdc++-v3/src/c++11/ios.cc","line_number":238,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-8"},"5340288":{"score":0.8080201,"function_name":"__vmi_class_type_info::\n__do_find_public_src","code":"__class_type_info::__sub_kind __vmi_class_type_info::\n__do_find_public_src (ptrdiff_t src2dst,\n                      const void *obj_ptr,\n                      const __class_type_info *src_type,\n                      const void *src_ptr) const\n{\n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    return __contained_public;\n  \n  for (std::size_t i = __base_count; i--;)\n    {\n      if (!__base_info[i].__is_public_p ())\n        continue; // Not public, can't be here.\n      \n      const void *base = obj_ptr;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      \n      if (is_virtual)\n        {\n          if (src2dst == -3)\n            continue; // Not a virtual base, so can't be here.\n        }\n      base = convert_to_base (base, is_virtual, offset);\n      \n      __sub_kind base_kind = __base_info[i].__base_type-\u003e__do_find_public_src\n                              (src2dst, base, src_type, src_ptr);\n      if (contained_p (base_kind))\n        {\n          if (is_virtual)\n            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n          return base_kind;\n        }\n    }\n  \n  return __not_contained;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":32,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-12"},"5340544":{"score":0.8700894,"function_name":"__vmi_class_type_info::\n__do_dyncast","code":"bool __vmi_class_type_info::\n__do_dyncast (ptrdiff_t src2dst,\n              __sub_kind access_path,\n              const __class_type_info *dst_type,\n              const void *obj_ptr,\n              const __class_type_info *src_type,\n              const void *src_ptr,\n              __dyncast_result \u0026__restrict result) const\n{\n  if (result.whole_details \u0026 __flags_unknown_mask)\n    result.whole_details = __flags;\n  \n  if (obj_ptr == src_ptr \u0026\u0026 *this == *src_type)\n    {\n      // The src object we started from. Indicate how we are accessible from\n      // the most derived object.\n      result.whole2src = access_path;\n      return false;\n    }\n  if (*this == *dst_type)\n    {\n      result.dst_ptr = obj_ptr;\n      result.whole2dst = access_path;\n      if (src2dst \u003e= 0)\n        result.dst2src = adjust_pointer \u003cvoid\u003e (obj_ptr, src2dst) == src_ptr\n              ? __contained_public : __not_contained;\n      else if (src2dst == -2)\n        result.dst2src = __not_contained;\n      return false;\n    }\n\n  // If src_type is a unique non-virtual base of dst_type, we have a good\n  // guess at the address we want, so in the first pass try skipping any\n  // bases which don't contain that address.\n  const void *dst_cand = NULL;\n  if (src2dst \u003e= 0)\n    dst_cand = adjust_pointer\u003cvoid\u003e(src_ptr, -src2dst);\n  bool first_pass = true;\n  bool skipped = false;\n\n  bool result_ambig = false;\n again:\n  for (std::size_t i = __base_count; i--;)\n    {\n      __dyncast_result result2 (result.whole_details);\n      void const *base = obj_ptr;\n      __sub_kind base_access = access_path;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      \n      if (is_virtual)\n        base_access = __sub_kind (base_access | __contained_virtual_mask);\n      base = convert_to_base (base, is_virtual, offset);\n\n      if (dst_cand)\n\t{\n\t  bool skip_on_first_pass = base \u003e dst_cand;\n\t  if (skip_on_first_pass == first_pass)\n\t    {\n\t      // We aren't interested in this base on this pass: either\n\t      // we're on the first pass and this base doesn't contain the\n\t      // likely address, or we're on the second pass and we checked\n\t      // this base on the first pass.\n\t      skipped = true;\n\t      continue;\n\t    }\n\t}\n\n      if (!__base_info[i].__is_public_p ())\n        {\n          if (src2dst == -2 \u0026\u0026\n              !(result.whole_details\n                \u0026 (__non_diamond_repeat_mask | __diamond_shaped_mask)))\n            // The hierarchy has no duplicate bases (which might ambiguate\n            // things) and where we started is not a public base of what we\n            // want (so it cannot be a downcast). There is nothing of interest\n            // hiding in a non-public base.\n            continue;\n          base_access = __sub_kind (base_access \u0026 ~__contained_public_mask);\n        }\n      \n      bool result2_ambig\n          = __base_info[i].__base_type-\u003e__do_dyncast (src2dst, base_access,\n                                             dst_type, base,\n                                             src_type, src_ptr, result2);\n      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n      if (result2.dst2src == __contained_public\n          || result2.dst2src == __contained_ambig)\n        {\n          result.dst_ptr = result2.dst_ptr;\n          result.whole2dst = result2.whole2dst;\n          result.dst2src = result2.dst2src;\n          // Found a downcast which can't be bettered or an ambiguous downcast\n          // which can't be disambiguated\n          return result2_ambig;\n        }\n      \n      if (!result_ambig \u0026\u0026 !result.dst_ptr)\n        {\n          // Not found anything yet.\n          result.dst_ptr = result2.dst_ptr;\n          result.whole2dst = result2.whole2dst;\n          result_ambig = result2_ambig;\n          if (result.dst_ptr \u0026\u0026 result.whole2src != __unknown\n              \u0026\u0026 !(__flags \u0026 __non_diamond_repeat_mask))\n            // Found dst and src and we don't have repeated bases.\n            return result_ambig;\n        }\n      else if (result.dst_ptr \u0026\u0026 result.dst_ptr == result2.dst_ptr)\n        {\n          // Found at same address, must be via virtual.  Pick the most\n          // accessible path.\n          result.whole2dst =\n              __sub_kind (result.whole2dst | result2.whole2dst);\n        }\n      else if ((result.dst_ptr != 0 \u0026\u0026 result2.dst_ptr != 0)\n\t       || (result.dst_ptr != 0 \u0026\u0026 result2_ambig)\n\t       || (result2.dst_ptr != 0 \u0026\u0026 result_ambig))\n        {\n          // Found two different DST_TYPE bases, or a valid one and a set of\n          // ambiguous ones, must disambiguate. See whether SRC_PTR is\n          // contained publicly within one of the non-ambiguous choices. If it\n          // is in only one, then that's the choice. If it is in both, then\n          // we're ambiguous and fail. If it is in neither, we're ambiguous,\n          // but don't yet fail as we might later find a third base which does\n          // contain SRC_PTR.\n        \n          __sub_kind new_sub_kind = result2.dst2src;\n          __sub_kind old_sub_kind = result.dst2src;\n          \n          if (contained_p (result.whole2src)\n              \u0026\u0026 (!virtual_p (result.whole2src)\n                  || !(result.whole_details \u0026 __diamond_shaped_mask)))\n            {\n              // We already found SRC_PTR as a base of most derived, and\n              // either it was non-virtual, or the whole hierarchy is\n              // not-diamond shaped. Therefore if it is in either choice, it\n              // can only be in one of them, and we will already know.\n              if (old_sub_kind == __unknown)\n                old_sub_kind = __not_contained;\n              if (new_sub_kind == __unknown)\n                new_sub_kind = __not_contained;\n            }\n          else\n            {\n              if (old_sub_kind \u003e= __not_contained)\n                ;// already calculated\n              else if (contained_p (new_sub_kind)\n                       \u0026\u0026 (!virtual_p (new_sub_kind)\n                           || !(__flags \u0026 __diamond_shaped_mask)))\n                // Already found inside the other choice, and it was\n                // non-virtual or we are not diamond shaped.\n                old_sub_kind = __not_contained;\n              else\n                old_sub_kind = dst_type-\u003e__find_public_src\n                                (src2dst, result.dst_ptr, src_type, src_ptr);\n          \n              if (new_sub_kind \u003e= __not_contained)\n                ;// already calculated\n              else if (contained_p (old_sub_kind)\n                       \u0026\u0026 (!virtual_p (old_sub_kind)\n                           || !(__flags \u0026 __diamond_shaped_mask)))\n                // Already found inside the other choice, and it was\n                // non-virtual or we are not diamond shaped.\n                new_sub_kind = __not_contained;\n              else\n                new_sub_kind = dst_type-\u003e__find_public_src\n                                (src2dst, result2.dst_ptr, src_type, src_ptr);\n            }\n          \n          // Neither sub_kind can be contained_ambig -- we bail out early\n          // when we find those.\n          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n            {\n              // Only on one choice, not ambiguous.\n              if (contained_p (new_sub_kind))\n                {\n                  // Only in new.\n                  result.dst_ptr = result2.dst_ptr;\n                  result.whole2dst = result2.whole2dst;\n                  result_ambig = false;\n                  old_sub_kind = new_sub_kind;\n                }\n              result.dst2src = old_sub_kind;\n              if (public_p (result.dst2src))\n                return false; // Can't be an ambiguating downcast for later discovery.\n              if (!virtual_p (result.dst2src))\n                return false; // Found non-virtually can't be bettered\n            }\n          else if (contained_p (__sub_kind (new_sub_kind \u0026 old_sub_kind)))\n            {\n              // In both.\n              result.dst_ptr = NULL;\n              result.dst2src = __contained_ambig;\n              return true;  // Fail.\n            }\n          else\n            {\n              // In neither publicly, ambiguous for the moment, but keep\n              // looking. It is possible that it was private in one or\n              // both and therefore we should fail, but that's just tough.\n              result.dst_ptr = NULL;\n              result.dst2src = __not_contained;\n              result_ambig = true;\n            }\n        }\n      \n      if (result.whole2src == __contained_private)\n        // We found SRC_PTR as a private non-virtual base, therefore all\n        // cross casts will fail. We have already found a down cast, if\n        // there is one.\n        return result_ambig;\n    }\n\n  if (skipped \u0026\u0026 first_pass)\n    {\n      // We didn't find dst where we expected it, so let's go back and try\n      // the bases we skipped (if any).\n      first_pass = false;\n      goto again;\n    }\n\n  return result_ambig;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":79,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-12"},"5342336":{"score":0.7970395,"function_name":"__vmi_class_type_info::\n__do_upcast","code":"bool __vmi_class_type_info::\n__do_upcast (const __class_type_info *dst, const void *obj_ptr,\n             __upcast_result \u0026__restrict result) const\n{\n  if (__class_type_info::__do_upcast (dst, obj_ptr, result))\n    return true;\n  \n  int src_details = result.src_details;\n  if (src_details \u0026 __flags_unknown_mask)\n    src_details = __flags;\n  \n  for (std::size_t i = __base_count; i--;)\n    {\n      __upcast_result result2 (src_details);\n      const void *base = obj_ptr;\n      ptrdiff_t offset = __base_info[i].__offset ();\n      bool is_virtual = __base_info[i].__is_virtual_p ();\n      bool is_public = __base_info[i].__is_public_p ();\n      \n      if (!is_public \u0026\u0026 !(src_details \u0026 __non_diamond_repeat_mask))\n        // original cannot have an ambiguous base, so skip private bases\n        continue;\n\n      if (base)\n        base = convert_to_base (base, is_virtual, offset);\n      \n      if (__base_info[i].__base_type-\u003e__do_upcast (dst, base, result2))\n        {\n          if (result2.base_type == nonvirtual_base_type \u0026\u0026 is_virtual)\n            result2.base_type = __base_info[i].__base_type;\n          if (contained_p (result2.part2dst) \u0026\u0026 !is_public)\n            result2.part2dst = __sub_kind (result2.part2dst \u0026 ~__contained_public_mask);\n          \n          if (!result.base_type)\n            {\n              result = result2;\n              if (!contained_p (result.part2dst))\n                return true; // found ambiguously\n              \n              if (result.part2dst \u0026 __contained_public_mask)\n                {\n                  if (!(__flags \u0026 __non_diamond_repeat_mask))\n                    return true;  // cannot have an ambiguous other base\n                }\n              else\n                {\n                  if (!virtual_p (result.part2dst))\n                    return true; // cannot have another path\n                  if (!(__flags \u0026 __diamond_shaped_mask))\n                    return true; // cannot have a more accessible path\n                }\n            }\n          else if (result.dst_ptr != result2.dst_ptr)\n            {\n              // Found an ambiguity.\n\t      result.dst_ptr = NULL;\n\t      result.part2dst = __contained_ambig;\n\t      return true;\n            }\n          else if (result.dst_ptr)\n            {\n              // Ok, found real object via a virtual path.\n              result.part2dst\n                  = __sub_kind (result.part2dst | result2.part2dst);\n            }\n          else\n            {\n              // Dealing with a null pointer, need to check vbase\n              // containing each of the two choices.\n              if (result2.base_type == nonvirtual_base_type\n                  || result.base_type == nonvirtual_base_type\n                  || !(*result2.base_type == *result.base_type))\n                {\n                  // Already ambiguous, not virtual or via different virtuals.\n                  // Cannot match.\n                  result.part2dst = __contained_ambig;\n                  return true;\n                }\n              result.part2dst\n                  = __sub_kind (result.part2dst | result2.part2dst);\n            }\n        }\n    }\n  return result.part2dst != __unknown;\n}","filepath":"libstdc++-v3/libsupc++/vmi_class_type_info.cc","line_number":304,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-12"},"5344112":{"score":0.8583002,"function_name":"__convert_to_v","code":"void\n    __convert_to_v(const char* __s, float\u0026 __v, ios_base::iostate\u0026 __err, \n\t\t   const __c_locale\u0026 __cloc) throw()\n    {\n      char* __sanity;\n      __v = __strtof_l(__s, \u0026__sanity, __cloc);\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 23. Num_get overflow result.\n      if (__sanity == __s || *__sanity != '\\0')\n\t{\n\t  __v = 0.0f;\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == numeric_limits\u003cfloat\u003e::infinity())\n\t{\n\t  __v = numeric_limits\u003cfloat\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == -numeric_limits\u003cfloat\u003e::infinity())\n\t{\n\t  __v = -numeric_limits\u003cfloat\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":41,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5344288":{"score":0.86049455,"function_name":"__convert_to_v","code":"void\n    __convert_to_v(const char* __s, double\u0026 __v, ios_base::iostate\u0026 __err, \n\t\t   const __c_locale\u0026 __cloc) throw()\n    {\n      char* __sanity;\n      __v = __strtod_l(__s, \u0026__sanity, __cloc);\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 23. Num_get overflow result.\n      if (__sanity == __s || *__sanity != '\\0')\n\t{\n\t  __v = 0.0;\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == numeric_limits\u003cdouble\u003e::infinity())\n\t{\n\t  __v = numeric_limits\u003cdouble\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n      else if (__v == -numeric_limits\u003cdouble\u003e::infinity())\n\t{\n\t  __v = -numeric_limits\u003cdouble\u003e::max();\n\t  __err = ios_base::failbit;\n\t}\n    }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":68,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5344640":{"score":0.8240738,"function_name":"locale::facet::_S_create_c_locale","code":"void\n  locale::facet::_S_create_c_locale(__c_locale\u0026 __cloc, const char* __s, \n\t\t\t\t    __c_locale __old)\n  {\n    __cloc = __newlocale(1 \u003c\u003c LC_ALL, __s, __old);\n    if (!__cloc)\n      {\n\t// This named locale is not supported by the underlying OS.\n\t__throw_runtime_error(__N(\"locale::facet::_S_create_c_locale \"\n\t\t\t\t  \"name not valid\"));\n      }\n  }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":127,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5344752":{"score":0.8080749,"function_name":"locale::facet::_S_lc_ctype_c_locale","code":"__c_locale\n  locale::facet::_S_lc_ctype_c_locale(__c_locale __cloc, const char* __s)\n  {\n    __c_locale __dup = __duplocale(__cloc);\n    if (__dup == __c_locale(0))\n      __throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n\t\t\t\t\"duplocale error\"));\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __changed = __newlocale(LC_CTYPE_MASK, __s, __dup);\n#else\n    __c_locale __changed = __newlocale(1 \u003c\u003c LC_CTYPE, __s, __dup);\n#endif\n    if (__changed == __c_locale(0))\n      {\n\t__freelocale(__dup);\n\t__throw_runtime_error(__N(\"locale::facet::_S_lc_ctype_c_locale \"\n\t\t\t\t  \"newlocale error\"));\n      }\n    return __changed;\n  }","filepath":"libstdc++-v3/config/locale/gnu/c_locale.cc","line_number":151,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.5.0"},"5347776":{"score":0.8066323,"function_name":"locale::name","code":"string\n  locale::name() const\n  {\n    string __ret;\n    if (!_M_impl-\u003e_M_names[0])\n      __ret = '*';\n    else if (_M_impl-\u003e_M_check_same_name())\n      __ret = _M_impl-\u003e_M_names[0];\n    else\n      {\n\t__ret.reserve(128);\n\t__ret += _S_categories[0];\n\t__ret += '=';\n\t__ret += _M_impl-\u003e_M_names[0]; \n\tfor (size_t __i = 1; __i \u003c _S_categories_size; ++__i)\n\t  {\n\t    __ret += ';';\n\t    __ret += _S_categories[__i];\n\t    __ret += '=';\n\t    __ret += _M_impl-\u003e_M_names[__i];\n\t  }\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":120,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5348944":{"score":0.85135543,"function_name":"locale::_S_normalize_category","code":"locale::category\n  locale::_S_normalize_category(category __cat) \n  {\n    int __ret = 0;\n    if (__cat == none || ((__cat \u0026 all) \u0026\u0026 !(__cat \u0026 ~all)))\n      __ret = __cat;\n    else\n      {\n\t// NB: May be a C-style \"LC_ALL\" category; convert.\n\tswitch (__cat)\n\t  {\n\t  case LC_COLLATE:  \n\t    __ret = collate; \n\t    break;\n\t  case LC_CTYPE:    \n\t    __ret = ctype;\n\t    break;\n\t  case LC_MONETARY: \n\t    __ret = monetary;\n\t    break;\n\t  case LC_NUMERIC:  \n\t    __ret = numeric;\n\t    break;\n\t  case LC_TIME:     \n\t    __ret = time; \n\t    break;\n#ifdef _GLIBCXX_HAVE_LC_MESSAGES\n\t  case LC_MESSAGES: \n\t    __ret = messages;\n\t    break;\n#endif\t\n\t  case LC_ALL:      \n\t    __ret = all;\n\t    break;\n\t  default:\n\t    __throw_runtime_error(__N(\"locale::_S_normalize_category \"\n\t\t\t\t  \"category not found\"));\n\t  }\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":145,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5349216":{"score":0.8586236,"function_name":"locale::_Impl::\n  ~_Impl","code":"locale::_Impl::\n  ~_Impl() throw()\n  {\n    if (_M_facets)\n      for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\tif (_M_facets[__i])\n\t  _M_facets[__i]-\u003e_M_remove_reference();\n    delete [] _M_facets;\n\n    if (_M_caches)\n      for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\tif (_M_caches[__i])\n\t  _M_caches[__i]-\u003e_M_remove_reference(); \n    delete [] _M_caches;\n\n    if (_M_names)\n      for (size_t __i = 0; __i \u003c _S_categories_size; ++__i)\n\tdelete [] _M_names[__i];  \n    delete [] _M_names;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":226,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5349584":{"score":0.670389,"function_name":"locale::operator=","code":"const locale\u0026\n  locale::operator=(const locale\u0026 __other) throw()\n  {\n    __other._M_impl-\u003e_M_add_reference();\n    _M_impl-\u003e_M_remove_reference();\n    _M_impl = __other._M_impl;\n    return *this;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":111,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5349776":{"score":0.7379025,"function_name":"locale::_Impl::\n  _Impl","code":"locale::_Impl::\n  _Impl(const _Impl\u0026 __imp, size_t __refs)\n  : _M_refcount(__refs), _M_facets(0), _M_facets_size(__imp._M_facets_size),\n  _M_caches(0), _M_names(0)\n  {\n    try\n      {\n\t_M_facets = new const facet*[_M_facets_size];\n\tfor (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\t  {\n\t    _M_facets[__i] = __imp._M_facets[__i];\n\t    if (_M_facets[__i])\n\t      _M_facets[__i]-\u003e_M_add_reference();\n\t  }\n\t_M_caches = new const facet*[_M_facets_size];\n\tfor (size_t __j = 0; __j \u003c _M_facets_size; ++__j)\n\t  {\n\t    _M_caches[__j] = __imp._M_caches[__j];\n\t    if (_M_caches[__j])\n\t      _M_caches[__j]-\u003e_M_add_reference(); \t\n\t  }\n\t_M_names = new char*[_S_categories_size];\n\tfor (size_t __k = 0; __k \u003c _S_categories_size; ++__k)\n\t  _M_names[__k] = 0;\n\n\t// Name the categories.\n\tfor (size_t __l = 0; (__l \u003c _S_categories_size\n\t\t\t      \u0026\u0026 __imp._M_names[__l]); ++__l)\n\t  {\n\t    const size_t __len = std::strlen(__imp._M_names[__l]) + 1;\n\t    _M_names[__l] = new char[__len];\n\t    std::memcpy(_M_names[__l], __imp._M_names[__l], __len);\n\t  }\n      }\n    catch(...)\n      {\n\tthis-\u003e~_Impl();\n\t__throw_exception_again;\n      }\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":248,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5350272":{"score":0.7368817,"function_name":"locale::id::_M_id","code":"size_t\n  locale::id::_M_id() const\n  {\n    if (!_M_index)\n      {\n\t// XXX GLIBCXX_ABI Deprecated\n#ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n\tlocale::id *f = 0;\n# define _GLIBCXX_SYNC_ID(facet, mangled) \\\n\tif (this == \u0026::mangled)\t\t\t\t\\\n\t  f = \u0026facet::id\n\t_GLIBCXX_SYNC_ID (num_get\u003cchar\u003e, _ZNSt7num_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2idE);\n\t_GLIBCXX_SYNC_ID (num_put\u003cchar\u003e, _ZNSt7num_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE);\n\t_GLIBCXX_SYNC_ID (money_get\u003cchar\u003e, _ZNSt9money_getIcSt19istreambuf_iteratorIcSt11char_traitsIcEEE2idE);\n\t_GLIBCXX_SYNC_ID (money_put\u003cchar\u003e, _ZNSt9money_putIcSt19ostreambuf_iteratorIcSt11char_traitsIcEEE2idE);\n# ifdef _GLIBCXX_USE_WCHAR_T\n\t_GLIBCXX_SYNC_ID (num_get\u003cwchar_t\u003e, _ZNSt7num_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE);\n\t_GLIBCXX_SYNC_ID (num_put\u003cwchar_t\u003e, _ZNSt7num_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE);\n\t_GLIBCXX_SYNC_ID (money_get\u003cwchar_t\u003e, _ZNSt9money_getIwSt19istreambuf_iteratorIwSt11char_traitsIwEEE2idE);\n\t_GLIBCXX_SYNC_ID (money_put\u003cwchar_t\u003e, _ZNSt9money_putIwSt19ostreambuf_iteratorIwSt11char_traitsIwEEE2idE);\n# endif\n\tif (f)\n\t  _M_index = 1 + f-\u003e_M_id();\n\telse\n#endif\n\t  _M_index = 1 + __gnu_cxx::__exchange_and_add_dispatch(\u0026_S_refcount,\n\t\t\t\t\t\t\t\t1);\n      }\n    return _M_index - 1;\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":409,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5350336":{"score":0.8242285,"function_name":"locale::_Impl::\n  _M_install_facet","code":"void\n  locale::_Impl::\n  _M_install_facet(const locale::id* __idp, const facet* __fp)\n  {\n    if (__fp)\n      {\n\tsize_t __index = __idp-\u003e_M_id();\n\n\t// Check size of facet vector to ensure adequate room.\n\tif (__index \u003e _M_facets_size - 1)\n\t  {\n\t    const size_t __new_size = __index + 4;\n\n\t    // New facet array.\n\t    const facet** __oldf = _M_facets;\n\t    const facet** __newf;\n\t    __newf = new const facet*[__new_size]; \n\t    for (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\t      __newf[__i] = _M_facets[__i];\n\t    for (size_t __l = _M_facets_size; __l \u003c __new_size; ++__l)\n\t      __newf[__l] = 0;\n\n\t    // New cache array.\n\t    const facet** __oldc = _M_caches;\n\t    const facet** __newc;\n\t    try\n\t      {\n\t\t__newc = new const facet*[__new_size];\n\t      }\n\t    catch(...)\n\t      {\n\t\tdelete [] __newf;\n\t\t__throw_exception_again;\n\t      }\n\t    for (size_t __j = 0; __j \u003c _M_facets_size; ++__j)\n\t      __newc[__j] = _M_caches[__j];\n\t    for (size_t __k = _M_facets_size; __k \u003c __new_size; ++__k)\n\t      __newc[__k] = 0;\n\n\t    _M_facets_size = __new_size;\n\t    _M_facets = __newf;\n\t    _M_caches = __newc;\n\t    delete [] __oldf;\n\t    delete [] __oldc;\n\t  }\n\n\t__fp-\u003e_M_add_reference();\n\tconst facet*\u0026 __fpr = _M_facets[__index];\n\tif (__fpr)\n\t  {\n\t    // Replacing an existing facet. Order matters.\n\t    __fpr-\u003e_M_remove_reference();\n\t    __fpr = __fp;\n\t  }\n\telse\n\t  {\n\t    // Installing a newly created facet into an empty\n\t    // _M_facets container, say a newly-constructed,\n\t    // swanky-fresh _Impl.\n\t    _M_facets[__index] = __fp;\n\t  }\n\n\t// Ideally, it would be nice to only remove the caches that\n\t// are now incorrect. However, some of the caches depend on\n\t// multiple facets, and we only know about one facet\n\t// here. It's no great loss: the first use of the new facet\n\t// will create a new, correctly cached facet anyway.\n\tfor (size_t __i = 0; __i \u003c _M_facets_size; ++__i)\n\t  {\n\t    const facet* __cpr = _M_caches[__i];\n\t    if (__cpr)\n\t      {\n\t\t__cpr-\u003e_M_remove_reference();\n\t\t_M_caches[__i] = 0;\n\t      }\n\t  }\n      }\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":309,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5351440":{"score":0.92556584,"function_name":"locale::_Impl::\n  _M_replace_facet","code":"void\n  locale::_Impl::\n  _M_replace_facet(const _Impl* __imp, const locale::id* __idp)\n  {\n    size_t __index = __idp-\u003e_M_id();\n    if ((__index \u003e (__imp-\u003e_M_facets_size - 1)) \n\t|| !__imp-\u003e_M_facets[__index])\n      __throw_runtime_error(__N(\"locale::_Impl::_M_replace_facet\"));\n    _M_install_facet(__idp, __imp-\u003e_M_facets[__index]); \n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":298,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5351520":{"score":0.8624579,"function_name":"locale::_Impl::\n  _M_replace_category","code":"void\n  locale::_Impl::\n  _M_replace_category(const _Impl* __imp, \n\t\t      const locale::id* const* __idpp)\n  {\n    for (; *__idpp; ++__idpp)\n      _M_replace_facet(__imp, *__idpp);\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":289,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5351584":{"score":0.5894196,"function_name":"locale::_Impl::\n  _M_install_cache","code":"void\n  locale::_Impl::\n  _M_install_cache(const facet* __cache, size_t __index)\n  {\n    __gnu_cxx::__scoped_lock sentry(locale_cache_mutex);\n    if (_M_caches[__index] != 0)\n      {\n\t// Some other thread got in first.\n\tdelete __cache;\n      }\n    else\n      {\n\t__cache-\u003e_M_add_reference();\n\t_M_caches[__index] = __cache;\n      }\n  }","filepath":"libstdc++-v3/src/locale.cc","line_number":388,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.3.0"},"5431504":{"score":0.85434455,"function_name":"ctype_byname\u003cchar\u003e::ctype_byname","code":"ctype_byname\u003cchar\u003e::ctype_byname(const char* __s, size_t __refs)\n    : ctype\u003cchar\u003e(0, false, __refs) \n    { \t\t\n      if (std::strcmp(__s, \"C\") != 0 \u0026\u0026 std::strcmp(__s, \"POSIX\") != 0)\n\t{\n\t  this-\u003e_S_destroy_c_locale(this-\u003e_M_c_locale_ctype);\n\t  this-\u003e_S_create_c_locale(this-\u003e_M_c_locale_ctype, __s); \n\t  this-\u003e_M_toupper = this-\u003e_M_c_locale_ctype-\u003e__ctype_toupper;\n\t  this-\u003e_M_tolower = this-\u003e_M_c_locale_ctype-\u003e__ctype_tolower;\n\t  this-\u003e_M_table = this-\u003e_M_c_locale_ctype-\u003e__ctype_b;\n\t}\n    }"},"5431664":{"score":0.6918596,"function_name":"ctype\u003cwchar_t\u003e::_M_convert_to_wmask","code":"ctype\u003cwchar_t\u003e::__wmask_type\n  ctype\u003cwchar_t\u003e::_M_convert_to_wmask(const mask __m) const\n  {\n    __wmask_type __ret;\n    switch (__m)\n      {\n      case space:\n\t__ret = __wctype_l(\"space\", _M_c_locale_ctype);\n\tbreak;\n      case print:\n\t__ret = __wctype_l(\"print\", _M_c_locale_ctype);\n\tbreak;\n      case cntrl:\n\t__ret = __wctype_l(\"cntrl\", _M_c_locale_ctype);\n\tbreak;\n      case upper:\n\t__ret = __wctype_l(\"upper\", _M_c_locale_ctype);\n\tbreak;\n      case lower:\n\t__ret = __wctype_l(\"lower\", _M_c_locale_ctype);\n\tbreak;\n      case alpha:\n\t__ret = __wctype_l(\"alpha\", _M_c_locale_ctype);\n\tbreak;\n      case digit:\n\t__ret = __wctype_l(\"digit\", _M_c_locale_ctype);\n\tbreak;\n      case punct:\n\t__ret = __wctype_l(\"punct\", _M_c_locale_ctype);\n\tbreak;\n      case xdigit:\n\t__ret = __wctype_l(\"xdigit\", _M_c_locale_ctype);\n\tbreak;\n      case alnum:\n\t__ret = __wctype_l(\"alnum\", _M_c_locale_ctype);\n\tbreak;\n      case graph:\n\t__ret = __wctype_l(\"graph\", _M_c_locale_ctype);\n\tbreak;\n      default:\n\t__ret = __wmask_type();\n      }\n    return __ret;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":57,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432016":{"score":0.864107,"function_name":"ctype\u003cwchar_t\u003e::do_tolower","code":"const wchar_t*\n  ctype\u003cwchar_t\u003e::do_tolower(wchar_t* __lo, const wchar_t* __hi) const\n  {\n    while (__lo \u003c __hi)\n      {\n        *__lo = __towlower_l(*__lo, _M_c_locale_ctype);\n        ++__lo;\n      }\n    return __hi;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":121,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432160":{"score":0.8145238,"function_name":"ctype\u003cwchar_t\u003e::\n  do_is","code":"bool\n  ctype\u003cwchar_t\u003e::\n  do_is(mask __m, wchar_t __c) const\n  { \n    // The case of __m == ctype_base::space is particularly important,\n    // due to its use in many istream functions.  Therefore we deal with\n    // it first, exploiting the knowledge that on GNU systems _M_bit[5]\n    // is the mask corresponding to ctype_base::space.  NB: an encoding\n    // change would not affect correctness!\n    bool __ret = false;\n    if (__m == _M_bit[5])\n      __ret = __iswctype_l(__c, _M_wmask[5], _M_c_locale_ctype);\n    else\n      {\n\t// Highest bitmask in ctype_base == 10, but extra in \"C\"\n\t// library for blank.\n\tconst size_t __bitmasksize = 11;\n\tfor (size_t __bitcur = 0; __bitcur \u003c= __bitmasksize; ++__bitcur)\n\t  if (__m \u0026 _M_bit[__bitcur])\n\t    {\n\t      if (__iswctype_l(__c, _M_wmask[__bitcur], _M_c_locale_ctype))\n\t\t{\n\t\t  __ret = true;\n\t\t  break;\n\t\t}\n\t      else if (__m == _M_bit[__bitcur])\n\t\tbreak;\n\t    }\n      }\n    return __ret;    \n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":132,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432336":{"score":0.8130331,"function_name":"ctype\u003cwchar_t\u003e::\n  do_is","code":"const wchar_t* \n  ctype\u003cwchar_t\u003e::\n  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const\n  {\n    for (; __lo \u003c __hi; ++__vec, ++__lo)\n      {\n\t// Highest bitmask in ctype_base == 10, but extra in \"C\"\n\t// library for blank.\n\tconst size_t __bitmasksize = 11; \n\tmask __m = 0;\n\tfor (size_t __bitcur = 0; __bitcur \u003c= __bitmasksize; ++__bitcur)\n\t  if (__iswctype_l(*__lo, _M_wmask[__bitcur], _M_c_locale_ctype))\n\t    __m |= _M_bit[__bitcur];\n\t*__vec = __m;\n      }\n    return __hi;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":164,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432496":{"score":0.892821,"function_name":"ctype\u003cwchar_t\u003e::\n  do_scan_not","code":"const wchar_t*\n  ctype\u003cwchar_t\u003e::\n  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const\n  {\n    while (__lo \u003c __hi \u0026\u0026 this-\u003edo_is(__m, *__lo) != 0)\n      ++__lo;\n    return __lo;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":191,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432752":{"score":0.797643,"function_name":"ctype\u003cwchar_t\u003e::\n  do_narrow","code":"char\n  ctype\u003cwchar_t\u003e::\n  do_narrow(wchar_t __wc, char __dfault) const\n  {\n    if (__wc \u003e= 0 \u0026\u0026 __wc \u003c 128 \u0026\u0026 _M_narrow_ok)\n      return _M_narrow[__wc];\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_ctype);\n#endif\n    const int __c = wctob(__wc);\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n    return (__c == EOF ? __dfault : static_cast\u003cchar\u003e(__c)); \n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":218,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5432848":{"score":0.8419735,"function_name":"ctype\u003cwchar_t\u003e::\n  do_narrow","code":"const wchar_t*\n  ctype\u003cwchar_t\u003e::\n  do_narrow(const wchar_t* __lo, const wchar_t* __hi, char __dfault, \n\t    char* __dest) const\n  {\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_ctype);\n#endif\n    if (_M_narrow_ok)\n      while (__lo \u003c __hi)\n\t{\n\t  if (*__lo \u003e= 0 \u0026\u0026 *__lo \u003c 128)\n\t    *__dest = _M_narrow[*__lo];\n\t  else\n\t    {\n\t      const int __c = wctob(*__lo);\n\t      *__dest = (__c == EOF ? __dfault : static_cast\u003cchar\u003e(__c));\n\t    }\n\t  ++__lo;\n\t  ++__dest;\n\t}\n    else\n      while (__lo \u003c __hi)\n\t{\n\t  const int __c = wctob(*__lo);\n\t  *__dest = (__c == EOF ? __dfault : static_cast\u003cchar\u003e(__c));\n\t  ++__lo;\n\t  ++__dest;\n\t}\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n    return __hi;\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":234,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5433104":{"score":0.7451977,"function_name":"ctype\u003cwchar_t\u003e::_M_initialize_ctype","code":"void\n  ctype\u003cwchar_t\u003e::_M_initialize_ctype()\n  {\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __c_locale __old = __uselocale(_M_c_locale_ctype);\n#endif\n    wint_t __i;\n    for (__i = 0; __i \u003c 128; ++__i)\n      {\n\tconst int __c = wctob(__i);\n\tif (__c == EOF)\n\t  break;\n\telse\n\t  _M_narrow[__i] = static_cast\u003cchar\u003e(__c);\n      }\n    if (__i == 128)\n      _M_narrow_ok = true;\n    else\n      _M_narrow_ok = false;\n    for (size_t __j = 0;\n\t __j \u003c sizeof(_M_widen) / sizeof(wint_t); ++__j)\n      _M_widen[__j] = btowc(__j);\n\n    for (size_t __k = 0; __k \u003c= 11; ++__k)\n      { \n\t_M_bit[__k] = static_cast\u003cmask\u003e(_ISbit(__k));\n\t_M_wmask[__k] = _M_convert_to_wmask(_M_bit[__k]);\n      }\n#if __GLIBC__ \u003e 2 || (__GLIBC__ == 2 \u0026\u0026 __GLIBC_MINOR__ \u003e 2)\n    __uselocale(__old);\n#endif\n  }","filepath":"libstdc++-v3/config/locale/gnu/ctype_members.cc","line_number":269,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.4.0"},"5579216":{"score":0.7100251,"function_name":"ctype\u003cchar\u003e::ctype","code":"ctype\u003cchar\u003e::ctype(__c_locale __cloc, const mask* __table, bool __del,\n\t\t     size_t __refs)\n  : facet(__refs), _M_c_locale_ctype(_S_clone_c_locale(__cloc)),\n  _M_del(__table != 0 \u0026\u0026 __del),\n  _M_toupper(_M_c_locale_ctype-\u003e__ctype_toupper),\n  _M_tolower(_M_c_locale_ctype-\u003e__ctype_tolower),\n  _M_table(__table ? __table : _M_c_locale_ctype-\u003e__ctype_b),\n  _M_widen_ok(0), _M_narrow_ok(0)\n  {\n    __builtin_memset(_M_widen, 0, sizeof(_M_widen));\n    __builtin_memset(_M_narrow, 0, sizeof(_M_narrow));\n  }","filepath":"libstdc++-v3/config/os/gnu-linux/ctype_configure_char.cc","line_number":74,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5579456":{"score":0.7744546,"function_name":"ctype\u003cchar\u003e::ctype","code":"ctype\u003cchar\u003e::ctype(const mask* __table, bool __del, size_t __refs)\n  : facet(__refs), _M_c_locale_ctype(_S_get_c_locale()),\n  _M_del(__table != 0 \u0026\u0026 __del),\n  _M_toupper(_M_c_locale_ctype-\u003e__ctype_toupper),\n  _M_tolower(_M_c_locale_ctype-\u003e__ctype_tolower),\n  _M_table(__table ? __table : _M_c_locale_ctype-\u003e__ctype_b),\n  _M_widen_ok(0), _M_narrow_ok(0)\n  {\n    __builtin_memset(_M_widen, 0, sizeof(_M_widen));\n    __builtin_memset(_M_narrow, 0, sizeof(_M_narrow));\n  }","filepath":"libstdc++-v3/config/os/gnu-linux/ctype_configure_char.cc","line_number":121,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5579712":{"score":0.8860192,"function_name":"ctype\u003cchar\u003e::do_toupper","code":"const char*\n  ctype\u003cchar\u003e::do_toupper(char* __low, const char* __high) const\n  {\n    while (__low \u003c __high)\n      {\n\t*__low = _M_toupper[static_cast\u003cunsigned char\u003e(*__low)];\n\t++__low;\n      }\n    return __high;\n  }","filepath":"libstdc++-v3/config/os/gnu-linux/ctype_configure_char.cc","line_number":169,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5737584":{"score":0.7515043,"function_name":"moneypunct\u003cchar, true\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, true\u003e::_M_initialize_moneypunct(__c_locale __cloc,\n\t\t\t\t\t\t     const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, true\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT,\n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP,\n\t\t\t\t\t\t\t__cloc));\n\n\t  // Check for NULL, which implies no fractional digits.\n\t  if (_M_data-\u003e_M_decimal_point == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_frac_digits = 0;\n\t      _M_data-\u003e_M_decimal_point = '.';\n\t    }\n\t  else\n\t    _M_data-\u003e_M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS,\n\t\t\t\t\t\t\t__cloc));\n\n\t  const char* __cgroup = __nl_langinfo_l(__MON_GROUPING, __cloc);\n\t  const char* __cpossign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n\t  const char* __cnegsign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n\t  // _Intl == true\n\t  const char* __ccurr = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);\n\n\t  char* __group = 0;\n\t  char* __ps = 0;\n\t  char* __ns = 0;\n\t  const char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n\t  __try\n\t    {\n\t      size_t __len;\n\n\t      // Check for NULL, which implies no grouping.\n\t      if (_M_data-\u003e_M_thousands_sep == '\\0')\n\t\t{\n\t\t  // Like in \"C\" locale.\n\t\t  _M_data-\u003e_M_grouping = \"\";\n\t\t  _M_data-\u003e_M_grouping_size = 0;\n\t\t  _M_data-\u003e_M_use_grouping = false;\n\t\t  _M_data-\u003e_M_thousands_sep = ',';\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cgroup);\n\t\t  if (__len)\n\t\t    {\n\t\t      __group = new char[__len + 1];\n\t\t      memcpy(__group, __cgroup, __len + 1);\n\t\t      _M_data-\u003e_M_grouping = __group;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      _M_data-\u003e_M_grouping = \"\";\n\t\t      _M_data-\u003e_M_use_grouping = false;\n\t\t    }\n\t\t  _M_data-\u003e_M_grouping_size = __len;\n\t\t}\n\n\t      __len = strlen(__cpossign);\n\t      if (__len)\n\t\t{\n\t\t  __ps = new char[__len + 1];\n\t\t  memcpy(__ps, __cpossign, __len + 1);\n\t\t  _M_data-\u003e_M_positive_sign = __ps;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_positive_sign = \"\";\n\t      _M_data-\u003e_M_positive_sign_size = __len;\n\n\t      if (!__nposn)\n\t\t{\n\t\t  _M_data-\u003e_M_negative_sign = \"()\";\n\t\t  _M_data-\u003e_M_negative_sign_size = 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cnegsign);\n\t\t  if (__len)\n\t\t    {\n\t\t      __ns = new char[__len + 1];\n\t\t      memcpy(__ns, __cnegsign, __len + 1);\n\t\t      _M_data-\u003e_M_negative_sign = __ns;\n\t\t    }\n\t\t  else\n\t\t    _M_data-\u003e_M_negative_sign = \"\";\n\t\t  _M_data-\u003e_M_negative_sign_size = __len;\n\t\t}\n\n\t      __len = strlen(__ccurr);\n\t      if (__len)\n\t\t{\n\t\t  char* __curr = new char[__len + 1];\n\t\t  memcpy(__curr, __ccurr, __len + 1);\n\t\t  _M_data-\u003e_M_curr_symbol = __curr;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_curr_symbol = \"\";\n\t      _M_data-\u003e_M_curr_symbol_size = __len;\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete _M_data;\n\t      _M_data = 0;\n\t      delete [] __group;\n\t      delete [] __ps;\n\t      delete [] __ns;\n\t      __throw_exception_again;\n\t    }\n\n\t  char __pprecedes = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));\n\t  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n\t  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));\n\t  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n\t\t\t\t\t\t\t__nposn);\n\t}"},"5745328":{"score":0.796576,"function_name":"moneypunct\u003cchar, true\u003e::~moneypunct","code":"moneypunct\u003cchar, true\u003e::~moneypunct()\n    {\n      if (_M_data-\u003e_M_grouping_size)\n\tdelete [] _M_data-\u003e_M_grouping;\n      if (_M_data-\u003e_M_positive_sign_size)\n\tdelete [] _M_data-\u003e_M_positive_sign;\n      if (_M_data-\u003e_M_negative_sign_size\n          \u0026\u0026 strcmp(_M_data-\u003e_M_negative_sign, \"()\") != 0)\n\tdelete [] _M_data-\u003e_M_negative_sign;\n      if (_M_data-\u003e_M_curr_symbol_size)\n\tdelete [] _M_data-\u003e_M_curr_symbol;\n      delete _M_data;\n    }","filepath":"libstdc++-v3/config/locale/gnu/monetary_members.cc","line_number":509,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.7.0"},"5745808":{"score":0.7509691,"function_name":"moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct","code":"void\n    moneypunct\u003cchar, false\u003e::_M_initialize_moneypunct(__c_locale __cloc,\n\t\t\t\t\t\t      const char*)\n    {\n      if (!_M_data)\n\t_M_data = new __moneypunct_cache\u003cchar, false\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_data-\u003e_M_decimal_point = '.';\n\t  _M_data-\u003e_M_thousands_sep = ',';\n\t  _M_data-\u003e_M_grouping = \"\";\n\t  _M_data-\u003e_M_grouping_size = 0;\n\t  _M_data-\u003e_M_use_grouping = false;\n\t  _M_data-\u003e_M_curr_symbol = \"\";\n\t  _M_data-\u003e_M_curr_symbol_size = 0;\n\t  _M_data-\u003e_M_positive_sign = \"\";\n\t  _M_data-\u003e_M_positive_sign_size = 0;\n\t  _M_data-\u003e_M_negative_sign = \"\";\n\t  _M_data-\u003e_M_negative_sign_size = 0;\n\t  _M_data-\u003e_M_frac_digits = 0;\n\t  _M_data-\u003e_M_pos_format = money_base::_S_default_pattern;\n\t  _M_data-\u003e_M_neg_format = money_base::_S_default_pattern;\n\n\t  for (size_t __i = 0; __i \u003c money_base::_S_end; ++__i)\n\t    _M_data-\u003e_M_atoms[__i] = money_base::_S_atoms[__i];\n\t}\n      else\n\t{\n\t  // Named locale.\n\t  _M_data-\u003e_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT,\n\t\t\t\t\t\t\t__cloc));\n\t  _M_data-\u003e_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP,\n\t\t\t\t\t\t\t__cloc));\n\n\t  // Check for NULL, which implies no fractional digits.\n\t  if (_M_data-\u003e_M_decimal_point == '\\0')\n\t    {\n\t      // Like in \"C\" locale.\n\t      _M_data-\u003e_M_frac_digits = 0;\n\t      _M_data-\u003e_M_decimal_point = '.';\n\t    }\n\t  else\n\t    _M_data-\u003e_M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS,\n\t\t\t\t\t\t\t__cloc));\n\n\t  const char* __cgroup = __nl_langinfo_l(__MON_GROUPING, __cloc);\n\t  const char* __cpossign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n\t  const char* __cnegsign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n\t  // _Intl == false\n\t  const char* __ccurr = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n\n\t  char* __group = 0;\n\t  char* __ps = 0;\n\t  char* __ns = 0;\n\t  const char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n\t  __try\n\t    {\n\t      size_t __len;\n\n\t      // Check for NULL, which implies no grouping.\n\t      if (_M_data-\u003e_M_thousands_sep == '\\0')\n\t\t{\n\t\t  // Like in \"C\" locale.\n\t\t  _M_data-\u003e_M_grouping = \"\";\n\t\t  _M_data-\u003e_M_grouping_size = 0;\n\t\t  _M_data-\u003e_M_use_grouping = false;\n\t\t  _M_data-\u003e_M_thousands_sep = ',';\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cgroup);\n\t\t  if (__len)\n\t\t    {\n\t\t      __group = new char[__len + 1];\n\t\t      memcpy(__group, __cgroup, __len + 1);\n\t\t      _M_data-\u003e_M_grouping = __group;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      _M_data-\u003e_M_grouping = \"\";\n\t\t      _M_data-\u003e_M_use_grouping = false;\n\t\t    }\n\t\t  _M_data-\u003e_M_grouping_size = __len;\n\t\t}\n\n\t      __len = strlen(__cpossign);\n\t      if (__len)\n\t\t{\n\t\t  __ps = new char[__len + 1];\n\t\t  memcpy(__ps, __cpossign, __len + 1);\n\t\t  _M_data-\u003e_M_positive_sign = __ps;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_positive_sign = \"\";\n\t      _M_data-\u003e_M_positive_sign_size = __len;\n\n\t      if (!__nposn)\n\t\t{\n\t\t  _M_data-\u003e_M_negative_sign = \"()\";\n\t\t  _M_data-\u003e_M_negative_sign_size = 2;\n\t\t}\n\t      else\n\t\t{\n\t\t  __len = strlen(__cnegsign);\n\t\t  if (__len)\n\t\t    {\n\t\t      __ns = new char[__len + 1];\n\t\t      memcpy(__ns, __cnegsign, __len + 1);\n\t\t      _M_data-\u003e_M_negative_sign = __ns;\n\t\t    }\n\t\t  else\n\t\t    _M_data-\u003e_M_negative_sign = \"\";\n\t\t  _M_data-\u003e_M_negative_sign_size = __len;\n\t\t}\n\n\t      __len = strlen(__ccurr);\n\t      if (__len)\n\t\t{\n\t\t  char* __curr = new char[__len + 1];\n\t\t  memcpy(__curr, __ccurr, __len + 1);\n\t\t  _M_data-\u003e_M_curr_symbol = __curr;\n\t\t}\n\t      else\n\t\t_M_data-\u003e_M_curr_symbol = \"\";\n\t      _M_data-\u003e_M_curr_symbol_size = __len;\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete _M_data;\n\t      _M_data = 0;\n\t      delete [] __group;\n\t      delete [] __ps;\n\t      delete [] __ns;\n\t      __throw_exception_again;\n\t    }\n\n\t  char __pprecedes = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n\t  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n\t  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n\t  _M_data-\u003e_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,\n\t\t\t\t\t\t\t__pposn);\n\t  char __nprecedes = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n\t  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n\t  _M_data-\u003e_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,\n\t\t\t\t\t\t\t__nposn);\n\t}"},"5753264":{"score":0.78863263,"function_name":"template\u003c\u003e\n    void\n    __timepunct\u003cchar\u003e::\n    _M_put","code":"_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  template\u003c\u003e\n    void\n    __timepunct\u003cchar\u003e::\n    _M_put(char* __s, size_t __maxlen, const char* __format,\n\t   const tm* __tm) const throw()\n    {\n      const size_t __len = strftime_l(__s, __maxlen, __format, __tm,\n\t\t\t\t      (locale_t)_M_c_locale_timepunct);\n      // Make sure __s is null terminated.\n      if (__len == 0)\n\t__s[0] = '\\0';\n    }","filepath":"libstdc++-v3/config/locale/dragonfly/time_members.cc","line_number":42,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5755712":{"score":0.73208225,"function_name":"__timepunct\u003cwchar_t\u003e::\n    _M_put","code":"void\n    __timepunct\u003cwchar_t\u003e::\n    _M_put(wchar_t* __s, size_t __maxlen, const wchar_t* __format,\n\t   const tm* __tm) const throw()\n    {\n      const size_t __len = wcsftime_l(__s, __maxlen, __format, __tm,\n\t\t\t\t      (locale_t)_M_c_locale_timepunct);\n      // Make sure __s is null terminated.\n      if (__len == 0)\n\t__s[0] = L'\\0';\n    }","filepath":"libstdc++-v3/config/locale/dragonfly/time_members.cc","line_number":194,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5755760":{"score":0.71841633,"function_name":"__timepunct\u003cwchar_t\u003e::_M_initialize_timepunct","code":"void\n    __timepunct\u003cwchar_t\u003e::_M_initialize_timepunct(__c_locale __cloc)\n    {\n      if (!_M_data)\n\t_M_data = new __timepunct_cache\u003cwchar_t\u003e;\n\n      if (!__cloc)\n\t{\n\t  // \"C\" locale\n\t  _M_c_locale_timepunct = _S_get_c_locale();\n\n\t  _M_data-\u003e_M_date_format = L\"%m/%d/%y\";\n\t  _M_data-\u003e_M_date_era_format = L\"%m/%d/%y\";\n\t  _M_data-\u003e_M_time_format = L\"%H:%M:%S\";\n\t  _M_data-\u003e_M_time_era_format = L\"%H:%M:%S\";\n\t  _M_data-\u003e_M_date_time_format = L\"\";\n\t  _M_data-\u003e_M_date_time_era_format = L\"\";\n\t  _M_data-\u003e_M_am = L\"AM\";\n\t  _M_data-\u003e_M_pm = L\"PM\";\n\t  _M_data-\u003e_M_am_pm_format = L\"\";\n\n\t  // Day names, starting with \"C\"'s Sunday.\n\t  _M_data-\u003e_M_day1 = L\"Sunday\";\n\t  _M_data-\u003e_M_day2 = L\"Monday\";\n\t  _M_data-\u003e_M_day3 = L\"Tuesday\";\n\t  _M_data-\u003e_M_day4 = L\"Wednesday\";\n\t  _M_data-\u003e_M_day5 = L\"Thursday\";\n\t  _M_data-\u003e_M_day6 = L\"Friday\";\n\t  _M_data-\u003e_M_day7 = L\"Saturday\";\n\n\t  // Abbreviated day names, starting with \"C\"'s Sun.\n\t  _M_data-\u003e_M_aday1 = L\"Sun\";\n\t  _M_data-\u003e_M_aday2 = L\"Mon\";\n\t  _M_data-\u003e_M_aday3 = L\"Tue\";\n\t  _M_data-\u003e_M_aday4 = L\"Wed\";\n\t  _M_data-\u003e_M_aday5 = L\"Thu\";\n\t  _M_data-\u003e_M_aday6 = L\"Fri\";\n\t  _M_data-\u003e_M_aday7 = L\"Sat\";\n\n\t  // Month names, starting with \"C\"'s January.\n\t  _M_data-\u003e_M_month01 = L\"January\";\n\t  _M_data-\u003e_M_month02 = L\"February\";\n\t  _M_data-\u003e_M_month03 = L\"March\";\n\t  _M_data-\u003e_M_month04 = L\"April\";\n\t  _M_data-\u003e_M_month05 = L\"May\";\n\t  _M_data-\u003e_M_month06 = L\"June\";\n\t  _M_data-\u003e_M_month07 = L\"July\";\n\t  _M_data-\u003e_M_month08 = L\"August\";\n\t  _M_data-\u003e_M_month09 = L\"September\";\n\t  _M_data-\u003e_M_month10 = L\"October\";\n\t  _M_data-\u003e_M_month11 = L\"November\";\n\t  _M_data-\u003e_M_month12 = L\"December\";\n\n\t  // Abbreviated month names, starting with \"C\"'s Jan.\n\t  _M_data-\u003e_M_amonth01 = L\"Jan\";\n\t  _M_data-\u003e_M_amonth02 = L\"Feb\";\n\t  _M_data-\u003e_M_amonth03 = L\"Mar\";\n\t  _M_data-\u003e_M_amonth04 = L\"Apr\";\n\t  _M_data-\u003e_M_amonth05 = L\"May\";\n\t  _M_data-\u003e_M_amonth06 = L\"Jun\";\n\t  _M_data-\u003e_M_amonth07 = L\"Jul\";\n\t  _M_data-\u003e_M_amonth08 = L\"Aug\";\n\t  _M_data-\u003e_M_amonth09 = L\"Sep\";\n\t  _M_data-\u003e_M_amonth10 = L\"Oct\";\n\t  _M_data-\u003e_M_amonth11 = L\"Nov\";\n\t  _M_data-\u003e_M_amonth12 = L\"Dec\";\n\t}\n      else\n\t{\n\t  wchar_t *langstring = 0;\n\t  wchar_t holder[128];\n\t  size_t fmtlen;\n\n\t  _M_c_locale_timepunct = _S_clone_c_locale(__cloc);\n\n\t  WIDE_LANGINFO(_M_date_format, D_FMT)\n\t  WIDE_LANGINFO(_M_date_era_format, ERA_D_FMT)\n\t  WIDE_LANGINFO(_M_time_format, T_FMT)\n\t  WIDE_LANGINFO(_M_time_era_format, ERA_T_FMT)\n\t  WIDE_LANGINFO(_M_date_time_format, D_T_FMT)\n\t  WIDE_LANGINFO(_M_date_time_era_format, ERA_D_T_FMT)\n\t  WIDE_LANGINFO(_M_am, AM_STR)\n\t  WIDE_LANGINFO(_M_pm, PM_STR)\n\t  WIDE_LANGINFO(_M_am_pm_format, T_FMT_AMPM)\n\n\t  // Day names, starting with \"C\"'s Sunday.\n\t  WIDE_LANGINFO(_M_day1, DAY_1)\n\t  WIDE_LANGINFO(_M_day2, DAY_2)\n\t  WIDE_LANGINFO(_M_day3, DAY_3)\n\t  WIDE_LANGINFO(_M_day4, DAY_4)\n\t  WIDE_LANGINFO(_M_day5, DAY_5)\n\t  WIDE_LANGINFO(_M_day6, DAY_6)\n\t  WIDE_LANGINFO(_M_day7, DAY_7)\n\n\t  // Abbreviated day names, starting with \"C\"'s Sun.\n\t  WIDE_LANGINFO(_M_aday1, ABDAY_1)\n\t  WIDE_LANGINFO(_M_aday2, ABDAY_2)\n\t  WIDE_LANGINFO(_M_aday3, ABDAY_3)\n\t  WIDE_LANGINFO(_M_aday4, ABDAY_4)\n\t  WIDE_LANGINFO(_M_aday5, ABDAY_5)\n\t  WIDE_LANGINFO(_M_aday6, ABDAY_6)\n\t  WIDE_LANGINFO(_M_aday7, ABDAY_7)\n\n\t  // Month names, starting with \"C\"'s January.\n\t  WIDE_LANGINFO(_M_month01, MON_1)\n\t  WIDE_LANGINFO(_M_month02, MON_2)\n\t  WIDE_LANGINFO(_M_month03, MON_3)\n\t  WIDE_LANGINFO(_M_month04, MON_4)\n\t  WIDE_LANGINFO(_M_month05, MON_5)\n\t  WIDE_LANGINFO(_M_month06, MON_6)\n\t  WIDE_LANGINFO(_M_month07, MON_7)\n\t  WIDE_LANGINFO(_M_month08, MON_8)\n\t  WIDE_LANGINFO(_M_month09, MON_9)\n\t  WIDE_LANGINFO(_M_month10, MON_10)\n\t  WIDE_LANGINFO(_M_month11, MON_11)\n\t  WIDE_LANGINFO(_M_month12, MON_12)\n\n\t  // Abbreviated month names, starting with \"C\"'s Jan.\n\t  WIDE_LANGINFO(_M_amonth01, ABMON_1)\n\t  WIDE_LANGINFO(_M_amonth02, ABMON_2)\n\t  WIDE_LANGINFO(_M_amonth03, ABMON_3)\n\t  WIDE_LANGINFO(_M_amonth04, ABMON_4)\n\t  WIDE_LANGINFO(_M_amonth05, ABMON_5)\n\t  WIDE_LANGINFO(_M_amonth06, ABMON_6)\n\t  WIDE_LANGINFO(_M_amonth07, ABMON_7)\n\t  WIDE_LANGINFO(_M_amonth08, ABMON_8)\n\t  WIDE_LANGINFO(_M_amonth09, ABMON_9)\n\t  WIDE_LANGINFO(_M_amonth10, ABMON_10)\n\t  WIDE_LANGINFO(_M_amonth11, ABMON_11)\n\t  WIDE_LANGINFO(_M_amonth12, ABMON_12)\n\t}\n    }","filepath":"libstdc++-v3/config/locale/dragonfly/time_members.cc","line_number":215,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"basepoints/gcc-10"},"5772560":{"score":0.83746326,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_in","code":"codecvt_base::result\n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_in(state_type\u0026 __state, const extern_type* __from, \n\tconst extern_type* __from_end, const extern_type*\u0026 __from_next,\n\tintern_type* __to, intern_type* __to_end,\n\tintern_type*\u0026 __to_next) const\n  {\n    result __ret = ok;\n    state_type __tmp_state(__state);\n\n    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n\n    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n    // in case we store a L'\\0' and then continue, in a loop.\n    // NB: mbsnrtowcs is a GNU extension\n    for (__from_next = __from, __to_next = __to;\n\t __from_next \u003c __from_end \u0026\u0026 __to_next \u003c __to_end\n\t \u0026\u0026 __ret == ok;)\n      {\n\tconst extern_type* __from_chunk_end;\n\t__from_chunk_end = static_cast\u003cconst extern_type*\u003e(memchr(__from_next, '\\0',\n\t\t\t\t\t\t\t\t  __from_end\n\t\t\t\t\t\t\t\t  - __from_next));\n\tif (!__from_chunk_end)\n\t  __from_chunk_end = __from_end;\n\n\t__from = __from_next;\n\tsize_t __conv = mbsnrtowcs(__to_next, \u0026__from_next,\n\t\t\t\t   __from_chunk_end - __from_next,\n\t\t\t\t   __to_end - __to_next, \u0026__state);\n\tif (__conv == static_cast\u003csize_t\u003e(-1))\n\t  {\n\t    // In case of error, in order to stop at the exact place we\n\t    // have to start again from the beginning with a series of\n\t    // mbrtowc.\n\t    for (;; ++__to_next, __from += __conv)\n\t      {\n\t\t__conv = mbrtowc(__to_next, __from, __from_end - __from,\n\t\t\t\t \u0026__tmp_state);\n\t\tif (__conv == static_cast\u003csize_t\u003e(-1)\n\t\t    || __conv == static_cast\u003csize_t\u003e(-2))\n\t\t  break;\n\t      }\n\t    __from_next = __from;\n\t    __state = __tmp_state;\t    \n\t    __ret = error;\n\t  }\n\telse if (__from_next \u0026\u0026 __from_next \u003c __from_chunk_end)\n\t  {\n\t    // It is unclear what to return in this case (see DR 382). \n\t    __to_next += __conv;\n\t    __ret = partial;\n\t  }\n\telse\n\t  {\n\t    __from_next = __from_chunk_end;\n\t    __to_next += __conv;\n\t  }\n\n\tif (__from_next \u003c __from_end \u0026\u0026 __ret == ok)\n\t  {\n\t    if (__to_next \u003c __to_end)\n\t      {\n\t\t// XXX Probably wrong for stateful encodings\n\t\t__tmp_state = __state;\t\t\n\t\t++__from_next;\n\t\t*__to_next++ = L'\\0';\n\t      }\n\t    else\n\t      __ret = partial;\n\t  }\n      }\n\n    uselocale((locale_t)__old);\n\n    return __ret; \n  }","filepath":"contrib/gcc-5.0/libstdc++-v3/config/locale/dragonfly/codecvt_members.cc","line_number":114,"entry_url":"https://github.com/DragonFlyBSD/DragonFlyBSD.git","slot_name":"v4.3.1"},"5773184":{"score":0.58617735,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_max_length","code":"int \n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_max_length() const throw()\n  {\n    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n    // XXX Probably wrong for stateful encodings.\n    int __ret = MB_CUR_MAX;\n    uselocale((locale_t)__old);\n    return __ret;\n  }","filepath":"contrib/gcc-5.0/libstdc++-v3/config/locale/dragonfly/codecvt_members.cc","line_number":206,"entry_url":"https://github.com/DragonFlyBSD/DragonFlyBSD.git","slot_name":"v4.3.1"},"5773232":{"score":0.83534,"function_name":"codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_length","code":"int \n  codecvt\u003cwchar_t, char, mbstate_t\u003e::\n  do_length(state_type\u0026 __state, const extern_type* __from,\n\t    const extern_type* __end, size_t __max) const\n  {\n    int __ret = 0;\n    state_type __tmp_state(__state);\n\n    __c_locale __old = (__c_locale)uselocale((locale_t)_M_c_locale_codecvt);\n\n    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:\n    // in case we advance past it and then continue, in a loop.\n    // NB: mbsnrtowcs is a GNU extension\n  \n    // A dummy internal buffer is needed in order for mbsnrtocws to consider\n    // its fourth parameter (it wouldn't with NULL as first parameter).\n    wchar_t* __to = static_cast\u003cwchar_t*\u003e(__builtin_alloca(sizeof(wchar_t) \n\t\t\t\t\t\t\t   * __max));\n    while (__from \u003c __end \u0026\u0026 __max)\n      {\n\tconst extern_type* __from_chunk_end;\n\t__from_chunk_end = static_cast\u003cconst extern_type*\u003e(memchr(__from, '\\0',\n\t\t\t\t\t\t\t\t  __end\n\t\t\t\t\t\t\t\t  - __from));\n\tif (!__from_chunk_end)\n\t  __from_chunk_end = __end;\n\n\tconst extern_type* __tmp_from = __from;\n\tsize_t __conv = mbsnrtowcs(__to, \u0026__from,\n\t\t\t\t   __from_chunk_end - __from,\n\t\t\t\t   __max, \u0026__state);\n\tif (__conv == static_cast\u003csize_t\u003e(-1))\n\t  {\n\t    // In case of error, in order to stop at the exact place we\n\t    // have to start again from the beginning with a series of\n\t    // mbrtowc.\n\t    for (__from = __tmp_from;; __from += __conv)\n\t      {\n\t\t__conv = mbrtowc(0, __from, __end - __from,\n\t\t\t\t \u0026__tmp_state);\n\t\tif (__conv == static_cast\u003csize_t\u003e(-1)\n\t\t    || __conv == static_cast\u003csize_t\u003e(-2))\n\t\t  break;\n\t      }\n\t    __state = __tmp_state;\n\t    __ret += __from - __tmp_from;\n\t    break;\n\t  }\n\tif (!__from)\n\t  __from = __from_chunk_end;\n\t\n\t__ret += __from - __tmp_from;\n\t__max -= __conv;\n\n\tif (__from \u003c __end \u0026\u0026 __max)\n\t  {\n\t    // XXX Probably wrong for stateful encodings\n\t    __tmp_state = __state;\n\t    ++__from;\n\t    ++__ret;\n\t    --__max;\n\t  }\n      }\n\n    uselocale((locale_t)__old);\n\n    return __ret; \n  }","filepath":"contrib/gcc-5.0/libstdc++-v3/config/locale/dragonfly/codecvt_members.cc","line_number":217,"entry_url":"https://github.com/DragonFlyBSD/DragonFlyBSD.git","slot_name":"v4.3.1"},"5778304":{"score":0.8979818,"function_name":"execute_cfa_program","code":"static void\nexecute_cfa_program (const unsigned char *insn_ptr,\n\t\t     const unsigned char *insn_end,\n\t\t     struct _Unwind_Context *context,\n\t\t     _Unwind_FrameState *fs)\n{\n  struct frame_state_reg_info *unused_rs = NULL;\n\n  /* Don't allow remember/restore between CIE and FDE programs.  */\n  fs-\u003eregs.prev = NULL;\n\n  /* The comparison with the return address uses \u003c rather than \u003c= because\n     we are only interested in the effects of code before the call; for a\n     noreturn function, the return address may point to unrelated code with\n     a different stack configuration that we are not interested in.  We\n     assume that the call itself is unwind info-neutral; if not, or if\n     there are delay instructions that adjust the stack, these must be\n     reflected at the point immediately before the call insn.\n     In signal frames, return address is after last completed instruction,\n     so we add 1 to return address to make the comparison \u003c=.  */\n  while (insn_ptr \u003c insn_end\n\t \u0026\u0026 fs-\u003epc \u003c context-\u003era + _Unwind_IsSignalFrame (context))\n    {\n      unsigned char insn = *insn_ptr++;\n      _uleb128_t reg, utmp;\n      _sleb128_t offset, stmp;\n\n      if ((insn \u0026 0xc0) == DW_CFA_advance_loc)\n\tfs-\u003epc += (insn \u0026 0x3f) * fs-\u003ecode_align;\n      else if ((insn \u0026 0xc0) == DW_CFA_offset)\n\t{\n\t  reg = insn \u0026 0x3f;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Sword) utmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = offset;\n\t    }\n\t}\n      else if ((insn \u0026 0xc0) == DW_CFA_restore)\n\t{\n\t  reg = insn \u0026 0x3f;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    fs-\u003eregs.reg[reg].how = REG_UNSAVED;\n\t}\n      else switch (insn)\n\t{\n\tcase DW_CFA_set_loc:\n\t  {\n\t    _Unwind_Ptr pc;\n\n\t    insn_ptr = read_encoded_value (context, fs-\u003efde_encoding,\n\t\t\t\t\t   insn_ptr, \u0026pc);\n\t    fs-\u003epc = (void *) pc;\n\t  }\n\t  break;\n\n\tcase DW_CFA_advance_loc1:\n\t  fs-\u003epc += read_1u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 1;\n\t  break;\n\tcase DW_CFA_advance_loc2:\n\t  fs-\u003epc += read_2u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 2;\n\t  break;\n\tcase DW_CFA_advance_loc4:\n\t  fs-\u003epc += read_4u (insn_ptr) * fs-\u003ecode_align;\n\t  insn_ptr += 4;\n\t  break;\n\n\tcase DW_CFA_offset_extended:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Sword) utmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = offset;\n\t    }\n\t  break;\n\n\tcase DW_CFA_restore_extended:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  /* FIXME, this is wrong; the CIE might have said that the\n\t     register was saved somewhere.  */\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    fs-\u003eregs.reg[reg].how = REG_UNSAVED;\n\t  break;\n\n\tcase DW_CFA_same_value:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    fs-\u003eregs.reg[reg].how = REG_UNSAVED;\n\t  break;\n\n\tcase DW_CFA_undefined:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    fs-\u003eregs.reg[reg].how = REG_UNDEFINED;\n\t  break;\n\n\tcase DW_CFA_nop:\n\t  break;\n\n\tcase DW_CFA_register:\n\t  {\n\t    _uleb128_t reg2;\n\t    insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t    insn_ptr = read_uleb128 (insn_ptr, \u0026reg2);\n\t    reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t    if (UNWIND_COLUMN_IN_RANGE (reg))\n\t      {\n\t        fs-\u003eregs.reg[reg].how = REG_SAVED_REG;\n\t        fs-\u003eregs.reg[reg].loc.reg = (_Unwind_Word)reg2;\n\t      }\n\t  }\n\t  break;\n\n\tcase DW_CFA_remember_state:\n\t  {\n\t    struct frame_state_reg_info *new_rs;\n\t    if (unused_rs)\n\t      {\n\t\tnew_rs = unused_rs;\n\t\tunused_rs = unused_rs-\u003eprev;\n\t      }\n\t    else\n\t      new_rs = alloca (sizeof (struct frame_state_reg_info));\n\n\t    *new_rs = fs-\u003eregs;\n\t    fs-\u003eregs.prev = new_rs;\n\t  }\n\t  break;\n\n\tcase DW_CFA_restore_state:\n\t  {\n\t    struct frame_state_reg_info *old_rs = fs-\u003eregs.prev;\n\t    fs-\u003eregs = *old_rs;\n\t    old_rs-\u003eprev = unused_rs;\n\t    unused_rs = old_rs;\n\t  }\n\t  break;\n\n\tcase DW_CFA_def_cfa:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003eregs.cfa_reg = (_Unwind_Word)utmp;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003eregs.cfa_offset = (_Unwind_Word)utmp;\n\t  fs-\u003eregs.cfa_how = CFA_REG_OFFSET;\n\t  break;\n\n\tcase DW_CFA_def_cfa_register:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003eregs.cfa_reg = (_Unwind_Word)utmp;\n\t  fs-\u003eregs.cfa_how = CFA_REG_OFFSET;\n\t  break;\n\n\tcase DW_CFA_def_cfa_offset:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003eregs.cfa_offset = utmp;\n\t  /* cfa_how deliberately not set.  */\n\t  break;\n\n\tcase DW_CFA_def_cfa_expression:\n\t  fs-\u003eregs.cfa_exp = insn_ptr;\n\t  fs-\u003eregs.cfa_how = CFA_EXP;\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  insn_ptr += utmp;\n\t  break;\n\n\tcase DW_CFA_expression:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_EXP;\n\t      fs-\u003eregs.reg[reg].loc.exp = insn_ptr;\n\t    }\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  insn_ptr += utmp;\n\t  break;\n\n\t  /* Dwarf3.  */\n\tcase DW_CFA_offset_extended_sf:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026stmp);\n\t  offset = stmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = offset;\n\t    }\n\t  break;\n\n\tcase DW_CFA_def_cfa_sf:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  fs-\u003eregs.cfa_reg = (_Unwind_Word)utmp;\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026stmp);\n\t  fs-\u003eregs.cfa_offset = (_Unwind_Sword)stmp;\n\t  fs-\u003eregs.cfa_how = CFA_REG_OFFSET;\n\t  fs-\u003eregs.cfa_offset *= fs-\u003edata_align;\n\t  break;\n\n\tcase DW_CFA_def_cfa_offset_sf:\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026stmp);\n\t  fs-\u003eregs.cfa_offset = (_Unwind_Sword)stmp;\n\t  fs-\u003eregs.cfa_offset *= fs-\u003edata_align;\n\t  /* cfa_how deliberately not set.  */\n\t  break;\n\n\tcase DW_CFA_val_offset:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Sword) utmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_VAL_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = offset;\n\t    }\n\t  break;\n\n\tcase DW_CFA_val_offset_sf:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_sleb128 (insn_ptr, \u0026stmp);\n\t  offset = stmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_VAL_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = offset;\n\t    }\n\t  break;\n\n\tcase DW_CFA_val_expression:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_VAL_EXP;\n\t      fs-\u003eregs.reg[reg].loc.exp = insn_ptr;\n\t    }\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  insn_ptr += utmp;\n\t  break;\n\n\tcase DW_CFA_GNU_window_save:\n#if defined (__aarch64__) \u0026\u0026 !defined (__ILP32__)\n\t  /* This CFA is multiplexed with Sparc.  On AArch64 it's used to toggle\n\t     return address signing status.  */\n\t  fs-\u003eregs.reg[DWARF_REGNUM_AARCH64_RA_STATE].loc.offset ^= 1;\n#else\n\t  /* ??? Hardcoded for SPARC register window configuration.  */\n\t  if (__LIBGCC_DWARF_FRAME_REGISTERS__ \u003e= 32)\n\t    for (reg = 16; reg \u003c 32; ++reg)\n\t      {\n\t\tfs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t\tfs-\u003eregs.reg[reg].loc.offset = (reg - 16) * sizeof (void *);\n\t      }\n#endif\n\t  break;\n\n\tcase DW_CFA_GNU_args_size:\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  context-\u003eargs_size = (_Unwind_Word)utmp;\n\t  break;\n\n\tcase DW_CFA_GNU_negative_offset_extended:\n\t  /* Obsoleted by DW_CFA_offset_extended_sf, but used by\n\t     older PowerPC code.  */\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026reg);\n\t  insn_ptr = read_uleb128 (insn_ptr, \u0026utmp);\n\t  offset = (_Unwind_Word) utmp * fs-\u003edata_align;\n\t  reg = DWARF_REG_TO_UNWIND_COLUMN (reg);\n\t  if (UNWIND_COLUMN_IN_RANGE (reg))\n\t    {\n\t      fs-\u003eregs.reg[reg].how = REG_SAVED_OFFSET;\n\t      fs-\u003eregs.reg[reg].loc.offset = -offset;\n\t    }\n\t  break;\n\n\tdefault:\n\t  gcc_unreachable ();\n\t}\n    }\n}","filepath":"libgcc/unwind-dw2.c","line_number":949,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5780736":{"score":0.62878937,"function_name":"uw_frame_state_for","code":"static _Unwind_Reason_Code\nuw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n{\n  const struct dwarf_fde *fde;\n  const struct dwarf_cie *cie;\n  const unsigned char *aug, *insn, *end;\n\n  memset (fs, 0, sizeof (*fs));\n  context-\u003eargs_size = 0;\n  context-\u003elsda = 0;\n\n  if (context-\u003era == 0)\n    return _URC_END_OF_STACK;\n\n  fde = _Unwind_Find_FDE (context-\u003era + _Unwind_IsSignalFrame (context) - 1,\n\t\t\t  \u0026context-\u003ebases);\n  if (fde == NULL)\n    {\n#ifdef MD_FALLBACK_FRAME_STATE_FOR\n      /* Couldn't find frame unwind info for this function.  Try a\n\t target-specific fallback mechanism.  This will necessarily\n\t not provide a personality routine or LSDA.  */\n      return MD_FALLBACK_FRAME_STATE_FOR (context, fs);\n#else\n      return _URC_END_OF_STACK;\n#endif\n    }\n\n  fs-\u003epc = context-\u003ebases.func;\n\n  cie = get_cie (fde);\n  insn = extract_cie_info (cie, context, fs);\n  if (insn == NULL)\n    /* CIE contained unknown augmentation.  */\n    return _URC_FATAL_PHASE1_ERROR;\n\n  /* First decode all the insns in the CIE.  */\n  end = (const unsigned char *) next_fde ((const struct dwarf_fde *) cie);\n  execute_cfa_program (insn, end, context, fs);\n\n  /* Locate augmentation for the fde.  */\n  aug = (const unsigned char *) fde + sizeof (*fde);\n  aug += 2 * size_of_encoded_value (fs-\u003efde_encoding);\n  insn = NULL;\n  if (fs-\u003esaw_z)\n    {\n      _uleb128_t i;\n      aug = read_uleb128 (aug, \u0026i);\n      insn = aug + i;\n    }\n  if (fs-\u003elsda_encoding != DW_EH_PE_omit)\n    {\n      _Unwind_Ptr lsda;\n\n      aug = read_encoded_value (context, fs-\u003elsda_encoding, aug, \u0026lsda);\n      context-\u003elsda = (void *) lsda;\n    }\n\n  /* Then the insns in the FDE up to our target PC.  */\n  if (insn == NULL)\n    insn = aug;\n  end = (const unsigned char *) next_fde (fde);\n  execute_cfa_program (insn, end, context, fs);\n\n  return _URC_NO_REASON;\n}","filepath":"libgcc/unwind-dw2.c","line_number":1249,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5782352":{"score":0.78972274,"function_name":"execute_stack_op","code":"static _Unwind_Word\nexecute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n\t\t  struct _Unwind_Context *context, _Unwind_Word initial)\n{\n  _Unwind_Word stack[64];\t/* ??? Assume this is enough.  */\n  int stack_elt;\n\n  stack[0] = initial;\n  stack_elt = 1;\n\n  while (op_ptr \u003c op_end)\n    {\n      enum dwarf_location_atom op = *op_ptr++;\n      _Unwind_Word result;\n      _uleb128_t reg, utmp;\n      _sleb128_t offset, stmp;\n\n      switch (op)\n\t{\n\tcase DW_OP_lit0:\n\tcase DW_OP_lit1:\n\tcase DW_OP_lit2:\n\tcase DW_OP_lit3:\n\tcase DW_OP_lit4:\n\tcase DW_OP_lit5:\n\tcase DW_OP_lit6:\n\tcase DW_OP_lit7:\n\tcase DW_OP_lit8:\n\tcase DW_OP_lit9:\n\tcase DW_OP_lit10:\n\tcase DW_OP_lit11:\n\tcase DW_OP_lit12:\n\tcase DW_OP_lit13:\n\tcase DW_OP_lit14:\n\tcase DW_OP_lit15:\n\tcase DW_OP_lit16:\n\tcase DW_OP_lit17:\n\tcase DW_OP_lit18:\n\tcase DW_OP_lit19:\n\tcase DW_OP_lit20:\n\tcase DW_OP_lit21:\n\tcase DW_OP_lit22:\n\tcase DW_OP_lit23:\n\tcase DW_OP_lit24:\n\tcase DW_OP_lit25:\n\tcase DW_OP_lit26:\n\tcase DW_OP_lit27:\n\tcase DW_OP_lit28:\n\tcase DW_OP_lit29:\n\tcase DW_OP_lit30:\n\tcase DW_OP_lit31:\n\t  result = op - DW_OP_lit0;\n\t  break;\n\n\tcase DW_OP_addr:\n\t  result = (_Unwind_Word) (_Unwind_Ptr) read_pointer (op_ptr);\n\t  op_ptr += sizeof (void *);\n\t  break;\n\n\tcase DW_OP_GNU_encoded_addr:\n\t  {\n\t    _Unwind_Ptr presult;\n\t    op_ptr = read_encoded_value (context, *op_ptr, op_ptr+1, \u0026presult);\n\t    result = presult;\n\t  }\n\t  break;\n\n\tcase DW_OP_const1u:\n\t  result = read_1u (op_ptr);\n\t  op_ptr += 1;\n\t  break;\n\tcase DW_OP_const1s:\n\t  result = read_1s (op_ptr);\n\t  op_ptr += 1;\n\t  break;\n\tcase DW_OP_const2u:\n\t  result = read_2u (op_ptr);\n\t  op_ptr += 2;\n\t  break;\n\tcase DW_OP_const2s:\n\t  result = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  break;\n\tcase DW_OP_const4u:\n\t  result = read_4u (op_ptr);\n\t  op_ptr += 4;\n\t  break;\n\tcase DW_OP_const4s:\n\t  result = read_4s (op_ptr);\n\t  op_ptr += 4;\n\t  break;\n\tcase DW_OP_const8u:\n\t  result = read_8u (op_ptr);\n\t  op_ptr += 8;\n\t  break;\n\tcase DW_OP_const8s:\n\t  result = read_8s (op_ptr);\n\t  op_ptr += 8;\n\t  break;\n\tcase DW_OP_constu:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026utmp);\n\t  result = (_Unwind_Word)utmp;\n\t  break;\n\tcase DW_OP_consts:\n\t  op_ptr = read_sleb128 (op_ptr, \u0026stmp);\n\t  result = (_Unwind_Sword)stmp;\n\t  break;\n\n\tcase DW_OP_reg0:\n\tcase DW_OP_reg1:\n\tcase DW_OP_reg2:\n\tcase DW_OP_reg3:\n\tcase DW_OP_reg4:\n\tcase DW_OP_reg5:\n\tcase DW_OP_reg6:\n\tcase DW_OP_reg7:\n\tcase DW_OP_reg8:\n\tcase DW_OP_reg9:\n\tcase DW_OP_reg10:\n\tcase DW_OP_reg11:\n\tcase DW_OP_reg12:\n\tcase DW_OP_reg13:\n\tcase DW_OP_reg14:\n\tcase DW_OP_reg15:\n\tcase DW_OP_reg16:\n\tcase DW_OP_reg17:\n\tcase DW_OP_reg18:\n\tcase DW_OP_reg19:\n\tcase DW_OP_reg20:\n\tcase DW_OP_reg21:\n\tcase DW_OP_reg22:\n\tcase DW_OP_reg23:\n\tcase DW_OP_reg24:\n\tcase DW_OP_reg25:\n\tcase DW_OP_reg26:\n\tcase DW_OP_reg27:\n\tcase DW_OP_reg28:\n\tcase DW_OP_reg29:\n\tcase DW_OP_reg30:\n\tcase DW_OP_reg31:\n\t  result = _Unwind_GetGR (context, op - DW_OP_reg0);\n\t  break;\n\tcase DW_OP_regx:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026reg);\n\t  result = _Unwind_GetGR (context, reg);\n\t  break;\n\n\tcase DW_OP_breg0:\n\tcase DW_OP_breg1:\n\tcase DW_OP_breg2:\n\tcase DW_OP_breg3:\n\tcase DW_OP_breg4:\n\tcase DW_OP_breg5:\n\tcase DW_OP_breg6:\n\tcase DW_OP_breg7:\n\tcase DW_OP_breg8:\n\tcase DW_OP_breg9:\n\tcase DW_OP_breg10:\n\tcase DW_OP_breg11:\n\tcase DW_OP_breg12:\n\tcase DW_OP_breg13:\n\tcase DW_OP_breg14:\n\tcase DW_OP_breg15:\n\tcase DW_OP_breg16:\n\tcase DW_OP_breg17:\n\tcase DW_OP_breg18:\n\tcase DW_OP_breg19:\n\tcase DW_OP_breg20:\n\tcase DW_OP_breg21:\n\tcase DW_OP_breg22:\n\tcase DW_OP_breg23:\n\tcase DW_OP_breg24:\n\tcase DW_OP_breg25:\n\tcase DW_OP_breg26:\n\tcase DW_OP_breg27:\n\tcase DW_OP_breg28:\n\tcase DW_OP_breg29:\n\tcase DW_OP_breg30:\n\tcase DW_OP_breg31:\n\t  op_ptr = read_sleb128 (op_ptr, \u0026offset);\n\t  result = _Unwind_GetGR (context, op - DW_OP_breg0) + offset;\n\t  break;\n\tcase DW_OP_bregx:\n\t  op_ptr = read_uleb128 (op_ptr, \u0026reg);\n\t  op_ptr = read_sleb128 (op_ptr, \u0026offset);\n\t  result = _Unwind_GetGR (context, reg) + (_Unwind_Word)offset;\n\t  break;\n\n\tcase DW_OP_dup:\n\t  gcc_assert (stack_elt);\n\t  result = stack[stack_elt - 1];\n\t  break;\n\n\tcase DW_OP_drop:\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\t  goto no_push;\n\n\tcase DW_OP_pick:\n\t  offset = *op_ptr++;\n\t  gcc_assert (offset \u003c stack_elt - 1);\n\t  result = stack[stack_elt - 1 - offset];\n\t  break;\n\n\tcase DW_OP_over:\n\t  gcc_assert (stack_elt \u003e= 2);\n\t  result = stack[stack_elt - 2];\n\t  break;\n\n\tcase DW_OP_swap:\n\t  {\n\t    _Unwind_Word t;\n\t    gcc_assert (stack_elt \u003e= 2);\n\t    t = stack[stack_elt - 1];\n\t    stack[stack_elt - 1] = stack[stack_elt - 2];\n\t    stack[stack_elt - 2] = t;\n\t    goto no_push;\n\t  }\n\n\tcase DW_OP_rot:\n\t  {\n\t    _Unwind_Word t1, t2, t3;\n\n\t    gcc_assert (stack_elt \u003e= 3);\n\t    t1 = stack[stack_elt - 1];\n\t    t2 = stack[stack_elt - 2];\n\t    t3 = stack[stack_elt - 3];\n\t    stack[stack_elt - 1] = t2;\n\t    stack[stack_elt - 2] = t3;\n\t    stack[stack_elt - 3] = t1;\n\t    goto no_push;\n\t  }\n\n\tcase DW_OP_deref:\n\tcase DW_OP_deref_size:\n\tcase DW_OP_abs:\n\tcase DW_OP_neg:\n\tcase DW_OP_not:\n\tcase DW_OP_plus_uconst:\n\t  /* Unary operations.  */\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\n\t  result = stack[stack_elt];\n\n\t  switch (op)\n\t    {\n\t    case DW_OP_deref:\n\t      {\n\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n\t\tresult = (_Unwind_Ptr) read_pointer (ptr);\n\t      }\n\t      break;\n\n\t    case DW_OP_deref_size:\n\t      {\n\t\tvoid *ptr = (void *) (_Unwind_Ptr) result;\n\t\tswitch (*op_ptr++)\n\t\t  {\n\t\t  case 1:\n\t\t    result = read_1u (ptr);\n\t\t    break;\n\t\t  case 2:\n\t\t    result = read_2u (ptr);\n\t\t    break;\n\t\t  case 4:\n\t\t    result = read_4u (ptr);\n\t\t    break;\n\t\t  case 8:\n\t\t    result = read_8u (ptr);\n\t\t    break;\n\t\t  default:\n\t\t    gcc_unreachable ();\n\t\t  }\n\t      }\n\t      break;\n\n\t    case DW_OP_abs:\n\t      if ((_Unwind_Sword) result \u003c 0)\n\t\tresult = -result;\n\t      break;\n\t    case DW_OP_neg:\n\t      result = -result;\n\t      break;\n\t    case DW_OP_not:\n\t      result = ~result;\n\t      break;\n\t    case DW_OP_plus_uconst:\n\t      op_ptr = read_uleb128 (op_ptr, \u0026utmp);\n\t      result += (_Unwind_Word)utmp;\n\t      break;\n\n\t    default:\n\t      gcc_unreachable ();\n\t    }\n\t  break;\n\n\tcase DW_OP_and:\n\tcase DW_OP_div:\n\tcase DW_OP_minus:\n\tcase DW_OP_mod:\n\tcase DW_OP_mul:\n\tcase DW_OP_or:\n\tcase DW_OP_plus:\n\tcase DW_OP_shl:\n\tcase DW_OP_shr:\n\tcase DW_OP_shra:\n\tcase DW_OP_xor:\n\tcase DW_OP_le:\n\tcase DW_OP_ge:\n\tcase DW_OP_eq:\n\tcase DW_OP_lt:\n\tcase DW_OP_gt:\n\tcase DW_OP_ne:\n\t  {\n\t    /* Binary operations.  */\n\t    _Unwind_Word first, second;\n\t    gcc_assert (stack_elt \u003e= 2);\n\t    stack_elt -= 2;\n\n\t    second = stack[stack_elt];\n\t    first = stack[stack_elt + 1];\n\n\t    switch (op)\n\t      {\n\t      case DW_OP_and:\n\t\tresult = second \u0026 first;\n\t\tbreak;\n\t      case DW_OP_div:\n\t\tresult = (_Unwind_Sword) second / (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_minus:\n\t\tresult = second - first;\n\t\tbreak;\n\t      case DW_OP_mod:\n\t\tresult = second % first;\n\t\tbreak;\n\t      case DW_OP_mul:\n\t\tresult = second * first;\n\t\tbreak;\n\t      case DW_OP_or:\n\t\tresult = second | first;\n\t\tbreak;\n\t      case DW_OP_plus:\n\t\tresult = second + first;\n\t\tbreak;\n\t      case DW_OP_shl:\n\t\tresult = second \u003c\u003c first;\n\t\tbreak;\n\t      case DW_OP_shr:\n\t\tresult = second \u003e\u003e first;\n\t\tbreak;\n\t      case DW_OP_shra:\n\t\tresult = (_Unwind_Sword) second \u003e\u003e first;\n\t\tbreak;\n\t      case DW_OP_xor:\n\t\tresult = second ^ first;\n\t\tbreak;\n\t      case DW_OP_le:\n\t\tresult = (_Unwind_Sword) second \u003c= (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_ge:\n\t\tresult = (_Unwind_Sword) second \u003e= (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_eq:\n\t\tresult = (_Unwind_Sword) second == (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_lt:\n\t\tresult = (_Unwind_Sword) second \u003c (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_gt:\n\t\tresult = (_Unwind_Sword) second \u003e (_Unwind_Sword) first;\n\t\tbreak;\n\t      case DW_OP_ne:\n\t\tresult = (_Unwind_Sword) second != (_Unwind_Sword) first;\n\t\tbreak;\n\n\t      default:\n\t\tgcc_unreachable ();\n\t      }\n\t  }\n\t  break;\n\n\tcase DW_OP_skip:\n\t  offset = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  op_ptr += offset;\n\t  goto no_push;\n\n\tcase DW_OP_bra:\n\t  gcc_assert (stack_elt);\n\t  stack_elt -= 1;\n\n\t  offset = read_2s (op_ptr);\n\t  op_ptr += 2;\n\t  if (stack[stack_elt] != 0)\n\t    op_ptr += offset;\n\t  goto no_push;\n\n\tcase DW_OP_nop:\n\t  goto no_push;\n\n\tdefault:\n\t  gcc_unreachable ();\n\t}\n\n      /* Most things push a result value.  */\n      gcc_assert ((size_t) stack_elt \u003c sizeof(stack)/sizeof(*stack));\n      stack[stack_elt++] = result;\n    no_push:;\n    }\n\n  /* We were executing this program to get a value.  It should be\n     at top of stack.  */\n  gcc_assert (stack_elt);\n  stack_elt -= 1;\n  return stack[stack_elt];\n}","filepath":"libgcc/unwind-dw2.c","line_number":525,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5784448":{"score":0.6745664,"function_name":"uw_update_context_1","code":"static void\nuw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n{\n  struct _Unwind_Context orig_context = *context;\n  void *cfa;\n  long i;\n\n#ifdef __LIBGCC_EH_RETURN_STACKADJ_RTX__\n  /* Special handling here: Many machines do not use a frame pointer,\n     and track the CFA only through offsets from the stack pointer from\n     one frame to the next.  In this case, the stack pointer is never\n     stored, so it has no saved address in the context.  What we do\n     have is the CFA from the previous stack frame.\n\n     In very special situations (such as unwind info for signal return),\n     there may be location expressions that use the stack pointer as well.\n\n     Do this conditionally for one frame.  This allows the unwind info\n     for one frame to save a copy of the stack pointer from the previous\n     frame, and be able to use much easier CFA mechanisms to do it.\n     Always zap the saved stack pointer value for the next frame; carrying\n     the value over from one frame to another doesn't make sense.  */\n\n  _Unwind_SpTmp tmp_sp;\n\n  if (!_Unwind_GetGRPtr (\u0026orig_context, __builtin_dwarf_sp_column ()))\n    _Unwind_SetSpColumn (\u0026orig_context, context-\u003ecfa, \u0026tmp_sp);\n  _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), NULL);\n#endif\n\n  /* Compute this frame's CFA.  */\n  switch (fs-\u003eregs.cfa_how)\n    {\n    case CFA_REG_OFFSET:\n      cfa = _Unwind_GetPtr (\u0026orig_context, fs-\u003eregs.cfa_reg);\n      cfa += fs-\u003eregs.cfa_offset;\n      break;\n\n    case CFA_EXP:\n      {\n\tconst unsigned char *exp = fs-\u003eregs.cfa_exp;\n\t_uleb128_t len;\n\n\texp = read_uleb128 (exp, \u0026len);\n\tcfa = (void *) (_Unwind_Ptr)\n\t  execute_stack_op (exp, exp + len, \u0026orig_context, 0);\n\tbreak;\n      }\n\n    default:\n      gcc_unreachable ();\n    }\n  context-\u003ecfa = cfa;\n\n  /* Compute the addresses of all registers saved in this frame.  */\n  for (i = 0; i \u003c __LIBGCC_DWARF_FRAME_REGISTERS__ + 1; ++i)\n    switch (fs-\u003eregs.reg[i].how)\n      {\n      case REG_UNSAVED:\n      case REG_UNDEFINED:\n\tbreak;\n\n      case REG_SAVED_OFFSET:\n\t_Unwind_SetGRPtr (context, i,\n\t\t\t  (void *) (cfa + fs-\u003eregs.reg[i].loc.offset));\n\tbreak;\n\n      case REG_SAVED_REG:\n\tif (_Unwind_GRByValue (\u0026orig_context, fs-\u003eregs.reg[i].loc.reg))\n\t  _Unwind_SetGRValue (context, i,\n\t\t\t      _Unwind_GetGR (\u0026orig_context,\n\t\t\t\t\t     fs-\u003eregs.reg[i].loc.reg));\n\telse\n\t  _Unwind_SetGRPtr (context, i,\n\t\t\t    _Unwind_GetGRPtr (\u0026orig_context,\n\t\t\t\t\t      fs-\u003eregs.reg[i].loc.reg));\n\tbreak;\n\n      case REG_SAVED_EXP:\n\t{\n\t  const unsigned char *exp = fs-\u003eregs.reg[i].loc.exp;\n\t  _uleb128_t len;\n\t  _Unwind_Ptr val;\n\n\t  exp = read_uleb128 (exp, \u0026len);\n\t  val = execute_stack_op (exp, exp + len, \u0026orig_context,\n\t\t\t\t  (_Unwind_Ptr) cfa);\n\t  _Unwind_SetGRPtr (context, i, (void *) val);\n\t}\n\tbreak;\n\n      case REG_SAVED_VAL_OFFSET:\n\t_Unwind_SetGRValue (context, i,\n\t\t\t    (_Unwind_Internal_Ptr)\n\t\t\t    (cfa + fs-\u003eregs.reg[i].loc.offset));\n\tbreak;\n\n      case REG_SAVED_VAL_EXP:\n\t{\n\t  const unsigned char *exp = fs-\u003eregs.reg[i].loc.exp;\n\t  _uleb128_t len;\n\t  _Unwind_Ptr val;\n\n\t  exp = read_uleb128 (exp, \u0026len);\n\t  val = execute_stack_op (exp, exp + len, \u0026orig_context,\n\t\t\t\t  (_Unwind_Ptr) cfa);\n\t  _Unwind_SetGRValue (context, i, val);\n\t}\n\tbreak;\n      }\n\n  _Unwind_SetSignalFrame (context, fs-\u003esignal_frame);\n\n#ifdef MD_FROB_UPDATE_CONTEXT\n  MD_FROB_UPDATE_CONTEXT (context, fs);\n#endif\n}","filepath":"libgcc/unwind-dw2.c","line_number":1398,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5785440":{"score":0.6473918,"function_name":"uw_init_context_1","code":"static void __attribute__((noinline))\nuw_init_context_1 (struct _Unwind_Context *context,\n\t\t   void *outer_cfa, void *outer_ra)\n{\n  void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n  _Unwind_FrameState fs;\n  _Unwind_SpTmp sp_slot;\n  _Unwind_Reason_Code code;\n\n  memset (context, 0, sizeof (struct _Unwind_Context));\n  context-\u003era = ra;\n  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n    context-\u003eflags = EXTENDED_CONTEXT_BIT;\n\n  code = uw_frame_state_for (context, \u0026fs);\n  gcc_assert (code == _URC_NO_REASON);\n\n#if __GTHREADS\n  {\n    static __gthread_once_t once_regsizes = __GTHREAD_ONCE_INIT;\n    if (__gthread_once (\u0026once_regsizes, init_dwarf_reg_size_table) != 0\n\t\u0026\u0026 dwarf_reg_size_table[0] == 0)\n      init_dwarf_reg_size_table ();\n  }\n#else\n  if (dwarf_reg_size_table[0] == 0)\n    init_dwarf_reg_size_table ();\n#endif\n\n  /* Force the frame state to use the known cfa value.  */\n  _Unwind_SetSpColumn (context, outer_cfa, \u0026sp_slot);\n  fs.regs.cfa_how = CFA_REG_OFFSET;\n  fs.regs.cfa_reg = __builtin_dwarf_sp_column ();\n  fs.regs.cfa_offset = 0;\n\n  uw_update_context_1 (context, \u0026fs);\n\n  /* If the return address column was saved in a register in the\n     initialization context, then we can't see it in the given\n     call frame data.  So have the initialization context tell us.  */\n  context-\u003era = __builtin_extract_return_addr (outer_ra);\n}","filepath":"libgcc/unwind-dw2.c","line_number":1578,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5785824":{"score":0.8194462,"function_name":"uw_update_context","code":"static void\nuw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n{\n  uw_update_context_1 (context, fs);\n\n  /* In general this unwinder doesn't make any distinction between\n     undefined and same_value rule.  Call-saved registers are assumed\n     to have same_value rule by default and explicit undefined\n     rule is handled like same_value.  The only exception is\n     DW_CFA_undefined on retaddr_column which is supposed to\n     mark outermost frame in DWARF 3.  */\n  if (fs-\u003eregs.reg[DWARF_REG_TO_UNWIND_COLUMN (fs-\u003eretaddr_column)].how\n      == REG_UNDEFINED)\n    /* uw_frame_state_for uses context-\u003era == 0 check to find outermost\n       stack frame.  */\n    context-\u003era = 0;\n  else\n    {\n      /* Compute the return address now, since the return address column\n\t can change from frame to frame.  */\n      void *ret_addr;\n#ifdef MD_DEMANGLE_RETURN_ADDR\n      _Unwind_Word ra = _Unwind_GetGR (context, fs-\u003eretaddr_column);\n      ret_addr = MD_DEMANGLE_RETURN_ADDR (context, fs, ra);\n#else\n      ret_addr = _Unwind_GetPtr (context, fs-\u003eretaddr_column);\n#endif\n      context-\u003era = __builtin_extract_return_addr (ret_addr);\n    }\n}","filepath":"libgcc/unwind-dw2.c","line_number":1521,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5786384":{"score":0.7059859,"function_name":"uw_install_context_1","code":"static long\nuw_install_context_1 (struct _Unwind_Context *current,\n\t\t      struct _Unwind_Context *target)\n{\n  long i;\n  _Unwind_SpTmp sp_slot;\n\n  /* If the target frame does not have a saved stack pointer,\n     then set up the target's CFA.  */\n  if (!_Unwind_GetGRPtr (target, __builtin_dwarf_sp_column ()))\n    _Unwind_SetSpColumn (target, target-\u003ecfa, \u0026sp_slot);\n\n  for (i = 0; i \u003c __LIBGCC_DWARF_FRAME_REGISTERS__; ++i)\n    {\n      void *c = (void *) (_Unwind_Internal_Ptr) current-\u003ereg[i];\n      void *t = (void *) (_Unwind_Internal_Ptr)target-\u003ereg[i];\n\n      gcc_assert (current-\u003eby_value[i] == 0);\n      if (target-\u003eby_value[i] \u0026\u0026 c)\n\t{\n\t  _Unwind_Word w;\n\t  _Unwind_Ptr p;\n\t  if (dwarf_reg_size_table[i] == sizeof (_Unwind_Word))\n\t    {\n\t      w = (_Unwind_Internal_Ptr) t;\n\t      memcpy (c, \u0026w, sizeof (_Unwind_Word));\n\t    }\n\t  else\n\t    {\n\t      gcc_assert (dwarf_reg_size_table[i] == sizeof (_Unwind_Ptr));\n\t      p = (_Unwind_Internal_Ptr) t;\n\t      memcpy (c, \u0026p, sizeof (_Unwind_Ptr));\n\t    }\n\t}\n      else if (t \u0026\u0026 c \u0026\u0026 t != c)\n\tmemcpy (c, t, dwarf_reg_size_table[i]);\n    }\n\n  /* If the current frame doesn't have a saved stack pointer, then we\n     need to rely on EH_RETURN_STACKADJ_RTX to get our target stack\n     pointer value reloaded.  */\n  if (!_Unwind_GetGRPtr (current, __builtin_dwarf_sp_column ()))\n    {\n      void *target_cfa;\n\n      target_cfa = _Unwind_GetPtr (target, __builtin_dwarf_sp_column ());\n\n      /* We adjust SP by the difference between CURRENT and TARGET's CFA.  */\n      if (__LIBGCC_STACK_GROWS_DOWNWARD__)\n\treturn target_cfa - current-\u003ecfa + target-\u003eargs_size;\n      else\n\treturn current-\u003ecfa - target_cfa - target-\u003eargs_size;\n    }\n  return 0;\n}","filepath":"libgcc/unwind-dw2.c","line_number":1659,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5786832":{"score":0.7551267,"function_name":"_Unwind_GetGRPtr","code":"static inline void *\n_Unwind_GetGRPtr (struct _Unwind_Context *context, int index)\n{\n  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n  if (_Unwind_IsExtendedContext (context) \u0026\u0026 context-\u003eby_value[index])\n    return \u0026context-\u003ereg[index];\n  return (void *) (_Unwind_Internal_Ptr) context-\u003ereg[index];\n}","filepath":"libgcc/unwind-dw2.c","line_number":304,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5786928":{"score":0.70417655,"function_name":"_Unwind_SetGR","code":"inline void\n_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n{\n  int size;\n  void *ptr;\n\n  index = DWARF_REG_TO_UNWIND_COLUMN (index);\n  gcc_assert (index \u003c (int) sizeof(dwarf_reg_size_table));\n  size = dwarf_reg_size_table[index];\n\n  if (_Unwind_IsExtendedContext (context) \u0026\u0026 context-\u003eby_value[index])\n    {\n      context-\u003ereg[index] = _Unwind_Get_Unwind_Context_Reg_Val (val);\n      return;\n    }\n\n  ptr = (void *) (_Unwind_Internal_Ptr) context-\u003ereg[index];\n\n  if (size == sizeof(_Unwind_Ptr))\n    * (_Unwind_Ptr *) ptr = val;\n  else\n    {\n      gcc_assert (size == sizeof(_Unwind_Word));\n      * (_Unwind_Word *) ptr = val;\n    }\n}","filepath":"libgcc/unwind-dw2.c","line_number":275,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5787136":{"score":0.8863614,"function_name":"_Unwind_FindEnclosingFunction","code":"void *\n_Unwind_FindEnclosingFunction (void *pc)\n{\n  struct dwarf_eh_bases bases;\n  const struct dwarf_fde *fde = _Unwind_Find_FDE (pc-1, \u0026bases);\n  if (fde)\n    return bases.func;\n  else\n    return NULL;\n}","filepath":"libgcc/unwind-dw2.c","line_number":387,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5787216":{"score":0.8804756,"function_name":"__frame_state_for","code":"struct frame_state *\n__frame_state_for (void *pc_target, struct frame_state *state_in)\n{\n  struct _Unwind_Context context;\n  _Unwind_FrameState fs;\n  int reg;\n\n  memset (\u0026context, 0, sizeof (struct _Unwind_Context));\n  if (!ASSUME_EXTENDED_UNWIND_CONTEXT)\n    context.flags = EXTENDED_CONTEXT_BIT;\n  context.ra = pc_target + 1;\n\n  if (uw_frame_state_for (\u0026context, \u0026fs) != _URC_NO_REASON)\n    return 0;\n\n  /* We have no way to pass a location expression for the CFA to our\n     caller.  It wouldn't understand it anyway.  */\n  if (fs.regs.cfa_how == CFA_EXP)\n    return 0;\n\n  for (reg = 0; reg \u003c PRE_GCC3_DWARF_FRAME_REGISTERS + 1; reg++)\n    {\n      state_in-\u003esaved[reg] = fs.regs.reg[reg].how;\n      switch (state_in-\u003esaved[reg])\n\t{\n\tcase REG_SAVED_REG:\n\t  state_in-\u003ereg_or_offset[reg] = fs.regs.reg[reg].loc.reg;\n\t  break;\n\tcase REG_SAVED_OFFSET:\n\t  state_in-\u003ereg_or_offset[reg] = fs.regs.reg[reg].loc.offset;\n\t  break;\n\tdefault:\n\t  state_in-\u003ereg_or_offset[reg] = 0;\n\t  break;\n\t}\n    }\n\n  state_in-\u003ecfa_offset = fs.regs.cfa_offset;\n  state_in-\u003ecfa_reg = fs.regs.cfa_reg;\n  state_in-\u003eretaddr_column = fs.retaddr_column;\n  state_in-\u003eargs_size = context.args_size;\n  state_in-\u003eeh_ptr = fs.eh_ptr;\n\n  return state_in;\n}","filepath":"libgcc/unwind-dw2.c","line_number":1334,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-10.2.0"},"5788688":{"score":0.8443398,"function_name":"fde_unencoded_compare","code":"static int\nfde_unencoded_compare (struct object *ob __attribute__((unused)),\n\t\t       const fde *x, const fde *y)\n{\n  _Unwind_Ptr x_ptr, y_ptr;\n  memcpy (\u0026x_ptr, x-\u003epc_begin, sizeof (_Unwind_Ptr));\n  memcpy (\u0026y_ptr, y-\u003epc_begin, sizeof (_Unwind_Ptr));\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":329,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5788720":{"score":0.93287,"function_name":"frame_downheap","code":"static void\nframe_downheap (struct object *ob, fde_compare_t fde_compare, const fde **a,\n\t\tint lo, int hi)\n{\n  int i, j;\n\n  for (i = lo, j = 2*i+1;\n       j \u003c hi;\n       j = 2*i+1)\n    {\n      if (j+1 \u003c hi \u0026\u0026 fde_compare (ob, a[j], a[j+1]) \u003c 0)\n\t++j;\n\n      if (fde_compare (ob, a[i], a[j]) \u003c 0)\n\t{\n\t  SWAP (a[i], a[j]);\n\t  i = j;\n\t}\n      else\n\tbreak;\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":485,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5788928":{"score":0.90803444,"function_name":"frame_heapsort","code":"static void\nframe_heapsort (struct object *ob, fde_compare_t fde_compare,\n\t\tstruct fde_vector *erratic)\n{\n  /* For a description of this algorithm, see:\n     Samuel P. Harbison, Guy L. Steele Jr.: C, a reference manual, 2nd ed.,\n     p. 60-61.  */\n  const fde ** a = erratic-\u003earray;\n  /* A portion of the array is called a \"heap\" if for all i\u003e=0:\n     If i and 2i+1 are valid indices, then a[i] \u003e= a[2i+1].\n     If i and 2i+2 are valid indices, then a[i] \u003e= a[2i+2].  */\n  size_t n = erratic-\u003ecount;\n  int m;\n\n  /* Expand our heap incrementally from the end of the array, heapifying\n     each resulting semi-heap as we go.  After each step, a[m] is the top\n     of a heap.  */\n  for (m = n/2-1; m \u003e= 0; --m)\n    frame_downheap (ob, fde_compare, a, m, n);\n\n  /* Shrink our heap incrementally from the end of the array, first\n     swapping out the largest element a[0] and then re-heapifying the\n     resulting semi-heap.  After each step, a[0..m) is a heap.  */\n  for (m = n-1; m \u003e= 1; --m)\n    {\n      SWAP (a[0], a[m]);\n      frame_downheap (ob, fde_compare, a, 0, m);\n    }\n#undef SWAP\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":511,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5789216":{"score":0.8040272,"function_name":"base_from_object","code":"static _Unwind_Ptr\nbase_from_object (unsigned char encoding, struct object *ob)\n{\n  if (encoding == DW_EH_PE_omit)\n    return 0;\n\n  switch (encoding \u0026 0x70)\n    {\n    case DW_EH_PE_absptr:\n    case DW_EH_PE_pcrel:\n    case DW_EH_PE_aligned:\n      return 0;\n\n    case DW_EH_PE_textrel:\n      return (_Unwind_Ptr) ob-\u003etbase;\n    case DW_EH_PE_datarel:\n      return (_Unwind_Ptr) ob-\u003edbase;\n    default:\n      gcc_unreachable ();\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":238,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5789744":{"score":0.9053969,"function_name":"fde_single_encoding_compare","code":"static int\nfde_single_encoding_compare (struct object *ob, const fde *x, const fde *y)\n{\n  _Unwind_Ptr base, x_ptr, y_ptr;\n\n  base = base_from_object (ob-\u003es.b.encoding, ob);\n  read_encoded_value_with_base (ob-\u003es.b.encoding, base, x-\u003epc_begin, \u0026x_ptr);\n  read_encoded_value_with_base (ob-\u003es.b.encoding, base, y-\u003epc_begin, \u0026y_ptr);\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":344,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5789888":{"score":0.7564021,"function_name":"get_cie_encoding","code":"static int\nget_cie_encoding (const struct dwarf_cie *cie)\n{\n  const unsigned char *aug, *p;\n  _Unwind_Ptr dummy;\n  _uleb128_t utmp;\n  _sleb128_t stmp;\n\n  aug = cie-\u003eaugmentation;\n  p = aug + strlen ((const char *)aug) + 1; /* Skip the augmentation string.  */\n  if (__builtin_expect (cie-\u003eversion \u003e= 4, 0))\n    {\n      if (p[0] != sizeof (void *) || p[1] != 0)\n\treturn DW_EH_PE_omit;\t\t/* We are not prepared to handle unexpected\n\t\t\t\t\t   address sizes or segment selectors.  */\n      p += 2;\t\t\t\t/* Skip address size and segment size.  */\n    }\n\n  if (aug[0] != 'z')\n    return DW_EH_PE_absptr;\n\n  p = read_uleb128 (p, \u0026utmp);\t\t/* Skip code alignment.  */\n  p = read_sleb128 (p, \u0026stmp);\t\t/* Skip data alignment.  */\n  if (cie-\u003eversion == 1)\t\t/* Skip return address column.  */\n    p++;\n  else\n    p = read_uleb128 (p, \u0026utmp);\n\n  aug++;\t\t\t\t/* Skip 'z' */\n  p = read_uleb128 (p, \u0026utmp);\t\t/* Skip augmentation length.  */\n  while (1)\n    {\n      /* This is what we're looking for.  */\n      if (*aug == 'R')\n\treturn *p;\n      /* Personality encoding and pointer.  */\n      else if (*aug == 'P')\n\t{\n\t  /* ??? Avoid dereferencing indirect pointers, since we're\n\t     faking the base address.  Gotta keep DW_EH_PE_aligned\n\t     intact, however.  */\n\t  p = read_encoded_value_with_base (*p \u0026 0x7F, 0, p + 1, \u0026dummy);\n\t}\n      /* LSDA encoding.  */\n      else if (*aug == 'L')\n\tp++;\n      /* Otherwise end of string, or unknown augmentation.  */\n      else\n\treturn DW_EH_PE_absptr;\n      aug++;\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":263,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5790176":{"score":0.8135619,"function_name":"linear_search_fdes","code":"static const fde *\nlinear_search_fdes (struct object *ob, const fde *this_fde, void *pc)\n{\n  const struct dwarf_cie *last_cie = 0;\n  int encoding = ob-\u003es.b.encoding;\n  _Unwind_Ptr base = base_from_object (ob-\u003es.b.encoding, ob);\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n      _Unwind_Ptr pc_begin, pc_range;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      if (ob-\u003es.b.mixed_encoding)\n\t{\n\t  /* Determine the encoding for this FDE.  Note mixed encoded\n\t     objects for later.  */\n\t  this_cie = get_cie (this_fde);\n\t  if (this_cie != last_cie)\n\t    {\n\t      last_cie = this_cie;\n\t      encoding = get_cie_encoding (this_cie);\n\t      base = base_from_object (encoding, ob);\n\t    }\n\t}\n\n      if (encoding == DW_EH_PE_absptr)\n\t{\n\t  const _Unwind_Ptr *pc_array = (const _Unwind_Ptr *) this_fde-\u003epc_begin;\n\t  pc_begin = pc_array[0];\n\t  pc_range = pc_array[1];\n\t  if (pc_begin == 0)\n\t    continue;\n\t}\n      else\n\t{\n\t  _Unwind_Ptr mask;\n\t  const unsigned char *p;\n\n\t  p = read_encoded_value_with_base (encoding, base,\n\t\t\t\t\t    this_fde-\u003epc_begin, \u0026pc_begin);\n\t  read_encoded_value_with_base (encoding \u0026 0x0F, 0, p, \u0026pc_range);\n\n\t  /* Take care to ignore link-once functions that were removed.\n\t     In these cases, the function address will be NULL, but if\n\t     the encoding is smaller than a pointer a true NULL may not\n\t     be representable.  Assume 0 in the representable bits is NULL.  */\n\t  mask = size_of_encoded_value (encoding);\n\t  if (mask \u003c sizeof (void *))\n\t    mask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n\t  else\n\t    mask = -1;\n\n\t  if ((pc_begin \u0026 mask) == 0)\n\t    continue;\n\t}\n\n      if ((_Unwind_Ptr) pc - pc_begin \u003c pc_range)\n\treturn this_fde;\n    }\n\n  return NULL;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":797,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5791728":{"score":0.8943553,"function_name":"fde_mixed_encoding_compare","code":"static int\nfde_mixed_encoding_compare (struct object *ob, const fde *x, const fde *y)\n{\n  int x_encoding, y_encoding;\n  _Unwind_Ptr x_ptr, y_ptr;\n\n  x_encoding = get_fde_encoding (x);\n  read_encoded_value_with_base (x_encoding, base_from_object (x_encoding, ob),\n\t\t\t\tx-\u003epc_begin, \u0026x_ptr);\n\n  y_encoding = get_fde_encoding (y);\n  read_encoded_value_with_base (y_encoding, base_from_object (y_encoding, ob),\n\t\t\t\ty-\u003epc_begin, \u0026y_ptr);\n\n  if (x_ptr \u003e y_ptr)\n    return 1;\n  if (x_ptr \u003c y_ptr)\n    return -1;\n  return 0;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":360,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5791888":{"score":0.7655983,"function_name":"classify_object_over_fdes","code":"static size_t\nclassify_object_over_fdes (struct object *ob, const fde *this_fde)\n{\n  const struct dwarf_cie *last_cie = 0;\n  size_t count = 0;\n  int encoding = DW_EH_PE_absptr;\n  _Unwind_Ptr base = 0;\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n      _Unwind_Ptr mask, pc_begin;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      /* Determine the encoding for this FDE.  Note mixed encoded\n\t objects for later.  */\n      this_cie = get_cie (this_fde);\n      if (this_cie != last_cie)\n\t{\n\t  last_cie = this_cie;\n\t  encoding = get_cie_encoding (this_cie);\n\t  if (encoding == DW_EH_PE_omit)\n\t    return -1;\n\t  base = base_from_object (encoding, ob);\n\t  if (ob-\u003es.b.encoding == DW_EH_PE_omit)\n\t    ob-\u003es.b.encoding = encoding;\n\t  else if (ob-\u003es.b.encoding != encoding)\n\t    ob-\u003es.b.mixed_encoding = 1;\n\t}\n\n      read_encoded_value_with_base (encoding, base, this_fde-\u003epc_begin,\n\t\t\t\t    \u0026pc_begin);\n\n      /* Take care to ignore link-once functions that were removed.\n\t In these cases, the function address will be NULL, but if\n\t the encoding is smaller than a pointer a true NULL may not\n\t be representable.  Assume 0 in the representable bits is NULL.  */\n      mask = size_of_encoded_value (encoding);\n      if (mask \u003c sizeof (void *))\n\tmask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n      else\n\tmask = -1;\n\n      if ((pc_begin \u0026 mask) == 0)\n\tcontinue;\n\n      count += 1;\n      if ((void *) pc_begin \u003c ob-\u003epc_begin)\n\tob-\u003epc_begin = (void *) pc_begin;\n    }\n\n  return count;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":605,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5792240":{"score":0.706574,"function_name":"add_fdes","code":"static void\nadd_fdes (struct object *ob, struct fde_accumulator *accu, const fde *this_fde)\n{\n  const struct dwarf_cie *last_cie = 0;\n  int encoding = ob-\u003es.b.encoding;\n  _Unwind_Ptr base = base_from_object (ob-\u003es.b.encoding, ob);\n\n  for (; ! last_fde (ob, this_fde); this_fde = next_fde (this_fde))\n    {\n      const struct dwarf_cie *this_cie;\n\n      /* Skip CIEs.  */\n      if (this_fde-\u003eCIE_delta == 0)\n\tcontinue;\n\n      if (ob-\u003es.b.mixed_encoding)\n\t{\n\t  /* Determine the encoding for this FDE.  Note mixed encoded\n\t     objects for later.  */\n\t  this_cie = get_cie (this_fde);\n\t  if (this_cie != last_cie)\n\t    {\n\t      last_cie = this_cie;\n\t      encoding = get_cie_encoding (this_cie);\n\t      base = base_from_object (encoding, ob);\n\t    }\n\t}\n\n      if (encoding == DW_EH_PE_absptr)\n\t{\n\t  _Unwind_Ptr ptr;\n\t  memcpy (\u0026ptr, this_fde-\u003epc_begin, sizeof (_Unwind_Ptr));\n\t  if (ptr == 0)\n\t    continue;\n\t}\n      else\n\t{\n\t  _Unwind_Ptr pc_begin, mask;\n\n\t  read_encoded_value_with_base (encoding, base, this_fde-\u003epc_begin,\n\t\t\t\t\t\u0026pc_begin);\n\n\t  /* Take care to ignore link-once functions that were removed.\n\t     In these cases, the function address will be NULL, but if\n\t     the encoding is smaller than a pointer a true NULL may not\n\t     be representable.  Assume 0 in the representable bits is NULL.  */\n\t  mask = size_of_encoded_value (encoding);\n\t  if (mask \u003c sizeof (void *))\n\t    mask = (((_Unwind_Ptr) 1) \u003c\u003c (mask \u003c\u003c 3)) - 1;\n\t  else\n\t    mask = -1;\n\n\t  if ((pc_begin \u0026 mask) == 0)\n\t    continue;\n\t}\n\n      fde_insert (accu, this_fde);\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":662,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5792560":{"score":0.6397133,"function_name":"search_object","code":"static const fde *\nsearch_object (struct object* ob, void *pc)\n{\n  /* If the data hasn't been sorted, try to do this now.  We may have\n     more memory available than last time we tried.  */\n  if (! ob-\u003es.b.sorted)\n    {\n      init_object (ob);\n\n      /* Despite the above comment, the normal reason to get here is\n\t that we've not processed this object before.  A quick range\n\t check is in order.  */\n      if (pc \u003c ob-\u003epc_begin)\n\treturn NULL;\n    }\n\n  if (ob-\u003es.b.sorted)\n    {\n      if (ob-\u003es.b.mixed_encoding)\n\treturn binary_search_mixed_encoding_fdes (ob, pc);\n      else if (ob-\u003es.b.encoding == DW_EH_PE_absptr)\n\treturn binary_search_unencoded_fdes (ob, pc);\n      else\n\treturn binary_search_single_encoding_fdes (ob, pc);\n    }\n  else\n    {\n      /* Long slow laborious linear search, cos we've no memory.  */\n      if (ob-\u003es.b.from_array)\n\t{\n\t  fde **p;\n\t  for (p = ob-\u003eu.array; *p ; p++)\n\t    {\n\t      const fde *f = linear_search_fdes (ob, *p, pc);\n\t      if (f)\n\t\treturn f;\n\t    }\n\t  return NULL;\n\t}\n      else\n\treturn linear_search_fdes (ob, ob-\u003eu.single, pc);\n    }\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":954,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5794480":{"score":0.8372824,"function_name":"__register_frame_info_bases","code":"void\n__register_frame_info_bases (const void *begin, struct object *ob,\n\t\t\t     void *tbase, void *dbase)\n{\n  /* If .eh_frame is empty, don't register at all.  */\n  if ((const uword *) begin == 0 || *(const uword *) begin == 0)\n    return;\n\n  ob-\u003epc_begin = (void *)-1;\n  ob-\u003etbase = tbase;\n  ob-\u003edbase = dbase;\n  ob-\u003eu.single = begin;\n  ob-\u003es.i = 0;\n  ob-\u003es.b.encoding = DW_EH_PE_omit;\n#ifdef DWARF2_OBJECT_END_PTR_EXTENSION\n  ob-\u003efde_end = NULL;\n#endif\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  ob-\u003enext = unseen_objects;\n  unseen_objects = ob;\n\n  __gthread_mutex_unlock (\u0026object_mutex);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":76,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5794656":{"score":0.7414429,"function_name":"__register_frame","code":"void\n__register_frame (void *begin)\n{\n  struct object *ob;\n\n  /* If .eh_frame is empty, don't register at all.  */\n  if (*(uword *) begin == 0)\n    return;\n\n  ob = malloc (sizeof (struct object));\n  __register_frame_info (begin, ob);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":109,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5794704":{"score":0.7559242,"function_name":"__register_frame_info_table_bases","code":"void\n__register_frame_info_table_bases (void *begin, struct object *ob,\n\t\t\t\t   void *tbase, void *dbase)\n{\n  ob-\u003epc_begin = (void *)-1;\n  ob-\u003etbase = tbase;\n  ob-\u003edbase = dbase;\n  ob-\u003eu.array = begin;\n  ob-\u003es.i = 0;\n  ob-\u003es.b.from_array = 1;\n  ob-\u003es.b.encoding = DW_EH_PE_omit;\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  ob-\u003enext = unseen_objects;\n  unseen_objects = ob;\n\n  __gthread_mutex_unlock (\u0026object_mutex);\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":126,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5794880":{"score":0.7445969,"function_name":"__deregister_frame_info_bases","code":"void *\n__deregister_frame_info_bases (const void *begin)\n{\n  struct object **p;\n  struct object *ob = 0;\n\n  /* If .eh_frame is empty, we haven't registered.  */\n  if ((const uword *) begin == 0 || *(const uword *) begin == 0)\n    return ob;\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  for (p = \u0026unseen_objects; *p ; p = \u0026(*p)-\u003enext)\n    if ((*p)-\u003eu.single == begin)\n      {\n\tob = *p;\n\t*p = ob-\u003enext;\n\tgoto out;\n      }\n\n  for (p = \u0026seen_objects; *p ; p = \u0026(*p)-\u003enext)\n    if ((*p)-\u003es.b.sorted)\n      {\n\tif ((*p)-\u003eu.sort-\u003eorig_data == begin)\n\t  {\n\t    ob = *p;\n\t    *p = ob-\u003enext;\n\t    free (ob-\u003eu.sort);\n\t    goto out;\n\t  }\n      }\n    else\n      {\n\tif ((*p)-\u003eu.single == begin)\n\t  {\n\t    ob = *p;\n\t    *p = ob-\u003enext;\n\t    goto out;\n\t  }\n      }\n\n out:\n  __gthread_mutex_unlock (\u0026object_mutex);\n  gcc_assert (ob);\n  return (void *) ob;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":172,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"},"5795248":{"score":0.7552526,"function_name":"_Unwind_Find_FDE","code":"const fde *\n_Unwind_Find_FDE (void *pc, struct dwarf_eh_bases *bases)\n{\n  struct object *ob;\n  const fde *f = NULL;\n\n  init_object_mutex_once ();\n  __gthread_mutex_lock (\u0026object_mutex);\n\n  /* Linear search through the classified objects, to find the one\n     containing the pc.  Note that pc_begin is sorted descending, and\n     we expect objects to be non-overlapping.  */\n  for (ob = seen_objects; ob; ob = ob-\u003enext)\n    if (pc \u003e= ob-\u003epc_begin)\n      {\n\tf = search_object (ob, pc);\n\tif (f)\n\t  goto fini;\n\tbreak;\n      }\n\n  /* Classify and search the objects we've not yet processed.  */\n  while ((ob = unseen_objects))\n    {\n      struct object **p;\n\n      unseen_objects = ob-\u003enext;\n      f = search_object (ob, pc);\n\n      /* Insert the object into the classified list.  */\n      for (p = \u0026seen_objects; *p ; p = \u0026(*p)-\u003enext)\n\tif ((*p)-\u003epc_begin \u003c ob-\u003epc_begin)\n\t  break;\n      ob-\u003enext = *p;\n      *p = ob;\n\n      if (f)\n\tgoto fini;\n    }\n\n fini:\n  __gthread_mutex_unlock (\u0026object_mutex);\n\n  if (f)\n    {\n      int encoding;\n      _Unwind_Ptr func;\n\n      bases-\u003etbase = ob-\u003etbase;\n      bases-\u003edbase = ob-\u003edbase;\n\n      encoding = ob-\u003es.b.encoding;\n      if (ob-\u003es.b.mixed_encoding)\n\tencoding = get_fde_encoding (f);\n      read_encoded_value_with_base (encoding, base_from_object (encoding, ob),\n\t\t\t\t    f-\u003epc_begin, \u0026func);\n      bases-\u003efunc = (void *) func;\n    }\n\n  return f;\n}","filepath":"libgcc/unwind-dw2-fde.c","line_number":998,"entry_url":"https://github.com/gcc-mirror/gcc.git","slot_name":"releases/gcc-4.8.0"}}}